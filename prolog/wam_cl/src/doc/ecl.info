Info file: ecl.info,    -*-Text-*-
produced by latexinfo-format-buffer
from file: user.tex


                         ECoLisp User's Manual
                            Giuseppe Attardi
                                    
                      Dipartimento di Informatica
                          Universita` di Pisa






Preface
*******


ECoLisp (ECL for short) is a full implementation of the Common Lisp
language as described in the Common Lisp reference [Steele:84],

All Common Lisp functions, macros, and special forms are defined in ECoLisp,
though a few of them have slightly different meanings from those
described in [Steele:84].  All such differences are described in this
report. If a Common Lisp function (or macro or special form) does not
work as described in [Steele:84] and if this report does not describe
the difference explicitly, then there must be a bug in ECoLisp.  All
Common Lisp variables and constants are defined in ECoLisp exactly as
described in [Steele:84].

Currently, ECoLisp has been ported to the following platforms:

     
  1. Sparc, SunOS
     
  2. Silicon Graphics, Irix
     
  3. Intel x86, DOS/go32
     


This report is intended to complement [Steele:84].
This report describes deviations of ECoLisp from Common Lisp, those features
specific to ECoLisp, and the implementation-dependent functions of
Common Lisp.


Introduction
************



Support
=======



Credits
=======


Kyoto Common Lisp, from which ECoLisp is mostly derived, was
developed at the Research Institute for Mathematical Sciences (RIMS),
Kyoto University, with the cooperation of Nippon Data General
Corporation.
The main developers of Kyoto Common Lisp were
Taiichi Yuasa and Masami Hagiya, of the Research Institute for
Mathematical Sciences, at Kyoto University.

I must thank Yuasa and Hagiya for allowing me to use their code in
ECoLisp and to put ECoLisp in the Public Domain under the GNU General
Public Licence as published by the Free Software Foundation.

This document is based in part on the material in [Yuasa:85]

The following people or organizations must be credited for support
in the devlopement of Kyoto Common Lisp:
Prof. Reiji Nakajima at RIMS, Kyoto University;
Nippon Data General Corporation;
Teruo Yabe; Toshiyasu Harada; Takashi Suzuki;
Kibo Kurokawa;
Data General Corporation;
Richard Gabriel; Daniel Weinreb; Skef Wholey; Carl Hoffman;
Naruhiko Kawamura; Takashi Sakuragawa; Akinori Yonezawa;
Etsuya Shibayama;
Hagiwara Laboratory;
Shuji Doshita; Takashi Hattori.

William F. Schelter improved KCL in several areas and developed Austin
Kyoto Common Lisp (AKCL). Many ideas and code from AKCL have been incorporated
in ECoLisp.

The following people contributed to the developement of ECoLisp:
Stefano Diomedi, Tito Flagella, and Mauro Gaspari.

Andreas Stolcke helped in testing the release and configuration.


Distribution
============


Installation
============

 
This section explains how to install the ECoLisp system, separately for
each version of ECoLisp.


Unix Installation
-----------------


     
  1. Obtain the distribution from one the sites below via anonymous ftp:
        * ftp.icsi.berkeley.edu [128.32.201.7], directory `/pub/ai/ecl'
        * ftp.di.unipi.it [131.114.4.36], directory `/pub/lang/lisp'
     
     The distribution is in compressed tar file named like `ecl-XX.tar.gz'
     where `XX' is the version number.
     
  2. Prepare a directory (hereafter called "ECL directory") for
     ECoLisp.  In the following examples, we suppose that the {*ECL*directory} is `/usr/local/ecl'.
     
  3. Extract the content from the compressed tar file.
          
          zcat ecl-XX.tar | tar xf -
     
     
  4. An autoconfiguration mechanism allows you to perform a standard
     installation with the following commands:
          
          ./configure
          make
          make install
     
     The last one will try to install executable files, manual pages and info files
     in standard directories like `/usr/local/bin', `/usr/local/man/man1',
     `/usr/local/info'.
     If you don't have access rights to these directories, you can either
     give to configure alternate places or skip this step.
     Try `./configure -help' for instructions on how to supply this
     information to configure.
     


The configuration script figures out the machine where it is running and
creates a directory `machine' where to perform the installation.
If the program fails to recognize the machine, you will have to
check whether it is one of the supported machines present in
`src/h/machine.h'.

At the end of installation, the directory `machine' will contain
the following files:

     
     Executable files:
         ecl               the ECoLisp interpreter and compiler
     
     Command files:
         ecl.csh           script to invoke ECoLisp
     Help files:
         help.doc          data for the online help
     
     Auxiliary files:
         ecl_raw           Kernel Lisp
         libcrs.a          Common Runtime Support library
         compiler.o        compiler
         compiler.data     data for the compiler
         sysfun.lsp        data base for the compiler


You can remove all intermediate files produced during installation
with the command `make clean'. 


Entering and leaving ECoLisp===========================

 
ECoLisp is invoked by the command `ecl'.

     
     % ecl
     ECL (ECoLisp)  Version (0.8) 05/14/1993



When invoked, ECoLisp will print the banner and initialize the system.
The date in the ECoLisp banner identifies the revision of ECoLisp.
`Version (0.8) 05/14/1993' is the value of the
function `lisp-implementation-version'.

If there exists a file named {`init.lsp} in the current working'directory, ECoLisp successively evaluates the forms in the file,
immediately after the system initialization.  The user may set up his
or her own ECoLisp environment (e.g., the memory configuration) with
`init.lsp'.

After the initialization, ECoLisp enters the "top-level loop"  and
prints the prompt ``>''.

     
             Type :h for Help.  Top level.
             >


The prompt indicates that ECoLisp is now ready to receive a form from the
terminal and to evaluate it.

Usually, the current package (i.e., the value of  -- Variable: *package*
     ) is
     the user package, and the prompt appears as above.  If, however, the
     current package is other than the user package, then the prompt will
     be prefixed by the package name.
     
          
          PACKAGE-NAME>
     
     
     To exit from ECoLisp, call the function `quit'.
     
          
                    >(quit)
                    Bye.
                    %
     
     
     Alternatively, you may type ^D, i.e. press the key {D}while pressing down the control key (CTL).
     
          
                    >^Dbye.
                    %
     
     
     You can disable ^D as the exit command by setting to `T' the
     following variable:
     
      -- Variable: *ignore-eof-on-terminal-io*
          This variable controls whether an end of file character (normally ^D)
          should terminate the session. The default value is nil.
     
     
     The top-level loop of ECoLisp is almost the same as that defined in
     Section 20.2 of [Steele:84].  Since the input from the terminal is in
     line mode, each top-level form should be followed by a newline.  If
     more than one value is returned by the evaluation of the top-level
     form, the values will be printed successively.  If no value is
     returned, then nothing will be printed.
     
          
          >(values 1 2)
          1
          2
          
          >(values)
          
          >
     
     
     
     When an error is signalled, control will enter the break loop.
          
          
          >(defun foo (x) (bar x))
          foo
          
          >(defun bar (y) (bee y y))
          bar
          
          >(foo 'lish)
          Error: The function BEE is undefined.
          Error signalled by BAR.
          
          Broken at BAR.
          >>
     
     
     
     ``>>'' in the last line is the prompt of the break loop.
     Like in the top-level loop, the prompt will be prefixed by the current
     package name, if the current package is other than the `user'
     package.
     
     To go back to the top-level loop, type `:q'
     
          
          >>:q
          
          Top level.
          >
     
     
     
     See Section 5.4 for the details of the break loop.
     
     The terminal interrupt (usually caused by typing ^C
     (Control-`C')) is a kind of error.  It breaks the running program
     and calls the break level loop.
     
     Example:
          
          >(defun foo () (do () (nil)))
          foo
          
          >(foo)
          ^C
          Correctable error: Console interrupt.
          Signalled by DO.
          
          Broken at FOO.
          >>
     
     
     
     Data Types
     **********
     
     
     ECoLisp supports all Common Lisp data types exactly as defined in the
     [Steele:84].  This chapter simply complements Chapter 2 of [Steele:84], by
     describing implementation dependent features of Common Lisp data types.
     Each section in this chapter corresponds to the section in Chapter 2
     of [Steele:84], with the same section title.
     
     
     Numbers
     =======
     
     
     
     Integers
     --------
     
     
     {Fixnum}'s in ECoLisp are those integers in the range ^29^29-1.
     They are represented as immediate data, so no memory allocation is
     involved when using `fixnum''s.
     Other integers are `bignums'. Thus 25 factorial (25!)
     
          
          15511210043330985984000000
     
     
     is definetely a bignum in ECoLisp.
     
     Common Lisp constants related to integers have the following values
     in ECoLisp.
     
          
          
            most-positive-fixnum = 2^29-1-negative-fixnum = - 2^29-1 )
            boole-2 )
            boole-and )
            boole-andc1 )
            boole-andc2 )
            boole-c1 )
            boole-c2 )
            boole-clr )
            boole-eqv )
            boole-ior )
            boole-nand )
            boole-nor )
            boole-orc1 )
            boole-orc2 )
            boole-set )
            boole-xor )
     
     
     See Chapter 12 of [Steele:84] for their meanings.
     
     
     
     Ratios
     ------
     
      
     There are no implementation-dependent features for ratios.
     
     
     Floating-Point Numbers
     ----------------------
     
     
     ECoLisp supports two floating point formats: {single-float} and
     {double-float}.  These are implemented with IEEE single and double
     float arithmetic, respectively.  `short-float' is a synonym for
     `single-float', and `long-float' is a synonym for
     `double-float'.  The initial value of
     {read-default-float-format} is `single-float'.
     
     Both `single-float' and `double-float' are represented with a pointer
     descriptor, so float operations can cause number consing.  Number consing is
     greatly reduced if type declarations are supplied in programs.
     
     An expression such as `(eql 1.0s0 1.0d0)' is false, but `(eql
     1.0f0 1.0d0)' is true.  Similarly, `(typep 1.0l0 'short-float)' is
     false, but `(typep 1.0l0 'double-float') is true.  For output purposes
     all floating-point numbers are assumed to be of {*single} or {*double}*format.*
     The floating-point precisions and exponent sizes are:
     
          
          
          Format    precision exponent    
          ---------------------------- 
          Short      24 bits    8 bits
          Single     24 bits    8 bits
          Double     53 bits   11 bits
          Long       53 bits   11 bits
          
     
     
     There is no ``minus zero.'' `(eql 0.0 -0.0)' is true.
     
     
     Common Lisp constants related to floating-point numbers have the
     following values in ECoLisp.
          
          
              most-positive-short-float
                = most-positive-single-float
                = - most-negative-short-float
                = - most-negative-single-float
                = 3.402823s38
          
              least-positive-short-float
                = least-positive-single-float
                = - least-negative-short-float
                = - least-negative-single-float
                = 1.401298s-45
          
              most-positive-long-float
                = most-positive-double-float
                = - most-negative-long-float
                = - most-negative-double-float
                = 1.797693134862315f308
          
              least-positive-long-float
                = least-positive-double-float
                = - least-negative-long-float
                = - least-negative-double-float
                = 4.940656458412469f-324
          
              short-float-epsilon
                = 2.980232s-8
          
              short-float-negative-epsilon
                = 2.980232s-8
          
              long-float-epsilon
                = double-float-epsilon
                = single-float-epsilon
                = 5.5511151231257827f-17
          
              long-float-negative-epsilon
                = double-float-negative-epsilon
                = single-float-negative-epsilon
                = 5.5511151231257827f-17
          
              pi = 3.141592653589793
          
     
     
     See Chapter 12 of [Steele:84] for their meanings.
     
     
     
     Complex Numbers
     ---------------
     
      
     There are no implementation-dependent features for complex numbers.
     
     
     
     Characters
     ==========
     
     
     
     Standard Characters
     -------------------
     
     
     ECoLisp supports all standard and semi-standard characters listed in
     Section 2.2.1 of [Steele:84].
     Non-printing characters have the following character codes.
          
          
                 Character        Code  (in octal)
                 --------------------------------
                 #\Space                 040
                 #\Newline               012
                 #\Backspace             010
                 #\Tab                   011
                 #\Linefeed              012
                 #\Page                  014
                 #\Return                015
                 #\Rubout                177
          
     
     
     Note that `#\Linefeed' is synonymous with
     `#\Newline' and thus is a member of `standard-char'.
     Other semi-standard characters are not members of `standard-char'.
     
     
     Line Divisions
     --------------
     
     
     Since ECoLisp represents the `#\Newline' character by a single
     code 12, problems with line divisions discussed in Section 2.2.2 of the
     [Steele:84] are absent in ECoLisp.
     
     
     
     Non-standard Characters
     -----------------------
     
      
     ECoLisp supports no additional non-standard characters.
     
     
     
     Character Attributes
     --------------------
     
      
     The font fields of ECoLisp characters are always 0.
     
     Common Lisp constants related to characters have the following values in
     ECoLisp.
     
          
              char-bits-limit = 16
              char-code-limit = 256
              char-control-bit = 1 
              char-font-limit = 1 
              char-meta-bit = 2
              char-super-bit = 4
              char-hyper-bit = 8
     
     
     See Chapter 13 of [Steele:84] for their meanings.
     
     
     
     String Characters
     -----------------
     
      
     Since the font fields of ECoLisp characters are always `0',
     `string-char' is considered to be identical to `character'.
     
     
     
     Symbols
     =======
     
      
     The print name of a symbol may consist of up to 16777216 (i.e., the value
     of `array-total-size-limit') characters.  However, when a symbol is
     read, the number of characters (not counting escape characters)
     in the print name is limited to 2048.
     
     
     
     Lists and Conses
     ================
     
      
     There are no implementation-dependent features for lists and conses.
     
     
     Arrays
     ======
     
      
     ECoLisp arrays can have up to 64 ranks.
     
     When the value of the Common Lisp variable `*print-array*' (see
     Section 22.1.6 of [Steele:84]) is nil, then bit-vectors are printed as
     `#<a bit-vector ADDRESS>', other vectors are printed as
     `#<a vector ADDRESS>', and other arrays are printed as
     `#<an array ADDRESS>'. The default value for
     `*print-array*' is nil.
     
     Common Lisp constants related to arrays have the following values in
     ECoLisp.
     
          
              array-dimension-limit = 16777216
              array-rank-limit = 64
              array-total-size-limit = 16777216
     
     
     See Section 17.1 of [Steele:84] for their meanings.
     
     
     
     Vectors
     -------
     
      
     In ECoLisp, array elements are represented in one of six ways depending
     on the type of the `array'.
     
          
          
          Array Type                               Element Representation
          ---------------------------------------------------------------
          (array t) and (vector t)                      a cell pointer
          (array fixnum) and (vector fixnum)            32 bit signed integer
          (array string-char) and string                8 bit code
          (array short-float) and (vector short-float)  32 bit floating point
          (array long-float) and (vector long-float)    64 bit floating point
          (array bit) and bit-vector                    1 bit bit
     
     
     
     Strings
     -------
     
     
     A string may consists of up to 16777216 (i.e., the value of
     `array-total-size-limit') characters.  However, when a string is
     read, the number of characters (not counting escape characters) in the
     string is limited to 2048.
     
     
     
     Bit-Vectors
     -----------
     
      
     There are no implementation-dependent features for bit-vectors.
     
     
     
     Hash Tables
     ===========
     
      
     All hash tables are printed as `#<a hash-table ADDRESS>'.
     
     
     
     Readtables
     ==========
     
      
     All readtables are printed as `#<a readtable ADDRESS>'.
     
     
     
     Packages
     ========
     
      
     The following packages are built into ECoLisp.
     
          
               lisp     user     keyword     system
     
     
     The `system' package has two nicknames `sys' and `si';
     `system:symbol' may be written as `sys:symbol' or
     `si:symbol'.  Other packages have no nicknames.
     
     Depending on the configuation option by which ECoLisp has been built,
     additional packages may be available:
          
               compiler clos xlib
     
     
     The `compiler' package contains symbols used by the ECoLisp compiler.
     Other packages are described in Section 11.6 of [Steele:84].
     The `clos' package is used for the internal symbols of the
     Common Lisp Object System, which is described in Chapter 14.
     The `xlib' package is used for the internal symbols of CLX,
     the Common Lisp Language X Interface to the X Window System, which is described
     in a separate manual.
     
     Packages are printed as `#<PACKAGE-NAME package>'.
     
     
     
     Pathnames
     =========
     
      
     ECoLisp provides a `#' macro `#"' that reads a pathname:
     `#"STRING"' is equivalent to `(pathname
     "STRING"').  For example,
     
          
          #"foo.lsp"
     
     
     is equivalent to
     
          
          (pathname "foo.lsp").
     
     
     The same format is used when a pathname is printed.
     
     The initial value of the Common Lisp variable
     `*default-pathname-defaults*' is `#""' (or, equivalently,
     `(pathname "")').
     
     A pathname in the file system of Common Lisp consists of the following
     six elements:
     
          
                    host  device  directory  name  type  version
     
     
     Among these elements, ECoLisp does not use `host', `device',
     and `version'.  That is, when converting a namestring into a
     pathname, ECoLisp turns these three elements into nil.  Conversely, when
     converting a pathname into a namestring, ECoLisp ignores these three
     elements.
     
     In the sequel, we explain how ECoLisp converts a namestring into a
     pathname.
     
     If a namestring contains one or more periods `.', the last period
     separates the namestring into the file name and the filetype.
     
          
               "foo.lsp"
                   name:          "foo" 
                   type:          "lsp"
          
               "a.b.c" 
                   name:          "a.b" 
                   type:          "c" 
     
     
     If a namestring ends with a period, the filetype becomes the null
     string.
          
               "foo." 
                    name:          "foo" 
                    type:          ""  (null string)
     
     
     If a namestring begins with a period, the file name becomes nil.
     
          
               ".lsp" 
                    name:          nil 
                    type:          "lsp" 
     
     
     If a namestring contains no period, the filetype is nil.
     
          
              "foo" 
                    name:          "foo" 
                    type:          nil 
     
     
     In a pathname, the file directory is represented as a list.
     
          
               "common/demo/foo.lsp" 
                    directory:     ("common"   "demo") 
                    name:          "foo" 
                    type:          "lsp" 
     
     
     If a namestring does not contain a directory, the directory component
     of the pathname is nil. 
     
          
               "foo.lsp" 
                    directory:     nil 
                    name:          "foo" 
                    type:          "lsp" 
     
     
     In a pathname, the root directory is represented by the keyword
     `:root'.
     
          
               "/usr/common/foo.lsp"
                    directory:     (:root "usr" "common") 
                    name:          "foo" 
                    type:          "lsp" 
     
     
     The abbreviation symbols ``.'' and ``..'' may be used
     in a namestring.
     
          
               "./demo/queen.lsp" 
                    directory:     ({:current} "demo") 
                    name:          "queen" 
                    type:          "lsp" 
          
               "../../demo/queen.lsp" 
                    directory:     ({:parent} :parent "demo") 
                    name:          "queen" 
                    type:          "lsp" 
     
     
     `:current' and `:parent' represent the current directory
     and the parent directory, respectively.
     
     The part of a namestring after the last slash ``/'' is always regarded
     as representing the file name and the filetype.  In order to represent
     a pathname with both the name and the filetype nil, end the pathname
     with a slash.
     
          
               "/usr/common/" 
                    directory:     (:root "usr" "common") 
                    name:          nil 
                    type:          nil 
          
               "/usr/common/.lsp" 
                    directory:     (:root "usr" "common") 
                    name:          nil 
                    type:          "lsp" 
     
     
     ``*'' in the place of file name or filetype becomes  `:wild'
     
          
               "*.lsp" 
                    name:          :wild 
                    type:          "lsp" 
          
               "foo.*" 
                    name:          "foo" 
                    type:          :wild 
     
     
     
     Streams
     =======
     
      
     Streams are printed in the following formats.
     
     `#<input stream  FILE-NAME>'     
          An input stream from the file FILE-NAME.
          
     `#<output stream FILE-NAME>'     
          
          An output stream to the file FILE-NAME.
          
     `#<string-input stream from STRING>'     
          
          An input stream generated by `(make-string-input-stream
          STRING )'.
          
     `#<a string-output stream>'     
           An output stream generated by
          the function `make-string-output-stream'.
          
     `#<a two-way stream>'     
          
          A stream generated by the function `make-two-way-stream'.
          
     `#<an echo stream>'     
          
          A bidirectional stream generated by the function `make-echo-stream'.
          
     `#<synonym stream to SYMBOL>'     
          
          The stream generated by `(make-synonym-stream SYMBOL )'.
          
     `#<a concatenated stream>'     
          
          An input stream generated by the function `make-concatenated-stream'.
          
     `#<a broadcast stream>'     
          
          An output stream generated by the function `make-broadcast-stream'.
     
     
     
     Random-States
     =============
     
     
     ECoLisp provides a `#' macro ``#$'' that reads a random state.
     `#$'INTEGER is equivalent to `(make-random-state
     INTEGER)'.  The same format is used when a random state is
     printed.
     
     
     
     Structures
     ==========
     
      
     There are no implementation-dependent features for structures.
     
     
     
     Functions
     =========
     
      
     An interpreted function (including macro expansion functions) is
     represented in one of the following formats.
     
          
     `(lambda LAMBDA-LIST . body)'      A lambda-expression
          with null lexical environment and with no implicit block around it.
          This type of function typically appears when ``(lambda LAMBDA-LIST .  body)' is evaluated.
          
     `(lambda-block BLOCK-NAME   LAMBDA-LIST  .  body)'     
          A lambda-expression with null lexical environment but with an implicit
          block around it.  This type of function typically appears when `(defun FUNCTION-NAME LAMBDA-LIST .  body)' is evaluated.  In
          this case, BLOCK-NAME is identical to FUNCTION-NAME .
          
     `(lambda-closure ENV1   ENV2   ENV3   LAMBDA-LIST .  body)'     
          
          A lambda-expression with lexical environments but with no implicit
          block around it.  This type of function typically appears when `#`(lambda LAMBDA-LIST .  body)' (or, equivalently, `(function (lambda LAMBDA-LIST .  body))') is evaluated. ENV1, ENV2, and ENV3 represent the variable bindings, the local
          function/macro definitions, and the tag/block-name establishments,
          respectively, at the time the closure was created.
          
     `(lambda-block-closure ENV1 ENV2 ENV3 BLOCK-NAME LAMBDA-LIST  .  body)'     
          
          A lambda-expression with lexical environments and with an implicit
          block around it.  Local functions and local macros are represented
          in this format. ENV1, ENV2, and ENV3 represent the
          variable bindings, the local function/macro bindings, and the
          tag/block-name establishments, respectively, at the time the local
          function/macro was created by `flet', `labels', or
          `macrolet'.  The BLOCK-NAME is identical to the local
          function/macro name.
     
     
     Compiled functions (including compiled macro-expansion functions) are
     printed in the following formats.
     
          
          #<compiled-function NAME>
     
     or
          
          #<compiled-closure nil>
     
     
     Incidentally, the value of `(symbol-function SPECIAL-FORM-NAME)'
     is a list,
     
          
          (special . ADDRESS)
     
     
     if SPECIAL-FORM-NAME names a special form.
     
     Common Lisp constants related to functions have the following values in ECoLisp.
     
          
          call-arguments-limit = 64
          lambda-list-keywords = (&optional &rest &key &allow-other-keys
                                  &aux &whole &environment &body)
          lambda-parameters-limit = 64
          multiple-values-limit = 32
     
     
     Refer to [Steele:84] for their meanings.
     
     
     
     Unreadable Data Objects
     =======================
     
      
     There are no implementation-dependent features for unreadable data objects.
     
     
     
     Overlap, Inclusion, and Disjointness of Types
     =============================================
     
     
      
     In ECoLisp, the types `number' and `array' are certainly
     subtypes of `common', since ECoLisp does not extend the set of objects
     of these types.
     
     
     
     Input and Output
     ****************
     
     
     
     Read Macros
     ===========
     
     
     The following `#' macros are introduced in ECoLisp. 
     
     `#"'     
           `#"STRING"' reads a pathname.`#" STRING "' is equivalent to `(pathname "STRING")'.
           
     `#$'     
           `#$INTEGER' reads a random state.
            `#$'INTEGER is equivalent to `    (make-random-state INTEGER)' .
     
     
     The `#' macro '`#,'' works as described in [Steele:84], only
     if it is included in a constant object.  The forms immediately after
     ``#,'' below will be evaluated when the compiled code is loaded.
     
          
          '#,x
          '(a b c (d #,e f) g)
          #(1 2 3 #,(+ a b c) 5 6)
          #C(0.0 #,(exp 1))
     
     
     Otherwise, the effect of using '`#,'' is unpredictable.  Note
     that, when interpreted code is loaded, '`#,'' has the same effect
     as the `#' macro '`#.''.
     
     
     
     Input and Output Functions
     ==========================
     
     
     The input and output functions of ECoLisp almost follow the definitions in
     Chapter 22 of [Steele:84].  Most of the differences come from the fact
     that, in ECoLisp, input from the terminal is always in line mode and
     binary I/O is not supported.
     
     In ECoLisp, `*terminal-io*' is a two-way stream from the standard
     input and to the standard output.  The echoing to the terminal is
     performed by the underlying operating system.  In particular, when a
     disk file is assigned to the standard output, nothing will be echoed
     at the terminal.
     
     Those functions that deviate from the definitions in [Steele:84]
     are listed below.
     
     
      -- Function: load PATHNAME {:print :verbose :if-does-not-exist}
     
          If PATHNAME does not specify the filetype of the input file,
          then load first tries to load a file with the filetype `.o', i.e., the
          fasl file (see Chapter 6). If it fails, then `load' tries to load a
          file with the filetype `.lsp'.
          ECoLisp assumes that `.lsp' is the standard filetype for source
          files.  If it fails again, then `load' will load the specified
          file with no filetype.
          
          `load' recognizes a file as a fasl file if and only if the
          filetype of the file is `.o'.  Other files are assumed to be
          source files.
     
     
     
      -- Function: open
          The argument to the keyword variable `:element-type'
          and `:element-type' is always bound to the value
          `string-char'.
     
     
     
      -- Function: close
          The keyword variable :ABORT is always ignored.
     
     
     
      -- Function: listen
          `listen' always returns true.
     
     
     
      -- Function: read-char-no-hang
          `read-char-no-hang' is equivalent to `read-char'.
     
     
     
      -- Function: clear-input
          `clear-input' and `clear-output' simply
          return nil without doing anything.
     
     
     
      -- Function: read-byte
     
     
      -- Function: write-byte
          These functions may operate on any stream.  They read or write a byte
          (8 bits) at a time.
     
     
     The functions `princ', `write-char' and `write-byte' do
     not always flush the stream.  The stream is flushed when
       1. a newline character is written, or
          
       2. the input from the terminal is requested in the case that these
          functions operate on `*terminal-io*'
     



Block Transfer
==============


More efficient block transfer can be obtained with the following functions.


 -- Function: read-bytes STREAM STRING START END

     It reads from STREAM a series of bytes to be placed into STRING
     starting from position START up to END (exclusive). It returns
     the number of bytes actually transferred, or `-1' if the operation
     failed. The STREAM is automatically flushed. This function may operate
     on any stream.



 -- Function: write-bytes STREAM STRING START END

     It writes onto STREAMthe series of bytes from STRING
     starting from position START up to END (exclusive). It returns
     the number of bytes actually transferred, or `-1' if the operation
     failed. The STREAM is automatically flushed. This function may operate
     on any stream.



Network Streams
===============


With a configuration option, the following function is available which opens
streams across network connections.


 -- Function: open-client-stream HOST PORT

     The string HOST indicates the name of the host, while PORT is
     an integer which identifies the port number to which to connect.
     This function returns a two-way stream which can be used in any of the stream
     operations.



 -- Function: open-server-stream HOST PORT

     A stream connected to port number PORT is created to
     which clients can connect.
     This function returns a two-way stream which can be used in any of the stream
     operations.



CLOS Streams
============


When the optional CLOS subsystem is available, an interface is provided by ECoLispfor using CLOS objects as Common Lisp input/output character streams.
Such support can be used for instance to build interactive character streams,
which may be used by applications as the stream argument for Common Lisp
I/O functions such as `read', `listen', `prin1', etc.
The fundamental interface to `interactive-stream' objects consists of
(generic) functions which implement the basic Common Lisp character stream
operations (see Common Lisp, Chapter 22) but whose details are implementation
dependent.

The following functions are automatically invoked by ECoLisp when a stream
operation involves a CLOS object as a stream parameter. The programmer
should define these methods for any class of objects which are to be used
for character input/output.


CLOS Stream Input
-----------------


Character input from an `interactive-stream' is implemented by the
following methods.


 -- Method: stream-read-char (OBJECT interactive-stream)

     Returns the next character object read from the CLOS stream OBJECT.



 -- Method: stream-read-line (OBJECT interactive-stream) &restMAKE-ARRAY-OPTIONS

     Reads character objects from the CLOS stream OBJECT, up to and including
     the next `#' character, and returns them as a string (without the
     `#'. If given, the MAKE-ARRAY-OPTIONS arguments are passed
     to `make-array' when the returned string is created.



 -- Method: stream-unread-char (OBJECT interactive-stream) CHARACTER

     Unreads the character object CHARACTER from the CLOS stream OBJECT.
     CHARACTER will be the next character read by `stream-read-char'.



 -- Method: stream-peek-char (OBJECT interactive-stream) PEEK-TYPE

     Returns the character object which would be returned by `stream-read-char' but does not remove it from the input buffer.
     If PEEK-TYPE is true, `steam-peek-char' skips over any whitespace
     characters, removing them from the input buffer, and returns the next
     character.



 -- Method: stream-listen (OBJECT interactive-stream)

     Returns nil is no character is immediately available from the CLOS stream
     OBJECT. Otherwise, the next character is returned, as if
     `stream-peek-char' had been called.



 -- Method: stream-clear-input OBJECT

     Clears any buffered characters on the CLOS stream OBJECT. Returns nil.



CLOS Stream Output
------------------


Character output from an `interactive-stream' is implemented by the
following methods.


 -- Method: stream-write-char (OBJECT interactive-stream) CHARACTER

     Outputs the character CHARACTER to the CLOS stream OBJECT
     and returns it.



 -- Method: stream-write-line (OBJECT interactive-stream) STRING &optionalSTART END

     Writes character objects from thestring STRING onto the CLOS stream
     OBJECT. If given, the START and END arguments indicate
     a substring that is to be output.



 -- Method: stream-fresh-line (OBJECT interactive-stream)

     Outputs a `#\'`newline' character to the CLOS stream
     OBJECT if and only if the stream is not already at the beginning
     of a new line.  Returns non-nil if a `#\'`newline' was
     output and nil otherwise.



 -- Method: stream-clear-output (OBJECT interactive-stream)

     Aborts any outstanding output operation on the CLOS stream OBJECT and
     returns nil.



 -- Method: stream-forse-output (OBJECT interactive-stream)

     Initiates the emptying of the internal buffers on the CLOS stream OBJECT
     and returns nil.



Memory Management
*****************

 

Implementation Types
====================


Each ECoLisp object belongs to one of the 22 {*implementation types}.*The implementation types are shown in Table 4-1 with the corresponding
Common Lisp data types.  In the table, the compiled functions are divided
into three implementation types; `cfun' is the type of compiled
functions without environment, `cclosure' is the type of
compiled functions with environment (i.e., the type of compiled
closures) and `gfun' is the type of compiled generic
functions of CLOS.

{Table 4-1  Implementation Types}



{*Implementation Type} {*Common Lisp Data Type} [1 em]**`cons' `cons'
{fixnum} {fixnum}
`bignum' `bignum'
`ratio' `ratio'
`short-float' `short-float'
`long-float' `long-float (= double-float = single-float)'
`complex' `complex'
`character' `character'
`symbol' `symbol'
`package' `package'
`hash-table' `hash-table'
`array' `(and array (not vector))'
`vector'  `(and vector (not string) (not bit-vector))'
`string' `string'
`bit-vector' `bit-vector'
`structure' `structure'
`stream' `stream'
`random-state' `random-state'
`readtable' `readtable'
`cfun' `compiled-function  without environment' 
`cclosure' `compiled-function  with environment' 
`gfun' `none (CLOS generic-function)' 
`instance' `none (CLOS instance)' 
`thread' `none (thread)' 
`cont' `none (continuation)' 


Each object is represented by a cell allocated in the heap area of the
interpreter.  The size of the cell is determined by the implementation
type of the object.

The implementation types are classified according to the size of the
cells for the objects of the type, as shown in Table 4-2.  The size of
the cells in the same type class is the same.


{Table 4-2  Classification of Implementation Types}



{*Class} {*Implementation Types}[1 em]**1 `        CONS BIGNUM RATIO COMPLEX STRUCTURE'
2 `        SHORT-FLOAT RANDOM-STATE READTABLE'
3 `        LONG-FLOAT CFUN CCLOSURE'
4 `        SYMBOL'
5 `        PACKAGE'
6 `        ARRAY HASH-TABLE VECTOR BIT-VECTOR STREAM'
7 `        STRING'
8 `        PATHNAME'


For objects of the (implementation) types `readtable',
`symbol', `package', `array', `hash-table',
`vector', `bit-vector', `stream', `cclosure',
`string', `cfun', and `structure' (or
`instance'), the cell is simply a header of the object.  The
body of the object is allocated separately from the cell and is
managed in a different manner.  The memory space occupied by the
body of such an object is called a "block".  A block is
either "contiguous" or "relocatable" depending on the
area in which it is allocated.  The difference between the two
areas will be explained below.  Table 4-3 lists these types,
along with the contents of the body and the kind of the block.

                
{Table 4-3  Types with Bodies}




{*Type} {*Body} {*Block}[1 em]**`readtable' `read table' `contiguous'*`symbol' `symbol name' `relocatable'
`package' `hash table' `contiguous'
`array' `array body' `relocatable or contiguous'
`hash-table' `hash table' `relocatable'
`vector' `vector body' `relocatable or contiguous'
`bit-vector' `bit-vector body' `relocatable or contiguous'
`stream' `I/O buffer' `contiguous'
`cclosure' `code' `   contiguous'
`string' `string body' `relocatable or contiguous'
`cfun' `code' `contiguous'
`structure' `structure body' `relocatable'
`instance' `instance slots' `relocatable'
`thread' `thread data' `contiguous'



Usually, the body of an array, a vector, a bit-vector, or a string is
allocated as a relocatable block.  In ECoLisp, the function `make-array' takes an extra keyword argument {static}.  If the
{static} argument is supplied with a non-nil value, then the
body of the array is allocated as a contiguous block.


Heap and Relocatable Areas
==========================


The memory space of ECoLisp is divided into two parts: the heap area and
the relocatable area.  Both areas occupy a contiguous space in the
memory.

Cells of ECoLisp objects are allocated in the heap.  ECoLisp divides the heap
into pages (1 page = 2048 bytes), and each page consists of cells in
the same type class (see Table 4-2).  Cells in different type classes
are allocated in different pages.  Some blocks are also allocated in
the heap: They are called contiguous blocks.  The pages for contiguous
blocks contain only contiguous blocks.  Thus each page in the heap is
either a page for cells in a particular type class, or a page for
contiguous blocks.  Blocks not in the heap are called relocatable
blocks and are allocated in the relocatable area.

The user may specify the maximum number of pages that can be allocated
for each type class by calling the ECoLisp specific function `allocate'.  There is also a limit on the number of pages for
contiguous blocks; the limit can be altered by calling the ECoLispspecific function `allocate-contiguous-pages' size of the
relocatable area is specified by the ECoLisp specific function `allocate-relocatable-pages'.  See Section 4.4 for these functions.

In some installations of ECoLisp, the total amount of memory that ECoLisp can
use is limited.  In such cases, the entire memory may become exhausted
before the maximum number of pages for each type class, for contiguous
blocks, or for the relocatable area have been allocated.

The heap lies in a part of memory with lower address than the
relocatable area and there is a ``hole'' between the two areas (see
Figure 4-1).  On request for a new page of heap, the page with the
lowest address in the hole is used.  When the hole is exhausted, the
relocatable area is shifted toward the higher address space and a new
hole of an appropriate size is created between the two areas.


{Figure 4-1  Heap and Relocatable Area}


{{lower address} {3in}{}`higher address'}

{{{.5in}{}*heap*{.5in}{}}
{2 em}{}*hole* {2 em}{}{*relocatable area*}}


The Garbage Collector
=====================


ECoLisp uses a {*conservative garbage collection} technique for collecting*the C stack and a type accurate technique for areas containing Lisp objects.
Scanning conservatively the C stack, looking for potential pointers to Lisp
objects, ensures that no live Lisp objects get collected, even if they
are passed to external procedures in C or some other language.
This approach greatly simplies integration of Lisp and C code, since
it is not necessary to protect Lisp object form collection when a foreign
function is invoked.

The garbage collector of ECoLisp has three levels according to what it
collects:
               1. 
     cells
               2. 
     cells and relocatable blocks
               3. 
     cells, relocatable blocks and contiguous blocks.


In levels 2 and 3, the relocatable area is shifted to the higher
address space to reserve an appropriate number of pages in the hole.

For each type class, ECoLisp keeps a free list of unused cells, and when
the free list is exhausted, a new page is allocated, or the garbage
collector is invoked, depending on whether the maximum number of pages
for that class have been allocated or not.

The garbage collector does not compactify the heap.  That is, cells
and contiguous blocks are never moved to another place.  Moreover,
once a page is allocated for a particular type class or for contiguous
blocks, that page will never be freed for other classes, even if the
entire page becomes garbage.

On the other hand, the relocatable area is compactified during level 2
and level 3 of garbage collection.  A relocatable block is really
relocatable.

The garbage collector is automatically invoked in one of the following
situations.  The number in the parentheses indicates the level of garbage
collection that is performed.

  1. The free list of a certain type class is exhausted
     after the maximum number of pages have been allocated for that
     type class (1). 
     
  2. The hole is exhausted (2).
     
  3. The relocatable area is exhausted after the maximum number of
     pages have been allocated for the relocatable area (2).
     
  4. The contiguous blocks are exhausted after the maximum number of
     pages have been allocated for contiguous blocks (3).


The garbage collector is also invoked by the following ECoLisp specific
function.


 -- Function: gc
     The garbage collector is invoked with the level specified by X.
     If X is nil, the garbage collector is invoked for level 1
     garbage collection.  If X is true, it is invoked for level 3
     garbage collection.  Otherwise, it is invoked for level 2 garbage
     collection.  If `sys:*gc-verbose*' is non-nil, then it print
     messages at the start and end of each garbage collection.



 -- Variable: *gc-verbose*
     This variable controls whether to print messages at the
     start and end of each garbage collection.
     If `sys:*gc-verbose*' is nil, `gc' foregoes printing any
     messages.  The default value is `T'.



Allocation Functions
====================

 
The following functions are used to set or inspect the (maximum)
number of pages for each type class, for contiguous blocks, or for
relocatable blocks.

  -- Function: allocate TYPE NUMBER

     Sets the
     maximum number of pages for the type class of the implementation type
     TYPE to NUMBER.  If more than NUMBER pages have
     already been allocated, an error is signalled.



 -- Function: allocated-pages TYPE

     Returns the number of pages currently allocated
     for the type class of the implementation type TYPE.



 -- Function: maximum-allocatable-pages TYPE

     Returns the current maximum number of pages
     for type class of the implementation type TYPE.



 -- Function: allocate-contiguous-pages NUMBER

     Sets the maximum number of pages for contiguous blocks to NUMBER.



 -- Function: allocated-contiguous-pages
     Returns the number of pages allocated for contiguous blocks.



 -- Function: maximum-contiguous-pages
     Returns the current maximum number of pages for contiguous blocks.



 -- Function: allocate-relocatable-pages NUMBER

     Sets the maximum number of pages for relocatable blocks
     to NUMBER.  The relocatable area is expanded to NUMBER
     pages immediately.  Therefore,``the current maximum number'' and ``the
     number of pages allocated'' have the same meanings for relocatable blocks.



 -- Function: allocated-relocatable-pages
     Returns the number of pages allocated for relocatable blocks.


If the pages for a particular type class are exhausted after the
maximum number of pages for that class have been allocated, and if
there remain no free cells (actually, if there remain very few cells),
ECoLisp behaves as directed by the value of the ECoLisp specific variable
`*ignore-maximum-pages*'.  If the value is nil, then ECoLispsignals a correctable error and enters the break loop.  The user can
reset the maximum number by calling `allocate' and then continue
the execution of the program by typing {r}.

Example:

     
     
     >(make-list 100000)
     
     Correctable error: The storage for CONS is exhausted.
                        Currently, 531 pages are allocated.
                        Use ALLOCATE to expand the space.
     Signalled by MAKE-LIST.
     
     Broken at FUNCALL.
     >>(ALLOCATE 'CONS 1000)
     t
     
     >>:r
     
     (nil nil nil nil nil nil nil nil nil nil ............

 
The user can also reset the maximum number of pages for relocatable
blocks and for contiguous blocks in a similar manner.  On the other
hand, if the value of `*ignore-maximum-pages*' is non-nil, then
ECoLisp automatically increments the maximum number of pages for the class
by 50 percent.  The initial value of `*ignore-maximum-pages*' is
true.



Storage Information
===================

 

 -- Function: room &optionalX

     The function `room' prints the storage information.  The argument
     X  is simply ignored and
     the output of `room'  is always in the same
     format.  `room'  prints the following information:


     
   * for each type class
        * the number of pages so-far allocated for the type class 
        * the maximum number of pages for the type class
        * the percentage of used cells to cells so-far allocated 
        * the number of times the garbage collector has been 
          called to collect cells of the type class 
        * the implementation types that belong to the type class
     
   * the number of pages actually allocated for contiguous blocks
   * the maximum number of pages for contiguous blocks
   * the number of times the garbage collector has been called to 
     collect contiguous blocks 
   * the number of pages in the hole
   * the maximum number of pages for relocatable blocks
   * the number of times the garbage collector has been called to
     collect relocatable blocks 
   * the total number of pages allocated for cells
   * the total number of pages allocated
   * the number of available pages
   * the number of pages ECoLisp can use.


The number of times the garbage collector has been called is not
shown, if the number is zero.

In the following example, the maximum of `531' pages have
already been allocated for the type class to which cons belongs, but
only 16.9 percent of the cells are actually used.  The garbage
collector was once invoked to collect cells in this type class.

     
     
     > (room)
      200/200   48.4%    CONS BIGNUM RATIO COMPLEX STRUCTURE
        1/5      7.4%    SHORT-FLOAT RANDOM-STATE READTABLE
       10/34    99.3%    LONG-FLOAT CFUN CCLOSURE
       47/64    71.9%    SYMBOL
        1/1      8.9%    PACKAGE
        2/69    81.8%    ARRAY HASH-TABLE VECTOR BIT-VECTOR STREAM
       16/40    95.9%    STRING
        1/1      6.8%    PATHNAME
     
        0/271            contiguous (1 blocks)
          127            hole
          40     3.4%    relocatable
     
       278 pages for cells
       445 total pages
     14709 pages available
      1230 pages in heap but not gc'd + pages needed for gc marking
     16384 maximum pages
     



Program Development Facilities
******************************



The Tracer
==========

 
The Tracer causes selected `functions' to be traced.  When such a traced  
`function' is invoked, it prints

     
       LEVEL > (NAME   ARG1   ...   ARGN) 


On return from a traced `function', it prints
     
       < LEVEL  (NAME   VALUE1   ...   VALUEN) 


NAME is the name of the traced `function', ARGS are
the arguments, and VALUES are the return values.  LEVEL is
a number which is incremented each time a traced `function' is
invoked and is decremented at the completion of the invocation.  Trace
print-outs are indented according to the LEVEL.

In the current version of ECoLisp, macros and special forms cannot be
traced.



 -- Macro: trace {FUNCTION-NAME |               (FUNCTION-NAME {&keyFORM}*)}*

     Causes one or more functions to be traced.  Each FUNCTION-NAME
     must be a symbol which is not evaluated.  If a function is called from
     a compiled function in the same file, tracing will not be enabled.  If
     this is the case, to enable tracing, recompile the caller with a
     `notinline' declaration for the called function. `trace'
     returns a name list of those functions that were traced by the call to
     trace.  If no FUNCTION-NAME is given, `trace' simply
     returns a name list of all the currently traced functions.
     
     Trace options can cause the normal printout to be suppressed, or cause
     extra information to be printed.  Each option is a pair of an option
     keyword and a value form. If an already traced function is traced
     again, any new options replace the old options.  FORM is an
     expression to be evaluated in an environment where SYS::ARGLIST
     is bound to the current list of arguments to the function.
     
     The following options are defined:
     
     \kwd{cond} \var{form}, \kwd{cond-before} \var{form},
          {cond-after} FORM
               
          If {cond-before} is specified, then `trace' does nothing unless
          FORM evaluates to true at the time of the call.  {cond-after}
          is similar, but suppresses the initial printout, and is tested when the
          function returns.  {cond} tries both before and after.
          
     {step} FORM     
          If FORM evaluates to true, the stepper is entered.
          
     \kwd{break} \var{form}, {break-after} FORM
               
          If specified, and FORM evaluates to true, then the debugger is
          invoked at the start of the function or at the end of the function
          according to the respective option.
          
     \kwd{print} \var{form},{print-after} FORM
               
          In addition to the usual printout, the result of evaluating FORM
          is printed at the start of the function or at the end of the function,
          according to the respective option.  Multiple print options cause
          multiple values to be printed.
     




 -- Macro: untrace {FUNCTION-NAME}*

     Causes the specified functions to be not traced any more.
     FUNCTION-NAMES must be symbols and they are not
     evaluated. `untrace' returns a name list of those functions that
     were untraced by the call to `untrace'.  If no
     FUNCTION-NAME is given, `untrace' will untrace all the
     currently traced functions and will return a list of their names.
     



The Stepper
===========




 -- Macro: step FORM

     Starts evaluating the {it form} in the single-step mode.  In this
     mode, before any form is evaluated, the Stepper will print the form
     and prompt the user for a Stepper command.  The Stepper binds the two
     variables {print-level} and {print-length} both to
     `2', so that the current form may not occupy too much space on
     the screen.  A Stepper command will be executed when the user types
     the single character for the command followed by the required
     arguments, if any, and presses the newline key.  If the user presses
     the newline key without having typed any character, then the Stepper
     will assume that the Stepper command `n' was abbreviated.
     


The Stepper commands are:

`Newline'     
       Next.Evaluates the current form in the single-step mode. 
     
{s}, {skip}     
      Skip.Evaluates the current form in
     the ordinary mode.  The single-step mode will be resumed at completion
     of the evaluation.
     
{b}, {back}     
      Backwards.Steps back to previous step form.
     
{pr}, {print}     
      Print.Pretty-prints the current form.
     
{form}     
      Form.Return the current form.  Nothing is
     done, but the current form is returned as the value of this command.  As a
     consequence, it is printed by the top level in the usual way and saved in
     the variable `*'.  The main purpose of this command is to allow the
     current form to be examined further by accessing `*'.
     
{ret}, {return}     
      Return.Return without evaluating the
     current form.
     
{x}, {exit}     
      Exit.Evaluates the current form and any other forms in the ordinary mode.
     
`?'     
      Help.Lists the commands. 



Errors
======




 -- Variable: *break-enable*
     This variable is used to determine whether to enter the break loop (see
     Section 5.4) when an error occurs.  Even the function `break'
     checks this variable.  Initially, this variable is set to true, and
     thus an error will invoke the break loop.  If the value is nil,
     functions that cause fatal errors, such as ` error', will just
     print an error message and control will return to the top-level loop (or
     to the current break loop, if already in the break loop).  Functions
     that cause correctable errors, such as ` cerror', will print an
     error message and a ``continue message'', and control will return to the
     next form.  In ECoLisp, backtrace is not part of an error message, but a
     break loop command will print backtrace.  Therefore, if
     {break-enable} is nil, no backtrace appears on the screen.
     
     When the break loop is entered, {break-enable} will be bound
     to nil.
     



The Break Loop
==============

 
The break loop is a read-eval-print loop similar to the top-level
loop.  In addition to ordinary Lisp forms, the break loop accepts
various commands with which the user can inspect and modify the state
of the program execution.  Each break loop command is identified with
a keyword (i.e., a symbol in the `keyword' package).  A break
loop command is executed when the user inputs a list whose first
element is the keyword that identifies the command.  The rest of the
list is the arguments to the command.  They are evaluated before being
passed to the command.  If the command needs no arguments, then the
user may input only the keyword.  It is an error if the given keyword
does not identify any command.  Any other input to the break loop is
regarded as an ordinary Lisp form; the form will be evaluated and the
resulting values will be printed on the terminal.

There can be several instances of the break loop at the same time, and
each such instance is identified by a {*level number}.  When the*break loop is entered during execution in the top-level loop, the break
loop instance is given the level number 1.  The break loop instance that
is entered from the level {*n} break loop is given the level number*N|code{+1}.  The prompt of the level {*n} break loop is*N`+1' consecutive `>''s, occasionally prefixed with the
name of the current package.

The break loop keeps track of the invocation sequence of functions
(including special forms and macro expansion functions), which led up
to the break loop from the previous break loop (or from the top-level
loop, if the current break loop is level 1).  The invocation sequence
is maintained in a pushdown stack of {*events}.  An event consists*of an {*event function} and an {*event environment}.  An event*function is:*  1. 
     an interpreted (i.e., not compiled) function (global function, local function, lambda-expression, or closure), 
     
  2. a special form within an interpreted function, 
     
  3. a macro expansion function called from an interpreted function, 
     
  4. a compiled function called from an interpreted function, or 
     
  5. a compiled function called from another compiled function which
     was compiled while the `safety' optimize level is 3 or with a
     `notinline' declaration for the called function (see Chapter 7).


An event is pushed on the event stack when execution of its event
function begins, and is poped away at the completion of the execution.
An event environment is the `environment' of the event function at the
time the next event is pushed.  Actually, an event environment is a
pointer to the main stack of ECoLisp.  For each interpreted event function
(i.e., event function in classes 1, 2, and 3), the pointer points to
the first entry of the three contiguous main stack entries that hold
the lexical environment of the event function.  For each compiled
event function (i.e., event function in classes 4 and 5), the pointer
is set to the first entry of the main stack area that is used locally
by the compiled code.  In most cases, the first argument to the
compiled function is saved in the first entry, the second argument in
the second entry, and so on.  The local variables of the function are
allocated in the entries following the arguments.  However, this is
not always the case.  Refer to Section 7.3 for variable allocations in
compiled functions.

By break level commands, the user can choose one of the events as the
{*current event}.  If the current event function is an interpreted*event function, then the break loop evaluates Lisp forms in the
lexical environment retrieved from the event environment.  In
particular, local variables may be referenced by the variable names,
local functions and local macros may be invoked as usual, established
blocks may be exited from, and tags may be used as the destination of
`go'.  If the current function is a compiled function, Lisp
forms are evaluated in the null environment.

Within the break loop, each event is represented by the {*event*symbol}.  The {backtrace} command, for example, lists events in
terms of their event symbols.  If the event function is a named
function (global or local) or a macro expansion function, then the
function or macro name is used as the event symbol.  If the event
function is a special form, then the name of the special form is used.
If the event function is a lambda-expression (or a closure), then the
symbol lambda (or lambda-closure) is used.

To suppress unnecessary information, the user can hide (or make
invisible) some of the events.  Invisible events do not appear in the
backtrace, for example.  Initially, only those events are invisible
whose event symbols belong to the system internal package system.
When the break loop is entered, the last visible event becomes the
current event.

The break loop commands are described below.  Some of the commands
allow abbreviation in the keywords that identify them.  For example,
the user may abbreviate {current} as {c}.  The break
loop commands return no values at all.

"Break Command"{:current}{}
{Break Command}{:c}{}
Prints the event symbol of the current event.

"Break Command"{:previous}{&optionalN}
{Break Command}{:p}{&optionalN}
Makes the N-th previous visible event the
new current event.  Invisible events are not counted.  If there are
less than N previous events, then the first visible event in the
invocation sequence becomes the new current event. N must be a
positive integer and the default is `1'.

"Break Command"{:next}{&optionalN}
{Break Command}{:n}{&optionalN}
Makes the N-th next visible event the
new current event.  If there are less than N next events,
then the last visible event in the invocation sequence
becomes the new current event. N  must be a positive integer and the  
default is `1'.

"Break Command"{:backtrace}{}
{Break Command}{:b}{}
Prints the event symbols of all visible events in order.  The symbol of
the current event is printed
in upper-case letters and the event symbols of other events are in lower-case.

"Break Command"{:help}{}
{Break Command}{:h}{}
Lists the break loop commands.

"Break Command"{:quit}{&optionalN}
{Break Command}{:q}{&optionalN}
Returns control to the level N break loop.  If N is 0 or if
N is omitted, then control will return to the top-level
loop. N must be a non-negative integer smaller than the current
break level.

"Break Command"{:resume}{}
{Break Command}{:r}{}
Returns control to the caller of the break loop.  If the break loop has
been entered from `cerror', `cerror' returns nil as its
value and control will resume at that point.  Otherwise, this command
returns control to the previous break loop (or to the top-level loop, if
the current break level is `1').

"Break Command"{:variables}{}
{Break Command}{:v}{}
Prints the names of the bound variables in the current
environment.  To see the value of a bound variable, just type the
variable name.

"Break Command"{:functions}{}
Prints the names of the local functions and local macros
in the current environment.  To see the definition of a local function
or macro, use the function special form in the usual way.  That is,
`(function NAME)' will return the definition of the local
function or macro whose name is NAME.  Local functions and local
macros may be invoked as usual.

"Break Command"{:blocks}{}
Prints the names of the blocks established in the current
environment.  If a block BLOCK is established, then the `return-from' form `(return-from BLOCK VALUE)' works as
usual.  That is, the block form that established BLOCK will
return VALUE as its value and control will resume at that point.

"Break Command"{:tags}{}
Prints the tags established in the current environment.  If a tag 
TAG is established, then the `go' form `(go TAG)' works
as usual.  That is, control will resume at the position of
TAG in the surrounding `tagbody'.

"Break Command"{:local}{&optionalN}
{Break Command}{:l}{&optionalN}
If N is `0' or if it is omitted, then this command prints
the value stored in the main stack entry that is pointed to by the
current event environment. N is an offset from that entry.  If
N is positive, then the value of the {*n}-th next (i.e.,*toward the top of the main stack) entry is printed.  If N is
negative, then the value of the N-th previous (i.e., toward the
bottom of the main stack) entry is printed. N must be an
integer.  It is an error if the specified entry does not lie between
the bottom and the top of the stack.

"Break Command"{:hide}{SYMBOL}
Hides all events whose event symbol is SYMBOL.  In particular, by
`:hide 'lambda' and `hide 'lambda-closure', all events become
invisible whose event functions are lambda-expressions and closures,
respectively.  If the event symbol of the current event happens to be
SYMBOL, then the last previous visible event will become the new
current event.
SYMBOL must be a symbol.

Events of `eval' and `evalhook' may never become
invisible and attempts to hide them are simply ignored.  It is always
the case that the first event function is either `eval' 
or `evalhook'.  Keeping both of them visible is the simplest way
to avoid the silly attempts of the user to hide all events.

"Break Command"{:hide-package}{PACKAGE}
Hides all events whose event symbol belongs to the package
PACKAGE. PACKAGE may be any object that represents a
package, i.e., a package object, a symbol, or a string.  If the event
symbol of the current event happens to belong to the package
PACKAGE, then the last previous visible event will become the
new current event.  Even if `lisp' package was specified as
PACKAGE, events of `eval' and `evalhook' do not
become invisible.  See the description of {hide} above.

"Break Command"{:unhide}{SYMBOL}
{unhide} is the inverse command of {hide}.  If, however, 
SYMBOL belongs to one of the {hide-package}d packages, events
of SYMBOL become visible only after the package is `:unhide-package 'd'. SYMBOL must be a symbol.

"Break Command"{:unhide-package}{PACKAGE}
{unhide-package} is the inverse command of {hide-package}.
However, an event whose event symbol belongs to PACKAGE becomes
visible only after the symbol is `unhide 'd', if the symbol was
{code 'd} before. PACKAGE may be any object that
represents a package, i.e., a package object, a symbol, or a string.

Example:

     
     > (defun fact (x) (if (= x 0) one (* x (fact (1- x)))))
     fact                    ;;;  Wrong definition for  fact, the factorial. 
             
     > (fact 6)              ;;;  Tries to calculate factorial 6. 
     
     Error: The variable ONE is unbound.
     Error signalled by IF.
     
     Broken at IF:           ;;;  Enters the break-loop. 
     >> :h                   ;;;  Help. 
     
     Break commands:
     :q(uit)         Return to some previous break level.
     :pop            Pop to previous break level.
     :c(ontinue)     Continue execution.
     :b(acktrace)    Print backtrace.
     :f(unction)     Show current function.
     :p(revious)     Go to previous function.
     :n(ext)         Go to next function.
     :g(o)           Go to next function.
     :fs             Search forward for function.
     :bs             Search backward for function.
     :v(ariables)    Show local variables, functions, blocks, and tags.
     :l(ocal)        Return the nth local value on the stack.
     :hide           Hide function.
     :unhide         Unhide function.
     :hp             Hide package.
     :unhp           Unhide package.
     :unhide-all     Unhide all variables and packages.
     :vs             Show value stack.
     :bds            Show binding stack.
     :m(essage)      Show error message.
     :hs             Help stack.
     
     Top level commands:
     :cf             Compile file.
     :exit or ^D     Exit Lisp.
     :ld             Load file.
     :step           Single step form.
     :tr(ace)        Trace function.
     :untr(ace)      Untrace function.
     
     Help commands:
     :apropos        Apropos.
     :doc(ument)     Document.
     :h(elp) or ?    Help.  Type ":help help" for more information.
     
     >> :b                   ;;;  Backtrace. 
     Backtrace: eval > fact > if > fact > if > fact > if > fact >
     if > fact > if > fact > if > fact > IF
     
     >>: p                   ;;;  Moves to the previous event. 
     Broken at FACT.
     
     >> :b                   ;;;  Now inside of  fact  but outside of  if. 
     Backtrace: eval > fact > if > fact > if > fact > if > fact > 
     if > fact > if > fact > if > FACT > if
     
     >> :v                   ;;;  Shows local variables. 
     Local variables:
       X: 1
     Block names: FACT.
     
     >> x                    ;;;  The value of x is 1. 
     1
     
     >> (return-from fact 1) ;;;  Returns from the  fact  block with value  1. 
     720                     ;;;  Now the correct answer. 
     
     >                      ;;;  Top-level.



Describe and Inspect
====================



 -- Function: describe OBJECT

     Prints the information about OBJECT  to the stream that is
     the value of `*standard-output*'.  The description of an object
     consists of several fields, each of which is described in a recursive
     manner.  For example, a symbol may have fields such as home package,
     variable documentation, value, function documentation, function
     binding, type documentation, `deftype' definition, properties.



 -- Function: inspect OBJECT


Prints the information about OBJECT in an interactive manner.
The output of inspect is similar to that of `describe', but
after printing the label and the value of a field (the value itself is
not `describe 'd'), it prompts the user to input a one-character
command.  The input to `inspect' is taken from the stream that
is the value of `*query-io*'.  Normally, the inspection of OBJECT terminates after all of its fields have been inspected.  The
following commands are supported:

`n'     
      Next.hfill
     Goes to the next level; the field is inspected recursively.
     
`s'     
      Skip.hfill
     Skips the inspection of the field. `inspect'  proceeds to  
     the next field. 
     
`p'     
      Print.hfill
     Pretty-prints the field and prompts again.
     
`u' FORM     
      Update.hfill
     The FORM  is evaluated and the field is  
     replaced by the resulting value.  If the field cannot be updated, the message 
     `Not updated.'  will be printed. 
     
`a'     
      Abort.hfill
     Aborts the inspection of the current object.  The field and  
     the rest of the fields are not inspected.
     
`e' FORM     
      Eval.hfill
     Evaluates the specified form in the null environment 
     and prints the resulting values.  Then prompts again with the same 
     field.
     
`q'     
      Quit.hfill
     Aborts the entire inspection.
     
`?'     
      Help.hfill
     Lists the `inspect' commands.



Online Help
===========


Online help is provided by the following functions.


 -- Function: help &optionalSYMBOL

     `help' with no arguments prints a greeting message to ECoLisp beginners.
     `help' with a symbol argument prints the documentation associated
     with the symbol.



 -- Function: help* STRING &optionalPACKAGE

     Prints the documentation associated with those symbols in the specified
     PACKAGE whose print names contain STRING as substring.
     STRING may be a symbol, in which case the print name of that symbol is
     used. PACKAGE is optional and defaults to the LISP psackage.
     If PACKAGE is nil, then all packages are searched.



The Compiler
************

 
The ECoLisp compiler translates a Lisp program stored in a source file into
a C program, invokes the C compiler to compile the C program, and then
generates an object file, called {*fasl file} (or {*o-file}*because of the actual filetype).  The compiled program in a fasl file*is loaded by the function `load'.

Ordinarily, the object program generated by the ECoLisp compiler scarcely does
runtime error-checking for runtime efficiency.  In addition, Lisp functions
in the same source file are linked together and some system functions are
open-coded in-line.  To control runtime error checking, supply appropriate
`optimize' declarations (see Section 7.1).

The ECoLisp compiler processes the `eval-when' special form exactly
as specified in [Steele:84] (see Section 5.3.3 of [Steele:84]).

Notice that KCL and AKCL instead behave differently from the Common Lisp
specification, since they normally process all top-level forms in *compile-time-too* mode.  If it is desired that each top-level form
be processed in {*compile-time-too} mode, set the value of the variable `*eval-when-compiler*' to true.

The ECoLisp compiler is invoked by the functions `compile-file',
`compile', and `disassemble' described below.  In
addition, the ECoLisp compiler may be invoked directly by the Shell
commands `ecl'.  This command requires the file name of the
source file as its argument. `ecl' simply adds `.lsp' to
the file name argument to obtain the full name of the source file.

     
             `% ecl' FILENAME


has the same effect as the compiler invocation `(compile-file
FILENAME)' from within ECoLisp, and

     
             `% ecl -C' FILENAME


has the same effects as `(compile-file FILENAME :o-file t
:c-file t :h-file t :data-file t)'.


 -- Function: compile-file PATHNAME
        {:output-file :output-file :o-file :c-file :h-file :data-file}

     `compile-file' compiles the Lisp program stored in the
     file specified by INPUT-PATHNAME, and generates a binary file.
     Also `compile-file' generates the following temporary files.
     
     {*Temporary File} {*Contents}  {*c-file}    C version of the Lisp program *H-FILE   The include file referenced in the c-file 
     DATA-FILE   The Lisp data to be used at load time
     
     
     If files of these names already exist, the old files will be
     deleted first.  Usually, these intermediate files are automatically
     deleted after execution of `compile-file'.
     
     The input-file is determined in the usual manner (see Section 2.9),
     except that, if the filetype is not specified, then the default
     filetype `.lsp' will be used.  The keyword parameter `:output-file' defines the default directory and the default name to be
     applied to the output files (i.e., the fasl file and the temporary
     files).  {output-file} itself defaults to INPUT-PATHNAME.
     That is, if {output-file} is not supplied, then the directory
     and the name of the input file will be used as the default directory
     and the default name for the output files.  The filetypes of the
     output files are fixed as follows.
     
     
     {*Output File} {*Filetype} fasl file       `.o'  
             c-file          `.c' 
             h-file          `.h'  
             data-file       `.data'
     
     
     
     Each output file can be specified by the corresponding keyword
     parameter.  If the value of the keyword parameter is nil, then
     the output file will be deleted after execution of `compile-file'.  If the value of the keyword parameter is true,
     then the output file will be left in the default directory under the
     default name.  Otherwise, the output file will be left in the
     directory under the name specified by the keyword parameter.  The
     default value of {o-file} is true, and the default values
     of {c-file, :h-file}, and {data-file} are all `nil'.
     
          
          (compile-file 'foo) 
     
     
          
           The source file is `FOO.lsp' and the fasl file is `FOO.o'
          both in the current directory.
     
     
          
          (compile-file 'foo.lish) 
     
     
          
           The source file is `FOO.LISH' and the fasl file is `FOO.o''.
     
     
          
          (compile-file "/usr/mas/foo" :output-file "/usr/tai/baa") 
     
     
          
           The source file is `foo.lsp' in the directory `/usr/mas',
          and the fasl file is `baa.o' in the directory `/usr/tai'.
     



 -- Function: compile NAME CODE &optionalDEFINITION

     If DEFINITION  is not supplied, NAME  should be the name
     of a not-yet-compiled function.  In this case, compile compiles the
     function, replaces the previous definition of NAME with the
     compiled function,{*and} returns NAME.  If DEFINITION*is supplied, it should be a lambda-expression to be compiled and NAME should be a symbol.  If NAME is a non-nil symbol,
     then compile installs the compiled function as the function definition
     of NAME and returns NAME.  If NAME is nil,
     then compile simply returns the compiled function.
     
     The ECoLisp compiler is essentially a file compiler, and forms to be
     compiled are supposed to be stored in a file.  Thus compile actually
     creates a source file which contains the form designated by the
     arguments.  Then compile calls `compile-file' to get a fasl
     file, which is then loaded into ECoLisp.  The source file and the fasl
     file are given the names {`gazonk.lsp} and {`gazonk.fasl},'respectively.  These files are not deleted automatically after the'execution of `compile'.
     




 -- Function: disassemble &optionalTHING {:h-file :data-file}

     This function does not actually disassemble.  It always calls
     the ECoLisp compiler and prints the contents of the c-file, i.e., the
     C-language code, generated by the ECoLisp compiler.  If THING is not
     supplied, or if it is nil, then the previously compiled form
     by disassemble will be compiled again.  If THING is a symbol
     other than nil, then it must be the name of a not-yet-compiled
     function, whose definition is to be compiled.  In this case, it is an
     error if the name is associated with a special form or a macro.  If
     THING is a lambda-expression `(lambda LAMBDA-LIST .
     BODY)', then `disassemble' first creates a function definition
     `(defun gazonk LAMBDA-LIST .  BODY)' and this definition
     is compiled.  (The function name `gazonk' has no special
     meanings.  Indeed, the displayed code is essentially independent of
     the function name.)  Otherwise, THING itself will be compiled as
     a top-level form.  In any case, `disassemble' does not install
     the compiled function.  `disassemble' returns no value.
     
     No intermediate h-file is created if the keyword parameter `:h-file' is nil or if {h-file} is not supplied.
     Otherwise, an intermediate h-file is created under the name specified
     by {h-file}.  Similarly, the intermediate data-file is
     specified by the keyword parameter {data-file}.
     


  -- Variable: *eval-when-compile*
     The compiler processes each
     top-level form in "not-compile-time" mode if the value of
     this variable is nil, and in "compile-time-too" mode,
     otherwise.  See Section 5.3.3 of [Steele:84] for these two modes.
     The initial value of this variable is nil.




Declarations
************

 
ECoLisp supports all kinds of declarations described in the
[Steele:84].  Any valid declaration will affect the ECoLisp environment in
some way or another, although information obtained by declarations,
other than special declarations, is mainly used by the ECoLisp compiler.

As described in [Steele:84], Common Lisp declarations are divided into
two classes: PROCLAMATIONS and others.  A proclamation is a global
declaration given by the function `proclaim', the top-level
*macro* `defvar', or the top-level macro `defparameter'.
Once given, a proclamation remains effective during the ECoLisp session
unless it is shadowed by a local declaration or is canceled by another
proclamation.  Any other declaration is a *local declaration* and
is given only by the special form `declare'.  A local declaration
remains in effect only within the body of the construct that surrounds
the declaration.

In the following nonsensical example borrowed from Chapter 9 of
[Steele:84],

     
     (defun nonsense (k x z)
        (foo z x)
        (let ((j (foo k x))
              (x (* k k)))
             (declare (inline foo) (special x z))
          (foo x j z)))


the `inline' and the special declarations both remain
in effect within the surrounding `let' form.  In this case,
we say that the `let' form is the {*surrounding*construct} of these declarations.


 -- Function: proclamation DECL-SPEC

     This function is introduced to ECoLisp so that the user can see currently
     effective proclamations.  The argument DECL-SPEC specifies the
     proclamation to be checked.  It may be any declaration specification that
     can be a valid argument to the function `proclaim'.  The
     function `proclamation' returns true if the specified
     proclamation is still in effect.  Otherwise, it returns nil.
     For example,
     
          
          >(proclaim '(special *x*))  ;;;  The variable  *x*  is 
          nil                         ;;;  proclaimed to be globally special. 
           
          >(proclamation '(special *x*))
          t
           
          >(defvar *y*)                ;;;  Another way to proclaim a variable 
          nil                          ;;;  to be globally special. 
           
          >(proclamation '(special *y*))
          t
     
     




 -- Special form: the VALUE-TYPE FORM

     The ECoLisp interpreter does actually check whether the value of the
     {*form} conforms to the data type specified by {*value-type} and*signals an error if the value does not.  The type checking is performed by*the function `typep'.  For example,


     
     (the fixnum (foo))


is equivalent to
     
     (let ((values (multiple-value-list (foo))))
        (cond ((endp values) (error ``Too few return values."))
              ((not (endp (cdr values)))
               (error ``Too many return values."))
              ((typep (car values) 'fixnum) (car values))
              (t (error ``~s is not of type fixnum." (car values)))))


     
      On the other hand, the ECoLisp compiler uses the special form to
     obtain type information for compiled code optimization. No code for
     runtime type-checking is embedded in the compiled code.



Declaration Specifiers
======================

 
ECoLisp recognizes all declaration specifiers defined in [Steele:84].
The syntax of each such declaration specifier is exactly the same as
defined in [Steele:84].  In addition, ECoLisp recognizes the `object' declaration specifier which is specific to ECoLisp.

"Declaration"{special}{{VARIABLE-NAME}*}
The interpreter and the compiler of ECoLisp both treat special
declarations exactly as described in [Steele:84].

"Declaration"{type}{TYPE {VARIABLE-NAME}*}
A `type' proclamation  `(type {*type var1*var2} ...)' specifies that the dynamic values of the named variables
are of the type {*type}.  A local `type' declaration*specifies that the variables mentioned are bound by the surrounding
construct and have values of the type {*type} during execution of*the surrounding construct.  The compiler issues a warning if one of
the named variables is not bound by the surrounding construct.  The
information given by `type' declarations is used by the compiler
to optimize the compiled code.  The behavior of the compiled code is
unpredictable if a wrong `type' declaration is supplied.  The
compiler detects certain wrong `type' declarations at compile
time.

For example,
     
     >(defun foo (x y)
        (declare (fixnum x) (character y))
        (setq x y)
       ...))
     foo
     
     >(compile 'foo)
     
     ; (defun foo ...) is being compiled.
     ;; Warning: Type mismatches between x and y.


See Section 7.3 for further information on `type' declarations.

"Declaration"{type}{{VARIABLE-NAME}*
(TYPE VAR1 VAR2 ...) is equivalent to
 `(type TYPE VAR1 VAR2 ...)', provided
that TYPE is one of the symbols in Table 4-1
of [Steele:84], other
than `function'.  Declaration specifications that begin
with `function' are
regarded as `function' declarations (see below).

"Declaration"{function}{FUNCTION-NAME ARGUMENT-TYPES . RETURN-TYPES}
A `function' declaration is used to obtain type
information for function call forms.  That is, a `function'
declaration specifies the argument and the return types of each form
that calls the named function.

     
     (defun foo ()
       (declare (function bar (character) fixnum))
       (+ (bar (atcholi1)) (bar (atcholi2))))


In this example, the `function' declaration
specifies that the two functions `atcholi1' and `atcholi2'
both return character objects when called within the body of `foo', and that the function bar returns fixnum objects when called
within the body of `foo'.  The type information given by
function declarations is used by the compiler to optimize the compiled
code.  The behavior of the compiled code is unpredictable if a wrong
`function' declaration is supplied.  The compiler detects
certain wrong `function' declarations at compile time.

For example,

     
     >(defun foo (x)
        (declare (fixnum x)
                 (function bar (character) fixnum))
        (bar x))
     foo
     
     >(compile 'foo)
     
     ; (defun foo ...) is being compiled.
     ;; Warning: The type of the form x is not character.


However, the compiler does not check the number of arguments, and thus,
the following function definition will be compiled successfully without
any warnings.

     
     (defun foo ()
       (declare (function bar (character character) fixnum))
       (+ (bar (atcholi1)) (bar (atcholi2) (atcholi3) (atcholi4))))


For this definition, the compiler assumes that the three functions
`atcholi1', `atcholi2', and `atcholi3' will return
fixnum objects.  The return type of `atcholi4' is unknown at
compile time.

The complete syntax of a function declaration is:

     
     (function  function-name
       ( {type}* [ { &optional|&rest |&key } {thing}* ] )
       { (values { type }* ) |{ type }* } 
     )


Although &optional, &rest, and &keymarkers may appear in the list of
argument types, only those TYPES are recognized that appear before
any such markers and the rest of the list is simply ignored.  Note that
functions with &optional, &rest, or &keyparameters may still be
declared by `function' declarations because of the use of `function' declarations mentioned above.

The `values' construct in the specification of return types is
almost useless: `(function FUNCTION-NAME ARGUMENT-TYPES
(VALUES TYPE1 TYPE2 ...))'  is equivalent to `(function FUNCTION-NAME ARGMENT-TYPES TYPE1 TYPE2 ...)'.  We, the
implementors of ECoLispwonder why the value construct was introduced in
Common Lisp.

See Section 7.3 for further information on `function' declarations.

"Declaration"{ftype}{FUNCTION-TYPE
{FUNCTION-NAME}*} FUNCTION-TYPE must be a list whose
first element is the symbol `function'.  `(ftype (function
. REST) FUNCTION-NAME-1 ...  FUNCTION-NAME-N)' is
equivalent to
N consecutive `function' declarations `(function
FUNCTION-NAME-1 . REST')} ... `(function
FUNCTION-NAME-N . REST')}.

"Declaration"{notinline}{{FUNCTION-NAME}*}
`(notinline FUNCTION1 FUNCTION2 ...)'  specifies
that the compiler should not compile the named functions in-line.  Calls
to the named functions can be traced and an event (see Section 5.4) is pushed
on the event stack when any one of the named functions is invoked.

"Declaration"{inline}{{FUNCTION-NAME}*}
An `inline' proclamation cancels currently
effective `notinline' proclamations, and a local
`inline' declaration locally shadows currently effective
`notinline' declarations.

     
     >(defun foo (x)
        (cons (car x)
              (locally (declare (inline car)) (car x))))
     foo
     
     >(defun bar (x)
        (cons (car x)
              (locally (declare (inline car)) (car x))))
     foo
     
     >(proclaim '(notinline car))
     nil
     
     >(compile 'foo)
     ...
     
     >(proclaim '(inline car))
     nil
     
     >(compile 'bar)
     ...


Usually, primitive functions such as `car' are
compiled in-line.  Therefore, in this example, only the first call to
`car' within `foo' is compiled not in-line.

In general, the ECoLisp compiler compiles functions in-line whenever
possible.  Thus an `inline' declaration `(inline FUNCTION1 FUNCTION2 ...)' is worthless if none of the named functions
have previously been declared to be `notinline'.

"Declaration"{ignore}{{VARIABLE-NAME}*}
Usually, the compiler issues a warning if a lexical variable is
never referred to.  `(ignore VAR1 ...  VARN)' causes the
compiler not to issue a warning even if the named variables are never
referred to.  The compiler issues a warning if one of the named
variables is not bound by the surrounding construct, or if a named
variable is actually referred to.  `ignore' proclamations are
simply ignored.

"Declaration"{optimize}{{(QUALITY VALUE) |QUALITY}}*}
ECoLisp supports the four `optimize' qualities listed in the
[Steele:84].

`speed' and `compilation-speed' are used to set up the
optimization switch of the C language compiler which is invoked to
compile the C-language code generated by the ECoLisp compiler (see Chapter
6).  `(optimize (speed N))' and `(optimize
(compilation-speed M))' are equivalent, where N and M are integers between 0 and 3, and M is equal to 3-N.
When a ECoLisp session is started, the `speed' quality is set to 3.
That is, by default, the compiler generates the fastest code in the
longest compilation time.  The `space' quality specifies whether
the code size is important or not: The compiled code is a little bit
larger and faster when compiled with the space quality 0, than when
compiled with the space quality 1, 2, or 3.  When a ECoLisp session is
started, the `space' quality is set to 0.  The `safety'
quality determines how much runtime error checking code should be
embedded in the compiled code.  If the `safety' quality is 0,
the compiled code scarcely does runtime error checking.  If the `safety' quality is 1, then the compiled code for a function will check
the number of arguments to the function at runtime.  If the `safety' quality is 2 or 3, then the compiled code does full runtime
error checking.  In addition, the highest quality value 3 causes the
compiler to treat all functions as if they were declared to be `notinline'.  When a ECoLisp session is started, the `safety'
quality is set to 0.

"Declaration"{declaration}{{NAME}*}
A `declaration' declaration is used exactly as specified in the
[Steele:84].

"Declaration"{object}{{VARIABLE-NAME}*}
This is the only declaration specifier that is specific to ECoLisp.     
`(object VAR1  ...  VARN)'  affects only variable bindings and
specifies that the named variables can be allocated in the
C stack (see Section 7.3).  The compiler issues a warning if
one of the named variables is not bound by the surrounding
construct. `object' proclamations are simply ignored.


Significant Type Specifiers
===========================


Whenever a declaration is encountered, each type specifier
(if any) in the declaration is converted to one of the following type
specifiers, which are collectively called the {*significant type*specifiers}.

     
               |------------   fixnum 
               |------------   character 
               |------------   short-float 
               |------------   long-float 
           t --|----   (array t)  --------------  (vector t) 
               |----   (array fixnum)  ---------  (vector fixnum) 
               |----   (array string-char)   ---  string 
               |----   (array short-float)   ---  (vector short-float) 
               |----   (array long-float)    ---  (vector long-float) 
               |----   (array bit)   -----------   bit-vector 


Here, the lines indicate subtype relations; the right type
is a subtype of the left type.  For instance, `(vector t)' 
is a subtype of  `(array t)'  and true, and
`(array t)' itself is a subtype of true.  However,
`(array t)' and `(array string-char)' are disjoint types.

The function `subtypep' is used for the conversion to significant
type specifiers: If the first value of `(subtypep RAW-TYPE
TYPE)' is
true for one of the significant type specifiers TYPE,
then the type specifier RAW-TYPE in
the declaration is converted to TYPE.  If there are more than one
such significant type specifiers, then the type specifier that is a
subtype of other specifiers is selected.
For example, type specifiers {fixnum},  `(mod 3)', and
`(member 0 1)' are all converted to {fixnum}, though they are
also subtypes of true.

Because of this type specifier conversion, ECoLisp may sometimes regard
two seemingly distinct declarations as the same.
For example, the following `type' declarations are completely equivalent,
internally in ECoLisp.

     
     declare (type fixnum x))
     
     declare (type (mod 3) x))
     
     declare (type (member 0 1) x))

 
Type specifiers in declaration specifications passed to the
ECoLisp specific function
`proclamation' are also converted to significant type specifiers.  Thus, for example,

     
     >(proclaim '(function foo (fixnum) fixnum))
     nil
     
     >(proclamation '(function foo ((mod 3)) (member 0 1)))
     t
     
     >(proclamation '(function foo (number) character))
     nil


The first call to `proclamation' returns true because
both `(mod 3)' and `(member 0 1)'  are converted to
{fixnum} before the function type of `foo' is checked.


Treatment of Type Declarations
==============================

 
ECoLisp uses several runtime stacks.

Arguments to functions, lexical and temporary variables are allocated
on the C stack. Temporary values saved on the C stack may sometimes be
represented as RAW DATA instead of pointers to heap-allocated
cells.  Accessing such raw data on the C stack results in faster
compiled code, partly because no pointer deferencing operation is
necessary, and partly because no cell is newly allocated on the heap
when a new object is created. This is particularly helpful for numeric code
which computes with floating point numbers.

ECoLisp uses a conservative garbage collector to scan the C stack and find
references to live object.


Variable Allocations
====================


If a lexical variable is declared to be of {fixnum},
`character', `short-float', `long-float', or their
subtypes, then it is allocated on the C stack rather than on the value
stack.  In addition, the variable always has a raw datum as its value:
32 bit signed integer for fixnums, 8 bit character code with 24 bit
padding for characters (remember that the font and bit fields of ECoLispcharacters are always 0), 32 bit floating point representation for
short-floats, and 64 bit floating point representation for
long-floats.  Similarly, if a lexical variable is named in an `object' declaration (see Section 7.1), then it is allocated on the C
stack but, in this case, the variable always has a cell pointer as its
value.  The user is strongly recommended to make sure that objects
stored in such an `object' variable may never be garbage
collected unexpectedly.  For example,

     
     (do ((x (foo) (cdr x)))
         ((endp x))
         (let ((y (car x)))
              (declare (object y))
           (bar y)))


this `object' declaration is completely safe because the value
of the variable Y is always a substructure of the value of
X, which in turn is protected against garbage collection.
Incidentally, loop variables of `dolist' may always be declared
as object variables, since the `dolist' form has essentially the
same control structure as the `do' form above.  On the other
hand, the result of evaluation of the following form is unpredictable,
because the cons cell pointed to from the `object' variable
Z may be garbage collected before `bar' is called.

     
     (let ((z (cons x y)))
          (declare (object z))
       (foo (cons x y))
       (bar z))


Lexical variables that are not declared to be of {fixnum},
{character}, {short-float}, {long-float}, or
their subtypes, and that are not named in `object' declarations
are usually allocated on the value stack, but may possibly be allocated
on the C stack automatically by the compiler.


Built-in Functions that Operate on Raw Data Directly
====================================================

 
Some built-in Common Lisp functions can directly operate on raw data, if
appropriate declarations are supplied.  The addition function ) is
among such functions.

     
     (let ((x 1))
          (declare (fixnum x))
       ...
       (setq x (+ x 2))
       ...
       )


In the compiled code for this `let' form, the raw fixnum datum
(i.e., the 32 bit signed integer) stored in X is simply
incremented by 2 and the resulting 32 bit signed integer is stored
back into X.  The compiler is sure that the addition for 32
bit signed integers will be performed on the call to `+', because
the arguments are both fixnums and the return value must be also a
fixnum since the value is to be assigned to the {fixnum}
variable.  The knowledge of both the argument types and the return
type is necessary for this decision: Addition of two fixnums may
possibly produce a bignum and addition of two bignums may happen to
produce a fixnum value.  If either the argument type or the return
type were not known to the compiler, the general addition function
would be called to handle the general case.  In the following form,
for example, the compiler cannot be sure that the return value of the
multiplication is a fixnum or that the arguments of the addition are
fixnums.

     
     (setq x (+ (* x 3) 2))


In order to obtain the optimal code, a `the' special form should
surround the multiplication.

     
     (setq x (+ (the fixnum (* x 3)) 2))


Built-in Common Lisp functions that can directly operate on raw data are:

  1. arithmetic functions such as `+',  `-',
     `1+', `1-',  `*', `floor',  `mod', `/', and
     `expt'.
     
  2. predicates such as `eq', `eql', `equal',
     `zerop', `plusp', `minusp', `=', `/=', `<',
     `<=', `>', `>=', `char=', `char/=', `char<',
     `char<=', `char>', and `char>='.
     
  3. sequence processing functions that receive or return one or more
     fixnum values, such as `nth', `nthcdr', `length', and
     `elt'.
     
  4. array access functions such as `svref', `char', `schar',
     and `aref' (see below).
     
  5. system-internal functions for array update (see below).
      
  6. type-specific functions such as `char-code', `code-char',
     and `float'.


As mentioned in Section 2.5.1, array elements are represented in one
of six ways depending on the type of the array.  By supplying
appropriate array type declarations, array access and update
operations can handle raw data stored in arrays.  For example,

     
     (let ((a (make-array n :element-type 'fixnum))
           (sum 0))
          (declare (type (array fixnum) a)
                   (fixnum sum))
       (dotimes (i n)             ;;; Array initialization.
                (declare (fixnum i))
          (setf (aref a i) i))
       ....
       (dotimes (i n)             ;;; Summing up the elements.
                (declare (fixnum i))
          (setq sum (+ (aref a i) sum)))
       ....
       )


The `setf' form replaces the `i-th' element of the
array  a  by the raw fixnum value of `i'.  The
`aref' form retrieves the raw fixnum datum stored
in `a'.  This raw datum is then added to the raw fixnum
value of the fixnum variable `sum', producing the raw fixnum datum to be stored
in `sum'.  Similar raw data handling is possible for
arrays of types
`(array fixnum),  (vector fixnum),
 (array string-char),  string,
 (array short-float),  (vector short-float),
 (array long-float)', and `(vector long-float)'.


Arguments/Values Passing
========================


Function proclamations `(function FUNCTION-NAME
(ARG-TYPE1 ARG-TYPE2 ...) RETURN-TYPE)' or its
equivalents give the compiler the chance to generate compiled code so
that arguments to the named functions and resulting values of the named
functions will be passed via the C stack, thus increasing the efficiency
of calls to these functions.  Such arguments/values passing via the C
stack is possible only if the called function is also defined in the
same source file.  This is because the code for the called function must
have two entries: One entry for C arguments/values passing and another
for ordinary Lisp arguments/values passing.  (An ordinary function has
only the latter entry.)  When the latter entry is used, the arguments
are {*unboxed} and passed to the former entry.  On return from the*function, the resulting value is cast into a Lisp data type.

A good example of this follows.

     
     (eval-when (compile)
       (proclaim '(function tak (fixnum fixnum fixnum) fixnum)))
     
     (defun tak (x y z)
       (declare (fixnum x y z))
       (if (not (< y x))
           z
           (tak (tak (1- x) y z)
                (tak (1- y) z x)
                (tak (1- z) x y))))
     
     ;;; Call (tak 18 12 6).


When `tak' is called with the arguments `18, 12', and `6', the raw fixnum data of the arguments are set to the parameters
`x', `y', `z'.  After that, only raw C data are used
to perform the execution: No cell pointers are newly allocated nor even
referenced.  The built-in functions ) and `1-' directly
operate on the raw data.  Only at the return from the top-level call of
`tak', the resulting raw data value (which happens to be `7') is reallocated on the heap.  Note that both the `function'
proclamation and the local {fixnum} declaration are necessary
to obtain the optimal code.  The `function' proclamation is
necessary for arguments/values passing via the C stack and the
{fixnum} declaration is necessary to unbox the parameters into
C variables.


Operating System Interface
**************************


ECoLisp provides the following facilities that are not defined in
[Steele:84].


 -- Function: save-system FILENAME

     `save' saves the current memory image into a program file FILENAME.
     After saving the memory image, the ECoLisp process terminates
     immediately.  To execute the saved program file, specify the full
     pathname of the file, as indicated in the example below.
     
     
          Example:
          
          >(defun plus (x y) (+ x y))
          plus
          
          >(save "savefile")
          %
          
          % pwd
          /usr/hagiya
          % /usr/hagiya/savefile
          
          >(plus 2 3)
          5
          
          >(quit)
          Bye.
          %
     



 -- Function: system STRING

     Executes a Shell command as if STRING is an input to the Shell.  
     On return from the Shell command, `system' returns the exit code
     of the command as an integer.




 -- Function: quit &optionalEXIT-CODE

     Terminates ECoLisp and returns the EXIT-CODE to the parent process.
     EXIT-CODE must be an integer and its default value is `0'.



Macros
******

 

System Macros
=============

 
The ECoLisp interpreter implements the following system macros as if
they were special forms.  That is, macro forms of the following macros are
directly evaluated without being macro-expanded.

     
         and       case      cond      decf      defmacro  defun
         do        do*       dolist    dotimes   incf      locally
         loop      multiple-value-bind           multiple-value-list
         multiple-value-setq           or        pop       prog
         prog*     prog1     prog2     psetq     push      return
         setf      unless    when


For these macro forms, the functions `macro-function' and
`special-form-p' both return non-nil values:
`macro-function' returns the macro expansion function and
`special-form-p' returns true.  Of course, functions such as
`macroexpand' and `macroexpand-1' will successfully expand
macro forms for these system macros.


Defmacro Lambda-Lists
=====================

 
A "defmacro lambda-list" is a lambda-list-like construct that is used
as the third element in the `defmacro' form,
     
     (defmacro NAME DEFMACRO-LAMBDA-LIST {DECLARATION DOC-STRING} {FORM})


The description of defmacro lambda-lists in [Steele:84] is quite ambiguous.
ECoLisp employs the following syntax.

The complete syntax of a defmacro lambda-list is:

     
     ( [ &whole VAR ]
       [ &environment VAR ]
       { PSEUDO-VAR }*
       [ &optional{ var |( pseudo-var [ initform [ pseudo-var ] ] ) }* ]
       { [ { &rest |&body } pseudo-var ]
         [ &key { var |( { var |( keyword pseudo-var ) } 
                          [ initform [ pseudo-var ] ] ) }* 
                  [ &allow-other-keys ] ] 
           [ &aux { var |( pseudo-var [ initform ] ) }* ] 
      |. var } 
     )


where PSEUDO-VAR is either a symbol or a list of the following form:

     
     ( { pseudo-var }* 
       [ &optional{ var |( pseudo-var [ initform [ pseudo-var ] ] ) }* ] 
       { [ { &rest |&body } pseudo-var ] 
         [ &key { var |( { var |( keyword pseudo-var ) } 
                          [ initform [ pseudo-var ] ] ) }* 
                  [ &allow-other-keys ] ] 
           [ &aux { var |( pseudo-var [ initform ] ) }* ] 
       |. var } 
     )


The defmacro lambda-list keyword `&whole' may appear only at the
top-level, first in the defmacro lambda-list.  It is not allowed within
PSEUDO-VAR.  Use of the `&whole' keyword does not affect the
processing of the rest of the defmacro lambda-list:

     
     (defmacro foo (&whole w x y) ...)

and
     
     (defmacro foo (x y) ...)


both bind the variables `x' and `y' to the second and the
third elements, respectively, of macro forms of `foo'.

The defmacro lambda-list keyword `&environment' may appear only at
the top-level, first in the defmacro lambda-list if `&whole' is
not supplied, or immediately after the variable that follows
`&whole', if `&whole' is supplied.  `&environment' is
not allowed within PSEUDO-VAR.  Like `&whole', use of
`&environment' does not affect the processing of the rest of the
defmacro lambda-list.  If an `&environment' parameter is supplied
andif this parameter is not used at all, then the ECoLisp compiler will
issue a warning.  To suppress the warning, just remove the parameter
from the defmacro lambda-list, or add an `ignore' declaration.
 
The defmacro lambda-list keyword `&body' is completely
equivalent to the &restkeyword.  ECoLisp takes no special action
for `&body' parameters.

Although useless, ECoLisp allows supplied-p parameters to be destructured.
This is useless because supplied-p parameters can never be bound to a
non-empty list.  Our intention is to stick to the specification in the
[Steele:84] as far as possible, even if it is silly to do so.

Like for ordinary lambda-lists, the interpreter detects invalid arguments to macro expansion functions.  When a parameter is destructured, the
structure of the corresponding argument is also checked.  Such runtime
argument checking may or may not be embedded in compiled code, depending on
the environment when the code was generated.  If the code
was generated while the `safety' optimize level is zero (that is,
while the value of `(proclamation '(optimize (safety 0)))' is true),
then the generated code does not perform argument checking at all.
Otherwise, the compiled code does check the validity of arguments.


The C Language Interface
************************

 
This chapter describes the facility of ECoLisp to interface the C language
and ECoLisp.  With this facility, the user can arrange his or her C-language
programs so that they can be invoked from ECoLisp. In addition, the user can
write Lisp function definitions in the C language to increase runtime
efficiency.

The basic idea of interfacing the C language is this:  As mentioned
in Chapter 6, the ECoLisp compiler, given a Lisp source file, creates an
intermediate C-language program file, called {*c-file}, which is*then compiled by the C-language compiler to obtain the final
fasl-file.  Usually, the c-file consists of C-language function
definitions.  The first C-language function in the c-file is the
``initializer'', which is executed when the fasl file is loaded, and
the other C-language functions are the C versions of the Lisp
functions (including macro expansion functions) defined in the source
file.  By using the top-level macros `Clines' and `defCfun'
described below, the user can direct the compiler to insert his or her
own C-language function definitions and/or C-language preprocessor
macros such as `#define' and `#include' into the c-file.  In
order that such C-language functions be invoked from ECoLisp, another
top-level macro `defentry' is used.  This macro defines a Lisp
function whose body consists of the calling sequence to the specified
C-language function.

The C-language function definitions are placed in the c-file in the
order of the corresponding Lisp functions defined
in the source file.  That is, the C code for the first Lisp function comes
first, the C code for the second Lisp function comes second, and so on.  If
a `Clines' or `defCfun' macro form appears between two
Lisp function definitions in the source file, then the C code specified by
the macro is placed in between the C code for the Lisp functions.

We define some terminology here which is used throughout this Chapter.
A {*C-id} is either a Lisp string consisting of a valid C-language*identifier, or a Lisp symbol whose print-name, with all its alphabetic
characters turned into lower case, is a valid C identifier.  Thus the
symbol `foo' is equivalent to the string `"foo"' when used as
a C-id.  Similarly, a {*C-expr} is a string or a symbol that may be*regarded as a C-language expression.  A {*C-type} is one of the Lisp*symbols `int, char, float, double,' and `object'.  Each
corresponds to a data type in the C language; `object' is the
type of Lisp object and other C-types are primitive data types in C.


 -- Macro: Clines {string}*

     When the ECoLisp compiler encounters a macro form  `(Clines        
     STRING1 ...  STRINGN)', it simply outputs the STRINGS into
     the c-file.  The arguments are not evaluated and each argument must be
     a string.  Each STRING may consist of any number of lines, and
     separate lines in the STRING are placed in separate lines in the
     c-file.  In addition, each STRING opens a fresh line in the
     c-file, i.e., the first character in the STRING is placed at the
     first column of a line.  Therefore, C-language preprocessor commands
     such as `#define' and `#include' will be recognized as
     such by the C compiler, if the ' # ' sign appears as the first
     character of the STRING or as the first character of a line
     within the STRING.
     
     When interpreted, a `Clines' macro form expands to nil.
     





 -- Macro: defentry FUNCTION PARAMETER-LIST C-FUNCTION

     `defentry' defines a Lisp function whose body consists of the
     calling sequence to a C-language function. FUNCTION is the name
     of the Lisp function to be defined, and C-FUNCTION specifies
     the C function to be invoked. C-FUNCTION must be either a list
     `(TYPE C-ID)' or C-ID, where TYPE and
     C-ID are the type and the name of the C function. TYPE
     must be a C-type or the symbol `void' which means that the C
     function returns no value.  `(object C-ID)' may be
     abbreviated as C-ID.  PARAMETER-LIST is a list of C-types
     for the parameters of the C function.  For example, the following
     `defentry' form defines a Lisp function `tak' from which
     the C function `tak' above is called.
     


     
     (defentry tak (int int int) (int tak))


The Lisp function `tak' defined by this `defentry' form
requires three arguments.  The arguments are converted to
`int' values before they are passed to the C function.  On return
from the C
function, the returned `int' value is converted
to a Lisp integer (actually a fixnum)
and this fixnum will be returned as the value
of the Lisp function.  See below for
type conversion between Lisp and the C language.

A `defentry' form is treated in the above way only when it
appears as a top-level form of a Lisp source file.  Otherwise, a
`defentry' form expands to nil.



 -- Macro: defla NAME LAMBDA-LIST {declaration |DOC-STRING}*


When interpreted, `defla' is exactly the same as `defun'.
That is, `(defla NAME LAMBDA-LIST .  BODY)' expands to
`(defun NAME LAMBDA-LIST .  BODY)'.  However, `defla'
forms are completely ignored by the compiler; no C-language code will be
generated for `defla' forms.  The primary use of `defla' is
to define a Lisp function in two ways within a single Lisp source file;
one in the C language and the other in Lisp.  `defla' is short for
{*DEF}ine {*L}isp {*A}lternative.*you have a Lisp source file whose contents are:

     
     ;;; C version of TAK.
     (Clines "
     
            int tak(x, y, z)                           
            int x, y, z;
            {       if (y >= x) return(z);
                    else return(tak(tak(x-1, y, z),
                                    tak(y-1, z, x),
                                    tak(z-1, x, y)));
           }
     "
     )
     
     ;;;  TAK calls the C function tak defined above.
     (defentry tak (int int int) (int tak))
     ;;;  The alternative Lisp definition of TAK.
     (defla tak (x y z)
        (if (>= y x)
            z
            (tak (tak (1- x) y z)
                 (tak (1- y) z x)
                 (tak (1- z) x y))))


When this file is loaded into ECoLisp, the interpreter uses the Lisp version
of the `tak' definition.  Once this file has been compiled, and when
the generated fasl file is loaded into ECoLisp, a function call to `tak'
is actually the call to the C version of `tak'.



 -- Function: defCbody NAME ARGS-TYPES RESULT-TYPE C-EXPR

     The ECoLisp compiler produces a function named NAME with as many
     arguments as ARG-TYPES.
     The C-EXPR is an arbitrary C expression where the arguments to
     the function are denoted by `#{*i}', where `{*i}' is*the integer corresponding to the argument position.*The ARGS-TYPES is the list of Common Lisptypes of the arguments to the
     function, while RESULT-TYPE is the Common Lisptype of the result.
     The actual arguments are coerced to the required types before executing
     the C-EXPR and the result is converted into a Lisp object.
     `defCbody' is ignored by the interpreter.


For example, the logical AND of two integers could be defined as:
     
     (defCbody logand (fixnum fixnum) fixnum "(#0) & (#1)")



 -- Function: definline NAME ARGS-TYPES RESULT-TYPE C-EXPR

     `definline' behaves exactly as `defCbody'.
     Moreover, after a `definline' definition has been supplied,
     the ECoLisp compiler will expand inline any call to function NAME into
     code corresponding to the C language expression C-EXPR, provided
     that the actual arguments are of the specified type.
     If the actual arguments cannot be coerced to those types, the inline
     expansion is not performed.
     `definline' is ignored by the interpreter.
     


For example, a function to access the n-th byte of a string and return it
as an integer can be defined as follows:

     
     (definline aref-byte (string fixnum) fixnum
        "(#0)->ust.ust_self[#1]")


The definitions of the C data structures used to represent Common Lispobjects can be found in file `ecl.h' in the directory `"src/h"'
of the source distribution.

ECoLisp converts a Lisp object into a C-language data by using the
Common Lisp function `coerce': For the C-type `int' (or
`char'), the object is first coerced to a Lisp integer and the
least significant 32-bit (or 8-bit) field is used as the C `int'
(or `char').  For the C-type `float' (or `double'),
the object is coerced to a short-float (or a long-float) and this
value is used as the `C float' (or `double').  Conversion
from a C data into a Lisp object is obvious: `C char, int,
float,' and `double' become the equivalent Lisp
`character', `fixnum', `short-float', and
`long-float', respectively.

Here we list the complete syntax of `Clines', `defentry',
`definline' and `defCbody' macro forms.

     
     Clines-form:
             (Clines { string }* )
     
     defentry-form:
             (defentry symbol
                     ( { C-type }* )
                     { C-function-name |( { C-type |void } C-function-name ) } )
     
     defCbody-form:
             (defCbody symbol ( { type }* ) type C-expr)
     
     definline-form:
             (defCbody symbol ( { type }* ) type C-expr)
     
     C-function-name:
     C-expr:
              { string |symbol }
      
     C-type:
              { object |int |char |float |double }



CLOS
****



 -- Generic Function: add-method GENERIC-FUNCTION METHOD



 -- Method: add-method (GENERIC-FUNCTION standard-generic-function) (METHOD method)




 -- Macro: call-method METHOD NEXT-METHOD-LIST




 -- Function: call-next-method &restargs




 -- Generic Function: change-class INSTANCE NEW-CLASS

 -- Method: change-class (INSTANCE standard-object) (NEW-CLASS standard-class)

 -- Method: change-class (INSTANCE t) (NEW-CLASS symbol)




 -- Generic Function: class-name CLASS

 -- Method: class-name (CLASS class)


\enddefmethod

\defgeneric{(setf class-name)}{\var{new-value} \var{class}}
\enddefgeneric
\defmethodx{(setf class-name)}{new-value (class class)}
\enddefmethod

\defun{class-of}{\var{object}}
The function \code{class-of} returns the class of which the given
object is an instance.  The argument to class-of may be any \clisp{} object.
\enddefun

\defun{compute-applicable-methods}{\var{generic-function} \var{function-arguments}}
\enddefun

\defmac{defclass}{\var{class-name} (\mstar{superclass-name})}
        (\mstar{slot-specifier}) \mopt{ class-option }
\begin{example}
\var{class-name} ::= \var{symbol}
\var{superclass-name} ::= \var{symbol}
\var{slot-specifier} ::= \var{slot-name} \mor (\var{slot-name} \mopt{ \var{slot-option}})
\var{slot-name} ::= \var{symbol}
\var{slot-option} ::= \mstar{:reader \var{reader-function-name}}
        \mor \mstar{:writer \var{writer-function-name}}
        \mor \mstar{:accessor \var{reader-function-name}}
        \mor {:allocation \var{allocation-type}}
        \mor \mstar{:initarg \var{initarg-name}}
        \mor {:initform \var{form}}
        \mor {:type \var{type-specifier}}
        \mor {:documentation \var{string}}
\var{reader-function-name} ::= \var{symbol}
\var{writer-function-name} ::= \var{function-name}
\var{function-name} ::= \var{symbol} \mor(setf \var{symbol})
\var{initarg-name} ::= \var{symbol}
\var{allocation-type} ::= :instance \mor :class
\var{class-option} ::= (:default-initargs \var{initarg-list})
        \mor (:documentation \var{string})
        \mor (:metaclass \var{class-name})
\var{initarg-list} ::= \mstar{\var{initarg-name} \var{default-initial-value-form}} 
\end{example}
\enddefmac

\defmac{defgeneric}{\var{function-name} \var{lambda-list}
        \mopt{\var{option} \mor \mstar{\var{method-description}} }}
\begin{example}
\var{function-name} ::= \var{symbol} \mor  (setf \var{symbol})
\var{lambda-list} ::= (\mstar{\var{var}}
            \mopt{&optional \mstar{\var{var} \mor (\var{var})} }
            \mopt{&rest \var{var} }
            \mopt{&key \mstar{\var{keyword-parameter}} \mopt{&allow-other-keys}})
\var{keyword-parameter} ::= \var{var} \mor ( {\var{var} \mor (\var{keywordvar} )})
 \var{option} ::= (:argument-precedence-order \mplus{\var{parameter-name}})
        \mor(declare \mplus{\var{declaration}})
        \mor (:documentation \var{string})
        \mor (:method-combination symbol \mstar{\var{arg}})
        \mor (:generic-function-class \var{class-name})
        \mor (:method-class \var{class-name})
\var{method-description} ::= (:method \mstar{\var{method-qualifier}} \var{specialized-lambda-list}
                       \mopt{ \mstar{\var{declaration} } \mor \var{documentation} }
                       \mstar{\var{form}} )
\var{method-qualifier} ::= \var{non-nil-atom}
\var{specialized-lambda-list} ::= ( \mstar{\var{var} \mor (\var{var} \var{parameter-specializer-name})}
            \mopt{&optional \mstar{\var{var} \mor (\var{var} \mopt{\var{initform} \mopt{\var{supplied-p-parameter}}})}}
            \mopt{&rest \var{var} }
            \mopt{&key \mstar{\var{specialized-keyword-parameter}} \mopt{&allow-other-keys}})
            \mopt{&aux \mstar{\var{var} \mor (\var{var} \mopt{\var{initform} })}} )
\var{specialized-keyword-parameter} ::= \var{var} \mor \mstar{({\var{var} \mor (\var{keywordvar} )} \mopt{\var{initform} \mopt{\var{supplied-p-parameter}}})}
\var{parameter-specializer-name} ::= \var{symbol} \mor (eql \var{eql-specializer-form})
\end{example}
\enddefmac

\defmac{define-method-combination}{\var{name} \mopt{\var{short-form-option} }}
\enddefmac
\defmacx{define-method-combination}{\var{name} \var{lambda-list}
                                ( \mstar{\var{method-group-specifier}} )
                                \mopt{(:arguments . \var{lambda-list})}
                                \mopt{(:generic-function \var{generic-fn-symbol} )}
                                 \mopt{ \mstar{\var{declaration}} \mor \var{doc-string} }
                                \mstar{\var{form}}}
\begin{example}
\var{short-form-option} ::= :documentation \var{string} 
                        \mor :identity-with-one-argument \var{boolean} 
                        \mor :operator \var{operator} 
\var{method-group-specifier} ::= (\var{variable}  {\mplus{\var{qualifier-pattern}}} \mor \var{predicate}
                            \mopt{ \var{long-form-option}  })
\var{long-form-option} ::= :description \var{format-string} 
                        \mor :order \var{order} 
                        \mor :required \var{boolean}
\end{example}
\enddefmac

\defmac{defmethod}{\var{function-name} \mstar{\var{method-qualifier}} \var{specialized-lambda-list}
        \mopt{ \mstar{\var{declaration}} \mor \var{doc-string} } \mstar{\var{form}}}
\begin{example}
\var{function-name} ::= \var{symbol} \mor (setf \var{symbol})
\var{method-qualifier} ::= \var{non-nil-atom} 
\var{parameter-specializer-name} ::= \var{symbol} \mor (eql \var{eql-specializer-form} )
\end{example}
\enddefmac

\defgeneric{documentation}{\var{x} \&optional \var{doc-type}}
\enddefgeneric
\defmethodx{documentation}{(\var{method} standard-method) \&optional \var{doc-type}}
\enddefmethod
\defmethodx{documentation}{(\var{generic-function} \var{standard-generic-function})
                        \keys{\&optional \var{doc-type}}}
\enddefmethod
\defmethodx{documentation}{(\var{class} standard-class) \&optional \var{doc-type}}
\enddefmethod
\defmethodx{doumentation}{(\var{method-combination} method-combination) \&optional \var{doc-type}}
\enddefmethod
\defmethodx{documentation}{(\var{slot-description} standard-slot-description)
                             \keys{\&optional \var{doc-type}}}
\enddefmethod
\defmethodx{documentation}{(\var{symbol} symbol) \&optional \var{doc-type}}
\enddefmethod
\defmethodx{documentation}{(\var{list} list) \&optional \var{doc-type}}
\enddefmethod

\defgeneric{(setf documentation)}{\var{new-value} \var{x} \&optional \var{doc-type}}
\enddefgeneric
\defmethodx{(setf documentation)}{\var{new-value} (\var{method} \var{standard-method}) \&optional \var{doc-type}}
\enddefmethod
\defmethodx{(setf documentation)}{\var{new-value} (\var{class} standard-class) \&optional \var{doc-type}}
\enddefmethod
\defmethodx{(setf documentation)}{\var{new-value} (\var{method-combination} method-combination)}
\enddefmethod
\defmethodx{(setf documentation)}{\var{new-value}
        (\var{slot-description} standard-slot-description) \&optional \var{doc-type}}
\enddefmethod
\defmethodx{(setf documentation)}{\var{new-value} (\var{symbol} symbol) \&optional \var{doc-type}}
\enddefmethod
\defmethodx{(setf documentation)}{\var{new-value} (\var{list} list) \&optional \var{doc-type}}
\enddefmethod

\defun{ensure-generic-function}{\var{function-name} \&key \var{lambda-list}
\keys{:argument-precedence-order :declare :documentation :generic-function-class}
\morekeys{:method-combination :method-class :environment}}
\var{function-name} ::= \var{symbol} \mor (setf \var{symbol})
\enddefun

\defun{find-class}{symbol \&optional errorp environment}

The function find-class returns the class object named by the given symbol in the given environment.
The first argument to find-class is a symbol. 
\enddefun

\defgeneric{find-method}{\var{generic-function} \var{method-qualifiers} \var{specializers} \&optional \var{errorp}}
\enddefgeneric
\defmethodx{find-method}{(generic-function standard-generic-function)}
                method-qualifiers specializers  \&optional errorp
\enddefmethod

\defgeneric{function-keywords}{\var{method}}
\enddefgeneric
\defmethodx{function-keywords}{(\var{method} standard-method)}
\enddefmethod

The generic function function-keywords is used to return the keyword parameter specifiers for a given method.

\defmac{generic-function}{\var{lambda-list} \mchoice{\var{option} \mor \mstar{method-description}}}

\begin{example}
option ::= (:argument-precedence-order \mplus{parameter-name})
        \mor (declare \mplus{declaration})
        \mor (:documentation \var{string})
        \mor (:method-combination \var{symbol} \mstar{arg} )
        \mor (:generic-function-class \var{class-name})
        \mor (:method-class \var{class-name})
method-description ::= (:method \mstar{method-qualifier}
                                \var{specialized-lambda-list}
                                \mstar{\var{declaration} \mor \var{documentation}}
                                \mstar{form} )
\end{example}
The \code{generic-function} macro creates an anonymous generic
function. The generic function is created with the set of methods
specified by its method descriptions.  The \var{option},
\var{method-qualifier}, and \var{specialized-lambda-list} arguments are
the same as for \code{defgeneric}.  The generic function object is
returned as the result.  If no method descriptions are specified, an
anonymous generic function with no methods is created.  See
\macref{defgeneric}, \macref{generic-flet}, \macref{generic-labels},
\macref{defmethod}.
\enddefmac

\defgeneric{initialize-instance}{\var{instance} \&rest \var{initargs}}
\enddefgeneric
\defmethodx{initialize-instance}{\var{(instance standard-object)} \&rest
\var{initargs}}

The generic function \code{initialize-instance} is called by
\code{make-instance} to initialize a newly created instance.  The
generic function \code{initialize-instance} is called with the new instance and
the defaulted initialization arguments.
\enddefmethod

\defun{invalid-method-error}{\var{method} \var{format-string} \&rest \var{args}}

The function \code{invalid-method-error} is used to signal an error when
there is an applicable method whose qualifiers are not valid for the
method combination type.  The error message is constructed by using a
format string and any arguments to it.  Because an implementation may
need to add additional contextual information to the error message,
invalid-method-error should be called only within the dynamic extent
of a method combination function.  The function invalid-method-error
is called automatically when a method fails to satisfy every qualifier
pattern and predicate in a define-method-combination form.  A method
combination function that imposes additional restrictions should call
invalid-method-error explicitly if it encounters a method it cannot
accept.
\enddefun

\defgeneric{make-instance}{\var{class} \&rest\var{ initargs}}
\enddefgeneric
\defmethodx{make-instance}{(\var{class} standard-class) \&rest \var{initargs}}
\enddefmethod
\defmethodx{make-instance}{(\var{class} symbol) \&rest \var{initargs}}

The generic function make-instance creates and returns a new instance of
the given class.  The generic function make-instance may be used as
described in section 1.9.  The class argument is a class object or a
symbol that names a class.  The remaining arguments form a list of
alternating initialization argument names and values.  If the second of
the above methods is selected, that method invokes make-instance on the
arguments (find-class class) and initargs.  The initialization arguments
are checked within make-instance (see section 1.9).  The new instance is
returned.
\enddefmethod

\defgeneric{make-instances-obsolete}{\var{class}}
\enddefgeneric
\defmethodx{make-instances-obsolete}{(\var{class} standard-class)}
\enddefmethod
\defmethodx{make-instances-obsolete}{(\var{class} symbol)}
\enddefmethod

\defun{method-combination-error}{\var{format-string} \&rest \var{args}}

The function method-combination-error is used to signal an error in method combination.  The error message is constructed by using a format string and any arguments to it.  Because an implementation may need to add additional contextual information to the error message, method-combination-error should be called only within the dynamic extent of a method combination function.
The format-string argument is a control string that can be given to format, and args are any arguments required by that string.
\enddefun

\defgeneric{method-qualifiers}{\var{method}}
\enddefgeneric
\defmethod{method-qualifiers}{(\var{method} standard-method)}

The generic function method-qualifiers returns a list of the qualifiers of the given method.
\enddefmethod

\defun{next-method-p}{}

The locally defined function next-method-p can be used within the body
of a method defined by a method-defining form to determine whether a
next method exists.
\enddefun

\defgeneric{no-applicable-method}{\var{generic-function} \&rest \var{function-arguments}}
\enddefgeneric
\defmethodx{no-applicable-method}{(\var{generic-function} t) \&rest \var{function-arguments}}

The generic function no-applicable-method is called when a generic function of the class standard-generic-function is invoked and no method on that generic function is applicable. The default method signals an error.
\enddefmethod

\defgeneric{no-next-method}{\var{generic-function} \var{method} \&rest \var{args}}
\enddefgeneric
\defmethodx{no-next-method}{(\var{generic-function} standard-generic-function)
                    (\var{method} standard-method) \&rest \var{args}}
\enddefmethod

\defgeneric{print-object}{\var{object} \var{stream}}
\enddefgeneric
\defmethodx{print-object}{(\var{object} standard-object) \var{stream}}

The generic function print-object writes the printed representation of an object to a stream.  The function print-object is called by the print system; it should not be called by the user.
\enddefmethod

\defgeneric{reinitialize-instance}{\var{instance} \&rest \var{initargs}}
\enddefgeneric
\defmethodx{reinitialize-instance}{(\var{instance} standard-object) \&rest \var{initargs}}

The generic function reinitialize-instance can be used to change the
values of local slots according to initialization arguments.  This
generic function is called by the Meta-Object Protocol.  It can also
be called by users.
\enddefmethod

\defgeneric{remove-method}{\var{generic-function} \var{method}}
\enddefgeneric
\defmethodx{remove-method}{(\var{generic-function} standard-generic-function) \var{method}}

The generic function remove-method removes a method from a generic
function.  It destructively modifies the specified generic function
and returns the modified generic function as its result.
\enddefmethod

\defgeneric{shared-initialize}{\var{instance slot-names \&rest \var{initargs}}}
\enddefgeneric
\defmethodx{shared-initialize}{(\var{instance} standard-object) \var{slot-names} \&rest \var{initargs}}

The generic function shared-initialize is used to fill the slots of an
instance using initialization arguments and :initform forms.  It is
called when an instance is created, when an instance is re-initialized,
when an instance is updated to conform to a redefined class, and when an
instance is updated to conform to a different class.  The generic
function \code{shared-initialize} is called by the system-supplied
primary method for \code{initialize-instance},
\code{reinitialize-instance},
\code{update-instance-for-redefined-class}, and
\code{update-instance-for-different-class}.
\enddefmethod

\defun{slot-boundp}{\var{instance} \var{slot-name}}

The function slot-boundp tests whether a specific slot in an instance is bound.
The arguments are the instance and the name of the slot.
\enddefun

\defun{slot-exists-p}{\var{object} \var{slot-name}}

The function slot-exists-p tests whether the specified object has a
slot of the given name.  The object argument is any object.  The
slot-name argument is a symbol.
\enddefun

\defun{slot-makunbound}{\var{instance} \var{slot-name}}

The function slot-makunbound restores a slot in an instance to the
unbound state.  The arguments to slot-makunbound are the instance and
the name of the slot.
\enddefun

\defgeneric{slot-missing}{\var{class} \var{object} \var{slot-name} \var{operation} \&optional \var{new-value}}
\defmethodx{slot-missing}{(\var{class} t) \var{object} \var{slot-name} \var{operation} \&optional \var{new-value}}

The generic function slot-missing is invoked when an attempt is made
to access a slot in an object whose metaclass is standard-class and
the name of the slot provided is not a name of a slot in that class.
The default method signals an error.
\enddefmethod

\defgeneric{slot-unbound}{\var{class} \var{instance} \var{slot-name}}
\enddefgeneric
\defmethodx{slot-unbound}{(\var{class} t) \var{instance} \var{slot-name}}

The generic function slot-unbound is called when an unbound slot is
read in an instance whose metaclass is standard-class. The default
method signals an error.
\enddefmethod

\defun{slot-value}{\var{object} \var{slot-name}}

The function slot-value returns the value contained in the slot
slot-name of the given object.  If there is no slot with that name,
slot-missing is called.  If the slot is unbound, slot-unbound is
called.  The macro setf can be used with slot-value to change the
value of a slot.
\enddefun

\defgeneric{update-instance-for-different-class}
        {\var{previous} \var{current} \&rest \var{initargs}}
\enddefgeneric
\defmethodx{update-instance-for-different-class}{(\var{previous} standard-object)
        (\var{currentstandard-object}) \&rest \var{initargs}}
\enddefmethod

\defgeneric{update-instance-for-redefined-class}
        {\var{instance} \var{added-slots} \var{discarded-slots} \var{property-list} \&rest \var{initargs}}
\enddefgeneric
\defmethodx{update-instance-for-redefined-class}{(\var{instance} standard-object)
        \var{added-slots} \var{discarded-slots} \var{property-list} \&rest \var{initargs}}
\enddefmethod

\defmac{with-accessors}{(\mstar{slot-entry}) \var{instance-form} \mstar{\var{declaration}} \mstar{\var{form}}}

The macro with-accessors creates a lexical environment in which
specified slots are lexically available through their accessors as if
they were variables.  The macro with-accessors invokes the appropriate
accessors to access the specified slots.  Both setf and setq can be
used to set the value of the slot.  The result returned is that
obtained by executing the forms specified by the body argument.
\enddefmac

\defmac{with-slots}{(\mstar{\var{slot-entry}}) \var{instance-form} \mstar{declaration} \mstar{form}}
\begin{example}
\var{slot-entry} ::= \var{slot-name} \mor (\var{variable-name} \var{slot-name})
\end{example}

The macro \code{with-slots} creates a lexical context for referring to
specified slots as though they were variables.  Within such a context
the value of the slot can be specified by using its slot name, as if it
were a lexically bound variable.  Both \code{setf} and \code{setq} can
be used to set the value of the slot.
\enddefmac

\chapter{Multithread}

The goals of the present design are to provide a minimal set of facilities,
which stand directly on the core of the {\sc Lisp} computational model, and
which provide the maximum degree of flexibility to build higher level
concurrency and synchronization constructs.

In particular we wanted a system which:
\begin{itemize}
\item is semantically based
\item is flexible enough to allow freedom to experiment new constructs
\item blends with the functional nature of {\sc Lisp}
\item blends with object-oriented programming
\end{itemize}

We have achieved this by taking the fundamental concepts of denotational
description of functional languages like {\sc Lisp} and making them accessible
within the programming language itself according to the technique of
reflection \cite{Smith:84}.

We show several examples of how typical concurrent programming
constructs can be implemented using these primitives.

\section{Model}

The computational model on which our design is based is the functional model
described with continuation semantics.  Processing happens through steps of
function application.  Each function invocation is supplied with a
continuation, representing the continuation of the program.  Normally as the
last step of each function execution, the continuation is invoked with
arguments the values to be returned by the function. The continuation will
then proceed execution with such values.  However the function can instead
invoke an alternative continuation, discarding the continutation it has
received. In this way, the function has the ability to alter the flow of
control of the program.  The theory of denotational semantics shows that
with this style of description, any arbitrary control construct can be
programmed.

Our approach has been to take this underlying model and to make it visible
to the {\sc Lisp} programmer. Control flow proceed normally through function
calls, unless the program requests to access its continuation. It can then
decide whether it wants to resume such continuation at the end, thereby
proceeding normally, or to discard that continuation and proceed in a
different way. Continuations are first-class objects which can be passed as
arguments or returned as values from functions.

Given this model of computation, the only addition which is
necessary to be able to handle concurrency is the ability to
create multiple threads of execution.
Control of flow among different threads is obtained just by
the use of continuations.

\subsection{Threads}

A thread identifies one sequential flow of execution. A thread contains all
the dynamic information needed by the {\sc Lisp} executor.  A list of active
threads is managed by a scheduler, which switches execution among them at
the expiration of a time slice or when a thread gets suspended.

The structure of a thread is roughly as follows:
\begin{center}
Thread\\
\begin{tabular}{|c|}\\
Function\\
Run Time Stack(s)\\
Program Counter\\
CPU Registers\\
Next Thread\\
\end{tabular}
\end{center}

\subsection{Continuations}

A {\tindexed continuation} represents a thread suspended at a
particular point in its execution, when it is expecting some
return values from a procedure call or some arguments to a procedure.
Since a continuation can be resumed only once, each continuation
is unique.

\subsection{Concurrency}

Actors can be activated concurrently by means of the send primitive. When
send is invoked, a new {\emph thread}, is created for processing the message
by the actor, unless the {\emph actor} is already running. In the latter case,
the message will be just enqueued within the actor.

During the execution of the actor, any function called within the body of
the actor will use the stack of the new thread. Only using one of the
message passing primitives like {\emph send} and {\emph reply} the execution
will switch to a different stack.

\subsection{Mixed Computations}

In our model computation can proceed in two ways. One way corresponds to the
traditional sequential execution with function invocation and return, always
running within a single thread; the second way enables parallel execution
where function activations proceed concurrently, each one in a separate
thread.  Activation and exchange of data is obtained with the primitive
\code{resume}.

A relevant feature or our approach is that the message passing
primitives are just a generalization of the call/return mechanism,
and therefore it is possible for the two mechanisms to cohexist
easily and neatly.

\section{Manual Section}

The present design is structured in two levels.  The first level introduces
the new data types continuation and thread, and provides a set of primitives
to create and operate on them.  Using these primitives it is already
possible to generate and control concurrent computations expressed in terms
of \clisp{} functions.

The second level is built on top of the facilities of the first level. By
exploiting the capability to get a hold and manipulate continuations, the
second level provides a set of constructs for concurrent object oriented
programming.  Concurrent activities can be generated by using the
asynchronous send construct.  Synchronization is provided through
serialization of message processing by an actor.

\subsection{Primitives}

Two new data types are introduced into the language:
\begin{itemize}
\item thread
\item continuation
\end{itemize}

\subsubsection{Threads}

\defun{make-thread}{\var{function} \keys{:cont :name :size}}

\var{function} may be a compiled-code object, or a lambda-expression, or a
symbol; in the latter case the global functional value of that symbol is
used (which cannot be a special form nor a macro). make-thread creates a new
thread ready to execute \var{function}. The thread is in a
\cindexed{SUSPENDED} status and does not run. A thread can be put into
execution only by making a continuation for it and issuing a resume to such
continuation with a list of arguments.

\var{name} is a symbol or string used to identify the thread.  \var{size}
is the dimension of the evaluation stack to be used by the thread.
\enddefun

\defun{deactivate}{\var{thread}}

It stops a \cindexed{RUNNING} \code{thread}, removing it from the queue of
active threads, and sets its status to \cindexed{STOPPED}. A stopped thread
can be resumed with reactivate. Signals an error if the thread is not
\cindexed{RUNNING}.
\enddefun

\defun{reactivate}{\var{thread}}

Puts a \cindexed{STOPPED} \var{thread} back into the queue of active threads
for further execution, and sets its status to \cindexed{RUNNING}.  Signals
an error if the thread is not \cindexed{STOPPED}.

\defun{kill-thread}{\var{thread}}

Stops the thread execution and sets its status to \cindexed{DEAD} so that
it will not be run by the scheduler any more. If the status of
the \var{thread} is already \cindexed{DEAD} the function has no effect.
Returns \nil.
\enddefun

\defun{thread-status}{\var{thread}}

Returns the status of the \var{thread}, one of the symbols RUNNING,
\cindexed{SUSPENDED}, \cindexed{STOPPED} or \cindexed{DEAD}.
.enddefun

\defun{current-thread}{}

It returns the thread within which this function was called.
.enddefun

\subsubsection{Continuations}

\defun{make-continuation}{\var{thread} \&key \var{cont}}

Builds a unique new continuation for resuming the \var{thread}.
\var{cont} is an optional continuation to be supplied to the thread.
Further make-continuations on the same thread are disallowed
until the last continuation created has been resumed.
\enddefun

\defun{resume}{\var{continuation} \&rest \var{args}}

Resumes execution of \var{continuation} and passes it the \var{args}.  If
\var{continuation} was created by make-continuation of a function, the
behavior is similar to the behavior of a funcall to that function. However
execution goes on in a separate thread, that is concurrently to the thread
which is issuing the resume.  Resume returns immediately the thread which
has been activated.  The thread for continuation must be
\cindexed{SUSPENDED}, otherwise resume will produce an error. This could
happen if continuation was created with the result of current-thread and
that thread has not been suspended. If the continuation had already been
resumed or timed-out, resume signals an error. If continuation is
\nil, resume has no effect. Resume reenables make-continuation for the
thread of \var{continuation}.
\enddefun

\defun{pass}{\var{continuation} \&rest \var{args}}

same behaviour as \var{resume} except that suspends the current thread.
\var{pass} does not return.
\enddefun

\defun{spawn}{\var{function} \&rest \var{args}}

Creates a new thread where \var{function} is applied to the \var{args}.
Returns immediately the new thread without waiting for the function
to return.

\code{Spawn} behaves like if it were defined as:
\begin{lisp}
(defmacro spawn (function \&rest args)
        `(resume (make-continuation (make-thread ,function)) ,@ args))
\end{lisp}

\enddefun

\defun{timeout}{\var{delay} \var{continuation} \var{alternative}}

If after \var{delay} seconds \var{continuation} has not been
resumed, the \var{alternative} continuation is resumed and
\var{continuation} is marked as \cindexed{TIMED-OUT}.
Returns \nil{} immediately.
.enddefun

\subsubsection{Scheduler}

\defun{disable-scheduler}{}\c should be %disable-scheduler but latex complains.

\code{%disable-scheduler} disables the scheduler, so that the execution
of the current thread will not be interrupted by the scheduler until the
function \code{%enable-scheduler} is called. Returns \nil.
\enddefun

\defun{enable-scheduler}{}\c should be %enable-scheduler but latex complains.

\code{%enable-scheduler} enables the scheduler, so that it will
time-slice execution among all the \cindexed{RUNNING} threads. Returns
\nil.
\enddefun

\defun{suspend}{}\c should be %suspend but latex complains.

\code{%suspend} sets the status of the current thread to
\cindexed{SUSPENDED} and suspends its execution. The scheduler is
enabled again in the same way as the function \code{%enable-scheduler}
does. The thread will proceed execution {\emph only} when a continuation
referring to the thread will be resumed. In that case \code{suspend}
will return the values specified by \code{resume}.
\enddefun

\appendix
\chapter{\ecl{} Summary}

In this section we list all symbols defined in \ecl{}.

\defunx{*}{\&rest \var{numbers} }
\enddefun
\defvarx{*}
\enddefvar
\defvarx{**}
\enddefvar
\defvarx{***}
\enddefvar
\defvarx{*applyhook*}
\enddefvar
\defvarx{*break-enable*}
\enddefvar
\defvarx{*break-on-warnings*}
\enddefvar
\defvarx{*cc*}[compiler]
\enddefvar
\defvarx{*compile-print*}[compiler]
\enddefvar
\defvarx{*compile-verbose*}[compiler]
\enddefvar
\defvarx{*gc-verbose*}[system]
\enddefvar
\defvarx{*debug-io*}
\enddefvar
\defvarx{*default-pathname-defaults*}
\enddefvar
\defvarx{*error-output*}
\enddefvar
\defvarx{*eval-when-compile*}
\enddefvar
\defvarx{*evalhook*}
\enddefvar
\defvarx{*features*}
\enddefvar
\defvarx{*ignore-eof-on-terminal-io*}[system]
\enddefvar
\defvarx{*ignore-maximum-pages*}
\enddefvar
\defvarx{*indent-formatted-output*}[system]
\enddefvar
\defvarx{*interrupt-enable*}[system]
\enddefvar
\defvarx{*lisp-init-file-list*}[system]
\enddefvar
\defvarx{*lisp-maxpages*}[system]
\enddefvar
\defvarx{*load-verbose*}
\enddefvar
\defvarx{*macroexpand-hook*}
\enddefvar
\defunx{*make-constant}[system]{\var{symbol} \var{value} }
\enddefun
\defunx{*make-special}[system]{\var{symbol} }
\enddefun
\defvarx{*modules*}
\enddefvar
\defvarx{*gc-verbose*}[system]
\enddefvar
\defvarx{*package*}
\enddefvar
\defvarx{*print-array*}
\enddefvar
\defvarx{*print-base*}
\enddefvar
\defvarx{*print-case*}
\enddefvar
\defvarx{*print-circle*}
\enddefvar
\defvarx{*print-escape*}
\enddefvar
\defvarx{*print-gensym*}
\enddefvar
\defvarx{*print-length*}
\enddefvar
\defvarx{*print-level*}
\enddefvar
\defvarx{*print-pretty*}
\enddefvar
\defvarx{*print-radix*}
\enddefvar
\defvarx{*query-io*}
\enddefvar
\defvarx{*random-state*}
\enddefvar
\defvarx{*read-base*}
\enddefvar
\defvarx{*read-default-float-format*}
\enddefvar
\defvarx{*read-suppress*}
\enddefvar
\defvarx{*readtable*}
\enddefvar
\defvarx{*standard-input*}
\enddefvar
\defvarx{*standard-output*}
\enddefvar
\defvarx{*suppress-compiler-notes*}[compiler]
\enddefvar
\defvarx{*suppress-compiler-warnings*}[compiler]
\enddefvar
\defvarx{*system-directory*}[system]
\enddefvar
\defvarx{*terminal-io*}
\enddefvar
\defvarx{*trace-output*}
\enddefvar
\defunx{+}{\&rest \var{numbers} }
\enddefun
\defvarx{+}
\enddefvar
\defvarx{++}
\enddefvar
\defvarx{+++}
\enddefvar
\defunx{-}{\var{number} \&rest \var{more-numbers} }
\enddefun
\defvarx{-}
\enddefvar
\defunx{/}{\var{number} \&rest \var{more-numbers} }
\enddefun
\defvarx{/}
\enddefvar
\defvarx{//}
\enddefvar
\defvarx{///}
\enddefvar
\defunx{/=}{\var{number} \&rest \var{more-numbers} }
\enddefun
\defunx{1+}{\var{number} }
\enddefun
\defunx{1-}{\var{number} }
\enddefun
\defunx{<}{\var{number} \&rest \var{more-numbers} }
\enddefun
\defunx{<=}{\var{number} \&rest \var{more-numbers} }
\enddefun
\defunx{=}{\var{number} \&rest \var{more-numbers} }
\enddefun
\defunx{>}{\var{number} \&rest \var{more-numbers} }
\enddefun
\defunx{>=}{\var{number} \&rest \var{more-numbers} }
\enddefun
\defunx{abs}{\var{number} }
\enddefun
\defunx{acons}{\var{key} \var{datum} \var{alist} }
\enddefun
\defunx{acos}{\var{number} }
\enddefun
\defunx{acosh}{\var{number} }
\enddefun
\defunx{adjoin}{\var{item} \var{list} \&key (\var{key} #'identity ) (\var{test} #'eql ) \var{test-not} }
\enddefun
\defunx{adjust-array}{\var{array} \var{dimensions} \&key (\var{element-type} (array-element-type array) ) \var{initial-element} (\var{initial-contents} nil ) (\var{fill-pointer} nil ) (\var{displaced-to} nil ) (\var{displaced-index-offset} 0 ) }
\enddefun
\defunx{adjustable-array-p}{\var{array} }
\enddefun
\defunx{allocate}[system]{\var{type} \var{number} \&optional (\var{really-allocate} nil ) }
\enddefun
\defunx{allocate-contiguous-pages}[system]{\var{number} \&optional (\var{really-allocate} nil ) }
\enddefun
\defunx{allocate-gfun}[system]{\var{name} \var{arity} \var{hash-table} }
\enddefun
\defunx{allocate-instance}[system]{\var{class} \var{length} }
\enddefun
\defunx{allocate-relocatable-pages}[system]{\var{number} }
\enddefun
\defunx{allocated-contiguous-pages}[system]{}
\enddefun
\defunx{allocated-pages}[system]{\var{type} }
\enddefun
\defunx{allocated-relocatable-pages}[system]{}
\enddefun
\defunx{alpha-char-p}{\var{char} }
\enddefun
\defunx{alphanumericp}{\var{char} }
\enddefun
\defspecx{and}{(and {form}*)}
\enddefspec
\defunx{append}{\&rest \var{lists} }
\enddefun
\defunx{apply}{\var{function} \var{arg} \&rest \var{more-args} }
\enddefun
\defunx{applyhook}{\var{function} \var{list} \var{evalhookfn} \var{applyhookfn} \&optional (\var{env} nil ) }
\enddefun
\defunx{apropos}{\var{string} \&optional (\var{package} nil ) }
\enddefun
\defunx{apropos-list}{\var{string} \&optional (\var{package} nil ) }
\enddefun
\defunx{aref}{\var{array} \&rest \var{indexes} }
\enddefun
\defunx{argc}[system]{}
\enddefun
\defunx{arglist}{(SYMBOL)}
\enddefun
\defunx{argv}[system]{\var{n} }
\enddefun
\deftypex{array}
\enddeftype
\defunx{array-dimension}{\var{array} \var{n} }
\enddefun
\defvarx{array-dimension-limit}
\enddefvar
\defunx{array-dimensions}{\var{array} }
\enddefun
\defunx{array-element-type}{\var{array} }
\enddefun
\defunx{array-has-fill-pointer-p}{\var{array} }
\enddefun
\defunx{array-in-bounds-p}{\var{array} \&rest \var{indexes} }
\enddefun
\defunx{array-rank}{\var{array} }
\enddefun
\defvarx{array-rank-limit}
\enddefvar
\defunx{array-row-major-index}{\var{array} \&rest \var{indexes} }
\enddefun
\defunx{array-total-size}{\var{array} }
\enddefun
\defvarx{array-total-size-limit}
\enddefvar
\defunx{arrayp}{\var{x} }
\enddefun
\defunx{ash}{\var{integer} \var{count} }
\enddefun
\defunx{asin}{\var{number} }
\enddefun
\defunx{asinh}{\var{number} }
\enddefun
\defmacx{assert}{(assert form [({place}*) [string {arg}*]])}
\enddefmac
\defunx{assoc}{\var{item} \var{alist} \&key (\var{test} #'eql ) \var{test-not} (\var{key} #'identity ) }
\enddefun
\defunx{assoc-if}{\var{test} \var{alist} }
\enddefun
\defunx{assoc-if-not}{\var{test} \var{alist} }
\enddefun
\defunx{atan}{\var{x} \&optional (\var{y} 1 ) }
\enddefun
\defunx{atanh}{\var{number} }
\enddefun
\deftypex{atom}
\enddeftype
\defunx{atom}{\var{x} }
\enddefun
\defunx{bds-val}[system]{\var{n} }
\enddefun
\defunx{bds-var}[system]{\var{n} }
\enddefun
\deftypex{bignum}
\enddeftype
\deftypex{bit}
\enddeftype
\defunx{bit}{\var{bit-array} \&rest \var{indexes} }
\enddefun
\defunx{bit-and}{\var{bit-array1} \var{bit-array2} \&optional (\var{result} nil ) }
\enddefun
\defunx{bit-andc1}{\var{bit-array1} \var{bit-array2} \&optional (\var{result} nil ) }
\enddefun
\defunx{bit-andc2}{\var{bit-array1} \var{bit-array2} \&optional (\var{result} nil ) }
\enddefun
\defunx{bit-eqv}{\var{bit-array1} \var{bit-array2} \&optional (\var{result} nil ) }
\enddefun
\defunx{bit-ior}{\var{bit-array1} \var{bit-array2} \&optional (\var{result} nil ) }
\enddefun
\defunx{bit-nand}{\var{bit-array1} \var{bit-array2} \&optional (\var{result} nil ) }
\enddefun
\defunx{bit-nor}{\var{bit-array1} \var{bit-array2} \&optional (\var{result} nil ) }
\enddefun
\defunx{bit-not}{\var{bit-array} \&optional (\var{result} nil ) }
\enddefun
\defunx{bit-orc1}{\var{bit-array1} \var{bit-array2} \&optional (\var{result} nil ) }
\enddefun
\defunx{bit-orc2}{\var{bit-array1} \var{bit-array2} \&optional (\var{result} nil ) }
\enddefun
\deftypex{bit-vector}
\enddeftype
\defunx{bit-vector-p}{\var{x} }
\enddefun
\defunx{bit-xor}{\var{bit-array1} \var{bit-array2} \&optional (\var{result} nil ) }
\enddefun
\defspecx{block}{(block name {form}*)}
\enddefspec
\defunx{boole}{\var{op} \var{integer1} \var{integer2} }
\enddefun
\defvarx{boole-1}
\enddefvar
\defvarx{boole-2}
\enddefvar
\defvarx{boole-and}
\enddefvar
\defvarx{boole-andc1}
\enddefvar
\defvarx{boole-andc2}
\enddefvar
\defvarx{boole-c1}
\enddefvar
\defvarx{boole-c2}
\enddefvar
\defvarx{boole-clr}
\enddefvar
\defvarx{boole-eqv}
\enddefvar
\defvarx{boole-ior}
\enddefvar
\defvarx{boole-nand}
\enddefvar
\defvarx{boole-nor}
\enddefvar
\defvarx{boole-orc1}
\enddefvar
\defvarx{boole-orc2}
\enddefvar
\defvarx{boole-set}
\enddefvar
\defvarx{boole-xor}
\enddefvar
\defunx{both-case-p}{\var{char} }
\enddefun
\defunx{boundp}{\var{symbol} }
\enddefun
\defunx{break}{\&optional (\var{format-string} nil ) \&rest \var{args} }
\enddefun
\defunx{butlast}{\var{list} \&optional (\var{n} 1 ) }
\enddefun
\defunx{quit}{}
\enddefun
\defunx{byte}{\var{size} \var{position} }
\enddefun
\defunx{byte-position}{\var{byte} }
\enddefun
\defunx{byte-size}{\var{byte} }
\enddefun
\defunx{caaaar}{\var{x} }
\enddefun
\defunx{caaadr}{\var{x} }
\enddefun
\defunx{caaar}{\var{x} }
\enddefun
\defunx{caadar}{\var{x} }
\enddefun
\defunx{caaddr}{\var{x} }
\enddefun
\defunx{caadr}{\var{x} }
\enddefun
\defunx{caar}{\var{x} }
\enddefun
\defunx{cadaar}{\var{x} }
\enddefun
\defunx{cadadr}{\var{x} }
\enddefun
\defunx{cadar}{\var{x} }
\enddefun
\defunx{caddar}{\var{x} }
\enddefun
\defunx{cadddr}{\var{x} }
\enddefun
\defunx{caddr}{\var{x} }
\enddefun
\defunx{cadr}{\var{x} }
\enddefun
\defvarx{call-arguments-limit}
\enddefvar
\defunx{car}{\var{x} }
\enddefun
\defspecx{case}{(case keyform {({key | ({key}*)} {form}*)}*)}
\enddefspec
\defspecx{catch}{(catch tag-form {form}*)}
\enddefspec
\defunx{catch-bad-signals}[system]{}
\enddefun
\defmacx{ccase}{(ccase place {({key | ({key}*)} {form}*)}*)}
\enddefmac
\defunx{cdaaar}{\var{x} }
\enddefun
\defunx{cdaadr}{\var{x} }
\enddefun
\defunx{cdaar}{\var{x} }
\enddefun
\defunx{cdadar}{\var{x} }
\enddefun
\defunx{cdaddr}{\var{x} }
\enddefun
\defunx{cdadr}{\var{x} }
\enddefun
\defunx{cdar}{\var{x} }
\enddefun
\defunx{cddaar}{\var{x} }
\enddefun
\defunx{cddadr}{\var{x} }
\enddefun
\defunx{cddar}{\var{x} }
\enddefun
\defunx{cdddar}{\var{x} }
\enddefun
\defunx{cddddr}{\var{x} }
\enddefun
\defunx{cdddr}{\var{x} }
\enddefun
\defunx{cddr}{\var{x} }
\enddefun
\defunx{cdr}{\var{x} }
\enddefun
\defunx{ceiling}{\var{number} \&optional (\var{divisor} 1 ) }
\enddefun
\defunx{cerror}{\var{continue-format-string} \var{error-format-string} \&rest \var{args} }
\enddefun
\defunx{change-instance}[system]{\var{instance} \var{class} \var{length} }
\enddefun
\defunx{char}{\var{string} \var{index} }
\enddefun
\defunx{char-bit}{\var{char} \var{name} }
\enddefun
\defunx{char-bits}{\var{char} }
\enddefun
\defvarx{char-bits-limit}
\enddefvar
\defunx{char-code}{\var{char} }
\enddefun
\defvarx{char-code-limit}
\enddefvar
\defvarx{char-control-bit}
\enddefvar
\defunx{char-downcase}{\var{char} }
\enddefun
\defunx{char-equal}{\var{char} \&rest \var{more-chars} }
\enddefun
\defunx{char-font}{\var{char} }
\enddefun
\defvarx{char-font-limit}
\enddefvar
\defunx{char-greaterp}{\var{char} \&rest \var{more-chars} }
\enddefun
\defvarx{char-hyper-bit}
\enddefvar
\defunx{char-int}{\var{char} }
\enddefun
\defunx{char-lessp}{\var{char} \&rest \var{more-chars} }
\enddefun
\defvarx{char-meta-bit}
\enddefvar
\defunx{char-name}{\var{char} }
\enddefun
\defunx{char-not-equal}{\var{char} \&rest \var{more-chars} }
\enddefun
\defunx{char-not-greaterp}{\var{char} \&rest \var{more-chars} }
\enddefun
\defunx{char-not-lessp}{\var{char} \&rest \var{more-chars} }
\enddefun
\defvarx{char-super-bit}
\enddefvar
\defunx{char-upcase}{\var{char} }
\enddefun
\defunx{char/=}{\var{char} \&rest \var{more-chars} }
\enddefun
\defunx{char<}{\var{char} \&rest \var{more-chars} }
\enddefun
\defunx{char<=}{\var{char} \&rest \var{more-chars} }
\enddefun
\defunx{char=}{\var{char} \&rest \var{more-chars} }
\enddefun
\defunx{char>}{\var{char} \&rest \var{more-chars} }
\enddefun
\defunx{char>=}{\var{char} \&rest \var{more-chars} }
\enddefun
\deftypex{character}
\enddeftype
\defunx{character}{\var{x} }
\enddefun
\defunx{characterp}{\var{x} }
\enddefun
\defunx{chdir}[system]{\var{filespec} }
\enddefun
\defmacx{check-type}{(check-type place typespec [string-form])}
\enddefmac
\defunx{cis}{\var{radians} }
\enddefun
\defunx{clear-input}{\&optional (\var{stream} *standard-input* ) }
\enddefun
\defunx{clear-output}{\&optional (\var{stream} *standard-output* ) }
\enddefun
\defmacx{clines}{(clines {string}*)}
\enddefmac
\defunx{close}{\var{stream} \&key (\var{abort} nil ) }
\enddefun
\defunx{clrhash}{\var{hash-table} }
\enddefun
\defunx{code-char}{\var{code} \&optional (\var{bits} 0 ) (\var{font} 0 ) }
\enddefun
\defunx{coerce}{\var{x} \var{type} }
\enddefun
\deftypex{common}
\enddeftype
\defunx{commonp}{\var{x} }
\enddefun
\defunx{compile}{\var{name} \&optional (\var{definition} nil ) }
\enddefun
\defunx{compile-file}{\var{input-pathname} \&key \var{output-file} (\var{load} nil ) (\var{o-file} t ) (\var{c-file} nil ) (\var{h-file} nil ) (\var{data-file} nil ) }
\enddefun
\deftypex{compiled-function}
\enddeftype
\defunx{compiled-function-name}[system]{\var{compiled-function} }
\enddefun
\defunx{compiled-function-p}{\var{x} }
\enddefun
\defspecx{compiler-let}{(compiler-let ({var | (var [value])}*) {form}*)}
\enddefspec
\deftypex{complex}
\enddeftype
\defunx{complex}{\var{realpart} \&optional (\var{imagpart} 0 ) }
\enddefun
\defunx{complexp}{\var{x} }
\enddefun
\defunx{concatenate}{\var{type} \&rest \var{sequences} }
\enddefun
\defspecx{cond}{(cond {(test {form}*)}*)}
\enddefspec
\defunx{conjugate}{\var{number} }
\enddefun
\deftypex{cons}
\enddeftype
\defunx{cons}{\var{x} \var{y} }
\enddefun
\defunx{consp}{\var{x} }
\enddefun
\defunx{constantp}{\var{x} }
\enddefun
\defunx{copy-alist}{\var{alist} }
\enddefun
\defunx{copy-list}{\var{list} }
\enddefun
\defunx{copy-readtable}{\&optional (\var{readtable} *readtable* ) (\var{to-readtable} nil ) }
\enddefun
\defunx{copy-seq}{\var{sequence} }
\enddefun
\defunx{copy-symbol}{\var{symbol} \&optional (\var{flag} nil ) }
\enddefun
\defunx{copy-tree}{\var{tree} }
\enddefun
\defunx{cos}{\var{radians} }
\enddefun
\defunx{cosh}{\var{number} }
\enddefun
\defunx{count}{\var{item} \var{sequence} \&key (\var{key} #'identity ) (\var{test} #'eql ) \var{test-not} (\var{start} 0 ) (\var{end} (length sequence) ) (\var{from-end} nil ) }
\enddefun
\defunx{count-if}{\var{test} \var{sequence} \&key (\var{key} #'identity ) (\var{start} 0 ) (\var{end} (length sequence) ) (\var{from-end} nil ) }
\enddefun
\defunx{count-if-not}{\var{test} \var{sequence} (\var{start} 0 ) (\var{end} (length sequence) ) (\var{from-end} nil ) }
\enddefun
\defmacx{ctypecase}{(ctypecase place {(type {form}*)}*)}
\enddefmac
\defunx{daylight-saving-time-p}[system]{}
\enddefun
\defspecx{decf}{(decf place [form])}
\enddefspec
\defspecx{declare}{(declare {decl-spec}*)}
\enddefspec
\defunx{decode-float}{\var{float} }
\enddefun
\defunx{decode-universal-time}{\var{integer} \&optional (\var{timezone} (get-local-time-zone) ) }
\enddefun
\defmacx{defcbody}{(defcbody symbol ({arg-type}*) value-type body)}
\enddefmac
\defmacx{defcfun}{(defcfun header n {element}*)}
\enddefmac
\defmacx{defconstant}{(defconstant symbol form [doc])}
\enddefmac
\defmacx{defentry}{(defentry symbol ({arg-type}*) (value-type function-name))}
\enddefmac
\defmacx{define-modify-macro}{(define-modify-macro symbol lambda-list function-name [doc])}
\enddefmac
\defmacx{define-setf-method}{(define-setf-method symbol defmacro-lambda-list {decl | doc}*
          {form}*)}
\enddefmac
\defmacx{definline}{(definline symbol ({arg-type}*) value-type body)}
\enddefmac
\defmacx{defla}{(defla name lambda-list {decl | doc}* {form}*)}
\enddefmac
\defmacx{defmacro}{(defmacro name defmacro-lambda-list {decl | doc}* {form}*)}
\enddefmac
\defmacx{defparameter}{(defparameter name form [doc])}
\enddefmac
\defmacx{defsetf}{(defsetf symbol update-fun [doc] )}
\enddefmac
\defmacx{defstruct}{(defstruct
         {name | (name {:conc-name | (:conc-name prefix-string) |
                        :constructor | (:constructor symbol [lambda-list]) |
                        :copier | (:copier symbol) |
                        :predicate | (:predicate symbol) |
                        (:include symbol) |
                        (:print-function function) |
                        (:type {vector | (vector type) | list}) |
                        :named |
                        (:initial-offset number)}*)}
         [doc]
         {slot-name |
          (slot-name [default-value-form] {:type type | :read-only flag}*) }*
         )}
\enddefmac
\defmacx{deftype}{(deftype name lambda-list {decl | doc}* {form}*)}
\enddefmac
\defspecx{defun}{(defun name lambda-list {decl | doc}* {form}*)}
\enddefspec
\defmacx{defunc}{(defunc symbol lambda-list {string}*)}
\enddefmac
\defmacx{defvar}{(defvar name [form [doc]])}
\enddefmac
\defunx{delete}{\var{item} \var{sequence} \&key (\var{key} #'identity ) (\var{test} #'eql ) \var{test-not} (\var{start} 0 ) (\var{end} (length sequence) ) (\var{count} most-positive-fixnum ) (\var{from-end} nil ) }
\enddefun
\defunx{delete-duplicates}{\var{sequence} \&key (\var{key} #'identity ) (\var{test} #'eql ) \var{test-not} (\var{start} 0 ) (\var{end} (length sequence) ) (\var{from-end} nil ) }
\enddefun
\defunx{delete-file}{\var{filespec} }
\enddefun
\defunx{delete-if}{\var{test} \var{sequence} \&key (\var{key} #'identity ) (\var{start} 0 ) (\var{end} (length sequence) ) (\var{count} most-positive-fixnum ) (\var{from-end} nil ) }
\enddefun
\defunx{delete-if-not}{\var{test} \var{sequence} \&key (\var{key} #'identity ) (\var{start} 0 ) (\var{end} (length sequence) ) (\var{count} most-positive-fixnum ) (\var{from-end} nil ) }
\enddefun
\defunx{denominator}{\var{rational} }
\enddefun
\defunx{deposit-field}{\var{integer1} \var{bytespec} \var{integer2} }
\enddefun
\defunx{describe}{\var{x} }
\enddefun
\defunx{digit-char}{\var{digit} \&optional (\var{n} 10 ) (\var{font} 0 ) }
\enddefun
\defunx{digit-char-p}{\var{char} \&optional (\var{n} 10 ) }
\enddefun
\defunx{directory}{\var{filespec} }
\enddefun
\defunx{directory-namestring}{\var{filespec} }
\enddefun
\defunx{disassemble}{\&optional (\var{thing} nil ) \&key (\var{h-file} nil ) (\var{data-file} nil ) }
\enddefun
\defunx{displaced-array-p}[system]{\var{array} }
\enddefun
\defspecx{do}{(do ({(var [init [step]])}*) (test {result}*)
          {decl}* {tag | statement}*)}
\enddefspec
\defspecx{do*}{(do* ({(var [init [step]])}*) (test {result}*)
          {decl}* {tag | statement}*)}
\enddefspec
\defmacx{do-all-symbols}{(do-all-symbols (var [result]) {decl}* {tag | statement}*)}
\enddefmac
\defmacx{do-external-symbols}{(do-external-symbols (var [package [result]])
          {decl}* {tag | statement}*)}
\enddefmac
\defmacx{do-symbols}{(do-symbols (var [package [result]])
          {decl}* {tag | statement}*)}
\enddefmac
\defunx{documentation}{\var{symbol} \var{doc-type} }
\enddefun
\defspecx{dolist}{(dolist (var form [result])
          {decl}* {tag | statement}*)}
\enddefspec
\deftypex{double-float}
\enddeftype
\defspecx{dotimes}{(dotimes (var form [result])
          {decl}* {tag | statement}*)}
\enddefspec
\defvarx{double-float-epsilon}
\enddefvar
\defvarx{double-float-negative-epsilon}
\enddefvar
\defunx{dpb}{\var{newbyte} \var{bytespec} \var{integer} }
\enddefun
\defunx{dribble}{\&optional \var{filespec} }
\enddefun
\defmacx{ecase}{(ecase keyform {({key | ({key}*)} {form}*)}*)}
\enddefmac
\defunx{ed}{\&optional \var{x} }
\enddefun
\defunx{eighth}{\var{x} }
\enddefun
\defunx{elt}{\var{sequence} \var{n} }
\enddefun
\defunx{encode-universal-time}{\var{second} \var{minute} \var{hour} \var{date} \var{month} \var{year} \&optional (\var{timezone} (get-local-time-zone) ) }
\enddefun
\defunx{endp}{\var{x} }
\enddefun
\defunx{enough-namestring}{\var{filespec} \&optional (\var{defaults} *default-pathname-defaults* ) }
\enddefun
\defunx{eq}{\var{x} \var{y} }
\enddefun
\defunx{eql}{\var{x} \var{y} }
\enddefun
\defunx{equal}{\var{x} \var{y} }
\enddefun
\defunx{equalp}{\var{x} \var{y} }
\enddefun
\defunx{error}{\var{format-string} \&rest \var{args} }
\enddefun
\defunx{error-set}[system]{\var{form} }
\enddefun
\defmacx{etypecase}{(etypecase keyform {(type {form}*)}*)}
\enddefmac
\defunx{eval}{\var{form} }
\enddefun
\defspecx{eval-when}{(eval-when ({situation}*) {form}*)}
\enddefspec
\defunx{evalhook}{\var{form} \var{fun1} \var{fun2} \&optional (\var{env} nil ) }
\enddefun
\defunx{evenp}{\var{integer} }
\enddefun
\defunx{every}{\var{predicate} \var{sequence} \&rest \var{more-sequences} }
\enddefun
\defunx{exp}{\var{number} }
\enddefun
\defunx{export}{\var{symbol} \&optional (\var{package} *package* ) }
\enddefun
\defunx{expt}{\var{number1} \var{number2} }
\enddefun
\defunx{faslink}[system]{\var{filespec} \var{string} }
\enddefun
\defunx{fboundp}{\var{symbol} }
\enddefun
\defunx{fceiling}{\var{number} \&optional (\var{divisor} 1 ) }
\enddefun
\defunx{ffloor}{\var{number} \&optional (\var{divisor} 1 ) }
\enddefun
\defunx{fifth}{\var{x} }
\enddefun
\defunx{file-author}{\var{filespec} }
\enddefun
\defunx{file-length}{\var{file-stream} }
\enddefun
\defunx{file-namestring}{\var{filespec} }
\enddefun
\defunx{file-position}{\var{file-stream} \&optional \var{file-position} }
\enddefun
\defunx{file-write-date}{\var{filespec} }
\enddefun
\defunx{fill}{\var{sequence} \var{item} \&key (\var{start} 0 ) (\var{end} (length sequence) ) }
\enddefun
\defunx{fill-pointer}{\var{vector} }
\enddefun
\defunx{find}{\var{item} \var{sequence} \&key (\var{key} #'identity ) (\var{test} #'eql ) \var{test-not} (\var{start} 0 ) (\var{end} (length sequence) ) (\var{from-end} nil ) }
\enddefun
\defunx{find-all-symbols}{\var{string} }
\enddefun
\defunx{find-if}{\var{test} \var{sequence} \&key (\var{key} #'identity ) (\var{start} 0 ) (\var{end} (length sequence) ) (\var{from-end} nil ) }
\enddefun
\defunx{find-if-not}{\var{test} \var{sequence} \&key (\var{key} #'identity ) (\var{start} 0 ) (\var{end} (length sequence) ) (\var{from-end} nil ) }
\enddefun
\defunx{find-package}{\var{name} }
\enddefun
\defunx{find-symbol}{\var{string} \&optional (\var{package} *package* ) }
\enddefun
\defunx{finish-output}{\&optional (\var{stream} *standard-output* ) }
\enddefun
\defunx{first}{\var{x} }
\enddefun
\defunx{fixnump}[system]{\var{x} }
\enddefun
\deftypex{fixnum}
\enddeftype
\defspecx{flet}{(flet ({(name lambda-list {decl | doc}* {form}*)}*) . body)}
\enddefspec
\deftypex{float}
\enddeftype
\defunx{float}{\var{number} \&optional \var{float} }
\enddefun
\defunx{float-digits}{\var{float} }
\enddefun
\defunx{float-precision}{\var{float} }
\enddefun
\defunx{float-radix}{\var{float} }
\enddefun
\defunx{float-sign}{\var{float1} \&optional (\var{float2} (float 1 float1) ) }
\enddefun
\defunx{floatp}{\var{x} }
\enddefun
\defunx{floor}{\var{number} \&optional (\var{divisor} 1 ) }
\enddefun
\defunx{fmakunbound}{\var{symbol} }
\enddefun
\defunx{force-output}{\&optional (\var{stream} *standard-output* ) }
\enddefun
\defunx{format}{\var{destination} \var{format-string} \&rest \var{args} }
\enddefun
\defunx{fourth}{\var{x} }
\enddefun
\defunx{fresh-line}{\&optional (\var{stream} *standard-output* ) }
\enddefun
\defunx{fround}{\var{number} \&optional (\var{divisor} 1 ) }
\enddefun
\defunx{frs-bds}[system]{\var{n} }
\enddefun
\defunx{frs-ihs}[system]{\var{n} }
\enddefun
\defunx{ftruncate}{\var{number} \&optional (\var{divisor} 1 ) }
\enddefun
\defunx{funcall}{\var{function} \&rest \var{args} }
\enddefun
\deftypex{function}
\enddeftype
\defspecx{function}{(function x) | #'x}
\enddefspec
\defunx{functionp}{\var{x} }
\enddefun
\defunx{gc}{\var{x} }
\enddefun
\defunx{gc-time}[system]{}
\enddefun
\defunx{gcd}{\&rest \var{integers} }
\enddefun
\defunx{gensym}{\&optional (\var{x} nil ) }
\enddefun
\defunx{gentemp}{\&optional (\var{string} \var{"t"} ) (\var{package} *package* ) }
\enddefun
\defunx{get}{\var{symbol} \var{property} \&optional (\var{default} nil ) }
\enddefun
\defunx{get-decoded-time}{}
\enddefun
\defunx{get-dispatch-macro-character}{\var{char} \var{subchar} \&optional (\var{readtable} *readtable* ) }
\enddefun
\defunx{get-hole-size}[system]{}
\enddefun
\defunx{get-internal-real-time}{}
\enddefun
\defunx{get-internal-run-time}{}
\enddefun
\defunx{get-local-time-zone}[system]{}
\enddefun
\defunx{get-macro-character}{\var{char} \&optional (\var{readtable} *readtable* ) }
\enddefun
\defunx{get-output-stream-string}{\var{string-output-stream} }
\enddefun
\defunx{get-properties}{\var{plist} \var{list} }
\enddefun
\defunx{get-setf-method}{\var{place} }
\enddefun
\defunx{get-setf-method-multiple-value}{\var{form} }
\enddefun
\defunx{get-string-input-stream-index}[system]{\var{string-input-stream} }
\enddefun
\defunx{get-universal-time}{}
\enddefun
\defunx{getenv}[system]{\var{string} }
\enddefun
\defunx{getf}{\var{plist} \var{property} \&optional (\var{default} nil ) }
\enddefun
\defunx{gethash}{\var{key} \var{hash-table} \&optional (\var{default} nil ) }
\enddefun
\defunx{gfun-instance}[system]{\var{gfun} }
\enddefun
\defunx{gfun-instance-set}[system]{\var{gfun} \var{instance} }
\enddefun
\defunx{gfun-name}[system]{\var{gfun} }
\enddefun
\defunx{gfun-name-set}[system]{\var{gfun} \var{name} }
\enddefun
\defunx{gfun-method-ht}[system]{\var{gfun} }
\enddefun
\defunx{gfun-method-ht-set}[system]{\var{gfun} \var{hash-table} }
\enddefun
\defunx{gfun-spec-how-ref}[system]{\var{gfun} \var{index} }
\enddefun
\defunx{gfun-spec-how-set}[system]{\var{gfun} \var{index} \var{specializer} }
\enddefun
\defunx{gfunp}[system]{\var{object} }
\enddefun
\defspecx{go}{(go tag)}
\enddefspec
\defunx{graphic-char-p}{\var{char} }
\enddefun
\deftypex{hash-table}
\enddeftype
\defunx{hash-table-count}{\var{hash-table} }
\enddefun
\defunx{hash-table-p}{\var{x} }
\enddefun
\defunx{help}{\&optional \var{symbol} }
\enddefun
\defunx{help*}{\var{string} \&optional (\var{package-spec} lisp ) }
\enddefun
\defunx{host-namestring}{\var{filespec} }
\enddefun
\defunx{identity}{\var{x} }
\enddefun
\defspecx{if}{(if test form1 [form2])}
\enddefspec
\defunx{ihs-fun}[system]{\var{n} }
\enddefun
\defunx{imagpart}{\var{number} }
\enddefun
\defunx{import}{\var{symbol} \&optional (\var{package} *package* ) }
\enddefun
\defunx{in-package}{\var{package-name} \&key (\var{nicknames} nil ) (\var{use} (lisp) ) }
\enddefun
\defspecx{incf}{(incf place [form])}
\enddefspec
\defunx{input-stream-p}{\var{stream} }
\enddefun
\defunx{inspect}{\var{x} }
\enddefun
\defunx{instancep}[system]{\var{object} }
\enddefun
\defunx{instance-ref}[system]{\var{instance} \var{index} }
\enddefun
\defunx{instance-set}[system]{\var{instance} \var{index} \var{value} }
\enddefun
\defunx{instance-class}[system]{\var{instance} }
\enddefun
\defunx{instance-class-set}[system]{\var{instance} \var{class} }
\enddefun
\defunx{int-char}{\var{integer} }
\enddefun
\deftypex{integer}
\enddeftype
\defunx{integer-decode-float}{\var{float} }
\enddefun
\defunx{integer-length}{\var{integer} }
\enddefun
\defunx{integerp}{\var{x} }
\enddefun
\defunx{intern}{\var{string} \&optional (\var{package} *package* ) }
\enddefun
\defvarx{internal-time-units-per-second}
\enddefvar
\defunx{intersection}{\var{list1} \var{list2} \&key (\var{key} #'identity ) (\var{test} #'eql ) \var{test-not} }
\enddefun
\defunx{isqrt}{\var{integer} }
\enddefun
\deftypex{keyword}
\enddeftype
\defunx{keywordp}{\var{x} }
\enddefun
\defspecx{labels}{(labels ({(name lambda-list {decl | doc}* {form}*)}*) . body)}
\enddefspec
\defvarx{lambda-list-keywords}
\enddefvar
\defvarx{lambda-parameters-limit}
\enddefvar
\defunx{last}{\var{list} }
\enddefun
\defunx{lcm}{\var{integer} \&rest \var{more-integers} }
\enddefun
\defunx{ldb}{\var{bytespec} \var{integer} }
\enddefun
\defunx{ldb-test}{\var{bytespec} \var{integer} }
\enddefun
\defunx{ldiff}{\var{list} \var{x} }
\enddefun
\defvarx{least-negative-double-float}
\enddefvar
\defvarx{least-negative-long-float}
\enddefvar
\defvarx{least-negative-short-float}
\enddefvar
\defvarx{least-negative-single-float}
\enddefvar
\defvarx{least-positive-double-float}
\enddefvar
\defvarx{least-positive-long-float}
\enddefvar
\defvarx{least-positive-short-float}
\enddefvar
\defvarx{least-positive-single-float}
\enddefvar
\defunx{length}{\var{sequence} }
\enddefun
\defspecx{let}{(let ({var | (var [init])}*) {decl}* {form}*)}
\enddefspec
\defspecx{let*}{(let* ({var | (var [init])}*) {decl}* {form}*)}
\enddefspec
\defunx{lisp-implementation-type}{}
\enddefun
\defunx{lisp-implementation-version}{}
\enddefun
\deftypex{list}
\enddeftype
\defunx{list}{\&rest \var{args} }
\enddefun
\defunx{list*}{\var{arg} \&rest \var{more-args} }
\enddefun
\defunx{list-all-packages}{}
\enddefun
\defunx{list-length}{\var{list} }
\enddefun
\defunx{listen}{\&optional (\var{stream} *standard-input* ) }
\enddefun
\defunx{listp}{\var{x} }
\enddefun
\defunx{load}{\var{filespec} \&key (\var{verbose} *load-verbose* ) (\var{print} nil ) (\var{if-does-not-exist} error ) }
\enddefun
\defspecx{locally}{(locally {decl}* {form}*)}
\enddefspec
\defunx{log}{\var{number1} \&optional \var{number2} }
\enddefun
\defunx{logand}{\&rest \var{integers} }
\enddefun
\defunx{logandc1}{\var{integer1} \var{integer2} }
\enddefun
\defunx{logandc2}{\var{integer1} \var{integer2} }
\enddefun
\defunx{logbitp}{\var{bit-position} \var{integer} }
\enddefun
\defunx{logcount}{\var{integer} }
\enddefun
\defunx{logeqv}{\&rest \var{integers} }
\enddefun
\defunx{logior}{\&rest \var{integers} }
\enddefun
\defunx{lognand}{\var{integer1} \var{integer2} }
\enddefun
\defunx{lognor}{\var{integer1} \var{integer2} }
\enddefun
\defunx{lognot}{\var{integer} }
\enddefun
\defunx{logorc1}{\var{integer1} \var{integer2} }
\enddefun
\defunx{logorc2}{\var{integer1} \var{integer2} }
\enddefun
\defunx{logtest}{\var{integer1} \var{integer2} }
\enddefun
\defunx{logxor}{\&rest \var{integers} }
\enddefun
\deftypex{long-float}
\enddeftype
\defvarx{long-float-epsilon}
\enddefvar
\defvarx{long-float-negative-epsilon}
\enddefvar
\defunx{long-site-name}{}
\enddefun
\defmacx{loop}{(loop {form}*)}
\enddefmac
\defunx{lower-case-p}{\var{char} }
\enddefun
\defunx{machine-instance}{}
\enddefun
\defunx{machine-type}{}
\enddefun
\defunx{machine-version}{}
\enddefun
\defunx{macro-function}{\var{symbol} }
\enddefun
\defunx{macroexpand}{\var{form} \&optional (\var{env} nil ) }
\enddefun
\defunx{macroexpand-1}{\var{form} \&optional (\var{env} nil ) }
\enddefun
\defspecx{macrolet}{(macrolet ({(name defmacro-lambda-list {decl | doc}* {form}*)}*)
          . body)}
\enddefspec
\defunx{make-array}{\var{dimensions} \&key (\var{element-type} t ) \var{initial-element} (\var{initial-contents} nil ) (\var{adjustable} nil ) (\var{fill-pointer} nil ) (\var{displaced-to} nil ) (\var{displaced-index-offset} 0 ) (\var{static} nil ) }
\enddefun
\defunx{make-broadcast-stream}{\&rest \var{streams} }
\enddefun
\defunx{make-char}{\var{char} \&optional (\var{bits} 0 ) (\var{font} 0 ) }
\enddefun
\defunx{make-concatenated-stream}{\&rest \var{streams} }
\enddefun
\defunx{make-dispatch-macro-character}{\var{char} \&optional (\var{non-terminating-p} nil ) (\var{readtable} *readtable* ) }
\enddefun
\defunx{make-echo-stream}{\var{stream1} \var{stream2} }
\enddefun
\defunx{make-hash-table}{\&key (\var{test} eql ) (\var{size} 1024 ) (\var{rehash-size} 1.5 ) (\var{rehash-threshold} 0.7 ) }
\enddefun
\defunx{make-list}{\var{length} \&key (\var{initial-element} nil ) }
\enddefun
\defunx{make-package}{\var{package-name} \&key (\var{nicknames} nil ) (\var{use} (lisp) ) }
\enddefun
\defunx{make-pathname}{\&key (\var{defaults} (parse-namestring "" (pathname-host *default-pathname-defaults*)) ) (\var{host} (pathname-host defaults) ) (\var{device} (pathname-device defaults) ) (\var{directory} (pathname-directory defaults) ) (\var{name} (pathname-name defaults) ) (\var{type} (pathname-type defaults) ) (\var{version} (pathname-version defaults) ) }
\enddefun
\defunx{make-random-state}{\&optional (\var{random-state} nil ) }
\enddefun
\defunx{make-sequence}{\var{type} \var{length} \&key \var{initial-element} }
\enddefun
\defunx{make-string}{\var{length} \&key (\var{initial-element}   ) }
\enddefun
\defunx{make-string-input-stream}{\var{string} \&optional (\var{start} 0 ) (\var{end} (length string) ) }
\enddefun
\defunx{make-string-output-stream}{}
\enddefun
\defunx{make-string-output-stream-from-string}[system]{\var{string} }
\enddefun
\defunx{make-symbol}{\var{string} }
\enddefun
\defunx{make-synonym-stream}{\var{symbol} }
\enddefun
\defunx{make-two-way-stream}{\var{stream1} \var{stream2} }
\enddefun
\defunx{makunbound}{\var{symbol} }
\enddefun
\defunx{map}{\var{type} \var{function} \var{sequence} \&rest \var{more-sequences} }
\enddefun
\defunx{mapc}{\var{function} \var{list} \&rest \var{more-lists} }
\enddefun
\defunx{mapcan}{\var{function} \var{list} \&rest \var{more-lists} }
\enddefun
\defunx{mapcar}{\var{function} \var{list} \&rest \var{more-lists} }
\enddefun
\defunx{mapcon}{\var{function} \var{list} \&rest \var{more-lists} }
\enddefun
\defunx{maphash}{\var{function} \var{hash-table} }
\enddefun
\defunx{mapl}{\var{function} \var{list} \&rest \var{more-lists} }
\enddefun
\defunx{maplist}{\var{function} \var{list} \&rest \var{more-lists} }
\enddefun
\defunx{mask-field}{\var{bytespec} \var{integer} }
\enddefun
\defunx{max}{\var{number} \&rest \var{more-numbers} }
\enddefun
\defunx{maximum-allocatable-pages}[system]{\var{type} }
\enddefun
\defunx{maximum-contiguous-pages}[system]{}
\enddefun
\defunx{member}{\var{item} \var{list} \&key (\var{key} #'identity ) (\var{test} #'eql ) \var{test-not} }
\enddefun
\defunx{member-if}{\var{test} \var{list} \&key (\var{key} #'identity ) }
\enddefun
\defunx{member-if-not}{\var{test} \var{list} \&key (\var{key} #'identity ) }
\enddefun
\defunx{merge}{\var{type} \var{sequence1} \var{sequence2} \var{test} \&key (\var{key} #'identity ) }
\enddefun
\defunx{merge-pathnames}{\var{filespec} \&optional (\var{defaults} *default-pathname-defaults* ) \var{default-version} }
\enddefun
\defunx{min}{\var{number} \&rest \var{more-numbers} }
\enddefun
\defunx{minusp}{\var{number} }
\enddefun
\defunx{mismatch}{\var{sequence1} \var{sequence2} \&key (\var{key} #'identity ) (\var{test} #'eql ) \var{test-not} (\var{start1} 0 ) (\var{end1} (length sequence1) ) (\var{start2} 0 ) (\var{end2} (length sequence2) ) (\var{from-end} nil ) }
\enddefun
\defunx{mod}{\var{number} \var{divisor} }
\enddefun
\defvarx{most-negative-double-float}
\enddefvar
\defvarx{most-negative-fixnum}
\enddefvar
\defvarx{most-negative-long-float}
\enddefvar
\defvarx{most-negative-short-float}
\enddefvar
\defvarx{most-negative-single-float}
\enddefvar
\defvarx{most-positive-double-float}
\enddefvar
\defvarx{most-positive-fixnum}
\enddefvar
\defvarx{most-positive-long-float}
\enddefvar
\defvarx{most-positive-short-float}
\enddefvar
\defvarx{most-positive-single-float}
\enddefvar
\defspecx{multiple-value-bind}{(multiple-value-bind ({var}*) init {decl}* {form}*)}
\enddefspec
\defspecx{multiple-value-call}{(multiple-value-call function-form {form}*)}
\enddefspec
\defspecx{multiple-value-list}{(multiple-value-list form)}
\enddefspec
\defspecx{multiple-value-prog1}{(multiple-value-prog1 first-form {form}*)}
\enddefspec
\defspecx{multiple-value-setq}{(multiple-value-setq {var}* form)}
\enddefspec
\defvarx{multiple-values-limit}
\enddefvar
\defunx{nani}[system]{\var{fixnum} }
\enddefun
\defunx{name-char}{\var{name} }
\enddefun
\defunx{namestring}{\var{filespec} }
\enddefun
\defunx{nbutlast}{\var{list} \&optional (\var{n} 1 ) }
\enddefun
\defunx{nconc}{\&rest \var{lists} }
\enddefun
\deftypex{nil}
\enddeftype
\defvarx{nil}
\enddefvar
\defunx{nintersection}{\var{list1} \var{list2} \&key (\var{key} #'identity ) (\var{test} #'eql ) \var{test-not} }
\enddefun
\defunx{ninth}{\var{x} }
\enddefun
\defunx{not}{\var{x} }
\enddefun
\defunx{notany}{\var{predicate} \var{sequence} \&rest \var{more-sequences} }
\enddefun
\defunx{notevery}{\var{predicate} \var{sequence} \&rest \var{more-sequences} }
\enddefun
\defunx{nreconc}{\var{x} \var{y} }
\enddefun
\defunx{nreverse}{\var{sequence} }
\enddefun
\defunx{nset-difference}{\var{list1} \var{list2} \&key (\var{key} #'identity ) (\var{test} #'eql ) \var{test-not} }
\enddefun
\defunx{nset-exclusive-or}{\var{list1} \var{list2} \&key (\var{key} #'identity ) (\var{test} #'eql ) \var{test-not} }
\enddefun
\defunx{nstring-capitalize}{\var{string} \&key (\var{start} 0 ) (\var{end} (length string) ) }
\enddefun
\defunx{nstring-downcase}{\var{string} \&key (\var{start} 0 ) (\var{end} (length string) ) }
\enddefun
\defunx{nstring-upcase}{\var{string} \&key (\var{start} 0 ) (\var{end} (length string) ) }
\enddefun
\defunx{nsublis}{\var{alist} \var{tree} \&key (\var{key} #'identity ) (\var{test} #'eql ) \var{test-not} }
\enddefun
\defunx{nsubst}{\var{new} \var{old} \var{tree} \&key (\var{key} #'identity ) (\var{test} #'eql ) \var{test-not} }
\enddefun
\defunx{nsubst-if}{\var{new} \var{test} \var{tree} \&key (\var{key} #'identity ) }
\enddefun
\defunx{nsubst-if-not}{\var{new} \var{test} \var{tree} \&key (\var{key} #'identity ) }
\enddefun
\defunx{nsubstitute}{\var{new} \var{old} \var{sequence} \&key (\var{key} #'identity ) (\var{test} #'eql ) \var{test-not} (\var{start} 0 ) (\var{end} (length sequence) ) (\var{count} most-positive-fixnum ) (\var{from-end} nil ) }
\enddefun
\defunx{nsubstitute-if}{\var{new} \var{test} \var{sequence} \&key (\var{key} #'identity ) (\var{start} 0 ) (\var{end} (length sequence) ) (\var{count} most-positive-fixnum ) (\var{from-end} nil ) }
\enddefun
\defunx{nsubstitute-if-not}{\var{new} \var{test} \var{sequence} \&key (\var{key} #'identity ) (\var{start} 0 ) (\var{end} (length sequence) ) (\var{count} most-positive-fixnum ) (\var{from-end} nil ) }
\enddefun
\defunx{nth}{\var{n} \var{list} }
\enddefun
\defunx{nthcdr}{\var{n} \var{list} }
\enddefun
\deftypex{null}
\enddeftype
\defunx{null}{\var{x} }
\enddefun
\deftypex{number}
\enddeftype
\defunx{numberp}{\var{x} }
\enddefun
\defunx{numerator}{\var{rational} }
\enddefun
\defunx{nunion}{\var{list1} \var{list2} \&key (\var{key} #'identity ) (\var{test} #'eql ) \var{test-not} }
\enddefun
\defunx{oddp}{\var{integer} }
\enddefun
\defunx{open}{\var{filespec} \&key (\var{direction} input ) \var{element-type} \var{if-exists} \var{if-does-not-exist} }
\enddefun
\defunx{open-client-stream}[system]{\var{host} \var{port} }
\enddefun
\defunx{open-server-stream}[system]{\var{host} \var{port} }
\enddefun
\defspecx{or}{(or {form}*)}
\enddefspec
\defunx{output-stream-p}{\var{stream} }
\enddefun
\defunx{output-stream-string}[system]{\var{string-output-stream} }
\enddefun
\deftypex{package}
\enddeftype
\defunx{package-name}{\var{package} }
\enddefun
\defunx{package-nicknames}{\var{package} }
\enddefun
\defunx{package-shadowing-symbols}{\var{package} }
\enddefun
\defunx{package-use-list}{\var{package} }
\enddefun
\defunx{package-used-by-list}{\var{package} }
\enddefun
\defunx{packagep}{\var{x} }
\enddefun
\defunx{pairlis}{\var{keys} \var{items} \&optional (\var{alist} nil ) }
\enddefun
\defunx{parse-integer}{\var{string} \&key (\var{start} 0 ) (\var{end} (length string) ) (\var{radix} 10 ) (\var{junk-allowed} nil ) }
\enddefun
\defunx{parse-namestring}{\var{string} \&optional \var{host} \var{defaults} \&key (\var{start} 0 ) \var{end} (\var{junk-allowed} nil ) }
\enddefun
\deftypex{pathname}
\enddeftype
\defunx{pathname}{\var{filespec} }
\enddefun
\defunx{pathname-device}{\var{filespec} }
\enddefun
\defunx{pathname-directory}{\var{filespec} }
\enddefun
\defunx{pathname-host}{\var{filespec} }
\enddefun
\defunx{pathname-name}{\var{filespec} }
\enddefun
\defunx{pathname-type}{\var{filespec} }
\enddefun
\defunx{pathname-version}{\var{filespec} }
\enddefun
\defunx{pathnamep}{\var{x} }
\enddefun
\defunx{peek-char}{\&optional (\var{char-spec} nil ) (\var{stream} *standard-input* ) (\var{eof-error-p} t ) (\var{eof-value} nil ) (\var{recursive-p} nil ) }
\enddefun
\defunx{phase}{\var{number} }
\enddefun
\defvarx{pi}
\enddefvar
\defunx{pointer}[system]{\var{object} }
\enddefun
\defunx{plusp}{\var{number} }
\enddefun
\defspecx{pop}{(pop place)}
\enddefspec
\defunx{position}{\var{item} \var{sequence} \&key (\var{key} #'identity ) (\var{test} #'eql ) \var{test-not} (\var{start} 0 ) (\var{end} (length sequence) ) (\var{from-end} nil ) }
\enddefun
\defunx{position-if}{\var{test} \var{sequence} \&key (\var{key} #'identity ) (\var{start} 0 ) (\var{end} (length sequence) ) (\var{from-end} nil ) }
\enddefun
\defunx{position-if-not}{\var{test} \var{sequence} \&key (\var{key} #'identity ) (\var{start} 0 ) (\var{end} (length sequence) ) (\var{from-end} nil ) }
\enddefun
\defunx{pprint}{\var{object} \&optional (\var{stream} *standard-output* ) }
\enddefun
\defunx{prin1}{\var{object} \&optional (\var{stream} *standard-output* ) }
\enddefun
\defunx{prin1-to-string}{\var{object} }
\enddefun
\defunx{princ}{\var{object} \&optional (\var{stream} *standard-output* ) }
\enddefun
\defunx{princ-to-string}{\var{object} }
\enddefun
\defunx{print}{\var{object} \&optional (\var{stream} *standard-output* ) }
\enddefun
\defunx{probe-file}{\var{filespec} }
\enddefun
\defunx{proclaim}{\var{decl-spec} }
\enddefun
\defunx{proclamation}{\var{decl-spec} }
\enddefun
\defspecx{prog}{(prog ({var | (var [init])}*) {decl}* {tag | statement}*)}
\enddefspec
\defspecx{prog*}{(prog* ({var | (var [init])}*) {decl}* {tag | statement}*)}
\enddefspec
\defspecx{prog1}{(prog1 first-form {form}*)}
\enddefspec
\defspecx{prog2}{(prog2 first-form second-form {forms}*)}
\enddefspec
\defspecx{progn}{(progn {form}*)}
\enddefspec
\defspecx{progv}{(progv symbols-form values-form {form}*)}
\enddefspec
\defunx{provide}{\var{module-name} }
\enddefun
\defmacx{psetf}{(psetf {place form}*)}
\enddefmac
\defspecx{psetq}{(psetq {var form}*)}
\enddefspec
\defspecx{push}{(push form place)}
\enddefspec
\defmacx{pushnew}{(pushnew form place {keyword-form value-form}*)}
\enddefmac
\defspecx{quote}{(quote x) | 'x}
\enddefspec
\defunx{random}{\var{number} \&optional (\var{random-state} *random-state* ) }
\enddefun
\deftypex{random-state}
\enddeftype
\defunx{random-state-p}{\var{x} }
\enddefun
\defunx{rassoc}{\var{item} \var{alist} \&key (\var{test} #'eql ) \var{test-not} (\var{key} #'identity ) }
\enddefun
\defunx{rassoc-if}{\var{test} \var{alist} }
\enddefun
\defunx{rassoc-if-not}{\var{test} \var{alist} }
\enddefun
\deftypex{ratio}
\enddeftype
\deftypex{rational}
\enddeftype
\defunx{rational}{\var{number} }
\enddefun
\defunx{rationalize}{\var{number} }
\enddefun
\defunx{rationalp}{\var{x} }
\enddefun
\defunx{read}{\&optional (\var{stream} *standard-input* ) (\var{eof-error-p} t ) (\var{eof-value} nil ) (\var{recursivep} nil ) }
\enddefun
\defunx{read-byte}{\var{stream} \&optional (\var{eof-error-p} t ) (\var{eof-value} nil ) }
\enddefun
\defunx{read-bytes}[system]{\var{stream} \var{string} \var{start} \var{end} }
\enddefun
\defunx{read-char}{\&optional (\var{stream} *standard-input* ) (\var{eof-error-p} t ) (\var{eof-value} nil ) (\var{recursive-p} nil ) }
\enddefun
\defunx{read-char-no-hang}{\&optional (\var{stream} *standard-input* ) (\var{eof-error-p} t ) (\var{eof-value} nil ) (\var{recursive-p} nil ) }
\enddefun
\defunx{read-delimited-list}{\var{char} \&optional (\var{stream} *standard-input* ) (\var{recursive-p} nil ) }
\enddefun
\defunx{read-from-string}{\var{string} \&optional (\var{eof-error-p} t ) (\var{eof-value} nil ) \&key (\var{start} 0 ) (\var{end} (length string) ) (\var{preserve-whitespace} nil ) }
\enddefun
\defunx{read-line}{\&optional (\var{stream} *standard-input* ) (\var{eof-error-p} t ) (\var{eof-value} nil ) (\var{recursive-p} nil ) }
\enddefun
\defunx{read-preserving-whitespace}{\&optional (\var{stream} *standard-input* ) (\var{eof-error-p} t ) (\var{eof-value} nil ) (\var{recursive-p} nil ) }
\enddefun
\deftypex{readtable}
\enddeftype
\defunx{readtablep}{\var{x} }
\enddefun
\defunx{realpart}{\var{number} }
\enddefun
\defunx{reduce}{\var{function} \var{sequence} \&key (\var{from-end} nil ) (\var{start} 0 ) (\var{end} (length sequence) ) \var{initial-value} }
\enddefun
\defunx{rem}{\var{number} \var{divisor} }
\enddefun
\defmacx{remf}{(remf place form)}
\enddefmac
\defunx{remhash}{\var{key} \var{hash-table} }
\enddefun
\defunx{remove}{\var{item} \var{sequence} \&key (\var{key} #'identity ) (\var{test} #'eql ) \var{test-not} (\var{start} 0 ) (\var{end} (length sequence) ) (\var{count} most-positive-fixnum ) (\var{from-end} nil ) }
\enddefun
\defunx{remove-duplicates}{\var{sequence} \&key (\var{key} #'identity ) (\var{test} #'eql ) \var{test-not} (\var{start} 0 ) (\var{end} (length sequence) ) (\var{from-end} nil ) }
\enddefun
\defunx{remove-if}{\var{test} \var{sequence} \&key (\var{key} #'identity ) (\var{start} 0 ) (\var{end} (length sequence) ) (\var{count} most-positive-fixnum ) (\var{from-end} nil ) }
\enddefun
\defunx{remove-if-not}{\var{test} \var{sequence} \&key (\var{key} #'identity ) (\var{start} 0 ) (\var{end} (length sequence) ) (\var{count} most-positive-fixnum ) (\var{from-end} nil ) }
\enddefun
\defunx{remprop}{\var{symbol} \var{indicator} }
\enddefun
\defunx{rename-file}{\var{filespec} \var{new-filespec} }
\enddefun
\defunx{rename-package}{\var{package} \var{new-name} \&optional (\var{new-nicknames} nil ) }
\enddefun
\defunx{replace}{\var{sequence1} \var{sequence2} \&key (\var{start1} 0 ) (\var{end1} (length sequence1) ) (\var{start2} 0 ) (\var{end2} (length sequence2) ) }
\enddefun
\defunx{require}{\var{module-name} \&optional \var{pathname} }
\enddefun
\defunx{reset-gc-count}[system]{}
\enddefun
\defunx{reset-stack-limits}[system]{}
\enddefun
\defunx{rest}{\var{x} }
\enddefun
\defspecx{return}{(return [result])}
\enddefspec
\defspecx{return-from}{(return-from symbol [result])}
\enddefspec
\defunx{revappend}{\var{x} \var{y} }
\enddefun
\defunx{reverse}{\var{sequence} }
\enddefun
\defunx{room}{\&optional (\var{x} t ) }
\enddefun
\defmacx{rotatef}{(rotatef {place}*)}
\enddefmac
\defunx{round}{\var{number} \&optional (\var{divisor} 1 ) }
\enddefun
\defunx{rplaca}{\var{cons} \var{x} }
\enddefun
\defunx{rplacd}{\var{cons} \var{x} }
\enddefun
\defunx{save}[system]{(FILESPEC)}
\enddefun
\defunx{save-system}[system]{\var{pathname} }
\enddefun
\defunx{sbit}{\var{simple-bit-array} \&rest \var{subscripts} }
\enddefun
\defunx{scale-float}{\var{float} \var{integer} }
\enddefun
\defunx{schar}{\var{simple-string} \var{n} }
\enddefun
\defunx{search}{\var{sequence1} \var{sequence2} \&key (\var{key} #'identity ) (\var{test} #'eql ) \var{test-not} (\var{start1} 0 ) (\var{end1} (length sequence1) ) (\var{start2} 0 ) (\var{end2} (length sequence2) ) (\var{from-end} nil ) }
\enddefun
\defunx{second}{\var{x} }
\enddefun
\deftypex{sequence}
\enddeftype
\defunx{set}{\var{symbol} \var{object} }
\enddefun
\defunx{set-char-bit}{\var{char} \var{bit-name} \var{flag} }
\enddefun
\defunx{set-difference}{\var{list1} \var{list2} \&key (\var{key} #'identity ) (\var{test} #'eql ) \var{test-not} }
\enddefun
\defunx{set-dispatch-macro-character}{\var{char} \var{subchar} \var{function} \&optional (\var{readtable} *readtable* ) }
\enddefun
\defunx{set-exclusive-or}{\var{list1} \var{list2} \&key (\var{key} #'identity ) (\var{test} #'eql ) \var{test-not} }
\enddefun
\defunx{set-hole-size}[system]{\var{fixnum} }
\enddefun
\defunx{set-macro-character}{\var{char} \var{function} \&optional (\var{non-terminating-p} nil ) (\var{readtable} *readtable* ) }
\enddefun
\defunx{set-syntax-from-char}{\var{to-char} \var{from-char} \&optional (\var{to-readtable} *readtable* ) (\var{from-readtable} nil ) }
\enddefun
\defspecx{setf}{(setf {place form}*)}
\enddefspec
\defspecx{setq}{(setq {var form}*)}
\enddefspec
\defunx{seventh}{\var{x} }
\enddefun
\defunx{shadow}{\var{symbol} \&optional (\var{package} *package* ) }
\enddefun
\defunx{shadowing-import}{\var{symbol} \&optional (\var{package} *package* ) }
\enddefun
\defmacx{shiftf}{(shiftf {place}+ form)}
\enddefmac
\deftypex{short-float}
\enddeftype
\defvarx{short-float-epsilon}
\enddefvar
\defvarx{short-float-negative-epsilon}
\enddefvar
\defunx{short-site-name}{}
\enddefun
\deftypex{signed-byte}
\enddeftype
\defunx{signum}{\var{number} }
\enddefun
\deftypex{simple-array}
\enddeftype
\deftypex{simple-bit-vector}
\enddeftype
\defunx{simple-bit-vector-p}{\var{x} }
\enddefun
\deftypex{simple-string}
\enddeftype
\defunx{simple-string-p}{\var{x} }
\enddefun
\deftypex{simple-vector}
\enddeftype
\defunx{simple-vector-p}{\var{x} }
\enddefun
\defunx{sin}{\var{radians} }
\enddefun
\deftypex{single-float}
\enddeftype
\defvarx{single-float-epsilon}
\enddefvar
\defvarx{single-float-negative-epsilon}
\enddefvar
\defunx{sinh}{\var{number} }
\enddefun
\defunx{sixth}{\var{x} }
\enddefun
\defunx{sleep}{\var{n} }
\enddefun
\defunx{sl-boundp}[system]{\var{object} }
\enddefun
\defunx{sl-makunbound}[system]{\var{instance} \var{index} }
\enddefun
\defunx{software-type}{}
\enddefun
\defunx{software-version}{}
\enddefun
\defunx{some}{\var{predicate} \var{sequence} \&rest \var{more-sequences} }
\enddefun
\defunx{sort}{\var{sequence} \var{test} \&key (\var{key} #'identity ) }
\enddefun
\defunx{special-form-p}{\var{symbol} }
\enddefun
\defunx{specialp}[system]{\var{symbol} }
\enddefun
\defunx{sqrt}{\var{number} }
\enddefun
\defunx{stable-sort}{\var{sequence} \var{test} \&key (\var{key} #'identity ) }
\enddefun
\deftypex{standard-char}
\enddeftype
\defunx{standard-char-p}{\var{char} }
\enddefun
\defmacx{step}{(step form)}
\enddefmac
\deftypex{stream}
\enddeftype
\defunx{stream-element-type}{\var{stream} }
\enddefun
\defunx{streamp}{\var{x} }
\enddefun
\defunx{stream-read-char}{((OBJ STREAM-CLASS))}
\enddefun
\defunx{stream-read-line}{((OBJ STREAM-CLASS) &REST MAKE-ARRAY-OPTIONS)}
\enddefun
\defunx{stream-unread-char}{((OBJ STREAM-CLASS) CHARACTER)}
\enddefun
\defunx{stream-peek-char}{((OBJ STREAM-CLASS) PEEK-TYPE)}
\enddefun
\defunx{stream-listen}{((OBJ STREAM-CLASS))}
\enddefun
\defunx{stream-clear-input}{((OBJ STREAM-CLASS))}
\enddefun
\defunx{stream-write-char}{((OBJ STREAM-CLASS) CHARACTER)}
\enddefun
\defunx{stream-write-string}{((OBJ STREAM-CLASS) STRING &OPTIONAL START END)}
\enddefun
\defunx{stream-fresh-line}{((OBJ STREAM-CLASS))}
\enddefun
\defunx{stream-clear-output}{((OBJ STREAM-CLASS))}
\enddefun
\defunx{stream-force-output}{((OBJ STREAM-CLASS))}
\enddefun
\deftypex{string}
\enddeftype
\defunx{string}{\var{x} }
\enddefun
\defunx{string-capitalize}{\var{string} \&key (\var{start} 0 ) (\var{end} (length string) ) }
\enddefun
\deftypex{string-char}
\enddeftype
\defunx{string-char-p}{\var{char} }
\enddefun
\defunx{string-concatenate}[system]{\&rest \var{strings} }
\enddefun
\defunx{string-downcase}{\var{string} \&key (\var{start} 0 ) (\var{end} (length string) ) }
\enddefun
\defunx{string-equal}{\var{string1} \var{string2} \&key (\var{start1} 0 ) (\var{end1} (length string1) ) (\var{start2} 0 ) (\var{end2} (length string2) ) }
\enddefun
\defunx{string-greaterp}{\var{string1} \var{string2} \&key (\var{start1} 0 ) (\var{end1} (length string1) ) (\var{start2} 0 ) (\var{end2} (length string2) ) }
\enddefun
\defunx{string-left-trim}{\var{char-bag} \var{string} }
\enddefun
\defunx{string-lessp}{\var{string1} \var{string2} \&key (\var{start1} 0 ) (\var{end1} (length string1) ) (\var{start2} 0 ) (\var{end2} (length string2) ) }
\enddefun
\defunx{string-not-equal}{\var{string1} \var{string2} \&key (\var{start1} 0 ) (\var{end1} (length string1) ) (\var{start2} 0 ) (\var{end2} (length string2) ) }
\enddefun
\defunx{string-not-greaterp}{\var{string1} \var{string2} \&key (\var{start1} 0 ) (\var{end1} (length string1) ) (\var{start2} 0 ) (\var{end2} (length string2) ) }
\enddefun
\defunx{string-not-lessp}{\var{string1} \var{string2} \&key (\var{start1} 0 ) (\var{end1} (length string1) ) (\var{start2} 0 ) (\var{end2} (length string2) ) }
\enddefun
\defunx{string-right-trim}{\var{char-bag} \var{string} }
\enddefun
\defunx{string-to-object}[system]{\var{string} }
\enddefun
\defunx{string-trim}{\var{char-spec} \var{string} }
\enddefun
\defunx{string-upcase}{\var{string} \&key (\var{start} 0 ) (\var{end} (length string) ) }
\enddefun
\defunx{string/=}{\var{string1} \var{string2} \&key (\var{start1} 0 ) (\var{end1} (length string1) ) (\var{start2} 0 ) (\var{end2} (length string2) ) }
\enddefun
\defunx{string<}{\var{string1} \var{string2} \&key (\var{start1} 0 ) (\var{end1} (length string1) ) (\var{start2} 0 ) (\var{end2} (length string2) ) }
\enddefun
\defunx{string<=}{\var{string1} \var{string2} \&key (\var{start1} 0 ) (\var{end1} (length string1) ) (\var{start2} 0 ) (\var{end2} (length string2) ) }
\enddefun
\defunx{string=}{\var{string1} \var{string2} \&key (\var{start1} 0 ) (\var{end1} (length string1) ) (\var{start2} 0 ) (\var{end2} (length string2) ) }
\enddefun
\defunx{string>}{\var{string1} \var{string2} \&key (\var{start1} 0 ) (\var{end1} (length string1) ) (\var{start2} 0 ) (\var{end2} (length string2) ) }
\enddefun
\defunx{string>=}{\var{string1} \var{string2} \&key (\var{start1} 0 ) (\var{end1} (length string1) ) (\var{start2} 0 ) (\var{end2} (length string2) ) }
\enddefun
\defunx{stringp}{\var{x} }
\enddefun
\defunx{structurep}[system]{\var{x} }
\enddefun
\defunx{sublis}{\var{alist} \var{tree} \&key (\var{key} #'identity ) (\var{test} #'eql ) \var{test-not} }
\enddefun
\defunx{subseq}{\var{sequence} \var{start} \&optional (\var{end} (length sequence) ) }
\enddefun
\defunx{subsetp}{\var{list1} \var{list2} \&key (\var{key} #'identity ) (\var{test} #'eql ) \var{test-not} }
\enddefun
\defunx{subst}{\var{new} \var{old} \var{tree} \&key (\var{key} #'identity ) (\var{test} #'eql ) \var{test-not} }
\enddefun
\defunx{subst-if}{\var{new} \var{test} \var{tree} \&key (\var{key} #'identity ) }
\enddefun
\defunx{subst-if-not}{\var{new} \var{test} \var{tree} \&key (\var{key} #'identity ) }
\enddefun
\defunx{substitute}{\var{new} \var{old} \var{sequence} \&key (\var{key} #'identity ) (\var{test} #'eql ) \var{test-not} (\var{start} 0 ) (\var{end} (length sequence) ) (\var{count} most-positive-fixnum ) (\var{from-end} nil ) }
\enddefun
\defunx{substitute-if}{\var{new} \var{test} \var{sequence} \&key (\var{key} #'identity ) (\var{start} 0 ) (\var{end} (length sequence) ) (\var{count} most-positive-fixnum ) (\var{from-end} nil ) }
\enddefun
\defunx{substitute-if-not}{\var{new} \var{test} \var{sequence} \&key (\var{key} #'identity ) (\var{start} 0 ) (\var{end} (length sequence) ) (\var{count} most-positive-fixnum ) (\var{from-end} nil ) }
\enddefun
\defunx{subtypep}{\var{type1} \var{type2} }
\enddefun
\defunx{svref}{\var{simple-vector} \var{n} }
\enddefun
\defunx{sxhash}{\var{object} }
\enddefun
\deftypex{symbol}
\enddeftype
\defunx{symbol-function}{\var{symbol} }
\enddefun
\defunx{symbol-name}{\var{symbol} }
\enddefun
\defunx{symbol-package}{\var{symbol} }
\enddefun
\defunx{symbol-plist}{\var{symbol} }
\enddefun
\defunx{symbol-value}{\var{symbol} }
\enddefun
\defunx{symbolp}{\var{x} }
\enddefun
\defunx{system}{\var{string} }
\enddefun
\deftypex{t}
\enddeftype
\defvarx{t}
\enddefvar
\defspecx{tagbody}{(tagbody {tag | statement}*)}
\enddefspec
\defunx{tailp}{\var{x} \var{list} }
\enddefun
\defunx{tan}{\var{radians} }
\enddefun
\defunx{tanh}{\var{number} }
\enddefun
\defunx{tenth}{\var{x} }
\enddefun
\defunx{terpri}{\&optional (\var{stream} *standard-output* ) }
\enddefun
\defspecx{the}{(the type form)}
\enddefspec
\defunx{third}{\var{x} }
\enddefun
\defspecx{throw}{(throw tag form)}
\enddefspec
\defmacx{time}{(time form)}
\enddefmac
\defunx{top-level}[system]{}
\enddefun
\defmacx{trace}{(trace ({function-name | ({function-name}+)} {keyword [form]}*)}
\enddefmac
\defunx{tree-equal}{\var{x} \var{y} \&key (\var{test} #'eql ) \var{test-not} }
\enddefun
\defunx{truename}{\var{filespec} }
\enddefun
\defunx{truncate}{\var{number} \&optional (\var{divisor} 1 ) }
\enddefun
\defunx{type-of}{\var{x} }
\enddefun
\defmacx{typecase}{(typecase keyform {(type {form}*)}*)}
\enddefmac
\defunx{typep}{\var{x} \var{type} }
\enddefun
\defunx{uncatch-bad-signals}[system]{}
\enddefun
\defunx{unexport}{\var{symbol} \&optional (\var{package} *package* ) }
\enddefun
\defunx{unintern}{\var{symbol} \&optional (\var{package} *package* ) }
\enddefun
\defunx{union}{\var{list1} \var{list2} \&key (\var{key} #'identity ) (\var{test} #'eql ) \var{test-not} }
\enddefun
\defunx{universal-error-handler}[system]{\var{error-name} \var{continuable-p} \var{function-name} \var{continue-format-string} \var{error-format-string} \&rest \var{args} }
\enddefun
\defspecx{unless}{(unless test {form}*)}
\enddefspec
\defunx{unread-char}{\var{char} \&optional (\var{stream} *standard-input* ) }
\enddefun
\deftypex{unsigned-byte}
\enddeftype
\defmacx{untrace}{(untrace {function-name}*)}
\enddefmac
\defunx{unuse-package}{\var{package-spec} \&optional (\var{package} *package* ) }
\enddefun
\defspecx{unwind-protect}{(unwind-protect form {cleanup-form}*)}
\enddefspec
\defunx{upper-case-p}{\var{char} }
\enddefun
\defunx{use-package}{\var{package-spec} \&optional (\var{package} *package* ) }
\enddefun
\defunx{user-homedir-pathname}{\&optional \var{host} }
\enddefun
\defunx{values}{\&rest \var{args} }
\enddefun
\defunx{values-list}{\var{list} }
\enddefun
\deftypex{vector}
\enddeftype
\defunx{vector}{\&rest \var{objects} }
\enddefun
\defunx{vector-pop}{\var{vector} }
\enddefun
\defunx{vector-push}{\var{item} \var{vector} }
\enddefun
\defunx{vector-push-extend}{\var{item} \var{vector} \&optional (\var{n} (length vector) ) }
\enddefun
\defunx{vectorp}{\var{x} }
\enddefun
\defunx{warn}{\var{format-string} \&rest \var{args} }
\enddefun
\defspecx{when}{(when test {form}*)}
\enddefspec
\defmacx{with-input-from-string}{(with-input-from-string (var string-form {keyword value}*)
           {decl}* {form}*)}
\enddefmac
\defmacx{with-open-file}{(with-open-file (var filespec-form {options}*) {decl}* {form}*)}
\enddefmac
\defmacx{with-open-stream}{(with-open-stream (var stream-form) {decl}* {form}*)}
\enddefmac
\defmacx{with-output-to-string}{(with-output-to-string (var [string-form]) {decl}* {form}*)}
\enddefmac
\defunx{write}{\var{object} \&key (\var{stream} *standard-output* ) (\var{escape} *print-escape* ) (\var{radix} *print-radix* ) (\var{base} *print-base* ) (\var{circle} *print-circle* ) (\var{pretty} *print-pretty* ) (\var{level} *print-level* ) (\var{length} *print-length* ) (\var{case} *print-case* ) (\var{array} *print-array* ) (\var{gensym} *print-gensym* ) }
\enddefun
\defunx{write-byte}{\var{integer} \var{stream} }
\enddefun
\defunx{write-bytes}[system]{\var{stream} \var{string} \var{start} \var{end} }
\enddefun
\defunx{write-char}{\var{char} \&optional (\var{stream} *standard-output* ) }
\enddefun
\defunx{write-line}{\var{string} \&optional (\var{stream} *standard-output* ) \&key (\var{start} 0 ) (\var{end} (length string) ) }
\enddefun
\defunx{write-string}{\var{string} \&optional (\var{stream} *standard-output* ) \&key (\var{start} 0 ) (\var{end} (length string) ) }
\enddefun
\defunx{write-to-string}{\var{object} \&key (\var{escape} *print-escape* ) (\var{radix} *print-radix* ) (\var{base} *print-base* ) (\var{circle} *print-circle* ) (\var{pretty} *print-pretty* ) (\var{level} *print-level* ) (\var{length} *print-length* ) (\var{case} *print-case* ) (\var{array} *print-array* ) (\var{gensym} *print-gensym* ) }
\enddefun
\defunx{y-or-n-p}{\&optional (\var{format-string} nil ) \&rest \var{args} }
\enddefun
\defunx{yes-or-no-p}{\&optional (\var{format-string} nil ) \&rest \var{args} }
\enddefun
\defunx{zerop}{\var{number} }
\enddefun

\begin{thebibliography}{99}

\bibitem {Steele:84}
Guy L. Steele Jr. et al. ``Common Lisp: the Language'',
Digital Press, 1984.

\bibitem {Steele:90}
Guy L. Steele Jr. at al. ``Common Lisp: the Language II'', second edition,
Digital Press, 1990.

\bibitem {Yuasa:85}
Taiichi Yuasa and Masami Hagiya ``Kyoto \clisp{} Report'',
Research Institute for Mathematical Sciences, Kyoto University, 1988.

\bibitem {Smith:84}
B.C. Smith and J. des Rivieres  ``The Implementation of
Procedurally Reflective Languages'', {\emph Proc. of the 1984 ACM
Symposium on LISP and Functional Programming}, 1984.

\end{thebibliography}

\twocolumn
\node Function Index, Top, First Chapter, Top
\unnumbered{Function Index}
\printindex{fn}

\node Variable Index, Top, First Chapter, Top
\unnumbered{Variable Index}
\printindex{vr}

\c\node Keyword Index, Top, First Chapter, Top
\c\unnumbered{Keyword Index}
\c\printindex{ky}

\c\node Concept Index, Top, First Chapter, Top
\c\unnumbered{Concept Index}
\c\printindex{cp}

