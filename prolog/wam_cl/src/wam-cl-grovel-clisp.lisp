;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./exporting.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Macros that export their definienda
;;; Bruno Haible 2004-12-15
;;; Sam Steingold 2005-2007


#|
#-WAM-CL
(defpackage "EXPORTING"
  (:use "COMMON-LISP")
  (:documentation "Replacements for the standard macros with the versions that export their definienda.")
  (:shadow . #1=(defconstant defparameter defvar define-symbol-macro
                 defun defgeneric defmethod define-compiler-macro defsetf
                 define-setf-expander defmacro define-modify-macro
                 deftype defstruct defclass define-condition
                 define-method-combination
                 #+FFI def-c-type #+FFI def-c-enum #+FFI def-c-struct
                 #+FFI def-c-var #+FFI def-c-const
                 #+FFI def-c-call-out #+FFI def-call-out))
  (:export . #1#))
|#

#-WAM-CL
(in-package "EXPORTING")

#-WAM-CL
(setf (documentation (find-package "EXPORTING") 'sys::impnotes) "exporting")

;; Macros for the variable namespace.


#-WAM-CL
(cl:defmacro defconstant (&whole whole
                          name initial-value &optional documentation)
  (declare (ignore initial-value documentation))
  `(PROGN
     (EXPORT ',(or name '(NIL)))
     (CL:DEFCONSTANT ,name ,@(cddr whole))))


#-WAM-CL
(cl:defmacro defparameter (&whole whole
                           name initial-value &optional documentation)
  (declare (ignore initial-value documentation))
  `(PROGN
     (EXPORT ',(or name '(NIL)))
     (CL:DEFPARAMETER ,name ,@(cddr whole))))


#-WAM-CL
(cl:defmacro defvar (&whole whole
                     name &optional initial-value documentation)
  (declare (ignore initial-value documentation))
  `(PROGN
     (EXPORT ',(or name '(NIL)))
     (CL:DEFVAR ,name ,@(cddr whole))))


#-WAM-CL
(cl:defmacro define-symbol-macro (symbol expansion)
  `(PROGN
     (EXPORT ',(or symbol '(NIL)))
     (CL:DEFINE-SYMBOL-MACRO ,symbol ,expansion)))

;; Macros for the function namespace.


#-WAM-CL
(cl:defmacro defun (name lambda-list &body body)
  `(PROGN
     (EXPORT ',(or (sys::function-block-name name) '(NIL)))
     (CL:DEFUN ,name ,lambda-list ,@body)))


#-WAM-CL
(cl:defmacro defgeneric (name lambda-list &rest options)
  `(PROGN
     (EXPORT ',(or (sys::function-block-name name) '(NIL)))
     (CL:DEFGENERIC ,name ,lambda-list ,@options)))


#-WAM-CL
(cl:defmacro defmethod (name &rest definition)
  `(PROGN
     (EXPORT ',(or (sys::function-block-name name) '(NIL)))
     (CL:DEFMETHOD ,name ,@definition)))


#-WAM-CL
(cl:defmacro define-compiler-macro (name lambda-list &body body)
  `(PROGN
     (EXPORT ',(or (sys::function-block-name name) '(NIL)))
     (CL:DEFINE-COMPILER-MACRO ,name ,lambda-list ,@body)))


#-WAM-CL
(cl:defmacro defsetf (name &rest definition)
  `(PROGN
     (EXPORT ',(or name '(NIL)))
     (CL:DEFSETF ,name ,@definition)))


#-WAM-CL
(cl:defmacro define-setf-expander (name lambda-list &body body)
  `(PROGN
     (EXPORT ',(or name '(NIL)))
     (CL:DEFINE-SETF-EXPANDER ,name ,lambda-list ,@body)))


#-WAM-CL
(cl:defmacro defmacro (name lambda-list &body body)
  `(PROGN
     (EXPORT ',(or name '(NIL)))
     (CL:DEFMACRO ,name ,lambda-list ,@body)))


#-WAM-CL
(cl:defmacro define-modify-macro (&whole whole
                                  name lambda-list function
                                  &optional documentation)
  (declare (ignore lambda-list function documentation))
  `(PROGN
     (EXPORT ',(or name '(NIL)))
     (CL:DEFINE-MODIFY-MACRO ,name ,@(cddr whole))))

;; Macros for the type namespace.


#-WAM-CL
(cl:defmacro deftype (name lambda-list &body body)
  `(PROGN
     (EXPORT ',(or name '(NIL)))
     (CL:DEFTYPE ,name ,lambda-list ,@body)))

(cl:defun slot-definition-accessor-symbols (slot)
  (mapcar #'sys::function-block-name
          (append (clos:slot-definition-readers slot)
                  (clos:slot-definition-writers slot))))

(cl:defun all-accessor-symbols (direct-slot-list)
  (mapcan #'slot-definition-accessor-symbols direct-slot-list))

(cl:defun class-accessor-symbols (class) ; ABI
  (all-accessor-symbols (clos:class-direct-slots class)))

(cl:defun export-structure-accessories (name) ; ABI
  (export name)
  (export (ext:structure-keyword-constructor name))
  (export (ext:structure-boa-constructors name))
  (export (ext:structure-copier name))
  (export (ext:structure-predicate name))
  (dolist (slot (ext:structure-direct-slots name))
    (export (slot-definition-accessor-symbols slot))))

(cl:defmacro defstruct (name+options &rest slots)
  `(LET ((NAME (CL:DEFSTRUCT ,name+options ,@slots)))
     (EXPORT-STRUCTURE-ACCESSORIES NAME)
     NAME))

(cl:defmacro defclass (name superclasses slot-specs &rest options)
  `(PROGN
     (EXPORT ',(or name '(NIL)))
     (LET ((C (CL:DEFCLASS ,name ,superclasses ,slot-specs ,@options)))
       (EXPORT (CLASS-ACCESSOR-SYMBOLS C))
       C)))

(cl:defmacro define-condition (name parent-types slot-specs &rest options)
  `(PROGN
     (EXPORT ',(or name '(NIL)))
     (LET ((C (CL:DEFINE-CONDITION ,name ,parent-types ,slot-specs ,@options)))
       (EXPORT (CLASS-ACCESSOR-SYMBOLS (FIND-CLASS C)))
       C)))

;; Macros for the method-combination namespace.

#-WAM-CL
(cl:defmacro define-method-combination (name &rest definition)
  `(PROGN
     (EXPORT ',(or name '(NIL)))
     (CL:DEFINE-METHOD-COMBINATION ,name ,@definition)))

;; FFI.

#+FFI
(cl:defmacro def-c-type (name &rest options)
  `(PROGN
     (EXPORT ',(or name '(NIL)))
     (FFI:DEF-C-TYPE ,name ,@options)))

#+FFI
(cl:defmacro def-c-enum (name &rest items)
  `(PROGN
     (EXPORT '(,name ,@(mapcar
                         #'(lambda (item) (if (consp item) (first item) item))
                         items)))
     (FFI:DEF-C-ENUM ,name ,@items)))

#+FFI
(cl:defmacro def-c-struct (name+options &rest slots)
  `(LET ((NAME (FFI:DEF-C-STRUCT ,name+options ,@slots)))
     (EXPORT-STRUCTURE-ACCESSORIES NAME)
     NAME))

#+FFI
(cl:defmacro def-c-const (name &rest options)
  `(PROGN
     (EXPORT ',(or name '(NIL)))
     (FFI:DEF-C-CONST ,name ,@options)))

#+FFI
(cl:defmacro def-c-var (name &rest options)
  `(PROGN
     (EXPORT ',(or name '(NIL)))
     (FFI:DEF-C-VAR ,name ,@options)))

#+FFI
(cl:defmacro def-c-call-out (name &rest options)
  `(PROGN
     (EXPORT ',(or name '(NIL)))
     (FFI:DEF-C-CALL-OUT ,name ,@options)))

#+FFI
(cl:defmacro def-call-out (name &rest options)
  `(PROGN
     (EXPORT ',(or name '(NIL)))
     (FFI:DEF-CALL-OUT ,name ,@options)))

#| ;; def-c-call-in and def-call-in don't actually define anything;
   ;; they are more like declarations.

#+FFI
 (cl:defmacro def-c-call-in (name &rest options)
  `(PROGN
     (EXPORT ',(or name '(NIL)))
     (FFI:DEF-C-CALL-IN ,name ,@options)))

#+FFI
 (cl:defmacro def-call-in (name &rest options)
  `(PROGN
     (EXPORT ',(or name '(NIL)))
     (FFI:DEF-CALL-IN ,name ,@options)))

|#

(pushnew "EXPORTING" custom:*system-package-list* :test #'string=)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./exporting.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./cmacros.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CLISP Compiler Macros
;;; Sam Steingold 2001-05-09
;;; Bruno Haible 2005
;;; CLHS 3.2.2.1 http://www.lisp.org/HyperSpec/Body/sec_3-2-2-1.html

(in-package "SYSTEM")

;; a legitimate option is to keep the `compiler-macro' definition of the
;; symbol in a global hash-table instead of the `symbol-plist'.
;; the reason we use plists is that
;; * this performance issue is related only to the compilation speed,
;;   not the execution speed
;; * the plists are actually quite short:
;;   [non-standard functions & macros used in this snippet are in CLOCC:
;;    compose:            <http://clocc.sf.net/clocc/src/port/ext.lisp>
;;    standard-deviation: <http://clocc.sf.net/clocc/src/cllib/math.lisp>
;;    top-bottom-ui:      <http://clocc.sf.net/clocc/src/cllib/sorted.lisp>
;;    CLOCC is available at <http://clocc.sf.net>]
;; (let ((al nil)
;;       (acc (compose length symbol-plist)))
;;   (do-all-symbols (sy) (push sy al))
;;   (delete-duplicates al :test #'eq)
;;   (format t "~&none:~10t ~5:d~%" (count-if #'zerop al :key acc))
;;   (multiple-value-bind (de me le) (standard-deviation al :key acc)
;;     (format t "std dev:~10t ~5f~%mean:~10t ~5f~%length:~10t ~5:d~%"
;;             de me le))
;;   (top-bottom-ui al 5 nil nil :key acc))
;; none:      4,206
;; std dev:   1.874
;; mean:      .6492
;; length:    5,089
;; Top/Bottom: list: 5,089 records.
;; Top (5):
;;   1: hostent-addrtype    ==> 10
;;   2: hostent-aliases     ==> 10
;;   3: hostent-addr-list   ==> 10
;;   4: hostent-name        ==> 10
;;   5: dir-key-info-type   ==> 10
;; also, compiler macros are probably not used often anyway.
;; At any rate, if someone will want to switch to a global hash-table,
;; one needs to change only the following two functions:
;;    compiler-macro-function and
;;    (setf compiler-macro-function)

(defun compiler-macro-function (name &optional environment)
  (declare (ignore environment))
  (setq name (check-function-name name 'compiler-macro-function))
  (get (get-funname-symbol name) 'compiler-macro))

(defun (setf compiler-macro-function) (newf name &optional environment) ; ABI
  (declare (ignore environment))
  (setq name (check-function-name name '(setf compiler-macro-function)))
  (setf (get (get-funname-symbol name) 'compiler-macro) newf))

;; (proclaim '(inline function-form-p simple-function-form-p))

;; Test whether the form is (FUNCTION ...).
(defun function-form-p (form)
  (and (consp form) (eq (car form) 'FUNCTION)
       (consp (cdr form)) (null (cddr form))))

;; Test whether the form is #'symbol or #'(SETF symbol).
(defun simple-function-form-p (form)
  (and (function-form-p form) (function-name-p (second form))))

;; (funcall (function foo) ...) ==> (foo ...)
(defun strip-funcall-form (form) ; ABI
  (if (and (eq (car form) 'funcall) (simple-function-form-p (second form)))
    (cons (second (second form)) (cddr form))
    form))

(defmacro define-compiler-macro (&whole whole-form
                                 name args &body body)
  (declare (ignore name args body))
  (multiple-value-bind (expansion expansion-lambdabody name lambdalist docstring)
      (sys::make-macro-expansion (cdr whole-form) whole-form
                                 #'function-name-p 'strip-funcall-form)
    (declare (ignore expansion-lambdabody lambdalist))
    (sys::check-redefinition name 'define-compiler-macro
                             (and (compiler-macro-function name)
                                  (TEXT "compiler macro")))
    `(EVAL-WHEN (COMPILE LOAD EVAL)
       ,@(when docstring
           `((SYSTEM::%SET-DOCUMENTATION ',name 'COMPILER-MACRO ,docstring)))
       (SETF (COMPILER-MACRO-FUNCTION ',name) ,expansion)
       ',name)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./cmacros.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./places.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; CLISP - PLACES.LSP
;;; CLISP-specific: string-concat, %rplaca, %rplacd, store, setelt, ...

(in-package "SYSTEM")

(defmacro string-concat (&rest) `(concatenate 'string ,@rest))

;;;----------------------------------------------------------------------------
;;; Functions to define and deal with places
;;;----------------------------------------------------------------------------
;;; Return a symbol for SYSTEM::SETF-FUNCTION
;;; the returned symbol will be interned iff the argument is.
(defun setf-symbol (symbol)
  (let* ((pack (symbol-package symbol))
         (name (string-concat "(SETF " (if pack (package-name pack) "#") ":"
                              (symbol-name symbol) ")")))
    (if pack
        (intern name pack)
        (make-symbol name))))
;;;----------------------------------------------------------------------------
;;; Returns the symbol which is on the property list at SYSTEM::SETF-FUNCTION
(defun get-setf-symbol (symbol) ; ABI
  (or (get symbol 'SYSTEM::SETF-FUNCTION)
      (progn
        (when (get symbol 'SYSTEM::SETF-EXPANDER)
          (warn (TEXT "The function (~S ~S) is hidden by a SETF expander.")
                'setf symbol))
        (setf (get symbol 'SYSTEM::SETF-FUNCTION) (setf-symbol symbol)))))
;;;----------------------------------------------------------------------------
;;; Returns 5 values:
;;;   SM1  temps       variables to bind
;;;   SM2  subforms    values to bind to
;;;   SM3  stores      variables whose values are used by the setter form
;;;   SM4  setterform  setter form
;;;   SM5  getterform  getter form
(defun get-setf-expansion (form &optional env)
  (unless env ; user may pass env=NIL to mean "null lexical environment"
    (setq env (vector nil nil)))
  (loop
    ;; 1st step: search for global SETF definitions:
    (when (and (consp form) (symbolp (car form)))
      (when (global-in-fenv-p (car form) (svref env 1))
        ;; Operator not defined locally
        (let ((plist-info (get (first form) 'SYSTEM::SETF-EXPANDER)))
          (when plist-info
            (return-from get-setf-expansion
              (if (symbolp plist-info) ; Symbol comes from a short DEFSETF
                (do* ((storevar (gensym "NEW-"))
                      (tempvars nil (cons (gensym "TEMP-") tempvars))
                      (tempforms nil (cons (car formr) tempforms))
                      (formr (cdr form) (cdr formr)))
                     ((endp formr)
                      (setq tempforms (nreverse tempforms))
                      (values tempvars
                              tempforms
                              `(,storevar)
                              `(,plist-info ,@tempvars ,storevar)
                              `(,(first form) ,@tempvars))))
                (let ((argcount (car plist-info)))
                  (if (eql argcount -5)
                    ;; (-5 . fun) comes from DEFINE-SETF-METHOD
                    (funcall (cdr plist-info) form env)
                    ;; (argcount storevarcount . fun) comes from a long DEFSETF
                    (let ((access-form form)
                          (tempvars '())
                          (tempforms '())
                          (new-access-form '()))
                      (let ((i 0)) ; argument counter
                        ;; argcount = -1 if no keyword arguments exist
                        ;; resp.    = number of the arguments before &KEY,
                        ;;          = nil after these are processed.
                        (dolist (argform (cdr access-form))
                          (when (eql i argcount) (setq argcount nil i 0))
                          (if (and (null argcount) (evenp i))
                            (if (keywordp argform)
                              (push argform new-access-form)
                              (error-of-type 'source-program-error
                                :form form
                                :detail argform
                                (TEXT "The argument ~S to ~S should be a keyword.")
                                argform (car access-form)))
                            (let ((tempvar (gensym)))
                              (push tempvar tempvars)
                              (push argform tempforms)
                              (push tempvar new-access-form)))
                          (incf i)))
                      (setq new-access-form (nreverse new-access-form))
                      (let ((newval-vars (gensym-list (cadr plist-info))))
                        (values
                          (nreverse tempvars)
                          (nreverse tempforms)
                          newval-vars
                          (apply (cddr plist-info) env
                                 (append newval-vars new-access-form))
                          (cons (car access-form) new-access-form))))))))))))
    ;; 2nd step: macroexpand
    (when (eq form (setq form (macroexpand-1 form env)))
      (return)))
  ;; 3rd step: default SETF methods
  (cond ((symbolp form)
         (return-from get-setf-expansion
           (let ((storevar (gensym "NEW-")))
             (values nil
                     nil
                     `(,storevar)
                     `(SETQ ,form ,storevar)
                     `,form))))
        ((and (consp form) (symbolp (car form)))
         (return-from get-setf-expansion
           (do* ((storevar (gensym "NEW-"))
                 (tempvars nil (cons (gensym "TEMP-") tempvars))
                 (tempforms nil (cons (car formr) tempforms))
                 (formr (cdr form) (cdr formr)))
                ((endp formr)
                 (setq tempforms (nreverse tempforms))
                 (values tempvars
                         tempforms
                         `(,storevar)
                         ;; this is identical to CLISP-specific
                         ;; ((SETF ,(first form)) ,storevar ,@tempvars)
                         ;; but the we will return the form
                         ;; that will not confuse 3rd party code walkers
                         `(FUNCALL #'(SETF ,(first form)) ,storevar ,@tempvars)
                         `(,(first form) ,@tempvars))))))
        (t (error-of-type 'source-program-error
             :form form
             :detail form
             (TEXT "~S: Argument ~S is not a SETF place.")
             'get-setf-expansion form))))
;;;----------------------------------------------------------------------------
(defun get-setf-method (form &optional (env (vector nil nil)))
  (multiple-value-bind (temps subforms stores setterform getterform)
      (get-setf-expansion form env)
    (unless (and (consp stores) (null (cdr stores)))
      (error-of-type 'source-program-error
        :form form :detail form
        (TEXT "SETF place ~S should produce exactly one store variable.")
        form))
    (values temps subforms stores setterform getterform)))
;;;----------------------------------------------------------------------------
;;; Auxiliary functions for simplifying bindings and setterforms.

;;; Like (subst newitem olditem form), except that it works on forms and
;;; doesn't look inside quoted literals.
;;; FIXME: This is still not correct: The form can contain macros or THE.
(defun subst-in-form (newitem olditem form)
  ;; Don't use subst here, since a form can contain circular lists
  ;; hidden behind QUOTE.
  (if (atom form)
    (if (eql form olditem) newitem form)
    (if (eq (car form) 'QUOTE)
      form
      (let ((modified nil)
            (new-form-reversed '()))
        (do ((formr form (cdr formr)))
            ((atom formr)
             (unless (eql formr (setq formr (subst-in-form newitem olditem
                                                           formr)))
               (setq modified t))
             (if modified (nreconc new-form-reversed formr) form))
          (let ((new-subform (subst-in-form newitem olditem (car formr))))
            (unless (eql (car formr) new-subform)
              (setq modified t))
            (setq new-form-reversed (cons new-subform new-form-reversed))))))))

;;; Like (sublis alist form), except that it works on forms and
;;; doesn't look inside quoted literals.
;;; FIXME: This is still not correct: The form can contain macros or THE.
(defun sublis-in-form (alist form)
  ;; Don't use sublis here, since a form can contain circular lists
  ;; hidden behind QUOTE.
  (if (atom form)
    (let ((h (assoc form alist))) (if h (cdr h) form))
    (if (eq (car form) 'QUOTE)
      form
      (let ((modified nil)
            (new-form-reversed '()))
        (do ((formr form (cdr formr)))
            ((atom formr)
             (unless (eql formr (setq formr (sublis-in-form alist formr)))
               (setq modified t))
             (if modified (nreconc new-form-reversed formr) form))
          (let ((new-subform (sublis-in-form alist (car formr))))
            (unless (eql (car formr) new-subform)
              (setq modified t))
            (setq new-form-reversed (cons new-subform new-form-reversed))))))))

;;; An empty binding list can be optimized away.
(defun wrap-let* (bindlist form)
  (if (and (null bindlist)
           ;; But don't optimize the LET* away if the form is a PROGN form,
           ;; because when it occurs as a top-level form in a file and refers
           ;; to uninterned symbols, compiling the elements of the PROGN
           ;; separately leads to problems.
           (not (and (consp form) (eq (first form) 'PROGN))))
    form
    `(LET* ,bindlist ,form)))

;;; In simple assignments like (SETQ foo #:G0) the #:G0 can be replaced
;;; directly.
(defun simple-assignment-p (env store-form stores)
  (and (= (length stores) 1)
       (consp store-form)
       (eq (first store-form) 'SETQ)
       (= (length store-form) 3)
       (symbolp (second store-form))
       (not (nth-value 1 (macroexpand-1 (second store-form) env)))
       (simple-use-p (third store-form) (first stores))))
(defun simple-use-p (form var)
  (or (eq form var)
      (and (consp form) (eq (first form) 'THE) (= (length form) 3)
           (simple-use-p (third form) var))))

;;; Tests whether a variable (a gensym) occurs in the given form.
;;; FIXME: This is still not correct: The form can contain macros or THE.
(defun occurs-in-p (form var)
  ;; Don't use (tree-equal form form ...) here, since a form can contain
  ;; circular lists hidden behind QUOTE.
  (if (atom form)
    (eq form var)
    (if (eq (car form) 'QUOTE)
      nil
      (do ((formr form (cdr formr)))
          ((atom formr) (eq formr var))
        (when (occurs-in-p (car formr) var) (return t))))))

;;; Tests whether two forms are guaranteed to commute. The first is assumed to
;;; be a symbol, the second one can be more complex.
(defun commuting-forms-p (var form env)
  (and (symbolp var)
       (not (nth-value 1 (macroexpand-1 var env)))
       (not (nth-value 1 (macroexpand-1 form env)))
       (if (atom form)
         (not (eq form var))
         (let ((funname (first form))
               (argforms (rest form)))
           (and (function-name-p funname) ; we don't handle LAMBDAs here
                (if (symbolp funname)
                  (and (not (special-operator-p funname))
                       (null (macro-function funname env)))
                  t)
                (not (sys::fenv-search funname (and env (svref env 1))))
                (every #'(lambda (argform) (commuting-forms-p var argform env))
                       argforms))))))
;;; For bootstrapping.
(predefun sys::fenv-search (funname fenv)
  (declare (ignore funname fenv))
  nil)

;;; In simple function calls like (SYSTEM::%RPLACA foo #:G0) the #:G0 can be
;;; replaced directly if it occurs only once, as an argument, and the earlier
;;; arguments commute with the value.
(defun simple-occurrence-in-basic-block-p (env form var valform)
  (if (atom form)
    (eq form var)
    (case (first form)
      (SETQ
        (and (= (length form) 3)
             (symbolp (second form))
             (not (nth-value 1 (macroexpand-1 (second form) env)))
             (not (eq (second form) var))
             (simple-occurrence-in-basic-block-p env (third form) var valform)))
      (THE
        (and (= (length form) 3)
             (simple-occurrence-in-basic-block-p env (third form) var valform)))
      (t
        (let ((funname (first form))
              (argforms (rest form)))
          (and (function-name-p funname) ; we don't handle LAMBDAs here
               (if (symbolp funname)
                 (and (not (special-operator-p funname))
                      (null (macro-function funname env)))
                 t)
               ;; At this point we know it's a function call.
               ;; We assume the value to be put in for var does not change
               ;; funname's function definition,
               (do ((earlier-argforms (reverse argforms)
                                      (cdr earlier-argforms)))
                   ((null earlier-argforms) nil)
                 (when (occurs-in-p (car earlier-argforms) var)
                   ;; Found the last argument form that refers to var.
                   (return
                     (and (simple-occurrence-in-basic-block-p
                           env (car earlier-argforms) var valform)
                          (every #'(lambda (argform)
                                     (and (symbolp argform)
                                          (not (nth-value 1 (macroexpand-1
                                                             argform env)))
                                          (not (ext:special-variable-p
                                                argform env))
                                          (not (eq argform var))
                                          (commuting-forms-p argform valform
                                                             env)))
                                 (cdr earlier-argforms))))))))))))

(defun optimized-wrap-let* (env bindlist form) ; ABI
  (if (null bindlist)
    form
    (let* ((last-binding (car (last bindlist)))
           (last-var (first last-binding))
           (last-valform (second last-binding)))
      (if (simple-occurrence-in-basic-block-p env form last-var last-valform)
        (optimized-wrap-let* env (butlast bindlist)
          (subst-in-form last-valform last-var form))
        (wrap-let* bindlist form)))))

(defun optimized-wrap-multiple-value-bind (env varlist valuesform form)
  (cond ((null varlist)
         `(PROGN ,valuesform ,form))
        ((null (cdr varlist))
         (optimized-wrap-let* env (list (list (car varlist) valuesform)) form))
        (t `(MULTIPLE-VALUE-BIND ,varlist ,valuesform ,form))))

;;;----------------------------------------------------------------------------
(defmacro push (item place &environment env)
  (multiple-value-bind (temps subforms stores setterform getterform)
      (get-setf-expansion place env)
    (let ((itemtemps (gensym-list (length stores)))
          (bindlist (mapcar #'list temps subforms))
          (oldtemps (gensym-list (length stores))))
      (optimized-wrap-multiple-value-bind env itemtemps item
        (wrap-let* bindlist
          (optimized-wrap-multiple-value-bind env oldtemps getterform
            ;; We're not blindly optimizing this to
            ;;   (sublis-in-form
            ;;     (mapcar #'(lambda (storevar itemvar oldvar)
            ;;                 (cons storevar `(CONS ,itemvar ,oldvar)))
            ;;             stores itemtemps oldtemps)
            ;;     setterform)
            ;; because we don't want the CONS forms to be evaluated multiple
            ;; times. Instead we rely on simple-occurrence-in-basic-block-p for
            ;; doing the analysis.
            (optimized-wrap-let* env
              (mapcar #'(lambda (storevar itemvar oldvar)
                          (list storevar `(CONS ,itemvar ,oldvar)))
                      stores itemtemps oldtemps)
              setterform)))))))
;;;----------------------------------------------------------------------------
(eval-when (load compile eval)
  (defun check-accessor-name (accessfn whole-form)
    (unless (symbolp accessfn)
      (error-of-type 'source-program-error
        :form whole-form
        :detail accessfn
        (TEXT "The name of the accessor must be a symbol, not ~S")
        accessfn))))
(defmacro define-setf-expander (&whole whole-form
                                accessfn lambdalist &body body)
  (check-accessor-name accessfn whole-form)
  (multiple-value-bind (body-rest declarations docstring)
      (system::parse-body body t)
    (if (null body-rest) (setq body-rest '(NIL)))
    (let ((name (make-symbol (string-concat "SETF-" (symbol-name accessfn))))
          (SYSTEM::%WHOLE-FORM whole-form)
          (SYSTEM::%PROPER-LIST-P t))
      (multiple-value-bind (newlambdalist envvar)
          (remove-env-arg lambdalist name)
        (let ((SYSTEM::%ARG-COUNT 0)
              (SYSTEM::%MIN-ARGS 0)
              (SYSTEM::%RESTP nil)
              (SYSTEM::%NULL-TESTS nil)
              (SYSTEM::%LET-LIST nil)
              (SYSTEM::%KEYWORD-TESTS nil)
              (SYSTEM::%DEFAULT-FORM nil))
          (SYSTEM::ANALYZE1 newlambdalist '(CDR SYSTEM::%LAMBDA-LIST)
                            name 'SYSTEM::%LAMBDA-LIST)
          (if (null newlambdalist)
            (push `(IGNORE SYSTEM::%LAMBDA-LIST) declarations))
          (let ((lengthtest (sys::make-length-test 'SYSTEM::%LAMBDA-LIST 1))
                (mainform
                  `(LET* ,(nreverse SYSTEM::%LET-LIST)
                     ,@(if declarations `(,(cons 'DECLARE declarations)))
                     ,@(nreverse SYSTEM::%NULL-TESTS)
                     ,@(nreverse SYSTEM::%KEYWORD-TESTS)
                     (BLOCK ,accessfn ,@body-rest))))
            (if lengthtest
              (setq mainform
                `(IF ,lengthtest
                   (ERROR-OF-TYPE 'PROGRAM-ERROR
                     (TEXT "The SETF expander for ~S may not be called with ~S arguments.")
                     (QUOTE ,accessfn) (1- (LENGTH SYSTEM::%LAMBDA-LIST)))
                   ,mainform)))
            `(EVAL-WHEN (LOAD COMPILE EVAL)
               (LET ()
                 (REMPROP ',accessfn 'SYSTEM::DEFSTRUCT-WRITER)
                 (DEFUN ,name (SYSTEM::%LAMBDA-LIST ,(or envvar 'SYSTEM::ENV))
                   ,@(if envvar '() '((DECLARE (IGNORE SYSTEM::ENV))))
                   ,mainform)
                 (sys::check-redefinition
                  ',accessfn 'define-setf-expander
                  (and (get ',accessfn 'SYSTEM::SETF-EXPANDER)
                       (TEXT "SETF expander")))
                 (SYSTEM::%PUT ',accessfn 'SYSTEM::SETF-EXPANDER
                   (CONS -5 (FUNCTION ,name)))
                 (SYSTEM::%SET-DOCUMENTATION ',accessfn 'SETF ',docstring)
                 ',accessfn))))))))
;;;----------------------------------------------------------------------------
(defmacro defsetf (&whole whole-form
                   accessfn &rest args)
  (check-accessor-name accessfn whole-form)
  (cond ((and (consp args) (not (listp (first args))) (symbolp (first args)))
         `(EVAL-WHEN (LOAD COMPILE EVAL)
            (LET ()
              (REMPROP ',accessfn 'SYSTEM::DEFSTRUCT-WRITER)
              (SYS::CHECK-REDEFINITION
               ',accessfn 'DEFSETF
               (and (get ',accessfn 'SYSTEM::SETF-EXPANDER)
                    (TEXT "SETF expander")))
              (SYSTEM::%PUT ',accessfn 'SYSTEM::SETF-EXPANDER ',(first args))
              (SYSTEM::%SET-DOCUMENTATION ',accessfn 'SETF
                ,(if (and (null (cddr args))
                          (or (null (second args)) (stringp (second args))))
                   (second args)
                   (if (cddr args)
                     (error-of-type 'source-program-error
                       :form whole-form
                       :detail (cdr args)
                       (TEXT "~S: Too many arguments: ~S")
                       'defsetf (cdr args))
                     (error-of-type 'source-program-error
                       :form whole-form
                       :detail (second args)
                       (TEXT "~S: The documentation string must be a string: ~S")
                       'defsetf (second args)))))
              ',accessfn)))
        ((and (consp args) (listp (first args)) (consp (cdr args))
              (listp (second args)))
         (multiple-value-bind (body-rest declarations docstring)
             (system::parse-body (cddr args) t)
           (let* ((storevars (second args))
                  arg-count
                  (setter
                    (let ((lambdalist (first args)))
                      (multiple-value-bind (reqvars optvars optinits optsvars
                                            rest keyp keywords keyvars keyinits
                                            keysvars allowp env)
                          (analyze-defsetf-lambdalist lambdalist
                            #'(lambda (lalist detail errorstring &rest arguments)
                                (declare (ignore lalist));use WHOLE-FORM instead
                                (lambda-list-error whole-form detail
                                  (TEXT "~S ~S: invalid ~S lambda-list: ~?")
                                  'defsetf accessfn 'defsetf
                                  errorstring arguments)))
                        (declare (ignore optinits optsvars rest keywords keyvars
                                         keyinits keysvars allowp))
                        (setq arg-count (if keyp (+ (length reqvars)
                                                    (length optvars)) -1))
                        (if (eql env 0)
                          (setq env (gensym "IG")
                                declarations (cons `(IGNORE ,env) declarations))
                          (setq lambdalist
                                (let ((lr (memq '&ENVIRONMENT lambdalist)))
                                  (append (ldiff lambdalist lr) (cddr lr)))))
                        (when declarations
                          (setq declarations `((DECLARE ,@declarations))))
                        `(LAMBDA (,env ,@storevars ,@lambdalist)
                           ,@declarations
                           (BLOCK ,accessfn ,@body-rest))))))
             `(EVAL-WHEN (LOAD COMPILE EVAL)
                (LET ()
                  (REMPROP ',accessfn 'SYSTEM::DEFSTRUCT-WRITER)
                  (SYS::CHECK-REDEFINITION
                    ',accessfn 'DEFSETF
                    (AND (GET ',accessfn 'SYSTEM::SETF-EXPANDER)
                         (TEXT "SETF expander")))
                  (SYSTEM::%PUT ',accessfn 'SYSTEM::SETF-EXPANDER
                    (LIST* ,arg-count ,(length storevars)
                           (FUNCTION ,(concat-pnames "SETF-" accessfn)
                                     ,setter)))
                  (SYSTEM::%SET-DOCUMENTATION ',accessfn 'SETF ,docstring)
                  ',accessfn)))))
        (t (error-of-type 'source-program-error
             :form whole-form
             :detail args
             (TEXT "(~S ~S): Illegal syntax.")
             'defsetf accessfn))))
;;;----------------------------------------------------------------------------
;;; Redirects #'(SETF accessfn) to be the same as setterfn.
(defmacro def-setf-alias (accessfn setterfn)
  `(SYSTEM::%PUT ',accessfn 'SYSTEM::SETF-FUNCTION ',setterfn))
;;;----------------------------------------------------------------------------
;;; Definition of places:
;;;----------------------------------------------------------------------------
(def-setf-alias system::package-documentation SYSTEM::|(SETF PACKAGE-DOCUMENTATION)|)
(def-setf-alias package-case-inverted-p SYSTEM::|(SETF PACKAGE-CASE-INVERTED-P)|)
(def-setf-alias package-case-sensitive-p SYSTEM::|(SETF PACKAGE-CASE-SENSITIVE-P)|)
(def-setf-alias package-lock SYSTEM::|(SETF PACKAGE-LOCK)|)
(def-setf-alias hash-table-weak-p SYSTEM::|(SETF HASH-TABLE-WEAK-P)|)
(def-setf-alias hash-table-warn-if-needs-rehash-after-gc SYSTEM::|(SETF HASH-TABLE-WARN-IF-NEEDS-REHASH-AFTER-GC)|)
(def-setf-alias weak-pointer-value SYSTEM::|(SETF WEAK-POINTER-VALUE)|)
(def-setf-alias weak-list-list SYSTEM::|(SETF WEAK-LIST-LIST)|)
(def-setf-alias weak-mapping-value SYSTEM::|(SETF WEAK-MAPPING-VALUE)|)
(def-setf-alias weak-and-mapping-value SYSTEM::|(SETF WEAK-AND-MAPPING-VALUE)|)
(def-setf-alias weak-or-mapping-value SYSTEM::|(SETF WEAK-OR-MAPPING-VALUE)|)
(def-setf-alias weak-alist-contents SYSTEM::|(SETF WEAK-ALIST-CONTENTS)|)
(def-setf-alias weak-alist-value SYSTEM::|(SETF WEAK-ALIST-VALUE)|)
;;;----------------------------------------------------------------------------
(defsetf aref (array &rest indices) (value)
  `(SYSTEM::STORE ,array ,@indices ,value))
;;;----------------------------------------------------------------------------
(defun SYSTEM::%SETNTH (index list value) ; ABI
  (let ((pointer (nthcdr index list)))
    (if (null pointer)
      (error-of-type 'error
        (TEXT "~S: index ~S is too large for ~S")
        '(setf nth) index list)
      (rplaca pointer value))
    value))
(defsetf nth SYSTEM::%SETNTH)
;;;----------------------------------------------------------------------------
(def-setf-alias elt SYSTEM::|(SETF ELT)|)
;;;----------------------------------------------------------------------------
(defsetf rest SYSTEM::%RPLACD)
(defsetf first SYSTEM::%RPLACA)
(defsetf second (list) (value) `(SYSTEM::%RPLACA (CDR ,list) ,value))
(defsetf third (list) (value) `(SYSTEM::%RPLACA (CDDR ,list) ,value))
(defsetf fourth (list) (value) `(SYSTEM::%RPLACA (CDDDR ,list) ,value))
(defsetf fifth (list) (value) `(SYSTEM::%RPLACA (CDDDDR ,list) ,value))
(defsetf sixth (list) (value) `(SYSTEM::%RPLACA (CDR (CDDDDR ,list)) ,value))
(defsetf seventh (list) (value) `(SYSTEM::%RPLACA (CDDR (CDDDDR ,list)) ,value))
(defsetf eighth (list) (value) `(SYSTEM::%RPLACA (CDDDR (CDDDDR ,list)) ,value))
(defsetf ninth (list) (value) `(SYSTEM::%RPLACA (CDDDDR (CDDDDR ,list)) ,value))
(defsetf tenth (list) (value) `(SYSTEM::%RPLACA (CDR (CDDDDR (CDDDDR ,list))) ,value))

(defsetf car SYSTEM::%RPLACA)
(defsetf cdr SYSTEM::%RPLACD)
(defsetf caar (list) (value) `(SYSTEM::%RPLACA (CAR ,list) ,value))
(defsetf cadr (list) (value) `(SYSTEM::%RPLACA (CDR ,list) ,value))
(defsetf cdar (list) (value) `(SYSTEM::%RPLACD (CAR ,list) ,value))
(defsetf cddr (list) (value) `(SYSTEM::%RPLACD (CDR ,list) ,value))
(defsetf caaar (list) (value) `(SYSTEM::%RPLACA (CAAR ,list) ,value))
(defsetf caadr (list) (value) `(SYSTEM::%RPLACA (CADR ,list) ,value))
(defsetf cadar (list) (value) `(SYSTEM::%RPLACA (CDAR ,list) ,value))
(defsetf caddr (list) (value) `(SYSTEM::%RPLACA (CDDR ,list) ,value))
(defsetf cdaar (list) (value) `(SYSTEM::%RPLACD (CAAR ,list) ,value))
(defsetf cdadr (list) (value) `(SYSTEM::%RPLACD (CADR ,list) ,value))
(defsetf cddar (list) (value) `(SYSTEM::%RPLACD (CDAR ,list) ,value))
(defsetf cdddr (list) (value) `(SYSTEM::%RPLACD (CDDR ,list) ,value))
(defsetf caaaar (list) (value) `(SYSTEM::%RPLACA (CAAAR ,list) ,value))
(defsetf caaadr (list) (value) `(SYSTEM::%RPLACA (CAADR ,list) ,value))
(defsetf caadar (list) (value) `(SYSTEM::%RPLACA (CADAR ,list) ,value))
(defsetf caaddr (list) (value) `(SYSTEM::%RPLACA (CADDR ,list) ,value))
(defsetf cadaar (list) (value) `(SYSTEM::%RPLACA (CDAAR ,list) ,value))
(defsetf cadadr (list) (value) `(SYSTEM::%RPLACA (CDADR ,list) ,value))
(defsetf caddar (list) (value) `(SYSTEM::%RPLACA (CDDAR ,list) ,value))
(defsetf cadddr (list) (value) `(SYSTEM::%RPLACA (CDDDR ,list) ,value))
(defsetf cdaaar (list) (value) `(SYSTEM::%RPLACD (CAAAR ,list) ,value))
(defsetf cdaadr (list) (value) `(SYSTEM::%RPLACD (CAADR ,list) ,value))
(defsetf cdadar (list) (value) `(SYSTEM::%RPLACD (CADAR ,list) ,value))
(defsetf cdaddr (list) (value) `(SYSTEM::%RPLACD (CADDR ,list) ,value))
(defsetf cddaar (list) (value) `(SYSTEM::%RPLACD (CDAAR ,list) ,value))
(defsetf cddadr (list) (value) `(SYSTEM::%RPLACD (CDADR ,list) ,value))
(defsetf cdddar (list) (value) `(SYSTEM::%RPLACD (CDDAR ,list) ,value))
(defsetf cddddr (list) (value) `(SYSTEM::%RPLACD (CDDDR ,list) ,value))
;;;----------------------------------------------------------------------------
(defsetf svref SYSTEM::SVSTORE)
(defsetf row-major-aref system::row-major-store)
;;;----------------------------------------------------------------------------
;;; Simplify a form, when its values are not needed, only its side effects.
;;; Returns a list of subforms.
;;;   (values x y z) --> (x y z)
;;;   x --> (x)
(defun devalue-form (form)
  (if (eq (car form) 'VALUES) (cdr form) (list form)))
;;;----------------------------------------------------------------------------
(defmacro pop (place &environment env)
  (multiple-value-bind (temps subforms stores setterform getterform)
      (get-setf-expansion place env)
    ;; Be sure to call the CARs before the CDRs - it matters in case
    ;; not all of the places evaluate to lists.
    (let* ((bindlist (mapcar #'list temps subforms))
           (oldtemps (gensym-list (length stores)))
           (advance-and-set-form
             ;; We're not blindly optimizing this to
             ;;   (sublis-in-form
             ;;     (mapcar #'(lambda (storevar oldvar) (cons storevar `(CDR ,oldvar)))
             ;;             stores oldtemps)
             ;;     setterform)
             ;; because some part of the setterform could make side-effects that
             ;; affect the value of the CDRs. Instead we rely on
             ;; simple-occurrence-in-basic-block-p for doing the analysis.
             (optimized-wrap-let* env
               (mapcar #'(lambda (storevar oldvar)
                           (list storevar `(CDR ,oldvar)))
                       stores oldtemps)
               setterform)))
      (if (= (length stores) 1)
        (let ((prog1-form
                `(PROG1
                   (CAR ,(car oldtemps))
                   ,@(devalue-form advance-and-set-form))))
          (if (and (symbolp getterform)
                   (not (nth-value 1 (macroexpand-1 getterform env)))
                   (simple-occurrence-in-basic-block-p env advance-and-set-form
                     (car oldtemps) getterform))
            ;; getterform can be evaluated multiple times instead of once,
            ;; and nothing in the setterform interferes with its value.
            ;; => Optimize away the binding of the oldtemps.
            (optimized-wrap-let* env bindlist
              (subst-in-form getterform (car oldtemps)
                prog1-form))
            (optimized-wrap-let*
             env (nconc bindlist (list (list (car oldtemps) getterform)))
             prog1-form)))
        (optimized-wrap-let* env bindlist
          (optimized-wrap-multiple-value-bind env oldtemps getterform
            `(MULTIPLE-VALUE-PROG1
               (VALUES ,@(mapcar #'(lambda (oldvar) `(CAR ,oldvar)) oldtemps))
               ,@(devalue-form advance-and-set-form))))))))
;----------------------------------------------------------------------------
(defmacro psetf (&whole whole-form
                 &rest args &environment env)
  (labels ((recurse (args)
             (multiple-value-bind (temps subforms stores setterform getterform)
                 (get-setf-expansion (car args) env)
               (declare (ignore getterform))
               (when (atom (cdr args))
                 (error-of-type 'source-program-error
                   :form whole-form
                   :detail whole-form
                   (TEXT "~S called with an odd number of arguments: ~S")
                   'psetf whole-form))
               (wrap-let* (mapcar #'list temps subforms)
                 `(MULTIPLE-VALUE-BIND ,stores ,(second args)
                    ,@(when (cddr args) (list (recurse (cddr args))))
                    ,@(devalue-form setterform))))))
    (when args `(,@(recurse args) NIL))))
;;;----------------------------------------------------------------------------
(defmacro pushnew (item place &rest keylist &environment env)
  (multiple-value-bind (temps subforms stores setterform getterform)
      (get-setf-expansion place env)
    (let ((itemtemps (gensym-list (length stores)))
          (bindlist (mapcar #'list temps subforms))
          (oldtemps (gensym-list (length stores))))
      (optimized-wrap-multiple-value-bind env itemtemps item
        (wrap-let* bindlist
          (optimized-wrap-multiple-value-bind env oldtemps getterform
            ;; We're not blindly optimizing this to
            ;;   (sublis-in-form
            ;;     (mapcar #'(lambda (storevar itemvar oldvar)
            ;;                 (cons storevar `(ADJOIN ,itemvar ,oldvar ,@keylist)))
            ;;             stores itemtemps oldtemps)
            ;;     setterform)
            ;; because we don't want the ADJOIN forms to be evaluated multiple
            ;; times. Instead we rely on simple-occurrence-in-basic-block-p for
            ;; doing the analysis.
            (optimized-wrap-let* env
              (mapcar #'(lambda (storevar itemvar oldvar)
                          (list storevar `(ADJOIN ,itemvar ,oldvar ,@keylist)))
                      stores itemtemps oldtemps)
              setterform)))))))
;;;----------------------------------------------------------------------------
(defmacro remf (place indicator &environment env)
  (multiple-value-bind (temps subforms stores setterform getterform)
      (get-setf-method place env)
    (let* ((indicatorvar (gensym "INDICATOR-"))
           (oldtemps (gensym-list (length stores)))
           (bindlist
             ;; The order of the bindings is a not strictly left-to-right here,
             ;; but that's how ANSI CL 5.1.3 specifies it.
             `(,@(mapcar #'list temps subforms)
               (,indicatorvar ,indicator)
               (,(first oldtemps) ,getterform)))
           (removed-p (gensym)))
      (wrap-let* bindlist
        `(MULTIPLE-VALUE-BIND (,(first stores) ,removed-p)
             (SYSTEM::%REMF ,(first oldtemps) ,indicatorvar)
           (WHEN (AND ,removed-p (ATOM ,(first stores)))
             ,setterform)
           ,removed-p)))))
;;;----------------------------------------------------------------------------
(export 'ext::remove-plist "EXT")
;;; Remove the keys from the plist.
;;; Useful for re-using the &REST arg after removing some options.
(defun remove-plist (plist &rest keys)
  ;; This implementation is
  ;; 1. minimal-consing, non-consing if possible,
  ;; 2. O(L*K) where L = (length plist), K = (length keys).
  ;; Remove the first occurring key first, then the second occurring key, etc.
  ;; This allows us to use the built-in GET-PROPERTIES function.
  ;; Another O(L*K) algorithm is remove the keys in the order in which they
  ;; occur in keys, keeping track how much of the list has already been copied.
  (do ((copy '()))
      (nil)
    (let ((rest (nth-value 2 (get-properties plist keys))))
      (unless rest (return (nreconc copy plist)))
      (setq copy (nreconc (ldiff plist rest) copy))
      (setq plist (cddr rest)))))
;;;----------------------------------------------------------------------------
(defmacro rotatef (&rest args &environment env)
  (when (null args) (return-from rotatef NIL))
  (when (null (cdr args)) (return-from rotatef `(PROGN ,(car args) NIL)))
  (do* ((arglist args (cdr arglist))
        (res (list 'LET* nil nil))
        last-setterform
        (tail (cdr res))
        (bindlist '())
        (all-stores '())
        last-stores
        first-stores)
       ((null arglist)
        (setf (second res) (nreverse bindlist)
              (second (third res)) last-stores
              (cdr tail) (nconc (nreverse all-stores)
                                (devalue-form last-setterform))
              (cdr (last res)) (list nil))
        res)
    (multiple-value-bind (temps subforms stores setterform getterform)
        (get-setf-expansion (first arglist) env)
      (setq bindlist (nreconc (mapcar #'list temps subforms) bindlist))
      (setf (cadr tail) (list 'MULTIPLE-VALUE-BIND last-stores getterform nil))
      (setq tail (cddadr tail))
      (if (null first-stores)
        (setq first-stores stores)
        (setq all-stores (revappend (devalue-form last-setterform) all-stores)))
      (setq last-stores stores last-setterform setterform))))
;;;----------------------------------------------------------------------------
(defmacro define-modify-macro (&whole whole-form
                               name lambdalist function &optional docstring)
  (multiple-value-bind (reqvars optvars optinits optsvars rest)
      (analyze-modify-macro-lambdalist lambdalist
        #'(lambda (lalist detail errorstring &rest arguments)
            (declare (ignore lalist)) ; use WHOLE-FORM instead
            (lambda-list-error whole-form detail
              (TEXT "~S ~S: invalid ~S lambda-list: ~?")
              'define-modify-macro name 'define-modify-macro
              errorstring arguments)))
    (declare (ignore optinits optsvars))
    (let ((varlist (append reqvars optvars))
          (restvar (if (not (eql rest 0)) rest nil)))
      `(DEFMACRO ,name (PLACE ,@lambdalist &ENVIRONMENT ENV) ,docstring
         (MULTIPLE-VALUE-BIND (TEMPS SUBFORMS STORES SETTERFORM GETTERFORM)
             (GET-SETF-METHOD PLACE ENV)
           ;; ANSI CL 5.1.3. mandates the following evaluation order:
           ;; First the SUBFORMS,
           ;; then the varlist and restvar, then the GETTERFORM,
           ;; then the SETTERFORM.
           (LET ((LET-LIST (MAPCAR #'LIST TEMPS SUBFORMS)))
             (IF (AND ,@(mapcar #'(lambda (var) `(CONSTANTP ,var)) varlist)
                      ,@(when restvar `((EVERY #'CONSTANTP ,restvar))))
               ;; The varlist and restvar forms are constant forms, therefore
               ;; may be evaluated after the GETTER instead of before.
               (LET ((FUNCTION-APPLICATION
                       (LIST* ',function GETTERFORM ,@varlist ,restvar)))
                 (OPTIMIZED-WRAP-LET* ENV
                   (NCONC LET-LIST
                          (LIST (LIST (CAR STORES) FUNCTION-APPLICATION)))
                   SETTERFORM))
               ;; General case.
               (LET* ((ARGVARS
                        (MAPCAR #'(LAMBDA (VAR) (DECLARE (IGNORE VAR)) (GENSYM))
                                (LIST* ,@varlist ,restvar)))
                      (FUNCTION-APPLICATION
                        (LIST* ',function GETTERFORM ARGVARS)))
                 (OPTIMIZED-WRAP-LET* ENV
                   (NCONC LET-LIST
                          (MAPCAR #'LIST ARGVARS (LIST* ,@varlist ,restvar))
                          (LIST (LIST (CAR STORES) FUNCTION-APPLICATION)))
                   SETTERFORM)))))))))
;;;----------------------------------------------------------------------------
(define-modify-macro decf (&optional (delta 1)) -)
;;;----------------------------------------------------------------------------
(define-modify-macro incf (&optional (delta 1)) +)
;;;----------------------------------------------------------------------------
(defmacro setf (&whole whole-form
                &rest args &environment env)
  (let ((argcount (length args)))
    (cond ((eql argcount 2)
           (let* ((place (first args))
                  (value (second args)))
             (loop
               ;; 1st step: search for global SETF definitions:
               (when (and (consp place) (symbolp (car place)))
                 (when (global-in-fenv-p (car place) (svref env 1))
                   ;; operator not locally defined
                   (if (and (eq (first place) 'VALUES-LIST) (eql (length place) 2))
                     (return-from setf
                       `(VALUES-LIST
                          (SETF ,(second place) (MULTIPLE-VALUE-LIST ,value))))
                     (let ((plist-info (get (first place) 'SYSTEM::SETF-EXPANDER)))
                       (when plist-info
                         (return-from setf
                           (cond ((symbolp plist-info) ; Symbol comes from a short DEFSETF
                                  `(,plist-info ,@(cdr place) ,value))
                                 ((and (eq (first place) 'THE) (eql (length place) 3))
                                  `(SETF ,(third place) (THE ,(second place) ,value)))
                                 (t
                                  (multiple-value-bind (temps subforms stores setterform getterform)
                                      (get-setf-expansion place env)
                                    (declare (ignore getterform))
                                    (let ((bindlist (mapcar #'list temps subforms)))
                                      (if (= (length stores) 1)
                                        ;; 1 store variable
                                        (wrap-let* (nconc bindlist
                                                     (list `(,(first stores) ,value)))
                                          setterform)
                                        ;; multiple store variables
                                        (if ;; is setterform like
                                            ;; (VALUES (SETQ v1 store1) ...) ?
                                          (and (consp setterform)
                                               (eq (car setterform) 'VALUES)
                                               (do ((str stores (cdr str))
                                                    (sqr (cdr setterform) (cdr sqr)))
                                                   ((or (null str) (null sqr))
                                                    (and (null str) (null sqr)))
                                                 (unless (simple-assignment-p env (car sqr) (list (car str)))
                                                   (return nil))))
                                          (let ((vlist (mapcar #'second (rest setterform))))
                                            `(LET* ,bindlist
                                               (MULTIPLE-VALUE-SETQ ,vlist ,value)
                                               (VALUES ,@vlist)))
                                          (wrap-let* bindlist
                                            `(MULTIPLE-VALUE-BIND ,stores ,value
                                               ,setterform))))))))))))))
               ;; 2nd step: macroexpand
               (when (eq place (setq place (macroexpand-1 place env)))
                 (return)))
             ;; 3rd step: default SETF methods
             (cond ((symbolp place)
                    `(SETQ ,place ,value))
                   ((and (consp place) (symbolp (car place)))
                    (multiple-value-bind (temps subforms stores setterform getterform)
                        (get-setf-expansion place env)
                      (declare (ignore getterform))
                      ;; setterform probably looks like
                      ;;   `((SETF ,(first place)) ,@stores ,@temps).
                      ;; stores are probably superfluous and get optimized away.
                      (optimized-wrap-let* env
                        (nconc (mapcar #'list temps subforms)
                               (list (list (first stores) value)))
                        setterform)))
                   (t (error-of-type 'source-program-error
                        :form whole-form
                        :detail (first args)
                        (TEXT "~S: Illegal place: ~S")
                        'setf (first args))))))
          ((oddp argcount)
           (error-of-type 'source-program-error
             :form whole-form
             :detail whole-form
             (TEXT "~S called with an odd number of arguments: ~S")
             'setf whole-form))
          (t (do* ((arglist args (cddr arglist))
                   (L nil))
                  ((null arglist) `(LET () (PROGN ,@(nreverse L))))
               (push `(SETF ,(first arglist) ,(second arglist)) L))))))
;;;----------------------------------------------------------------------------
(defmacro shiftf (&whole whole-form
                  &rest args &environment env)
  (when (< (length args) 2)
    (error-of-type 'source-program-error
      :form whole-form
      :detail args
      (TEXT "~S: too few arguments: ~S")
      'shiftf whole-form))
  (do* ((arglist args (cdr arglist))
        (res (list 'LET* nil nil))
        last-setterform
        first-getterform
        (tail (cdr res))
        (bindlist '())
        (all-stores '())
        last-stores
        first-stores)
       ((null (cdr arglist))
        (setf (second res) (nreverse bindlist)
              (cadr tail) (list 'MULTIPLE-VALUE-BIND last-stores
                                (car (last args)) nil)
              tail (cddadr tail)
              (cdr tail) (nconc (nreverse all-stores)
                                (devalue-form last-setterform))
              (third res) (list 'MULTIPLE-VALUE-BIND first-stores
                                first-getterform (third res)
                                (cons 'values first-stores)))
        res)
    (multiple-value-bind (temps subforms stores setterform getterform)
        (get-setf-expansion (first arglist) env)
      (setq bindlist (nreconc (mapcar #'list temps subforms) bindlist))
      (if first-stores
        (setf all-stores (revappend (devalue-form last-setterform) all-stores)
              (cadr tail) (list 'MULTIPLE-VALUE-BIND last-stores getterform nil)
              tail (cddadr tail))
        (setq first-stores stores first-getterform getterform))
      (setq last-stores stores last-setterform setterform))))
;;;----------------------------------------------------------------------------
;;; more places
;;;----------------------------------------------------------------------------
(defsetf GET (symbol indicator &optional default) (value)
  (let ((storeform `(SYSTEM::%PUT ,symbol ,indicator ,value)))
    (if default
      `(PROGN ,default ,storeform) ; quasi-evaluate default, only feignedly
      `,storeform)))
;;;----------------------------------------------------------------------------
;;; Sets to a certain indicator a value into a given property list.
;;; Return NIL if successful, or the new (enhanced) property list.
(define-setf-expander getf (place indicator &optional default &environment env)
  (multiple-value-bind (temps subforms stores setterform getterform)
      (get-setf-method place env)
    (let* ((storevar (gensym "NEW-"))
           (indicatorvar (gensym "INDICATOR-"))
           (defaultvar-list (if default (list (gensym "IG")) `())))
      (values
        `(,@temps    ,indicatorvar ,@defaultvar-list)
        `(,@subforms ,indicator    ,@(if default `(,default) `()))
        `(,storevar)
        `(LET ((,(first stores)
                (SYS::%PUTF ,getterform ,indicatorvar ,storevar)))
           ,@defaultvar-list ; quasi-evalute defaultvar
           (WHEN ,(first stores) ,setterform)
           ,storevar)
        `(GETF ,getterform ,indicatorvar ,@defaultvar-list)))))
;;;----------------------------------------------------------------------------
(defsetf GETHASH (key hashtable &optional default) (value)
  (let ((storeform `(SYSTEM::PUTHASH ,key ,hashtable ,value)))
    (if default
      `(PROGN ,default ,storeform) ; quasi-evalute default
      `,storeform)))
;;;----------------------------------------------------------------------------
(defsetf fill-pointer SYSTEM::SET-FILL-POINTER)
;;;----------------------------------------------------------------------------
(defsetf readtable-case SYSTEM::SET-READTABLE-CASE)
;;;----------------------------------------------------------------------------
(defsetf SYMBOL-VALUE SYSTEM::SET-SYMBOL-VALUE)
(sys::%set-symbol-function 'SET #'SYSTEM::SET-SYMBOL-VALUE) ; deprecated alias
;;;----------------------------------------------------------------------------
(defsetf SYMBOL-FUNCTION SYSTEM::%SET-SYMBOL-FUNCTION)
;;;----------------------------------------------------------------------------
(defsetf SYMBOL-PLIST SYSTEM::%PUTPLIST)
;;;----------------------------------------------------------------------------
(defun SYSTEM::SET-FDEFINITION (name value) ; ABI
  (setf (symbol-function (get-funname-symbol name)) value))
(defsetf FDEFINITION SYSTEM::SET-FDEFINITION)
;;;----------------------------------------------------------------------------
(defsetf MACRO-FUNCTION (symbol &optional env) (value)
  (declare (ignore env))
  `(PROGN
     (SETF (SYMBOL-FUNCTION ,symbol) (SYSTEM::MAKE-MACRO ,value 0))
     (REMPROP ,symbol 'SYSTEM::MACRO)
     ,value))
;;;----------------------------------------------------------------------------
(defsetf CHAR SYSTEM::STORE-CHAR)
(defsetf SCHAR SYSTEM::STORE-SCHAR)
(defsetf BIT SYSTEM::STORE)
(defsetf SBIT SYSTEM::STORE)
(defsetf SUBSEQ (sequence start &optional end) (value)
  `(PROGN (REPLACE ,sequence ,value :START1 ,start :END1 ,end) ,value))
;;;----------------------------------------------------------------------------
(define-setf-expander char-bit (char name &environment env)
  (multiple-value-bind (temps subforms stores setterform getterform)
      (get-setf-method char env)
    (let* ((namevar (gensym))
           (storevar (gensym "NEW-")))
      (values `(,@temps    ,namevar)
              `(,@subforms ,name)
              `(,storevar)
              `(LET ((,(first stores)
                      (SET-CHAR-BIT ,getterform ,namevar ,storevar)))
                 ,setterform
                 ,storevar)
              `(CHAR-BIT ,getterform ,namevar)))))
;;;----------------------------------------------------------------------------
(define-setf-expander LDB (bytespec integer &environment env)
  (multiple-value-bind (temps subforms stores setterform getterform)
      (get-setf-method integer env)
    (let* ((bytespecvar (gensym "BYTESPEC-"))
           (storevar (gensym "NEW-")))
      (values (cons bytespecvar temps)
              (cons bytespec subforms)
              `(,storevar)
              `(LET ((,(first stores) (DPB ,storevar ,bytespecvar ,getterform)))
                 ,setterform
                 ,storevar)
              `(LDB ,bytespecvar ,getterform)))))
;;;----------------------------------------------------------------------------
(define-setf-expander MASK-FIELD (bytespec integer &environment env)
  (multiple-value-bind (temps subforms stores setterform getterform)
      (get-setf-method integer env)
    (let* ((bytespecvar (gensym "BYTESPEC-"))
           (storevar (gensym "NEW-")))
      (values (cons bytespecvar temps)
              (cons bytespec subforms)
              `(,storevar)
              `(LET ((,(first stores) (DEPOSIT-FIELD ,storevar ,bytespecvar ,getterform)))
                 ,setterform
                 ,storevar)
              `(MASK-FIELD ,bytespecvar ,getterform)))))
;;;----------------------------------------------------------------------------
(define-setf-expander THE (type place &environment env)
  (multiple-value-bind (temps subforms stores setterform getterform)
      (get-setf-expansion place env)
    (values temps subforms stores
            (sublis-in-form (mapcar #'(lambda (storevar simpletype)
                                        (cons storevar
                                              `(THE ,simpletype ,storevar)))
                                    stores
                                    (if (and (consp type)
                                             (eq (car type) 'VALUES))
                                      (cdr type)
                                      (list type)))
                            setterform)
            `(THE ,type ,getterform))))
;;;----------------------------------------------------------------------------
(define-setf-expander APPLY (&whole whole-form
                             fun &rest args &environment env)
  (if (and (listp fun)
           (eq (list-length fun) 2)
           (eq (first fun) 'FUNCTION)
           (symbolp (second fun)))
    (setq fun (second fun))
    (error-of-type 'source-program-error
      :form whole-form
      :detail fun
      (TEXT "~S is only defined for functions of the form #'symbol.")
      '(setf apply)))
  (multiple-value-bind (temps subforms stores setterform getterform)
      (get-setf-expansion (cons fun args) env)
    (unless (eq (car (last args)) (car (last subforms)))
      (error-of-type 'source-program-error
        :form whole-form
        :detail (cons fun args)
        (TEXT "~S on ~S is not a SETF place.")
        'apply fun))
    (let ((item (car (last temps)))) ; 'item' stands for an argument list!
      (labels ((splice (arglist)
                 ;; If we would want in (LIST . arglist) the 'item' not
                 ;; as one element, but spliced, as ',@item', so we
                 ;; would need the form, which returns (splice arglist).
                 (if (endp arglist)
                   'NIL
                   (let ((rest (splice (cdr arglist))))
                     (if (eql (car arglist) item)
                       ;; push an (APPEND item ...) to the front, as
                       ;; with backquote
                       (backquote-append item rest)
                       ;; push a (CONS (car arglist) ...) to the front,
                       ;; as with backquote
                       (backquote-cons (car arglist) rest))))))
        (flet ((call-splicing (form)
                 ;; replaces the function call form with one, where 'item'
                 ;; does not return one argument, but an argument list.
                 (let ((fun (first form))
                       (argform (splice (rest form))))
                   ;; (APPLY #'fun argform) simplified:
                   ;; (APPLY #'fun NIL) --> (fun)
                   ;; (APPLY #'fun (LIST ...)) --> (fun ...)
                   ;; (APPLY #'fun (CONS x y)) --> (APPLY #'fun x y)
                   ;; (APPLY #'fun (LIST* ... z)) --> (APPLY #'fun ... z)
                   (if (or (null argform)
                           (and (consp argform) (eq (car argform) 'LIST)))
                     (cons fun (cdr argform))
                     (list* 'APPLY
                            (list 'FUNCTION fun)
                            (if (and (consp argform)
                                     (or (eq (car argform) 'LIST*)
                                         (eq (car argform) 'CONS)))
                              (cdr argform)
                              (list argform)))))))
          (values temps subforms stores
                  (call-splicing setterform)
                  (call-splicing getterform)))))))
;;;----------------------------------------------------------------------------
;;; More places definitions
;;;----------------------------------------------------------------------------
(define-setf-expander funcall (&whole whole-form
                               fun &rest args &environment env)
  (unless (and (listp fun)
               (eq (list-length fun) 2)
               (let ((fun1 (first fun)))
                 (or (eq fun1 'FUNCTION) (eq fun1 'QUOTE)))
               (symbolp (second fun))
               (setq fun (second fun)))
    (error-of-type 'source-program-error
      :form whole-form
      :detail (cons fun args)
      (TEXT "~S is only defined for functions of the form #'symbol.")
      '(setf funcall)))
  (get-setf-expansion (cons fun args) env))
;;;----------------------------------------------------------------------------
(define-setf-expander PROGN (&rest forms &environment env)
  (let ((last (last forms)))
    (multiple-value-bind (temps subforms stores setterform getterform)
        (get-setf-expansion (car last) env)
      (if (eq forms last)
        (values temps subforms stores setterform getterform)
        (let ((dummyvar (gensym "IG")))
          (values
            `(,dummyvar                    ,@temps)
            `((PROGN ,@(ldiff forms last)) ,@subforms)
            stores
            `(PROGN
               ,dummyvar ; avoid warning about unused temporary variable
               ,setterform)
            getterform))))))
;;;----------------------------------------------------------------------------
(define-setf-expander LOCALLY (&rest body &environment env)
  (multiple-value-bind (body-rest declspecs) (system::parse-body body)
    (multiple-value-bind (temps subforms stores setterform getterform)
        (get-setf-expansion `(PROGN ,@body-rest) env)
      (if declspecs
        (let ((declarations `(DECLARE ,@declspecs)))
          (values
            temps
            (mapcar #'(lambda (x) `(LOCALLY ,declarations ,x)) subforms)
            stores
           `(LOCALLY ,declarations ,setterform)
           `(LOCALLY ,declarations ,getterform)))
        (values temps subforms stores setterform getterform)))))
;;;----------------------------------------------------------------------------
(define-setf-expander IF (&whole whole-form
                          condition t-form f-form &environment env)
  (let ((conditionvar (gensym "COND-")))
    (multiple-value-bind (T-temps T-subforms T-stores T-setterform T-getterform)
        (get-setf-expansion t-form env)
      (multiple-value-bind (F-temps F-subforms F-stores F-setterform F-getterform)
          (get-setf-expansion f-form env)
        (unless (eql (length T-stores) (length F-stores))
          (error-of-type 'source-program-error
            :form whole-form
            :detail whole-form
            (TEXT "SETF place ~S expects different numbers of values in the true and false branches (~D vs. ~D values).")
            (list 'IF condition t-form f-form) (length T-stores)
            (length F-stores)))
        (values
          `(,conditionvar
            ,@T-temps
            ,@F-temps)
          `(,condition
            ,@(mapcar #'(lambda (x) `(IF ,conditionvar ,x)) T-subforms)
            ,@(mapcar #'(lambda (x) `(IF (NOT ,conditionvar) ,x)) F-subforms))
          T-stores
          `(IF ,conditionvar ,T-setterform
               ,(sublis-in-form (mapcar #'cons F-stores T-stores) F-setterform))
          `(IF ,conditionvar ,T-getterform ,F-getterform))))))
;;;----------------------------------------------------------------------------
(defsetf GET-DISPATCH-MACRO-CHARACTER
         (disp-char sub-char &optional (readtable '*READTABLE*)) (value)
  `(PROGN (SET-DISPATCH-MACRO-CHARACTER ,disp-char ,sub-char ,value ,readtable) ,value))
;;;----------------------------------------------------------------------------
(def-setf-alias long-float-digits SYSTEM::|(SETF LONG-FLOAT-DIGITS)|)
;;;----------------------------------------------------------------------------
(defsetf system::%record-ref system::%record-store)
(defsetf system::%structure-ref system::%structure-store)
(defsetf system::closure-const (closure n) (value)
  `(system::set-closure-const ,value ,closure ,n))
;;;----------------------------------------------------------------------------
(def-setf-alias clos::standard-instance-access CLOS::|(SETF STANDARD-INSTANCE-ACCESS)|)
;;;----------------------------------------------------------------------------
(def-setf-alias system::closure-name SYSTEM::|(SETF CLOSURE-NAME)|)
;;;----------------------------------------------------------------------------
#+LOGICAL-PATHNAMES
(defsetf logical-pathname-translations set-logical-pathname-translations)
;;;----------------------------------------------------------------------------
(defsetf stream-external-format (stream &optional direction) (encoding)
  `(system::set-stream-external-format ,stream ,encoding ,direction))
;;;----------------------------------------------------------------------------
;;; How to handle (SETF (VALUES place1 ... placek) form)
;;; --> (MULTIPLE-VALUE-BIND (dummy1 ... dummyk) form
;;;       (SETF place1 dummy1 ... placek dummyk)
;;;       (VALUES dummy1 ... dummyk)
;;;)
(define-setf-expander values (&rest subplaces &environment env)
  (multiple-value-bind (temps subforms stores setterforms getterforms)
      (setf-VALUES-aux subplaces env)
    (values temps
            subforms
            stores
            `(VALUES ,@setterforms)
            `(VALUES ,@getterforms))))
(defun setf-VALUES-aux (places env)
  (do ((temps nil)
       (subforms nil)
       (stores nil)
       (setterforms nil)
       (getterforms nil)
       (placesr places))
      ((endp placesr)
       (setq temps (nreverse temps))
       (setq subforms (nreverse subforms))
       (setq stores (nreverse stores))
       (setq setterforms (nreverse setterforms))
       (setq getterforms (nreverse getterforms))
       (values temps subforms stores setterforms getterforms))
    (multiple-value-bind (SM-temps SM-subforms SM-stores SM-setterform
                          SM-getterform)
        (get-setf-expansion (pop placesr) env)
      (setq temps (revappend SM-temps temps))
      (setq subforms (revappend SM-subforms subforms))
      (dolist (extra-store (rest SM-stores)) ; See ANSI CL 5.1.2.3.
        (push extra-store temps)
        (push 'NIL subforms))
      ;; even if subform sets no values [e.g., (setf (values (values) .) .) ]
      ;; it should consume one assigned value
      (setq stores (cons (or (first SM-stores) (gensym "NEW-")) stores))
      (setq setterforms (cons SM-setterform setterforms))
      (setq getterforms (cons SM-getterform getterforms)))))
;;;----------------------------------------------------------------------------
;;; Analog to (MULTIPLE-VALUE-SETQ (var1 ... vark) form) :
;;; (MULTIPLE-VALUE-SETF (place1 ... placek) form)
;;; --> (VALUES (SETF (VALUES place1 ... placek) form))
;;; --> (MULTIPLE-VALUE-BIND (dummy1 ... dummyk) form
;;;       (SETF place1 dummy1 ... placek dummyk)
;;;       dummy1
;;;)
(defmacro multiple-value-setf (places form &environment env)
  (multiple-value-bind (temps subforms stores setterforms getterforms)
      (setf-VALUES-aux places env)
    (declare (ignore getterforms))
    (wrap-let* (mapcar #'list temps subforms)
      `(MULTIPLE-VALUE-BIND ,stores ,form
         ,@setterforms
         ,(first stores))))) ; (null stores) -> NIL -> Return value NIL
;;;----------------------------------------------------------------------------
;;;                              Symbol-macros
(define-symbol-macro *ansi* (sys::ansi))
(defsetf sys::ansi sys::set-ansi)
(system::%set-documentation '*ansi* 'variable
 "This symbol-macro modifies some variables for maximum ANSI CL compliance.
Variables affected: `custom:*floating-point-contagion-ansi*',
 `custom:*floating-point-rational-contagion-ansi*', `custom:*phase-ansi*',
 `custom:*merge-pathnames-ansi*', `custom:*print-pathnames-ansi*',
 `custom:*print-space-char-ansi*', `custom:*parse-namestring-ansi*',
 `custom:*print-empty-arrays-ansi*', `custom:*print-unreadable-ansi*',
 `custom:*sequence-count-ansi*', `custom:*coerce-fixnum-char-ansi*',
 `custom:*defun-accept-specialized-lambda-list*', `custom:*loop-ansi*'.
Invoking CLISP with `-ansi' sets this to T.
Invoking CLISP with `-traditional' sets this to NIL.")

(define-symbol-macro *current-language* (sys::current-language))
(defsetf sys::current-language sys::set-current-language)
(system::%set-documentation '*current-language* 'variable
 "This symbol-macro determines the current language used for UI.")

(define-symbol-macro *lib-directory* (sys::lib-directory))
(defsetf sys::lib-directory sys::set-lib-directory)
(system::%set-documentation '*lib-directory* 'variable
 "This symbol-macro determines the location where CLISP finds its data files.")

(define-symbol-macro *default-file-encoding*
  (system::default-file-encoding))
(defsetf system::default-file-encoding system::set-default-file-encoding)
#+UNICODE
(progn
  (define-symbol-macro *pathname-encoding* (system::pathname-encoding))
  (defsetf system::pathname-encoding system::set-pathname-encoding)
  (define-symbol-macro *terminal-encoding* (system::terminal-encoding))
  (defsetf system::terminal-encoding system::set-terminal-encoding)
  (define-symbol-macro *misc-encoding* (system::misc-encoding))
  (defsetf system::misc-encoding system::set-misc-encoding))
(when (fboundp 'sys::setenv)
  (defsetf ext:getenv sys::setenv))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./places.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./macros3.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(in-package "EXT")
(export '(ethe letf letf* with-collect compiled-file-p compile-time-value
          canonicalize))
(in-package "SYSTEM")
;;; ---------------------------------------------------------------------------
;;; Wie THE, nur dass auch im compilierten Code der Typtest durchgefhrt wird.
(defmacro ethe (typespec form)
  (let ((g (gensym "VALUES-")))
    `(THE ,typespec
       (LET ((,g (MULTIPLE-VALUE-LIST ,form)))
         (IF (SYS::%THE ,g ',(type-for-discrimination typespec))
           (VALUES-LIST ,g)
           (ERROR-OF-TYPE 'ERROR ; 'TYPE-ERROR ??
             (TEXT "The form ~S yielded ~:[no values~;~:*~{~S~^ ; ~}~] ,~@
                       that's not of type ~S.")
             ',form ,g ',typespec
) )  ) ) ) )
;;; ---------------------------------------------------------------------------
; Macro LETF / LETF* wie LET, LET*, nur dass als "Variable" beliebige Places
; (wie bei SETF) zugelassen sind, inklusive VALUES, VALUES-LIST.

; (LETF ((A form)) ...) --> (LET ((A form)) ...)

; (LETF (((CAR A) form)) ...)
;   --> (LET* ((#:G1 A)
;              (#:G2 (CAR #:G1))
;              (#:G3 form))
;         (UNWIND-PROTECT
;           (PROGN (SYSTEM::%RPLACA #:G1 #:G3) ...)
;           (SYSTEM::%RPLACA #:G1 #:G2)
;       ) )

; (LETF (((VALUES A B) form)) ...) --> (MULTIPLE-VALUE-BIND (A B) form ...)

; (LETF (((VALUES (CAR A) (CDR B)) form)) ...)
;   --> (LET* ((#:G1 A)
;              (#:G2 (CAR #:G1))
;              (#:G3 B)
;              (#:G4 (CDR #:G3)))
;         (MULTIPLE-VALUE-BIND (#:G5 #:G6) form
;           (UNWIND-PROTECT
;             (PROGN (SYSTEM::%RPLACA #:G1 #:G5) (SYSTEM::%RPLACD #:G3 #:G6)
;                    ...
;             )
;             (SYSTEM::%RPLACA #:G1 #:G2) (SYSTEM::%RPLACA #:G3 #:G4)
;       ) ) )

; (LETF (((VALUES-LIST A) form)) ...)
;   --> (LET ((A (MULTIPLE-VALUE-LIST form))) ...)

(defmacro LETF* (&whole whole-form
                 bindlist &body body &environment env)
  (multiple-value-bind (body-rest declarations) (SYSTEM::PARSE-BODY body)
    (let ((declare (if declarations `((DECLARE ,@declarations)) '())))
      (values (expand-LETF* bindlist declare body-rest whole-form env)))))

; expandiert ein LETF*, liefert die Expansion und
; T, falls diese Expansion mit einem LET* anfngt, dessen Bindungsliste
; erweitert werden darf.
(defun expand-LETF* (bindlist declare body whole-form env)
  (if (atom bindlist)
    (if bindlist
      (error-of-type 'source-program-error
        :form whole-form
        :detail bindlist
        (TEXT "LETF* code contains a dotted list, ending with ~S")
        bindlist
      )
      (values `(LET* () ,@declare ,@body) t)
    )
    (let ((bind (car bindlist)) place form)
      (if (atom bind)
        (setq place bind form nil)
        (if (and (consp (cdr bind)) (null (cddr bind)))
          (progn
            (setq place (car bind) form (cadr bind))
            (when (and (consp place) (eq (car place) 'VALUES-LIST) (eql (length place) 2))
              (setq place (second place) form `(MULTIPLE-VALUE-LIST ,form))
            )
            (loop
              (if (and (consp place) (eq (car place) 'THE) (eql (length place) 3))
                (setq place (third place) form `(THE ,(second place) ,form))
                (return)
          ) ) )
          (illegal-syntax bind 'LETF* whole-form)))
      (multiple-value-bind (rest-expanded flag)
          (expand-LETF* (cdr bindlist) declare body whole-form env)
        (if (and (atom place)
                 (not (and (symbolp place) (nth-value 1 (macroexpand-1 place env))))
            )
          (values
            (if flag
              `(LET* ,(cons (list place form) (cadr rest-expanded))
                 ,@(cddr rest-expanded)
               )
              `(LET* ((,place ,form)) ,@declare ,rest-expanded)
            )
            t
          )
          (if (and (consp place) (eq (car place) 'VALUES))
            (if (every #'(lambda (subplace)
                           (and (symbolp subplace)
                                (not (nth-value 1 (macroexpand-1 subplace env)))
                         ) )
                       place)
              (values
                `(MULTIPLE-VALUE-BIND ,(cdr place) ,form ,@declare ,rest-expanded)
                nil
              )
              (values
                (do ((bindlist nil)
                     (storetemps nil)
                     (stores1 nil)
                     (stores2 nil)
                     (subplacesr (cdr place)))
                    ((atom subplacesr)
                     `(LET* ,(nreverse bindlist)
                        ,@declare
                        (MULTIPLE-VALUE-BIND ,(nreverse storetemps) ,form
                          ,@declare
                          (UNWIND-PROTECT
                            (PROGN ,@(nreverse stores1) ,rest-expanded)
                            ,@(nreverse stores2)
                    ) ) ) )
                  (multiple-value-bind (SM-temps SM-subforms SM-stores SM-setterform SM-getterform)
                      (get-setf-method (pop subplacesr) env)
                    (setq bindlist
                      (cons (list (first SM-stores) SM-getterform)
                            (nreconc (mapcar #'list SM-temps SM-subforms) bindlist)
                    ) )
                    (let ((storetemp (gensym "LETF*-")))
                      (setq storetemps (cons storetemp storetemps))
                      ; We can use subst-in-form here, because storetemp is just a variable reference.
                      (setq stores1 (cons (subst-in-form storetemp (first SM-stores) SM-setterform) stores1))
                    )
                    (setq stores2 (cons SM-setterform stores2))
                ) )
                t
            ) )
            (multiple-value-bind (SM-temps SM-subforms SM-stores SM-setterform SM-getterform)
                (get-setf-method place env)
              (let ((formvar (gensym "LETF*-VALUE-")))
                (values
                  `(LET* (,.(mapcar #'list SM-temps SM-subforms)
                          (,(first SM-stores) ,SM-getterform)
                          (,formvar ,form))
                     ,@declare
                     (UNWIND-PROTECT
                       ; We can use subst-in-form here, because formvar is just a variable reference.
                       (PROGN ,(subst-in-form formvar (first SM-stores) SM-setterform) ,rest-expanded)
                       ,SM-setterform
                   ) )
                  t
            ) ) )
) ) ) ) ) )

(defmacro LETF (&whole whole-form
                bindlist &body body &environment env)
  (multiple-value-bind (body-rest declarations) (SYSTEM::PARSE-BODY body)
    (let ((declare (if declarations `((DECLARE ,@declarations)) '()))
          (let-list nil))
      (multiple-value-bind (let*-list let/let*-list uwp-store1 uwp-store2)
          (expand-LETF bindlist whole-form env)
        ; mehrfach folgendes anwenden:
        ; endet let*-list mit (#:G form) und kommt in let/let*-list (var #:G)
        ; vor, so drfen beide gestrichen werden, und dafr kommt (var form)
        ; an den Anfang von let-list.
        (setq let*-list (nreverse let*-list))
        (loop
          (unless (and (consp let*-list)
                       (let ((last (caar let*-list)))
                         (and (symbolp last) (null (symbol-package last))
                              (dolist (bind let/let*-list nil)
                                (when (eq (second bind) last)
                                  (push (list (first bind) (second (car let*-list)))
                                        let-list
                                  )
                                  (setq let/let*-list
                                    (delete last let/let*-list :key #'second
                                            :test #'eq :count 1
                                  ) )
                                  (setq let*-list (cdr let*-list))
                                  (return t)
                  )    ) )    ) )
            (return)
        ) )
        (setq let*-list (nreverse let*-list))
        ; Nun muss folgendes gemacht werden:
        ; 1. Die Bindungen von let*-list mit LETF* aktivieren,
        ; 2. die Bindungen von let-list mit LET aktivieren,
        ; 3. in beliebiger Reihenfolge:
        ;    a. die Bindungen von let/let*-list mit LET oder LET* aktivieren,
        ;    b. die Bindungen von uwp-store1 mit UNWIND-PROTECT aktivieren
        ;       und danach mit uwp-store2 deaktivieren.
        ; Beispielsweise:
#|      `(LETF* ,let*-list
           ,@declare
           (LET ,let-list
             ,@declare
             (LET* ,let/let*-list
               ,@declare
               `(UNWIND-PROTECT (PROGN ,@uwp-store1 ,@body-rest) ,@uwp-store2)
         ) ) )
|#
        (let ((body body-rest) ; eine Formenliste ohne Deklarationen
              (1form nil)) ; zeigt an, ob body aus einer einzigen Form besteht
          (when uwp-store1
            (unless body (setq body '(nil)))
            (setq body `((UNWIND-PROTECT (PROGN ,@uwp-store1 ,@body) ,@uwp-store2))
                  1form t
          ) )
          (when let/let*-list
            (setq body `((LET* ,let/let*-list ,@declare ,@body)) 1form t)
          )
          (when let-list
            (setq body `((LET ,let-list ,@declare ,@body)) 1form t)
          )
          (when let*-list
            (setq body `((LETF* ,let*-list ,@declare ,@body)) 1form t)
          )
          (if (and 1form (or (null declare) (not (eq (caar body) 'unwind-protect))))
            ; eine Form, keine Deklarationen oder fngt mit letf*/let/let* an
            (car body)
            ; allgemein
            `(LET () ,@declare (PROGN ,@body))
) ) ) ) ) )

; expandiert ein LETF, liefert:
; 1. eine Bindungsliste fr LETF*,
; 2. eine Bindungsliste fr LET/LET* (Reihenfolge der Bindung darin beliebig),
; 3. eine Liste von Bindungsanweisungen,
; 4. eine Liste von Entbindungsanweisungen
; (beide gleich lang).
(defun expand-LETF (bindlist whole-form env)
  (if (atom bindlist)
    (if bindlist
      (error-of-type 'source-program-error
        :form whole-form
        :detail bindlist
        (TEXT "LETF code contains a dotted list, ending with ~S")
        bindlist
      )
      (values '() '() '() '())
    )
    (let ((bind (car bindlist)) place form)
      (if (atom bind)
        (setq place bind form nil)
        (if (and (consp (cdr bind)) (null (cddr bind)))
          (progn
            (setq place (car bind) form (cadr bind))
            (when (and (consp place) (eq (car place) 'VALUES-LIST) (eql (length place) 2))
              (setq place (second place) form `(MULTIPLE-VALUE-LIST ,form))
            )
            (loop
              (if (and (consp place) (eq (car place) 'THE) (eql (length place) 3))
                (setq place (third place) form `(THE ,(second place) ,form))
                (return)
          ) ) )
          (illegal-syntax bind 'LETF whole-form)))
      (multiple-value-bind (L1 L2 L3 L4) (expand-LETF (cdr bindlist) whole-form env)
        (if (and (atom place)
                 (not (and (symbolp place) (nth-value 1 (macroexpand-1 place env))))
            )
          (let ((g (gensym)))
            (values (cons (list g form) L1) (cons (list place g) L2) L3 L4)
          )
          (if (and (consp place) (eq (car place) 'VALUES))
            (if (every #'(lambda (subplace)
                           (and (symbolp subplace)
                                (not (nth-value 1 (macroexpand-1 subplace env)))
                         ) )
                       place)
              (let ((gs (mapcar #'(lambda (subplace)
                                    (gensym (symbol-name subplace))
                                  )
                                (cdr place)
                   ))   )
                (values
                  (cons (list (cons 'VALUES gs) form) L1)
                  (nconc (mapcar #'list (cdr place) gs) L2)
                  L3
                  L4
              ) )
              (do ((bindlist nil)
                   (storetemps nil)
                   (stores1 nil)
                   (stores2 nil)
                   (subplacesr (cdr place)))
                  ((atom subplacesr)
                   (values
                     (nreconc bindlist
                              (cons (list (cons 'VALUES (nreverse storetemps)) form) L1)
                     )
                     L2
                     (nreconc stores1 L3)
                     (nreconc stores2 L4)
                  ))
                (multiple-value-bind (SM-temps SM-subforms SM-stores SM-setterform SM-getterform)
                    (get-setf-method (pop subplacesr) env)
                  (setq bindlist
                    (cons (list (first SM-stores) SM-getterform)
                          (nreconc (mapcar #'list SM-temps SM-subforms) bindlist)
                  ) )
                  (let ((storetemp (gensym "LETF-")))
                    (setq storetemps (cons storetemp storetemps))
                    ; We can use subst-in-form here, because storetemp is just a variable reference.
                    (setq stores1 (cons (subst-in-form storetemp (first SM-stores) SM-setterform) stores1))
                  )
                  (setq stores2 (cons SM-setterform stores2))
            ) ) )
            (multiple-value-bind (SM-temps SM-subforms SM-stores SM-setterform SM-getterform)
                (get-setf-method place env)
              (let ((g (gensym "LETF-VALUE-")))
                (values
                  `(,.(mapcar #'list SM-temps SM-subforms)
                    (,(first SM-stores) ,SM-getterform)
                    (,g ,form)
                    . ,L1)
                  L2
                  ; We can use subst-in-form here, because g is just a variable reference.
                  (cons (subst-in-form g (first SM-stores) SM-setterform) L3)
                  (cons SM-setterform L4)
            ) ) )
) ) ) ) ) )

;;; ---------------------------------------------------------------------------
(defmacro with-collect ((&rest collectors) &body forms)
  "Evaluate forms, collecting objects into lists.
Within the FORMS, you can use local macros listed among collectors,
they are returned as multiple values.
E.g., (with-collect (c1 c2) (dotimes (i 10) (if (oddp i) (c1 i) (c2 i))))
 ==> (1 3 5 7 9); (0 2 4 6 8) [2 values]
In CLISP, push/nreverse is about 1.25 times as fast as pushing into the
tail, so this macro uses push/nreverse on CLISP and push into the tail
on other lisps (which is 1.5-2 times as fast as push/nreverse there)."
  #+clisp
  (let ((ret (mapcar (lambda (cc) (gensym (format nil "~:@(~s~)-RET-" cc)))
                     collectors)))
    `(let (,@ret)
      (declare (list ,@ret))
      (macrolet ,(mapcar (lambda (co re) `(,co (form) `(push ,form ,',re)))
                         collectors ret)
        ,@forms
        (values ,@(mapcar (lambda (re) `(sys::list-nreverse ,re)) ret)))))
  #-clisp
  (let ((ret (mapcar (lambda (cc) (gensym (format nil "~:@(~s~)-RET-" cc)))
                     collectors))
        (tail (mapcar (lambda (cc) (gensym (format nil "~:@(~s~)-TAIL-" cc)))
                      collectors))
        (tmp (mapcar (lambda (cc) (gensym (format nil "~:@(~s~)-TMP-" cc)))
                     collectors)))
    `(let (,@ret ,@tail)
      (declare (list ,@ret ,@tail))
      (macrolet ,(mapcar (lambda (co re ta tm)
                           `(,co (form)
                             `(let ((,',tm (list ,form)))
                               (if ,',re (setf (cdr ,',ta) (setf ,',ta ,',tm))
                                   (setf ,',re (setf ,',ta ,',tm))))))
                         collectors ret tail tmp)
        ,@forms
        (values ,@ret)))))

;;; ---------------------------------------------------------------------------
(defun compiled-file-p (file-name)
  "Return non-NIL if FILE-NAME names a CLISP-compiled file
with compatible bytecodes."
  (with-open-file (in file-name :direction :input :if-does-not-exist nil)
    (handler-bind ((error (lambda (c) (declare (ignore c))
                                  (return-from compiled-file-p nil))))
      (and in (char= #\( (peek-char nil in nil #\a))
           (let ((form (read in nil nil)))
             (and (consp form)
                  (eq (car form) 'SYSTEM::VERSION)
                  (null (eval form))))))))

;;; ---------------------------------------------------------------------------
;;; http://groups.google.com/group/comp.lang.lisp/browse_thread/thread/7fda163e5e8194f2/65564bd5e2810f01
(defmacro compile-time-value (expression)
  "Evaluate the EXPRESSION at compile time, writing the value into the FAS file."
  (declare (ignore expression))
  () ; see compiler.lisp:c-COMPILE-TIME-VALUE
  #+(or) ;; the gensym result leaks into the *.lib and *.fas files
  (let ((result (gensym "COMPILE-TIME-VALUE-")))
    `(let ((,result nil))
       (declare (special ,result))
       (eval-when (compile)
         (setq ,result `',(eval ',expression)))
       (eval-when (compile load eval)
         (macrolet ((ctv () ,result))
           (eval-when (load eval) (ctv)))))))

;;; ---------------------------------------------------------------------------
(defun canonicalize (value functions &key (test 'eql) (max-iter 1024))
  "Call FUNCTIONS on VALUE until it stabilizes according to TEST.
TEST should be a avalid HASH-TABLE-TEST.
MAX-ITER limits the number of iteration over the FUNCTIONS (defaults to 1024).
Returns the canonicalized value and the number of iterations it required."
  (if functions
      (let ((ht (make-hash-table :test test)) (prev value) next (count 0))
        (setf (gethash value ht) 0)
        (loop (setq next (reduce (lambda (v f) (funcall f v)) functions
                                 :initial-value prev))
          (when (funcall test next prev) (return (values next count)))
          (let ((old (gethash next ht)))
            (when old
              (error "~S(~S ~S): circular computation: value ~S appears at steps ~:D and ~:D" 'canonicalize value functions next old (1+ count))))
          (when (and max-iter (= count max-iter))
            (error "~S(~S ~S): maximum number of iterations exceeded ~:D, last two values were ~S and ~S" 'canonicalize value functions max-iter prev next))
          (setq prev next)
          (setf (gethash next ht) (incf count))))
      value))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./macros3.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./macros2.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(common-lisp:in-package "SYSTEM")
;; ----------------------------------------------------------------------------
(defmacro typecase (&whole whole-form
                    keyform &rest typeclauselist)
  (let* ((tempvar (gensym "TYPECASE-KEY-"))
         (condclauselist nil))
    (do ((typeclauselistr typeclauselist (cdr typeclauselistr)) spec)
        ((atom typeclauselistr))
      (cond ((atom (car typeclauselistr))
             (error-of-type 'source-program-error
               :form whole-form
               :detail (car typeclauselistr)
               (TEXT "Invalid clause in ~S: ~S")
               'typecase (car typeclauselistr)))
            ((eq (setq spec (caar typeclauselistr)) T)
             (push `(T ,@(or (cdar typeclauselistr) '(NIL))) condclauselist)
             (return))
            ((and (atom (cdr typeclauselistr)) (eq spec 'OTHERWISE))
             (push `(T ,@(or (cdar typeclauselistr) '(NIL))) condclauselist))
            (t (push `((TYPEP ,tempvar (QUOTE ,spec))
                       ,@(or (cdar typeclauselistr) '(NIL)))
                     condclauselist))))
    `(LET ((,tempvar ,keyform)) (COND ,@(nreverse condclauselist)))))
;; ----------------------------------------------------------------------------
(defun type-error-string () ; ABI
  (TEXT "~A~%The value is: ~S"))
(defun check-type-error-string (place string typespec) ; ABI
  (format nil
    (TEXT "The value of ~S should be ~:[of type ~S~;~:*~A~].")
    place string typespec))
(defun report-one-new-value-string () ; ABI
  (TEXT "Input a new value for ~S."))
(defun report-one-new-value-string-instead ()
  (TEXT "Input a value to be used instead~@[ of ~S~]."))
(defun prompt-for-new-value-string () ; ABI
  (concatenate 'string "~&" (TEXT "New ~S") (prompt-finish)))
(predefmacro check-type (place typespec &optional (string nil))
  (let ((tag1 (gensym "CHECK-TYPE-"))
        (tag2 (gensym "OK-")))
    `(TAGBODY
       ,tag1
       (WHEN (TYPEP ,place ',typespec) (GO ,tag2))
       (CERROR (REPORT-ONE-NEW-VALUE-STRING)
         (TYPE-ERROR-STRING)
         (CHECK-TYPE-ERROR-STRING ',place ,string ',typespec)
         ,place)
       (FORMAT *QUERY-IO* (PROMPT-FOR-NEW-VALUE-STRING) ',place)
       (SETF ,place (READ *QUERY-IO*))
       (GO ,tag1)
       ,tag2)))
;; ----------------------------------------------------------------------------
(defun report-no-new-value-string () ; ABI
  (TEXT "Retry"))
(defun report-new-values-string () ; ABI
  (TEXT "Input new values for ~@{~S~^, ~}."))
(defun assert-error-string (test-form) ; ABI
  (format nil
    (TEXT "~S must evaluate to a non-NIL value.")
    test-form))
(predefmacro assert (test-form &optional (place-list nil) (string nil) &rest args)
  (let ((tag1 (gensym "ASSERT-"))
        (tag2 (gensym "OK-")))
    `(TAGBODY
       ,tag1
       (WHEN ,test-form (GO ,tag2))
       (CERROR ,(case (length place-list)
                  (0 `(REPORT-NO-NEW-VALUE-STRING))
                  (1 `(APPLY #'FORMAT NIL (REPORT-ONE-NEW-VALUE-STRING) ',place-list))
                  (t `(APPLY #'FORMAT NIL (REPORT-NEW-VALUES-STRING) ',place-list)))
               ',(or string "~A")
               ,@(if string
                   args
                   (list `(ASSERT-ERROR-STRING ',test-form))))
       ,@(mapcan
           #'(lambda (place)
               (list `(FORMAT *QUERY-IO* (PROMPT-FOR-NEW-VALUE-STRING) ',place)
                     `(SETF ,place (READ *QUERY-IO*))))
           place-list)
       (GO ,tag1)
       ,tag2)))
;; ----------------------------------------------------------------------------
(defun typecase-error-string (keyform typelist) ; ABI
  (format nil
    (TEXT "The value of ~S must be of one of the types ~{~S~^, ~}")
    keyform typelist))
(defun case-error-string (keyform caselist) ; ABI
  (format nil
    (TEXT "The value of ~S must be one of ~{~S~^, ~}")
    keyform caselist))

;;; Exhaustive Case Analysis

;; These macros are superseded by the corresponding ones from condition.lisp
;; when the condition system is available.

(flet ((parenthesize-keys (clauses)
         ;; PARENTHESIZE-KEYS is necessary to avoid confusing
         ;; the symbols OTHERWISE and T used as keys, with the same
         ;; symbols used in the syntax of the non exhaustive CASE.
         (mapcar #'(lambda (c)
                     (cond ((or (eq (car c) 't)
                                (eq (car c) 'otherwise))
                            (warn (TEXT "~S used as a key in ~S, it would be better to use parentheses.")
                                  (car c) c)
                            (cons (list (car c)) (cdr c)))
                           (t c)))
                 clauses))
       (case-list (clause-list)
         (mapcap #'(lambda (key-clause)
                     (setq key-clause (car key-clause))
                     (if (listp key-clause) key-clause (list key-clause)))
                 clause-list)))
  (flet ((typecase-errorstring (keyform keyclauselist)
           (let ((typelist (mapcar #'first keyclauselist)))
             `(TYPECASE-ERROR-STRING ',keyform ',typelist)))
         (typecase-expected-type (keyclauselist)
           `(OR ,@(mapcar #'first keyclauselist)))
         (case-errorstring (keyform keyclauselist)
           (let ((caselist (case-list keyclauselist)))
             `(CASE-ERROR-STRING ',keyform ',caselist)))
         (case-expected-type (keyclauselist)
           `(MEMBER ,@(case-list keyclauselist)))
         (simply-error (casename form clauselist errorstring expected-type)
           (let ((var (gensym)))
             `(LET ((,var ,form))
                (,casename ,var
                  ,@(parenthesize-keys clauselist)
                  (OTHERWISE
                    (ERROR-OF-TYPE 'TYPE-ERROR
                      :DATUM ,var :EXPECTED-TYPE ',expected-type
                      (TYPE-ERROR-STRING)
                      ,errorstring ,var))))))
         (retry-loop (casename place clauselist errorstring)
           (let ((g (gensym))
                 (h (gensym)))
             `(BLOCK ,g
                (TAGBODY
                  ,h
                  (RETURN-FROM ,g
                    (,casename ,place
                      ,@(parenthesize-keys clauselist)
                      (OTHERWISE
                        (CERROR (REPORT-ONE-NEW-VALUE-STRING)
                                (TYPE-ERROR-STRING)
                                ,errorstring
                                ,place)
                        (FORMAT *QUERY-IO* (PROMPT-FOR-NEW-VALUE-STRING)
                                ',place)
                        (SETF ,place (READ *QUERY-IO*))
                        (GO ,h)))))))))
    (predefmacro etypecase (keyform &rest keyclauselist)
      (if (assoc t keyclauselist)
          `(typecase ,keyform ,@keyclauselist)
          (simply-error 'TYPECASE keyform keyclauselist
                        (typecase-errorstring keyform keyclauselist)
                        (typecase-expected-type keyclauselist))))
    (predefmacro ctypecase (keyplace &rest keyclauselist)
      (if (assoc t keyclauselist)
          `(typecase ,keyplace ,@keyclauselist)
          (retry-loop 'TYPECASE keyplace keyclauselist
                      (typecase-errorstring keyplace keyclauselist))))
    (predefmacro ecase (keyform &rest keyclauselist)
      (simply-error 'CASE keyform keyclauselist
                    (case-errorstring keyform keyclauselist)
                    (case-expected-type keyclauselist)))
    (predefmacro ccase (keyform &rest keyclauselist)
      (retry-loop 'CASE keyform keyclauselist
                  (case-errorstring keyform keyclauselist)))))
;; ----------------------------------------------------------------------------
(defmacro deftype (&whole whole-form
                   name lambdalist &body body)
  (setq name (check-not-declaration name 'deftype))
  (if (or (get name 'TYPE-SYMBOL) (get name 'TYPE-LIST))
    (error-of-type 'source-program-error
      :form whole-form
      :detail name
      (TEXT "~S is a built-in type and may not be redefined.")
      name))
  (multiple-value-bind (body-rest declarations docstring)
      (SYSTEM::PARSE-BODY body t)
    (if declarations (setq declarations (list (cons 'DECLARE declarations))))
    (let ((%whole-form whole-form) (%proper-list-p t)
          (%arg-count 0) (%min-args 0) (%restp nil) (%null-tests nil)
          (%let-list nil) (%keyword-tests nil) (%default-form '(QUOTE *)))
      (analyze1 lambdalist '(CDR <DEFTYPE-FORM>) name '<DEFTYPE-FORM>)
      (let ((lengthtest (make-length-test '<DEFTYPE-FORM>))
            (mainform `(LET* ,(nreverse %let-list)
                         ,@declarations
                         ,@(nreverse %null-tests)
                         ,@(nreverse %keyword-tests)
                         (BLOCK ,name ,@body-rest))))
        (if lengthtest
          (setq mainform
            `(IF ,lengthtest
               (TYPE-CALL-ERROR <DEFTYPE-FORM>)
               ,mainform)))
        `(EVAL-WHEN (COMPILE LOAD EVAL)
           (LET ()
             (%PUT ',name 'DEFTYPE-EXPANDER
               (FUNCTION ,(make-symbol (string-concat "DEFTYPE-" (string name)))
                 (LAMBDA (<DEFTYPE-FORM>) ,mainform)))
             (SYS::%SET-DOCUMENTATION ',name 'TYPE ',docstring)
             ',name))))))
(defun type-call-error (deftype-form) ; ABI
  (error-of-type 'error
    (TEXT "The deftype expander for ~S may not be called with ~S arguments.")
    (car deftype-form) (1- (length deftype-form))))
;; ----------------------------------------------------------------------------
;; cf. X3J13 vote <173>
(defmacro define-symbol-macro (&whole whole-form
                               symbol expansion)
  (unless (symbolp symbol)
    (error-of-type 'source-program-error
      :form whole-form
      :detail symbol
      (TEXT "~S: the name of a symbol macro must be a symbol, not ~S")
      'define-symbol-macro symbol))
  `(LET ()
     (EVAL-WHEN (COMPILE LOAD EVAL)
       (SYSTEM::%PROCLAIM-SYMBOL-MACRO ',symbol)
       (SYSTEM::%PUT ',symbol 'SYSTEM::SYMBOLMACRO
                     (SYSTEM::MAKE-GLOBAL-SYMBOL-MACRO ',expansion)))
     ',symbol))
;; ----------------------------------------------------------------------------
;; X3J13 vote <123>
;; Macro (nth-value n form) == (nth n (multiple-value-list form)), CLtL2 S. 184
(defmacro nth-value (n form)
  (if (and (integerp n) (>= n 0))
    (if (< n (1- multiple-values-limit))
      (if (= n 0)
        `(PROG1 ,form)
        (let* ((resultvar (gensym "RESULT-"))
               (vars (list resultvar))
               (ignores '()))
          (do ((i n (1- i)))
              ((zerop i))
            (let ((g (gensym "IG")))
              (setq vars (cons g vars))
              (setq ignores (cons g ignores))
          ) )
          `(MULTIPLE-VALUE-BIND ,vars ,form
             (DECLARE (IGNORE ,@ignores))
             ,resultvar
           )
      ) )
      `(PROGN ,form NIL)
    )
    `(NTH ,n (MULTIPLE-VALUE-LIST ,form))
) )
;; ----------------------------------------------------------------------------
(defun gensym-list (how-many)
  (map-into (make-list (if (numberp how-many) how-many (length how-many)))
            #'gensym))
;; ----------------------------------------------------------------------------
(defmacro time (form)
  (let ((vars (gensym-list 9)))
    `(MULTIPLE-VALUE-BIND ,vars (%%TIME)
      ;; this construction uses stack space at run time only
      (UNWIND-PROTECT ,form (MULTIPLE-VALUE-CALL #'%TIME (%%TIME) ,@vars)))))
;; ----------------------------------------------------------------------------
(defmacro times (form)
  (let ((var1 (gensym "HEAP1-"))
        (var2 (gensym "GC-STAT1-"))
        (var3 (gensym "VALUES-"))
        (var4 (gensym "GC-STAT2-"))
        (timevars1 (gensym-list 9))
        (timevars2 (gensym-list 9)))
    (setq form
          `(PROGN
             (MULTIPLE-VALUE-SETQ ,timevars1 (%%TIME))
             (UNWIND-PROTECT
               ,form
               (MULTIPLE-VALUE-SETQ ,timevars2 (%%TIME)))))
    `(MULTIPLE-VALUE-BIND (,var1 ,var2 ,var3 ,var4 ,@timevars1 ,@timevars2)
         (%SPACE1)
       ;; this construction uses stack space at run time only
       (UNWIND-PROTECT
         (LET ((*GC-STATISTICS* (1+ (MAX *GC-STATISTICS* 0))))
           (UNWIND-PROTECT
             (SETQ ,var3 (MULTIPLE-VALUE-LIST ,form))
             (SETQ ,var4 (%SPACE2))))
         (%SPACE ,var1 ,var2 ,var3 ,var4)
         (%TIME ,@timevars2 ,@timevars1))
       (VALUES-LIST ,var3))))
;; ----------------------------------------------------------------------------
(defmacro with-input-from-string
    ((var string &key (index nil sindex) (start '0 sstart) (end 'NIL send))
     &body body)
  (multiple-value-bind (body-rest declarations) (SYSTEM::PARSE-BODY body)
    `(LET ((,var (MAKE-STRING-INPUT-STREAM ,string
                   ,@(if (or sstart send)
                       `(,start ,@(if send `(,end) '()))
                       '()))))
       (DECLARE (READ-ONLY ,var) ,@declarations)
       (UNWIND-PROTECT
         (PROGN ,@body-rest)
         ,@(if sindex
             `((SETF ,index (SYSTEM::STRING-INPUT-STREAM-INDEX ,var))) '())
         (CLOSE ,var)))))
;; ----------------------------------------------------------------------------
(defmacro with-open-file ((stream &rest options) &body body)
  (multiple-value-bind (body-rest declarations) (SYSTEM::PARSE-BODY body)
    `(LET ((,stream (OPEN ,@options)))
       (DECLARE (READ-ONLY ,stream) ,@declarations)
       (UNWIND-PROTECT (MULTIPLE-VALUE-PROG1 (PROGN ,@body-rest)
                         (WHEN ,stream (CLOSE ,stream)))
         (WHEN ,stream (CLOSE ,stream :ABORT T))))))
;; ----------------------------------------------------------------------------
(defmacro with-open-stream ((var stream) &body body)
  (multiple-value-bind (body-rest declarations) (SYSTEM::PARSE-BODY body)
    `(LET ((,var ,stream))
       (DECLARE (READ-ONLY ,var) ,@declarations)
       (UNWIND-PROTECT (MULTIPLE-VALUE-PROG1 (PROGN ,@body-rest)
                         (when ,var (CLOSE ,var)))
         (WHEN ,var (CLOSE ,var :ABORT T))))))
;; ----------------------------------------------------------------------------
(defmacro with-output-to-string ((var &optional (string nil)
                                  &key (element-type ''CHARACTER))
                                 &body body)
  ;; use SYS::BUILT-IN-STREAM-CLOSE instead of CLOSE for bootstrapping
  ;; because CLOSE is only defined in gray.lisp - fairly late in the game
  (multiple-value-bind (body-rest declarations) (SYSTEM::PARSE-BODY body)
    (if string
      (let ((ignored-var (gensym "IG")))
        `(LET ((,var (SYS::MAKE-STRING-PUSH-STREAM ,string))
               (,ignored-var ,element-type))
           (DECLARE (READ-ONLY ,var) (IGNORE ,ignored-var) ,@declarations)
           (UNWIND-PROTECT
             (PROGN ,@body-rest)
             (SYS::BUILT-IN-STREAM-CLOSE ,var))))
      `(LET ((,var (MAKE-STRING-OUTPUT-STREAM :ELEMENT-TYPE ,element-type)))
         (DECLARE (READ-ONLY ,var) ,@declarations)
         (UNWIND-PROTECT
           (PROGN ,@body-rest (GET-OUTPUT-STREAM-STRING ,var))
           (SYS::BUILT-IN-STREAM-CLOSE ,var))))))
;; ----------------------------------------------------------------------------
;; X3J13 vote <40>
(defmacro print-unreadable-object
          ((&whole args object stream &key type identity) &body body)
  (declare (ignore object stream type identity))
  `(SYSTEM::WRITE-UNREADABLE
     ,(if body `(FUNCTION (LAMBDA () ,@body)) 'NIL)
     ,@args))
;; ----------------------------------------------------------------------------
(in-package "EXT")
(export '(space with-output-to-printer))
(in-package "SYSTEM")
(defmacro with-output-to-printer ((var &rest options &key external-format)
                                  &body body)
  (declare (ignore external-format))
  (multiple-value-bind (body-rest declarations) (SYSTEM::PARSE-BODY body)
    (if declarations
      (setq declarations (list (cons 'DECLARE declarations))))
    `(LET ((,var (SYS::MAKE-PRINTER-STREAM ,@options)))
       ,@declarations
       (UNWIND-PROTECT
         (PROGN ,@body-rest)
         (CLOSE ,var)))))
#+UNIX
(defun make-printer-stream (&key (external-format :default)) ; ABI
  (make-pipe-output-stream "lpr" :external-format external-format))
#+WIN32
(defun make-printer-stream (&key (external-format :default)) ; ABI
  (open "prn" :direction :output :external-format external-format))
;; ----------------------------------------------------------------------------
(in-package "EXT")
(export 'without-floating-point-underflow)
(in-package "SYSTEM")
(defmacro without-floating-point-underflow (&body body)
  `(let ((SYS::*INHIBIT-FLOATING-POINT-UNDERFLOW* T))
    ;; need `progn' to signal an error when `body' starts with a declaration
    (progn ,@body)))
;; ----------------------------------------------------------------------------

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./macros2.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./macros1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Definitions for control structures etc.
;;;; 29.4.1988, 3.9.1988

(in-package "SYSTEM")
(export '(ext::fcase) "EXT")
(export '(custom::*suppress-similar-constant-redefinition-warning*) "CUSTOM")

;; (DEFMACRO-SPECIAL . macrodef) is like (DEFMACRO . macrodef) except
;; that it works on a special form without replacing the special form
;; handler. ANSI CL requires that all standard macros, even when implemented
;; as special forms, have a macro expander available.
(defmacro defmacro-special (&whole whole-form
                            &body macrodef)
  (multiple-value-bind (expansion expansion-lambdabody name lambdalist docstring)
      (make-macro-expansion macrodef whole-form)
    (declare (ignore expansion-lambdabody lambdalist docstring))
    `(SYSTEM::%PUT ',name 'SYSTEM::MACRO ,expansion)))

(defmacro defvar (&whole whole-form
                  symbol &optional (initial-value nil svar) docstring)
  (unless (symbolp symbol)
    (error-of-type 'source-program-error
      :form whole-form
      :detail symbol
      (TEXT "~S: non-symbol ~S cannot be a variable")
      'defvar symbol))
  (if (constantp symbol)
    (error-of-type 'source-program-error
      :form whole-form
      :detail symbol
      (TEXT "~S: the constant ~S must not be redefined to be a variable")
      'defvar symbol))
  `(LET ()
     (PROCLAIM '(SPECIAL ,symbol))
     ,@(if svar
         `((UNLESS (BOUNDP ',symbol)
             (SYS::SET-SYMBOL-VALUE ',symbol ,initial-value))))
     ,@(if docstring
           `((SYS::%SET-DOCUMENTATION ',symbol 'VARIABLE ',docstring)))
     ',symbol))

(defmacro defparameter (&whole whole-form
                        symbol initial-value &optional docstring)
  (unless (symbolp symbol)
    (error-of-type 'source-program-error
      :form whole-form
      :detail symbol
      (TEXT "~S: non-symbol ~S cannot be a variable")
      'defparameter symbol))
  (if (constantp symbol)
    (error-of-type 'source-program-error
      :form whole-form
      :detail symbol
      (TEXT "~S: the constant ~S must not be redefined to be a variable")
      'defparameter symbol))
  `(LET ()
     (PROCLAIM '(SPECIAL ,symbol))
     (SYS::SET-SYMBOL-VALUE ',symbol ,initial-value)
     ,@(if docstring `((SYS::%SET-DOCUMENTATION ',symbol 'VARIABLE ',docstring)))
     ',symbol))

(defmacro defconstant (&whole whole-form
                       symbol initial-value &optional docstring)
  (unless (symbolp symbol)
    (error-of-type 'source-program-error
      :form whole-form
      :detail symbol
      (TEXT "~S: non-symbol ~S cannot be defined constant")
      'defconstant symbol))
  (let ((initial-var (gensym)))
    `(LET ()
       (SYS::EVAL-WHEN-COMPILE
        (SYS::C-PROCLAIM-CONSTANT ',symbol ',initial-value))
       (LET ((,initial-var ,initial-value))
         (IF (CONSTANTP ',symbol)
           (UNLESS (CONSTANT-EQL ,initial-value ,initial-var
                                 (SYMBOL-VALUE ',symbol))
             (CONSTANT-WARNING ',symbol ',whole-form ,initial-var)))
         (SYS::%PROCLAIM-CONSTANT ',symbol ,initial-var)
         ,@(if docstring
             `((SYS::%SET-DOCUMENTATION ',symbol 'VARIABLE ',docstring)))
         ',symbol))))
; For inhibiting warnings about redefining constants when the old and the new
; value are the same string / bit vector:
(defmacro constant-eql (new-form new-value old-value) ; ABI
  (declare (ignore new-form))
  `(EQL ,new-value ,old-value))
; If new-value is known to be an immutable string / bit vector and old-value
; is the same string / bit vector, this can return T by using EQUAL instead of
; EQL.
(defun loose-constant-eql (new-value old-value) ; ABI
  (and (equal (type-of new-value) (type-of old-value))
       (equal new-value old-value)))
; The redefinition warning.
(defvar custom:*suppress-similar-constant-redefinition-warning* nil
  "When non-NIL, no warning is issued when a constant is redefined
to a new value which is visually similar (prints identically) to the old one.")
(defun constant-warning (symbol form new-value) ; ABI
  (let ((old-value (symbol-value symbol)))
    ;; use write-to-string instead of equal to handle circularity
    (if (string= (write-to-string new-value :pretty nil :circle t)
                 (write-to-string old-value :pretty nil :circle t))
        (unless custom:*suppress-similar-constant-redefinition-warning*
          (warn (TEXT "~S redefines the constant ~S. Its old value was visually similar though. Set ~S to avoid this warning.")
                form symbol
                'custom:*suppress-similar-constant-redefinition-warning*))
        (warn (TEXT "~S redefines the constant ~S. Its old value was ~S.")
              form symbol old-value))))

(defmacro-special and (&body args)
  (cond ((null args) T)
        ((null (cdr args)) (car args))
        (t (let ((L (mapcar #'(lambda (x) `((NOT ,x) NIL) ) args)))
             (rplaca (last L) `(T ,(car (last args))))
             (cons 'COND L)))))

(defmacro-special or (&body args)
  (cond ((null args) NIL)
        ((null (cdr args)) (car args))
        (t (let ((L (mapcar #'list args)))
             (rplaca (last L) `(T ,(car (last args))))
             (cons 'COND L)))))

(defmacro-special prog1 (form1 &rest moreforms)
  (let ((g (gensym "PROG1-")))
    `(LET ((,g ,form1)) ,@moreforms ,g)))

(defmacro-special prog2 (form1 form2 &rest moreforms)
  (let ((g (gensym "PROG2-")))
    `(LET () (PROGN ,form1 (LET ((,g ,form2)) ,@moreforms ,g)))))

(defmacro-special when (test &body forms)
  `(IF ,test (PROGN ,@forms)))

(defmacro-special unless (test &body forms)
  `(IF (NOT ,test) (PROGN ,@forms)))

;; DECLARE is a special form in CLISP, so it should provide a macroexpansion
(defmacro-special declare (&body ignore)
  (declare (ignore ignore))
  nil)

(defmacro return (&optional return-value)
  `(RETURN-FROM NIL ,return-value))

(predefmacro loop (&body body)
  (let ((tag (gensym)))
    `(BLOCK NIL (TAGBODY ,tag ,@body (GO ,tag)))))

(defun do/do*-expand (whole-form varclauselist exitclause body do let psetq)
  (when (atom exitclause)
    (error-of-type 'source-program-error
      :form whole-form
      :detail exitclause
      (TEXT "exit clause in ~S must be a list")
      do))
  (flet ((bad-syntax (formpiece)
           (error-of-type 'source-program-error
             :form whole-form
             :detail formpiece
             (TEXT "Invalid syntax in ~S form: ~S.") do formpiece)))
    (let ((bindlist nil)
          (reinitlist nil)
          (testtag (gensym "LOOP-"))
          (exittag (gensym "END-")))
      (multiple-value-bind (body-rest declarations) (sys::parse-body body)
        (when declarations
          (setq declarations (list (cons 'DECLARE declarations))))
        (loop
         (when (atom varclauselist)
           (if (null varclauselist)
               (return)
               (bad-syntax varclauselist)))
         (let ((varclause (first varclauselist)))
           (setq varclauselist (rest varclauselist))
           (cond ((atom varclause)
                  (setq bindlist (cons varclause bindlist)))
                 ((null (cdr varclause))
                  (setq bindlist (cons (first varclause) bindlist)))
                 ((atom (cdr varclause))
                  (bad-syntax varclause))
                 ((null (cddr varclause))
                  (setq bindlist (cons varclause bindlist)))
                 ((atom (cddr varclause))
                  (bad-syntax varclause))
                 ((null (cdddr varclause))
                  (setq bindlist
                        (cons (list (first varclause) (second varclause))
                              bindlist))
                  (setq reinitlist
                        (list* (third varclause) (first varclause) reinitlist)))
                 (t ;;(not (null (cdddr varclause)))
                  (bad-syntax varclause)))))
        `(BLOCK NIL
           (,let ,(nreverse bindlist)
            ,@declarations
            (TAGBODY
              ,testtag
              (IF ,(first exitclause) (GO ,exittag))
              ,@body-rest
              (,psetq ,@(nreverse reinitlist))
              (GO ,testtag)
              ,exittag
              (RETURN-FROM NIL (PROGN ,@(rest exitclause))))))))))

(fmakunbound 'do)
(defmacro do (&whole whole-form
              varclauselist exitclause &body body)
  (do/do*-expand whole-form varclauselist exitclause body 'DO 'LET 'PSETQ))

(defmacro do* (&whole whole-form
               varclauselist exitclause &body body)
  (do/do*-expand whole-form varclauselist exitclause body 'DO* 'LET* 'SETQ))

(defmacro dolist ((var listform &optional resultform) &body body)
  (multiple-value-bind (body-rest declarations) (sys::parse-body body)
    (let ((g (gensym "LIST-")))
      `(DO* ((,g ,listform (CDR ,g))
             (,var NIL))
            ((ENDP ,g)
             ,(if (constantp resultform)
               ; Ist resultform konstant, so ist es /= var. Daher braucht var
               ; whrend Auswertung von resultform nicht an NIL gebunden zu sein:
               `,resultform
               `(LET ((,var NIL))
                  (DECLARE (IGNORABLE ,var) ,@declarations)
                  ,resultform)))
         (DECLARE (LIST ,g) ,@declarations)
         (SETQ ,var (CAR ,g))
         ,@body-rest))))

(fmakunbound 'dotimes)
(defmacro dotimes ((var countform &optional resultform) &body body)
  (multiple-value-bind (body-rest declarations) (sys::parse-body body)
    (if declarations
      (setq declarations (list (cons 'DECLARE declarations))))
    (if (constantp countform)
      `(DO ((,var 0 (1+ ,var)))
           ((>= ,var ,countform) ,resultform)
         ,@declarations
         ,@body-rest)
      (let ((g (gensym "COUNT-")))
        `(DO ((,var 0 (1+ ,var))
              (,g ,countform))
             ((>= ,var ,g) ,resultform)
           ,@declarations
           ,@body-rest)))))

(defmacro-special psetq (&whole whole-form
                         &rest args)
  (do* ((setlist nil)
        (bindlist nil)
        (arglist args (cddr arglist)))
       ((null arglist)
        (setq setlist (cons 'NIL setlist))
        (cons 'LET (cons (nreverse bindlist) (nreverse setlist))))
    (if (null (cdr arglist))
      (error-of-type 'source-program-error
        :form whole-form
        :detail whole-form
        (TEXT "~S called with an odd number of arguments: ~S")
        'psetq whole-form))
    (let ((g (gensym "PSETQ-")))
      (setq setlist (cons `(SETQ ,(first arglist) ,g) setlist))
      (setq bindlist (cons `(,g ,(second arglist)) bindlist)))))

(defmacro-special multiple-value-list (form)
  `(MULTIPLE-VALUE-CALL #'LIST ,form))

(defmacro-special multiple-value-bind (varlist form &body body)
  (let ((g (gensym "VALUES-"))
        (poplist nil))
    (dolist (var varlist) (setq poplist (cons `(,var (POP ,g)) poplist)))
    `(LET* ((,g (MULTIPLE-VALUE-LIST ,form)) ,@(nreverse poplist))
       ,@body)))

(defmacro-special multiple-value-setq (varlist form)
  (let ((g (gensym "VALUES-"))
        (poplist nil))
    (dolist (var varlist) (setq poplist (cons `(SETQ ,var (POP ,g)) poplist)))
    `(LET* ((,g (MULTIPLE-VALUE-LIST ,form)))
       ,(if poplist `(PROG1 ,@(nreverse poplist)) NIL))))

(defmacro-special locally (&body body)
  `(LET () ,@body))

(defun case-expand (whole-form form-name test keyform clauses)
  (let ((var (gensym (string-concat (symbol-name form-name) "-KEY-"))))
    `(let ((,var ,keyform))
      (cond
        ,@(maplist
           #'(lambda (remaining-clauses)
               (let ((clause (first remaining-clauses))
                     (remaining-clauses (rest remaining-clauses)))
                 (unless (consp clause)
                   (error-of-type 'source-program-error
                     :form whole-form
                     :detail clause
                     (TEXT "~S: missing key list")
                     form-name))
                 (let ((keys (first clause)))
                   `(,(cond ((or (eq keys 'T) (eq keys 'OTHERWISE))
                             (if remaining-clauses
                                 (error-of-type 'source-program-error
                                   :form whole-form
                                   :detail clause
                                   (TEXT "~S: the ~S clause must be the last one")
                                   form-name keys)
                                 't))
                            ((listp keys)
                             `(or ,@(mapcar #'(lambda (key)
                                                `(,test ,var ',key))
                                            keys)))
                            (t `(,test ,var ',keys)))
                     ,@(rest clause)))))
           clauses)))))

(defmacro fcase (&whole whole-form
                 test keyform &body clauses)
  (case-expand whole-form 'fcase test keyform clauses))
(defmacro-special case (&whole whole-form
                        keyform &body clauses)
  (case-expand whole-form 'case 'eql keyform clauses))

(defmacro prog (varlist &body body)
  (multiple-value-bind (body-rest declarations) (sys::parse-body body)
    (if declarations
      (setq declarations (list (cons 'DECLARE declarations))))
    `(BLOCK NIL
       (LET ,varlist
         ,@declarations
         (TAGBODY ,@body-rest)))))

(defmacro prog* (varlist &body body)
  (multiple-value-bind (body-rest declarations) (sys::parse-body body)
    (if declarations
      (setq declarations (list (cons 'DECLARE declarations))))
    `(BLOCK NIL
       (LET* ,varlist
         ,@declarations
         (TAGBODY ,@body-rest)))))


;;; Macro-Expander fr COND:

#|
;; Dieser hier ist zwar krzer, aber er reduziert COND auf OR,
;; das seinerseits wieder auf COND reduziert, ...
 (defmacro-special cond (&whole whole-form
                         &body clauses)
  (ifify whole-form clauses))
;; macht eine clauselist von COND zu verschachtelten IFs und ORs.
 (defun ifify (whole-form clauselist)
  (cond ((null clauselist) NIL)
        ((atom clauselist)
         (error-of-type 'source-program-error
           :form whole-form
           :detail clauselist
           (TEXT "Not a list of COND clauses: ~S")
           clauselist))
        ((atom (car clauselist))
         (error-of-type 'source-program-error
           :form whole-form
           :detail (car clauselist)
           (TEXT "The atom ~S must not be used as a COND clause.")
           (car clauselist)))
        (t (let ((ifif (ifify whole-form (cdr clauselist))))
             (if (cdar clauselist)
               ; mindestens zweielementige Klausel
               (if (constantp (caar clauselist))
                 (if (eval (caar clauselist)) ; Test zur Expansionszeit auswerten
                   (if (cddar clauselist)
                     `(PROGN ,@(cdar clauselist))
                     (cadar clauselist))
                   ifif)
                 `(IF ,(caar clauselist)
                    ,(if (cddar clauselist)
                         `(PROGN ,@(cdar clauselist)) (cadar clauselist))
                    ,ifif))
               ; einelementige Klausel
               (if (constantp (caar clauselist))
                 (if (eval (caar clauselist)) ; Test zur Expansionszeit auswerten
                   (caar clauselist)
                   ifif)
                 `(OR ,(caar clauselist) ,ifif)))))))
|#

;; Noch einfacher ginge es auch so:
#|
 (defmacro-special cond (&whole whole-form
                         &body clauses)
  (cond ((null clauses) 'NIL)
        ((atom clauses)
         (error-of-type 'source-program-error
           :form whole-form
           :detail clauses
           (TEXT "COND code contains a dotted list, ending with ~S")
           clauses))
        (t (let ((clause (car clauses)))
             (if (atom clause)
               (error-of-type 'source-program-error
                 :form whole-form
                 :detail clause
                 (TEXT "COND clause without test: ~S")
                 clause)
               (let ((test (car clause)))
                 (if (cdr clause)
                   `(IF ,test (PROGN ,@(cdr clause)) (COND ,@(cdr clauses)))
                   `(OR ,test (COND ,@(cdr clauses))))))))))
|#

;; Dieser hier reduziert COND etwas umstndlicher auf IF-Folgen:
(defmacro-special cond (&whole whole-form
                        &body clauses)
  (let ((g (gensym "RESULT-")))
    (multiple-value-bind (ifif needed-g) (ifify whole-form clauses g)
      (if needed-g
        `(LET (,g) ,ifif)
        ifif))))
; macht eine clauselist von COND zu verschachtelten IFs.
; Zwei Werte: die neue Form, und ob die Dummyvariable g benutzt wurde.
(defun ifify (whole-form clauselist g)
  (cond ((null clauselist) (values NIL nil))
        ((atom clauselist)
         (error-of-type 'source-program-error
           :form whole-form
           :detail clauselist
           (TEXT "Not a list of COND clauses: ~S")
           clauselist))
        ((atom (car clauselist))
         (error-of-type 'source-program-error
           :form whole-form
           :detail (car clauselist)
           (TEXT "The atom ~S must not be used as a COND clause.")
           (car clauselist)))
        (t (multiple-value-bind (ifif needed-g) (ifify whole-form (cdr clauselist) g)
             (if (cdar clauselist)
               ; mindestens zweielementige Klausel
               (if (constantp (caar clauselist))
                 (if (eval (caar clauselist)) ; Test zur Expansionszeit auswerten
                   (if (cddar clauselist)
                     (values `(PROGN ,@(cdar clauselist)) nil)
                     (values (cadar clauselist) nil))
                   (values ifif needed-g))
                 (values
                   `(IF ,(caar clauselist)
                        ,(if (cddar clauselist)
                             `(PROGN ,@(cdar clauselist)) (cadar clauselist))
                        ,ifif)
                   needed-g))
               ; einelementige Klausel
               (if (constantp (caar clauselist))
                 (if (eval (caar clauselist)) ; Test zur Expansionszeit auswerten
                   (values (caar clauselist) nil)
                   (values ifif needed-g))
                 (if (atom (caar clauselist))
                   (values ; ein Atom produziert nur einen Wert und darf
                     `(IF ,(caar clauselist) ; mehrfach hintereinander
                          ,(caar clauselist) ; ausgewertet werden!
                          ,ifif)
                     needed-g)
                   (values
                     `(IF (SETQ ,g ,(caar clauselist)) ,g ,ifif)
                     t))))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./macros1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./keyboard.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Keyboard stream

(in-package "EXT")
(export '(with-keyboard *keyboard-input*))
(in-package "SYSTEM")

;;;--------------------------------------------------------------------------

(defvar *keyboard-input*)
(defmacro with-keyboard (&body body)
  `(SYS::EXEC-WITH-KEYBOARD (FUNCTION (LAMBDA () (PROGN ,@body))))
)
(defun exec-with-keyboard (fun) ; ABI
  #+WIN32 ; *keyboard-input* existiert schon
    (funcall fun)
  #+UNIX
    (let ((mode nil))
      (unless *keyboard-input*
        (setq *keyboard-input* (sys::make-keyboard-stream))
      )
      (unwind-protect
        (progn
          (setq mode (sys::terminal-raw *keyboard-input* t))
          (funcall fun)
        )
        (sys::terminal-raw *keyboard-input* mode)
)   ) )

; Used by spvw.d.
(defun wait-keypress ()
  (with-keyboard (read-char *keyboard-input*))
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./keyboard.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./savemem.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Saving memory images

(in-package "EXT")
(export '(saveinitmem *command-index*))
(in-package "SYSTEM")

;;---------------------------------------------------------------------------
;; Stores the current memory contents as "lispimag.mem", omitting garbage
;; collectible objects.
;; This function does not take arguments and has no local variables, since
;; otherwise in the interpreted mode the values of the variables are stored.
(defun %saveinitmem ()
  (do-all-symbols (sym) (remprop sym 'sys::definition))
  (when (fboundp 'clos::install-dispatch)
    (do-all-symbols (sym)
      (when (and (fboundp sym)
                 (typep (symbol-function sym) clos::<standard-generic-function>))
        (let ((gf (symbol-function sym)))
          (when (clos::gf-never-called-p gf)
            (clos::install-dispatch gf)
  ) ) ) ) )
  (setq - nil + nil ++ nil +++ nil * nil ** nil *** nil / nil // nil /// nil)
  (savemem "lispimag.mem" nil)
  (room nil)
)

;; Saves the current memory contents.
;; This function works only when compiled!
(defvar *saveinitmem-verbose* t
  "The default value for the :VERBOSE argument of SAVEINITMEM.")
(defun saveinitmem (&optional (filename "lispinit.mem")
                    &key ((:quiet *quiet*) nil)
                    (init-function nil init-function-p)
                    ((:verbose *saveinitmem-verbose*) *saveinitmem-verbose*)
                    ((:norc *norc*) nil)
                    ((:documentation *image-doc*)
                     (documentation init-function 'function))
                    ((:script *script*) (null init-function))
                    keep-global-handlers (start-package *package*)
                    (locked-packages *system-package-list*) executable)
  (let* ((old-driver *driver*) old-global-handlers file-size
         (*package* (sys::%find-package start-package))
         (active-restarts *active-restarts*)
         (condition-restarts *condition-restarts*)
         (fn (if (not executable)
               (merge-pathnames filename #.(make-pathname :type "mem"))
               ;; win32 executables require "exe" extension
               #+(or win32 cygwin)
               (make-pathname :type "exe" :defaults filename)
               #-(or win32 cygwin) filename)))
    ;; use setq in order not to create local per thread binding that will
    ;; not survive the savemem/loadmem. actually we need two new functions:
    ;; sys::symbol-global-value and sys::symbol-thread-value. will be added
    (setq *driver*
          #'(lambda ()
              ;;(declare (special *command-index* *home-package*))
              ;; Reset a few special variables. This must happen in the
              ;; fresh session, not in the old session, because that would
              ;; temporarily disable error handling in the old session.
              ;; Note: For GC purposes, neither is better: during savemem's
              ;; GC the old values are accessible anyway and thus not garbage
              ;; collected.
              (setq - nil
                    + nil
                    ++ nil
                    +++ nil
                    * nil
                    ** nil
                    *** nil
                    / nil
                    // nil
                    /// nil
                    *command-index* 0
                    *home-package* nil
                    ;; must make sure that the user can get clisp repl back
                    ;; from an executable image:
                    ;;  ./clisp -K boot -q -norc -x '(saveinitmem "x" :executable 0 :init-function (lambda () (print *args*) (exit)))'
                    ;; ./x --clisp-x '(ext:saveinitmem "myclisp" :executable t :init-function nil)'
                    ;; ./myclisp => [1]> ...
                    *driver* (if (and init-function-p (null init-function))
                                 #'sys::main-loop old-driver))
              (when init-function (funcall init-function))
              (funcall *driver*)))
    (unless keep-global-handlers
      (setq old-global-handlers ; disable and save all global handlers
            (ext::set-global-handler nil nil)))
    (setf (package-lock locked-packages) t)
    ;; set global not per thread ones (hopefully novody has bound them above us)
    (setq *active-restarts* nil
          *condition-restarts* nil)
    ;; we used to set *ACTIVE-RESTARTS* & *CONDITION-RESTARTS* above in the
    ;; *DRIVER* binding, but that caused mutiple ABORT restarts, bug
    ;; https://sourceforge.net/p/clisp/bugs/443/
    (setq file-size (savemem fn executable))
    ;; restore old driver
    (setq *driver* old-driver)
    ;; restore restarts
    (setq *active-restarts* active-restarts
          *condition-restarts* condition-restarts)
    (when old-global-handlers   ; re-install all global handlers
      (ext::set-global-handler old-global-handlers nil))
    (when *saveinitmem-verbose*
      (let ((*load-level* 1))   ; proper indentation
        (loading-message (TEXT "Wrote the memory image into ~A (~:D byte~:P)")
                         fn file-size))))
  (room nil))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./savemem.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./gstream.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ===========================================================================
;;; generic stream default methods
;;; Marcus Daniels 16.4.1994

(in-package "GSTREAM")
(common-lisp:export
 '(generic-stream-read-char
   generic-stream-peek-char
   generic-stream-read-char-will-hang-p
   generic-stream-clear-input
   generic-stream-write-char
   generic-stream-write-string
   generic-stream-finish-output
   generic-stream-force-output
   generic-stream-clear-output
   generic-stream-read-byte
   generic-stream-write-byte
   generic-stream-close
   generic-stream-controller
   generic-stream-p
   make-generic-stream))
(common-lisp:in-package "SYSTEM")
(use-package '("GSTREAM") "EXT")
(ext:re-export "GSTREAM" "EXT")

(clos:defclass generic-stream-controller () ())

(clos:defgeneric generic-stream-read-char (controller))
(clos:defgeneric generic-stream-peek-char (controller))
(clos:defgeneric generic-stream-read-char-will-hang-p (controller))
(clos:defgeneric generic-stream-clear-input (controller))
(clos:defgeneric generic-stream-write-char (controller ch))
(clos:defgeneric generic-stream-write-string (controller string start len))
(clos:defgeneric generic-stream-finish-output (controller))
(clos:defgeneric generic-stream-force-output (controller))
(clos:defgeneric generic-stream-clear-output (controller))
(clos:defgeneric generic-stream-read-byte (controller))
(clos:defgeneric generic-stream-write-byte (controller by))
(clos:defgeneric generic-stream-close (controller))

(clos:defmethod generic-stream-read-char ((controller generic-stream-controller))
  (declare (ignore controller))
)

(clos:defmethod generic-stream-peek-char ((controller generic-stream-controller))
  (values (generic-stream-read-char controller) t)
)

(clos:defmethod generic-stream-read-char-will-hang-p ((controller generic-stream-controller))
  (declare (ignore controller))
)

(clos:defmethod generic-stream-clear-input ((controller generic-stream-controller))
  (declare (ignore controller))
)

(clos:defmethod generic-stream-write-char ((controller generic-stream-controller) ch)
  (declare (ignore controller ch))
)

(clos:defmethod generic-stream-write-string ((controller generic-stream-controller) string start len)
  (dotimes (i len)
    (generic-stream-write-char controller (schar string (+ start i)))
) )

(clos:defmethod generic-stream-finish-output ((controller generic-stream-controller))
  (declare (ignore controller))
)

(clos:defmethod generic-stream-force-output ((controller generic-stream-controller))
  (declare (ignore controller))
)

(clos:defmethod generic-stream-clear-output ((controller generic-stream-controller))
  (declare (ignore controller))
)

(clos:defmethod generic-stream-read-byte ((controller generic-stream-controller))
  (declare (ignore controller))
)

(clos:defmethod generic-stream-write-byte ((controller generic-stream-controller) by)
  (declare (ignore controller by))
)

(clos:defmethod generic-stream-close ((controller generic-stream-controller))
  (declare (ignore controller))
)

#| ;; Example:
;; Alias streams just perform the required operation on another given stream.
(defclass alias-controller (generic-stream-controller)
  ((orig-stream :initarg :orig-stream))
)
(defun make-alias-stream (orig-stream)
  (make-generic-stream
    (make-instance 'alias-controller :orig-stream orig-stream)
) )
(defmethod generic-stream-read-char ((controller alias-controller))
  (with-slots (orig-stream) controller
    (read-char orig-stream nil nil)
) )
(defmethod generic-stream-peek-char ((controller alias-controller))
  (with-slots (orig-stream) controller
    (values (peek-char nil orig-stream nil nil) nil)
) )
(defmethod generic-stream-read-char-will-hang-p ((controller alias-controller))
  (with-slots (orig-stream) controller
    (if (listen orig-stream)
      nil
      (let ((ch (read-char-no-hang orig-stream nil t)))
        (cond ((eql ch t) nil) ; EOF
              ((null ch) t) ; nothing available, not EOF
              (t (unread-char ch orig-stream) nil)
) ) ) ) )
(defmethod generic-stream-clear-input ((controller alias-controller))
  (with-slots (orig-stream) controller
    (clear-input orig-stream)
    t
) )
(defmethod generic-stream-write-char ((controller alias-controller) ch)
  (with-slots (orig-stream) controller
    (write-char ch orig-stream)
) )
#| ; not needed, see general method above
(defmethod generic-stream-write-string ((controller alias-controller) string start len)
  (with-slots (orig-stream) controller
    (dotimes (i len)
      (write-char (schar string (+ start i)) orig-stream)
) ) )
|#
(defmethod generic-stream-finish-output ((controller alias-controller))
  (with-slots (orig-stream) controller
    (finish-output orig-stream)
) )
(defmethod generic-stream-force-output ((controller alias-controller))
  (with-slots (orig-stream) controller
    (force-output orig-stream)
) )
(defmethod generic-stream-clear-output ((controller alias-controller))
  (with-slots (orig-stream) controller
    (clear-output orig-stream)
) )
(defmethod generic-stream-read-byte ((controller alias-controller))
  (with-slots (orig-stream) controller
    (read-byte orig-stream nil nil)
) )
(defmethod generic-stream-write-byte (i (controller alias-controller))
  (with-slots (orig-stream) controller
    (write-byte i orig-stream)
) )
(defmethod generic-stream-close ((controller alias-controller))
  ; don't close orig-stream
)
|#

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./gstream.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./international.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;                           INTERNATIONALIZATION

(in-package "I18N")
(cl:export '(deflanguage definternational deflocalized localized english))

(common-lisp:in-package "SYSTEM")
(use-package '("I18N") "EXT")
(ext:re-export "I18N" "EXT")

;; ----------------------------------------------------------------------------
;; Languages and Internationalization:
;; (sys::current-language)
;;   returns the current language, a symbol.
;; (deflanguage lang [parent-lang])
;;   defines a language, being a descendant of parent-lang.
;; (sys::assert-language lang)
;;   asserts that lang is a valid language.
;; (definternational symbol
;;   { (lang value-form) }*
;;   [ (t lang) | (t (var) value-form*) ]
;; )
;;   defines an internationalized object, with some predefined values in
;;   the specified languages, and a default language or default function for
;;   unspecified languages.
;; (deflocalized symbol lang value-form)
;;   enhances an internationalized object.
;; (localized symbol [lang])
;;   looks up the value of an internationalized object in lang, which defaults
;;   to the current language.
;;
;; There is an analogy between
;;         deflanguage        --   defclass
;;         definternational   --   defgeneric
;;         deflocalized       --   defmethod
;;         localized          --   funcall
;; If you need something like "definternational with arguments", then use
;; defgeneric with EQL methods for the language argument. (Well, language
;; inheritance doesn't work with EQL methods.)
;;

(defvar *all-languages* nil)
(defun assert-language (lang) ; ABI
  (let ((h (assoc lang *all-languages*)))
    (unless h
      (error-of-type 'error
        (TEXT "Language ~S is not defined")
        lang
    ) )
    (cdr h)
) )
(defun ensure-language (lang parent-lang) ; ABI
  (let ((h (assoc lang *all-languages*)))
    (if h
      (unless (eq (cdr h) parent-lang)
        (error-of-type 'error
          (TEXT "Language ~S inherits from ~S")
          lang (cdr h)
      ) )
      (progn
        (or (null parent-lang) (assert-language parent-lang))
        (setq *all-languages*
              (nconc *all-languages* (list (cons lang parent-lang)))
  ) ) ) )
  lang
)
(defmacro deflanguage (lang &optional parent-lang)
  `(SYSTEM::ENSURE-LANGUAGE ',lang ',parent-lang)
)
(deflanguage ENGLISH)
(defmacro definternational (symbol &rest options)
  `(PROGN
     ,@(mapcap #'(lambda (option)
                   (let ((lang (first option)))
                     (if (eq lang 'T)
                       `((SYS::%PUT ',symbol 'SYS::OTHER-LANGUAGE
                           ,(if (listp (second option))
                              `(FUNCTION (LAMBDA ,@(cdr option)))
                              `(SYSTEM::DEFINTERNATIONAL-DEFAULT
                                 ',symbol ',(second option)
                               )
                            )
                        ))
                       `((ASSERT-LANGUAGE ',lang)
                         (SYS::%PUT ',symbol ',lang ,(second option))
                        )
                 ) ) )
               options
       )
     ',symbol
   )
)
(defmacro deflocalized (symbol lang form)
  `(PROGN
     (ASSERT-LANGUAGE ',lang)
     (SYS::%PUT ',symbol ',lang ,form)
     ',symbol
   )
)
(defun localized (symbol &optional (language (sys::current-language)))
  (let ((notfound '#:notfound)
        (lang language))
    (loop
      (let ((h (assoc lang *all-languages*)))
        (unless h
          (error-of-type 'error
            (TEXT "~S: Language ~S is not defined")
            'localized lang
        ) )
        (let ((value (get symbol lang notfound)))
          (unless (eq value notfound) (return-from localized value))
        )
        ; not found -> search parent language
        (setq lang (cdr h))
        ; no parent language -> lookup default function
        (unless lang (return))
  ) ) )
  (let ((h (get symbol 'SYS::OTHER-LANGUAGE)))
    (if h
      (funcall h language)
      ; no more parent language and no lookup default -> return nil
      nil
) ) )
;; Default defaulter: Look up for another language.
(defvar *localized-recursion* nil)
(defun definternational-default (symbol default-language) ; ABI
  #'(lambda (language)
      (if (eq *localized-recursion* symbol) ; catch endless recursion
        (error-of-type 'error
          (TEXT "~S ~S: no value for default language ~S")
          'localized symbol language
        )
        (let ((*localized-recursion* symbol))
          (localized symbol default-language)
    ) ) )
)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./international.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./install.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; win32 CLISP installation
;;; Copyright (C) 2001-2005,2011  Sam Steingold,
;;; released as a part of CLISP under GNU GPL v2+

;; load this file in the directory where your CLISP distribution is located
;;  - to set the Registry appropriately
;;  - to create CLISP.LNK & CLISP.URL on your desktop

(in-package "CL-USER")
(use-package "LDAP")

(defvar *clisp-home* (namestring (default-directory)))
(defvar *clisp-linkset* "base")
(defvar *clisp-driver* (ext:string-concat *clisp-home* "clisp.exe"))
(defun clisp-cmd ()
  (if (position #\Space *clisp-home*)
      (ext:string-concat "\"" *clisp-driver* "\" -K " *clisp-linkset*)
      (ext:string-concat *clisp-driver* " -K " *clisp-linkset*)))

(defvar *eflags*
  (make-array 4 :element-type '(unsigned-byte 8) :initial-contents '(0 0 0 0)))

(defparameter *lisp-type-map*  '((".lisp" . "lispfile")
                                 (".lsp" . "lispfile")
                                 (".cl" . "lispfile")
                                 (".fas" . "fasfile")
                                 (".mem" . "memfile")))

(format t "~& * Installing CLISP to run from ~a~%" *clisp-home*)

(defun add-lisp-file (dkey)
  (format t "associating CLISP with Lisp files under ~s~%" (dir-key-path dkey))
  (with-dir-key-open (lf dkey "lispfile" :direction :output)
    (setf (dir-key-value lf "") "Lisp source file"
          (dir-key-value lf "EditFlags") *eflags*)
    (with-dir-key-open (ic lf "DefaultIcon" :direction :output)
      (setf (dir-key-value ic "") "%SystemRoot%\\system32\\SHELL32.dll,41"))
    (with-dir-key-open (cc lf "Shell\\Compile_with_CLISP" :direction :output)
      (setf (dir-key-value cc "") "Compile with CLISP")
      (with-dir-key-open (cmd cc "command" :direction :output)
        (setf (dir-key-value cmd "")
              (ext:string-concat (clisp-cmd) " -c \"%1\""))))))

(defun add-fas-file (dkey)
  (format t "associating CLISP with FAS files under ~s~%" (dir-key-path dkey))
  (with-dir-key-open (ff dkey "fasfile" :direction :output)
    (setf (dir-key-value ff "") "CLISP compiled file"
          (dir-key-value ff "EditFlags") *eflags*)
    (with-dir-key-open (ic ff "DefaultIcon" :direction :output)
      (setf (dir-key-value ic "") "%SystemRoot%\\system32\\SHELL32.dll,21"))
    (with-dir-key-open (sh ff "Shell" :direction :output)
      (setf (dir-key-value sh "") "Execute_with_CLISP")
      (with-dir-key-open (ex sh "Execute_with_CLISP" :direction :output)
        (setf (dir-key-value ex "") "Execute with CLISP")
        (with-dir-key-open (cmd ex "command" :direction :output)
          (setf (dir-key-value cmd "")
                (ext:string-concat (clisp-cmd) " \"%1\""))))
      (with-dir-key-open (lo sh "Load_into_CLISP" :direction :output)
        (setf (dir-key-value lo "") "Load into CLISP")
        (with-dir-key-open (cmd lo "command" :direction :output)
          (setf (dir-key-value cmd "")
                (ext:string-concat (clisp-cmd) " -i \"%1\"")))))))

(defun add-mem-file (dkey)
  (format t "associating CLISP with MEM files under ~s~%" (dir-key-path dkey))
  (with-dir-key-open (mf dkey "memfile" :direction :output)
    (setf (dir-key-value mf "") "CLISP memory image"
          (dir-key-value mf "EditFlags") *eflags*)
    (with-dir-key-open (ic mf "DefaultIcon" :direction :output)
      (setf (dir-key-value ic "") "%SystemRoot%\\system32\\SHELL32.dll,21"))
    (with-dir-key-open (sh mf "Shell" :direction :output)
      (setf (dir-key-value sh "") "Run_with_CLISP")
      (with-dir-key-open (ex sh "Run_with_CLISP" :direction :output)
        (setf (dir-key-value ex "") "Run with CLISP")
        (with-dir-key-open (cmd ex "command" :direction :output)
          (setf (dir-key-value cmd "")
                (ext:string-concat (clisp-cmd) " -M \"%1\"")))))))

(defun make-clisp-shortcut (target)
  (format t "~&writing <~a>..." target) (force-output)
  (posix:make-shortcut
   target :path *clisp-driver*
   :arguments (ext:string-concat " -K " *clisp-linkset*)
   :working-directory (namestring (user-homedir-pathname))
   :description "GNU CLISP - ANSI Common Lisp implementation"
   :icon (ext:string-concat *clisp-home* "doc\\clisp.ico"))
  (format t "done~%"))

(defun maybe-make-clisp-shortcut (where dir)
  (let ((lnk-file (ext:string-concat dir "\\GNU CLISP.lnk")))
    (when (y-or-n-p "Create a shortcut to CLISP ~A <~A>?" where lnk-file)
      (make-clisp-shortcut lnk-file))))

(when (y-or-n-p "Use the `full' linking set?")
  (setq *clisp-linkset* "full"))

(when (y-or-n-p "Associate types~:{ <~a>,~} with CLISP?" *lisp-type-map*)
  (with-dir-key-open (c1 :win32 "HKEY_CLASSES_ROOT")
    (loop :for (type . key) :in *lisp-type-map* :do
       (with-dir-key-open (lf c1 type :direction :output)
         (setf (dir-key-value lf "") key)))
    (add-lisp-file c1)
    (add-fas-file c1)
    (add-mem-file c1)))

(let (desktop programs url-file)
  (with-dir-key-open (key :win32 "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders" :direction :input)
    (setq desktop (dir-key-value key "Common Desktop")
          programs (dir-key-value key "Common Programs")))
  (maybe-make-clisp-shortcut "on your desktop" desktop)
  (maybe-make-clisp-shortcut "in your Start menu" programs)
  (setq url-file (ext:string-concat desktop "\\GNU CLISP home.url"))
  (when (y-or-n-p "Create CLISP URL file on your desktop <~a>?" url-file)
    (with-open-file (url (substitute #\/ #\\ url-file) :direction :output)
      (format t "~&writing <~a>..." url-file) (force-output)
      (format url "[Internetshortcut]~%URL=http://clisp.org
IconFile=~adoc\\clisp.ico~%" *clisp-home*)
      (format t "done~%"))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./install.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./inspect.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Inspect
;;;
;;; Copyright (C) 2000-2008,2011 by Sam Steingold
;;; This is Free Software, distributed under the GNU GPL v2+
;;; See http://www.gnu.org/copyleft/gpl.html
;;;
;;; This code is adapted from CLOCC/CLLIB/inspect.lisp.
;;; Please see http://clocc.sourceforge.net/ and
;;; ftp://clocc.sourceforge.net/pub/clocc/snapshots/cllib.html
;;; for details.
;;;
;;; Please do not fork a separate CLISP version of this file!
;;; All changes should go into CLOCC/CLLIB/inspect.lisp first,
;;; and only then merged into this file.
;;; If you encounter a bug in this file, please set sys::*inspect-debug*
;;; to 5 and report all output with a detailed description of what you did
;;; to <clisp-list> (see http://clisp.org about CLISP mailing lists),
;;; as you do with any other CLISP bugs.
;;; If you would like to fix a bug in this file, please get CLOCC from
;;; the link above, build PORT and CLLIB as described there, and work
;;; on CLOCC/CLLIB/inspect.lisp.
;;; ___no patches to this file will be accepted by the CLISP maintainers___
;;;             - Sam Steingold

;;;
;;; utilities from cllib
;;;

(in-package "CUSTOM")
(common-lisp:export
 '(*inspect-frontend* *inspect-browser* *inspect-print-lines*
   *with-html-output-doctype* *user-mail-address*
   *inspect-print-level* *inspect-print-length* *inspect-length*)
 "CUSTOM")
(ext:re-export "CUSTOM" "EXT")

(common-lisp:in-package "EXT")
(export
 '(current-time with-http-output with-html-output)
 "EXT")

(in-package "SYSTEM")

(defun current-time (&optional (out t))
  "Print the current time to the stream (defaults to T)."
  (multiple-value-bind (se mi ho da mo ye) (get-decoded-time)
    (format out "~4d-~2,'0d-~2,'0d ~2,'0d:~2,'0d:~2,'0d"
            ye mo da ho mi se)))

(defmacro string-beg-with (beg strv &optional (lenv `(length ,strv)))
  "Check whether the string STRV starts with BEG."
  (if (stringp beg)
      (let ((len (length beg)))
        `(and (>= ,lenv ,len) (string-equal ,beg ,strv :end2 ,len)))
      (with-gensyms ("SBW-" len)
        `(let ((,len (length ,beg)))
          (and (>= ,lenv ,len) (string-equal ,beg ,strv :end2 ,len))))))

;; The characters which must be replaced before putting a string into HTML
(defvar *html-chars* '((#\< . "&lt;") (#\> . "&gt;") (#\& . "&amp;")))

(clos:defclass html-stream-out (fundamental-character-output-stream)
  ((target-stream :initarg :stream :type stream)))
(clos:defmethod stream-write-char ((stream html-stream-out) ch)
  (clos:with-slots (target-stream) stream
    (let ((char-cons (assoc ch *html-chars* :test #'char=)))
      (if char-cons (write-string (cdr char-cons) target-stream)
          (write-char ch target-stream)))))
(clos:defmethod stream-line-column ((stream html-stream-out)) nil)
(clos:defmethod stream-finish-output ((stream html-stream-out))
  (clos:with-slots (target-stream) stream (finish-output target-stream)))
(clos:defmethod stream-force-output ((stream html-stream-out))
  (clos:with-slots (target-stream) stream (force-output target-stream)))
(clos:defmethod stream-clear-output ((stream html-stream-out))
  (clos:with-slots (target-stream) stream (clear-output target-stream)))
(clos:defmethod close ((stream html-stream-out) &rest opts)
  (clos:with-slots (target-stream) stream (apply #'close target-stream opts))
  (call-next-method))


(defvar *with-html-output-doctype*
  '("html" "PUBLIC" "\"-//W3C//DTD XHTML 1.0 Strict//EN\""
    "\"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\""))
(defvar *user-mail-address*
  (concatenate 'string (or (getenv "USER") (getenv "USERNAME") "nobody") "@"
               (let ((st (machine-instance)))
                 (subseq st 0 (position #\Space st)))))

(defmacro with-html-output ((var stream
                             &key (doctype '*with-html-output-doctype*)
                                  (meta '(:http-equiv "Content-Type"
                                          :content "text/html"))
                                  base comment (title "untitled") (footer t)
                                  head)
                            &body body)
  (with-gensyms ("HTML-" raw mailto)
    `(let* ((,raw ,stream)
            (,var (clos::make-instance 'html-stream-out :stream ,raw))
            (,mailto (concatenate 'string "mailto:" *user-mail-address*)))
      (macrolet ((with-tag ((tag &rest options) &body forms)
                   `(progn (format ,',raw "<~a~@{ ~a=~s~}>" ,tag ,@options)
                     ,@forms (format ,',raw "</~a>~%" ,tag)))
                 (with-tagl ((tag &rest options) &body forms)
                   `(progn (format ,',raw "<~a~@{ ~a=~s~}>" ,tag ,@options)
                     ,@forms (format ,',raw "</~a>" ,tag))))
        (unwind-protect
             (progn
               (format ,raw "<!DOCTYPE~{ ~a~}>~%" ,doctype)
               ;; print the comment
               (format ,raw "<!--~% Created on ") (current-time ,raw)
               (format ,raw "~% by ~a~% using `with-open-html'
 Lisp: ~a ~a~@[~%~a~]~% -->~2%"
                       *user-mail-address*
                       (lisp-implementation-type) (lisp-implementation-version)
                       ,comment)
               (when ,base
                 (with-tag (:base :href ,base)))
               (with-tag (:html)
                 (with-tag (:head ,@head)
                   (with-tag (:meta ,@meta))
                   (with-tag (:link :rev "made" :href ,mailto))
                   (with-tag (:title) (princ ,title ,var)))
                 (with-tag (:body)
                   ,@body
                   (when ,footer
                     (with-tag (:p)
                       (with-tag (:hr))
                       (with-tag (:address)
                         (with-tag (:a :href ,mailto)
                           (princ *user-mail-address* ,var)))
                       (with-tagl (:strong) (current-time ,var)))))))
          (when ,var (close ,var))
          (when ,raw (close ,raw)))))))

(defvar *http-encoding*
  (make-encoding #+UNICODE :charset #+UNICODE charset:utf-8
                 :line-terminator :dos))

(defmacro with-http-output ((var raw &rest opts &key keep-alive (debug 0)
                             (return-code 200) (return-name "OK")
                             &allow-other-keys)
                            &body body)
  "Write some HTML to an http client on socket stream RAW.
Supplies some HTTP/1.0 headers and calls `with-html-output'."
  (with-gensyms ("HTTP-" string vector stream sock header line dbg alive)
    `(let* ((,sock ,raw)
            (,dbg ,debug) (,alive ,keep-alive)
            (,string (with-output-to-string (,stream)
                       (with-html-output (,var ,stream ,@(remove-plist opts :keep-alive :debug :return-code :return-name))
                         ,@body)))
            (,vector (ext:convert-string-to-bytes ,string *http-encoding*))
            (,header (list (format nil "HTTP/1.0 ~d ~a"
                                   ,return-code ,return-name)
                           #+UNICODE "Content-type: text/html; charset=utf-8"
                           #-UNICODE "Content-type: text/html"
                           (format nil "Content-length: ~d" (length ,vector))
                           (format nil "Connection: ~:[close~;keep-alive~]"
                                   ,alive))))
       (dolist (,line ,header)
         (write-line ,line ,sock)
         (when (and ,dbg (> ,dbg 0))
           (format t "<- ~a~%" ,line)))
       (terpri ,sock)
       (setf (stream-element-type ,sock) 'unsigned-byte)
       (write-byte-sequence ,vector ,sock)
       (setf (stream-element-type ,sock) 'character)
       (when (and ,dbg (> ,dbg 3))
         (format t "<- ~s~%" ,string))
       (unless ,alive
         (when (and ,dbg (> ,dbg 0))
           (format t "~s: closing ~s~%" 'with-http-output ,sock))
         (close ,sock)))))

(defun flush-http (sock)
  "Read everything from the HTTP socket SOCK, until a blank line."
  (loop :for line = (read-line sock nil nil)
        :while (and line (plusp (length line)))
        :collect line))

(defun http-error (sock url &key (name "Not Found") (code 404)
                   (keep-alive nil) (debug 0))
  "Report a request error."
  (with-http-output (out sock :keep-alive keep-alive :debug debug
                          :return-code code :return-name name)
    (with-tag (:h1) (princ name out))
    (with-tag (:p)
      (format out "The requested URL ~s was not found on this server." url))))

;;;
;;; options
;;;

(defvar *inspect-frontend* :tty) ; the default frontend
(defvar *inspect-browser* nil)  ; the default browser
(defvar *inspect-print-lines* 5) ; default for `*print-lines*'
(defvar *inspect-print-level* 5) ; default for `*print-level*'
(defvar *inspect-print-length* 10) ; default for `*print-length*'
(defvar *inspect-length* 5)     ; the number of sequence elements to print

(defvar *inspect-all* nil) ; all `inspection' objects in this session
(defparameter *inspect-debug* 0) ; debug level
(defvar *inspect-unbound-value*) ; the value for the unbound slots

;;;
;;; backend
;;;

(defstruct (inspection (:conc-name insp-))
  self                          ; the object being inspected
  (id (fill-pointer *inspect-all*) :type fixnum) ; unique in a session
  (title "" :type string)       ; the short description of the object
  (blurb nil :type list)        ; list of strings with general information
  (up nil :type (or null inspection)) ; parent
  (num-slots 0 :type fixnum)    ; the number of slots
  (pos nil :type (or null fixnum)) ; pos in parent
  (nth-slot nil :type (or null (function (integer) (values t t)))) ; val & name
  (set-slot nil :type (or null (function (integer t) t)))) ; set Nth slot

(defun insp-check (insp)
  ;; this should always be okay, nevertheless
  ;; we use `warn' instead of `assert' or `error' because
  ;; the objects being inspected could possibly be modified
  ;; in another thread
  (let ((up (insp-up insp)) (pos (insp-pos insp)) (id (insp-id insp)))
    (unless (eq insp (aref *inspect-all* id))
      (warn "~s: ~s appears corrupted (~d->~d):~%~s~%~s~%"
            'get-insp '*inspect-all* id (insp-id (aref *inspect-all* id))
            insp (aref *inspect-all* id)))
    (when up
      (unless (< -1 pos (insp-num-slots up))
        (warn "~s: pos out of range: ~d ~d~%" 'insp-check pos
              (insp-num-slots up)))
      (unless (eq (funcall (insp-nth-slot up) pos) (insp-self insp))
        (warn "~s: slot ~d of the ~s has changed:~%~s~%"
              'insp-check pos (insp-self up) up)))))

(defun insp-last-slot (insp)
  (1- (insp-num-slots insp)))
(defun insp-num-slots-print (insp)
  (min (insp-last-slot insp) *inspect-length*))
(defun insp-left-p (insp) ; check for the presence of a left neighbor
  (let ((pos (insp-pos insp)) (up (insp-up insp)))
    (and pos up (< 0 pos))))
(defun insp-right-p (insp) ; check for the presence of a right neighbor
  (let ((pos (insp-pos insp)) (up (insp-up insp)))
    (and pos up (< pos (insp-last-slot up)))))

(defun set-slot-error (ii obj)
  (error "~s: Cannot set the slot number ~s for object ~s"
         'set-slot-error ii obj))

(defmacro with-nth-hash-slot (ht args1 args2 retform)
  (with-gensyms ("WNGS-" ii jj)
    `(lambda (,ii ,@args1)
      (block with-nth-hash-slot
       (let ((,jj -1))
         (maphash (lambda ,args2
                    (declare (ignorable ,@args2))
                    (when (= ,ii (incf ,jj))
                      (return-from with-nth-hash-slot ,retform)))
                  ,ht))))))

(clos:defgeneric inspect-backend (object &rest opts)
  (:method ((obj array) &rest opts)
    (let* ((siz (array-total-size obj)) (type (array-element-type obj))
           (arr (make-array siz :displaced-to obj :element-type type)))
      (apply #'make-inspection :self obj :title
             (typecase obj (string "String") (vector "Vector") (t "Array"))
             :blurb (list (format nil "dimension~p:~{ ~:d~}"
                                  (array-rank obj) (array-dimensions obj))
                          (format nil "element-type: ~s" type)
                          (if (= 1 (array-rank obj))
                              (if (array-has-fill-pointer-p obj)
                                  (format nil "fill-pointer: ~:d"
                                              (fill-pointer obj))
                                  "no fill pointer")
                              (format nil "total size: ~:d" siz))
                          (multiple-value-bind (di off)
                              (array-displacement obj)
                            (if di (format nil "displaced to (~:d): ~s" off di)
                                "not displaced")))
             :num-slots siz :nth-slot (lambda (ii) (aref arr ii))
             :set-slot (lambda (ii val) (setf (aref arr ii) val))
             opts)))
  (:method ((obj hash-table) &rest opts)
    (let ((count (hash-table-count obj)))
      (apply #'make-inspection :self obj :title "Hash Table"
             :blurb (list (format nil "count: ~:d" count)
                          (format nil "size: ~:d" (hash-table-size obj))
                          (format nil "rehash-size: ~:d"
                                  (hash-table-rehash-size obj))
                          (format nil "rehash-threshold: ~:d"
                                  (hash-table-rehash-threshold obj))
                          (format nil "test: ~:d" (hash-table-test obj)))
             :num-slots count :set-slot
             (with-nth-hash-slot obj (val) (kk vv) (setf (gethash kk obj) val))
             :nth-slot
             (with-nth-hash-slot obj nil (kk vv) (values vv kk)) opts)))
  (:method ((obj cons) &rest opts)
    (multiple-value-bind (len dotted-p) (list-length-dotted obj)
      (apply
       #'make-inspection
       :num-slots (if len (if dotted-p (1+ len) len)
                      (1+ (position obj obj :test #'eq)))
       :nth-slot (lambda (ii) (if (and dotted-p (= ii len)) dotted-p
                                  (nth ii obj)))
       :set-slot (lambda (ii val)
                   (if (and dotted-p (= ii len))
                       (setf (cdr (nthcdr (1- ii) obj)) val)
                       (setf (nth ii obj) val)))
       :blurb (list (if len
                        (if dotted-p
                            (if (> len 1)
                                (format nil "a dotted list of length ~:d" len)
                                (format nil "a cons"))
                            (format nil "a list of length ~:d" len))
                        (format nil "a cyclic list")))
       :self obj :title (format nil "Cons") opts)))
  (:method ((obj symbol) &rest opts)
    (apply #'make-inspection :num-slots 2
           :nth-slot (lambda (ii)
                       (case ii
                         (0 (values (if (boundp obj)
                                        (symbol-value obj)
                                        *inspect-unbound-value*)
                                    :symbol-value))
                         (1 (values (symbol-plist obj) :symbol-plist))))
           :set-slot (lambda (ii val)
                       (case ii
                         (0 (setf (symbol-value obj) val))
                         (1 (setf (symbol-plist obj) val))))
           :blurb (list (format nil "package: ~s" (symbol-package obj)))
           :self obj :title "Symbol" opts))
  (:method ((obj structure-object) &rest opts)
    (let ((slots (clos::slot-names obj)))
      (apply #'make-inspection
             :num-slots (length slots)
             :nth-slot (lambda (ii)
                         (let ((slot (nth ii slots)))
                           (values (if (clos:slot-boundp obj slot)
                                       (clos:slot-value obj slot)
                                       *inspect-unbound-value*)
                                   slot)))
             :set-slot (lambda (ii val)
                         (setf (clos:slot-value obj (nth ii slots)) val))
             :self obj :title "structure object"
             :blurb (list (format nil "type: ~s" (type-of obj))) opts)))
  (:method ((obj clos::standard-object) &rest opts)
    (let ((slots (clos::slot-names obj)))
      (apply #'make-inspection
             :num-slots (length slots)
             :nth-slot (lambda (ii)
                         (let ((slot (nth ii slots)))
                           (values (if (clos:slot-boundp obj slot)
                                       (clos:slot-value obj slot)
                                       *inspect-unbound-value*)
                                   slot)))
             :set-slot (lambda (ii val)
                         (setf (clos:slot-value obj (nth ii slots)) val))
             :self obj :title "standard object"
             :blurb (list (format nil "type: ~s" (type-of obj))) opts)))
  (:method ((obj ratio) &rest opts)
    (apply #'make-inspection :self obj :title "rational number"
           :num-slots 2 :nth-slot
           (lambda (ii)
             (if (zerop ii)
                 (values (numerator obj) 'numerator)
                 (values (denominator obj) 'denominator)))
           :set-slot #'set-slot-error opts))
  (:method ((obj complex) &rest opts)
    (apply #'make-inspection :self obj :title "complex number"
           :num-slots 2 :nth-slot
           (lambda (ii)
             (if (zerop ii)
                 (values (realpart obj) 'realpart)
                 (values (imagpart obj) 'imagpart)))
           :set-slot #'set-slot-error opts))
  (:method ((obj t) &rest opts)
    (apply #'make-inspection :self obj :title "atom"
           :blurb (list (format nil "type: ~s" (type-of obj))
                        (format nil "class: ~s" (clos::class-of obj))) opts))
  (:method :around ((obj t) &key id &allow-other-keys)
    (or (and (not id) (find obj *inspect-all* :key #'insp-self))
        (let ((insp (clos::call-next-method)))
          (when (> *inspect-debug* 0)
            (format t "~s [id: ~:d, forced: ~s]: ~s~%" 'inspect-backend
                    (insp-id insp) id (insp-self insp)))
          (if id (setf (aref *inspect-all* id) insp)
              (vector-push-extend insp *inspect-all*))
          insp))))

(defun get-insp (id-or-insp com)
  "Get the INSPECTION object from the ID (or inspection object) and COMmand."
  (let ((insp (etypecase id-or-insp
                (inspection id-or-insp)
                (fixnum (aref *inspect-all* id-or-insp)))))
    (when insp
      (insp-check insp)
      (case com
        (:q :q)
        (:s                     ; re-inspect Self
         (inspect-backend (insp-self insp) :up (insp-up insp)
                          :pos (insp-pos insp) :id (insp-id insp)))
        (:u (insp-up insp))
        (:l (when (insp-pos insp)
              (get-insp (insp-up insp) (1- (insp-pos insp)))))
        (:r (when (insp-pos insp)
              (get-insp (insp-up insp) (1+ (insp-pos insp)))))
        (:w (setq *inspect-length* (* *inspect-length* 2))
            (inspect-backend (insp-self insp) :up (insp-up insp)
                             :pos (insp-pos insp) :id (insp-id insp)))
        (:n (setq *inspect-length* (round *inspect-length* 2))
            (inspect-backend (insp-self insp) :up (insp-up insp)
                             :pos (insp-pos insp) :id (insp-id insp)))
        (t (when (and (integerp com) (< -1 com (insp-num-slots insp)))
             (inspect-backend (funcall (insp-nth-slot insp) com)
                              :up insp :pos com)))))))

;;;
;;; frontends - common
;;;

(clos:defgeneric print-inspection (insp out frontend &rest opts)
  (:method ((insp inspection) (out stream) (frontend t) &rest opts)
    (error "~s: unknown inspect front end: ~s [~s ~s]"
           'print-inspection frontend out opts)))

(clos:defgeneric inspect-frontend (insp frontend)
  (:method ((insp inspection) (frontend t))
    (error "~s: unknown inspect front end: ~s" 'inspect-frontend frontend)))

(clos:defgeneric inspect-finalize (frontend)
  (:method ((frontend t))))

(defun inspect-read-clean-eval (insp stream)
  ;; `read' a form, destructively replace `:self' with INSP and `:slot'
  ;; with the appropriate `funcall', then `eval'
  ;; this is useful for frontends which provide an eval/modify facility
  (labels ((clean (form)
             (cond ((eq (car form) :self)
                    (setf (car form) (list 'quote (insp-self insp)))
                    (clean-up (cdr form)))
                   ((eq (car form) :slot)
                    (setf (car form) 'funcall
                          (cdr form) (cons (insp-nth-slot insp) (cdr form)))
                    (clean-up (cddr form)))
                   (t (clean-up (car form))
                      (clean-up (cdr form)))))
           (clean-up (form) (when (consp form) (clean form)) form))
    (eval (clean-up (read stream nil nil)))))

;;;
;;; TTY frontend
;;;

(clos:defmethod print-inspection ((insp inspection) (out stream)
                                  (backend (eql :tty)) &rest opts)
  (declare (ignore opts))
  (format out "~&~s:  ~a~%~{ ~a~%~}" (insp-self insp) (insp-title insp)
          (insp-blurb insp))
  (when (insp-nth-slot insp)
    (loop :for ii :from 0 :to (insp-num-slots-print insp)
          :do (multiple-value-bind (val name) (funcall (insp-nth-slot insp) ii)
                (format out "~d~@[ [~a]~]:  ~s~%" ii name val)))
    (let ((last (insp-last-slot insp)))
      (when (< *inspect-length* last)
        (format out "~:D more slot~:P available (use :e to increase ~S)"
                (- last *inspect-length*) '*inspect-length*)))))

(clos:defmethod inspect-frontend ((insp inspection) (frontend (eql :tty)))
  (print-inspection insp *terminal-io* frontend)
  (do (com (id (insp-id insp)))
      ((eq com :q))
    (fresh-line)
    (princ "INSPECT-- type :h for help; :q to return to the REPL ---> ")
    (force-output)
    (case (setq com (read *terminal-io* nil :q))
      (:q)
      ((:h :?) (format t " *** commands:~% :h, :?~15t this help
 :p, :a~15t Print the current item Again
 :s~15t re-inspect this item (Self)
 :d~15t Describe the current item
 :w~15t Widen: double ~S and re-inspect
 :n~15t Narrow: halve ~S and re-inspect
" '*inspect-length* '*inspect-length*)
       (when (insp-up insp)
         (format t " :u~15t return UP to the parent~%"))
       (when (insp-left-p insp)
         (format t " :l~15t inspect the Left neighbor~%"))
       (when (insp-right-p insp)
        (format t " :r~15t inspect the Right neighbor~%"))
       (when (insp-nth-slot insp)
         (format t " number~15t inspect this slot~%"))
       (format t " :e lisp-form~15t eval this form, with these substitutions:
 ~20t (:slot number) is replaced with the appropriate slot value
 ~20t :self is replaced with this object
 :m num lisp~15t Modify this slot
 :q~15t return to the main Read/Eval/Print loop~% ---> ")
       (force-output))
      (:d (describe (insp-self insp)))
      ((:p :a) (print-inspection insp *terminal-io* frontend))
      (:e (handler-case (let ((v (inspect-read-clean-eval insp *terminal-io*)))
                          (format t "~&~S~%" v))
            (error (err) (format t " *** error: ~A" err))))
      (:m (handler-case
              (let ((v (funcall (insp-set-slot insp)
                                (inspect-read-clean-eval insp *terminal-io*)
                                (inspect-read-clean-eval insp *terminal-io*))))
                (format t "~&~S~%" v))
            (error (err) (format t " *** error: ~A" err))))
      (t (cond ((setq insp (get-insp id com))
                (print-inspection insp *terminal-io* frontend)
                (setq id (insp-id insp)))
               (t (format t "command `~s' is not valid here~%" com)
                  (setq insp (get-insp id :s))))))))

;;;
;;; HTTP frontend
;;;

(clos:defmethod print-inspection ((insp inspection) (raw stream)
                                  (backend (eql :http)) &key keep-alive)
  (flet ((href (com) (format nil "/~d/~s" (insp-id insp) com)))
    (with-http-output (out raw :keep-alive keep-alive :debug *inspect-debug*
                           :title (insp-title insp) :footer nil)
      (with-tag (:h1) (princ (insp-title insp) out))
      (with-tag (:ul)
        (dolist (item (insp-blurb insp))
          (with-tag (:li) (princ item out))))
      (with-tag (:font :size "+4")
        (with-tag (:pre) (write (insp-self insp) :stream out)))
      (when (insp-nth-slot insp)
        (with-tag (:ol)
          (loop :for ii :from 0 :to (insp-num-slots-print insp)
                :do (multiple-value-bind (val name)
                        (funcall (insp-nth-slot insp) ii)
                      (with-tag (:li)
                        (with-tag (:a :href (href ii))
                          (princ (or name "inspect") out))
                        (with-tag (:pre) (write val :stream out))))))
        (let ((last (insp-last-slot insp)))
          (when (< *inspect-length* last)
            (with-tag (:p)
              (format out "~:D more slot~:P available"
                      (- last *inspect-length*))))))
      (with-tag (:hr))
      (with-tag (:h2) (princ "describe:" out))
      (with-tag (:pre) (describe (insp-self insp) out))
      (with-tag (:hr))  ; footer
      (with-tag (:table :width "100%")
        (with-tag (:tr)
          (with-tag (:td :align "left")
            (with-tag (:a :href (href :q)) (princ "quit" out)))
          (when (insp-left-p insp)
            (with-tag (:td :align "center")
              (with-tag (:a :href (href :l)) (princ "left" out))))
          (when (insp-right-p insp)
            (with-tag (:td :align "center")
              (with-tag (:a :href (href :r)) (princ "right" out))))
          (when (insp-up insp)
            (with-tag (:td :align "center")
              (with-tag (:a :href (href :u)) (princ "parent" out))))
          (with-tag (:td :align "center")
            (format out "~S: " '*inspect-length*)
            (with-tag (:a :href (href :w)) (princ "double" out))
            (princ " " out)
            (with-tag (:a :href (href :n)) (princ "halve" out)))
          (with-tag (:td :align "right")
            (with-tag (:a :href (href :s)) (princ "self" out))))))))

(defun http-command (server &key (debug *inspect-debug*) socket)
  "Accept a connection from the server, return the GET command and the socket."
  (when (> debug 1)
    (format t "~s: server: ~s; socket: ~s~%" 'http-command server socket))
  (let (response id com keep-alive)
    (loop (unless (and socket (open-stream-p socket))
            (setq socket (socket-accept server
                                        :external-format *http-encoding*))
            (when (> debug 1)
              (format t "~s: new socket: ~s~%" 'http-command socket)))
          (setq response (flush-http socket))
          (when response (return))
          ;; connection timed out?
          (close socket))
    (when (> debug 1)
      (dolist (line response)
        (format t "-> ~a~%" line)))
    (dolist (line response)
      (when (string-beg-with "Connection: " line)
        (setq keep-alive (string-equal line "keep-alive" :start1 12))
        (when (> debug 0)
          (format t "~s: connection: ~s (keep-alive: ~s)~%"
                  'http-command (subseq line 12) keep-alive))
        (when keep-alive
          ;; we override `keep-alive' because it makes it impossible to
          ;; switch browsers in the middle of an inspection session
          (setq keep-alive nil)
          (when (> debug 0)
            (format t "~s: overriding keep-alive to NIL~%" 'http-command))))
      (when (string-beg-with "GET /" line)
        (let ((pos (position #\/ line :test #'char= :start 5)))
          (setq id (parse-integer line :start 5 :end pos :junk-allowed t))
          (cond (id
                 (setq com
                       (if (char= #\% (aref line (1+ pos))) ; %xx hex
                           (progn ; "%3a" --> ":"
                             (setf (aref line (+ 3 pos))
                                   (code-char (parse-integer
                                               line :radix 16 :start (+ 2 pos)
                                               :end (+ 4 pos))))
                             (read-from-string line nil nil :start (+ 3 pos)))
                           (read-from-string line nil nil :start (1+ pos))))
                 (when (> debug 0)
                   (format t "~s: command: id=~d com=~s~%"
                           'http-command id com)))
                (t
                 (http-error socket line :debug debug :keep-alive keep-alive)
                 (when (> debug 0)
                   (format t "~s: invalid request: ~s~%"
                           'http-command line)))))))
    (values socket id com keep-alive)))

(clos:defmethod inspect-frontend ((insp inspection) (frontend (eql :http)))
  (let ((server
         (let* ((server (socket-server)) (port (socket-server-port server))
                (host (machine-instance)))
           (when (> *inspect-debug* 0)
             (format t "~&~s [~s]: server: ~s~%"
                     'inspect-frontend frontend server))
           (browse-url (format nil "http://~a:~d/0/:s"
                               (if *inspect-browser* "127.0.0.1"
                                   (subseq host 0 (position #\Space host)))
                               port)
                       :browser *inspect-browser*)
           server))
        sock id com keep-alive)
    (unwind-protect
         (loop (when (eq com :q) (return))
           (setf (values sock id com keep-alive)
                 (http-command server :socket sock))
           (when id
             (if (eq com :q)
               (with-http-output (out sock :keep-alive keep-alive
                                      :debug *inspect-debug*
                                      :title "inspect" :footer nil)
                 (with-tag (:h1) (princ "thanks for using inspect" out))
                 (with-tag (:p) (princ "you may close this window now" out)))
               (if (setq insp (get-insp id com))
                 (print-inspection insp sock frontend :keep-alive keep-alive)
                 (with-http-output (out sock :keep-alive keep-alive
                                        :debug *inspect-debug*
                                        :title "inspect" :footer nil)
                   (with-tag (:h1)
                     (format out "error: wrong command: ~:d/~s" id com))
                   (with-tag (:p)
                     (princ "either this is an old inspect session, or a " out)
                     (with-tag (:a :href "https://sourceforge.net/bugs/?func=addbug&group_id=1802") (princ "bug" out))))))
             (when (> *inspect-debug* 0)
               (format t "~s [~s]: cmd:~d/~s id:~d~%" 'inspect-frontend
                       frontend id com (insp-id insp)))))
      (socket-server-close server)
      (when (open-stream-p sock)
        (do () ((null (read-char-no-hang sock))))
        (close sock)))))
;;;
;;; the juice
;;;

;;;###autoload
(defun inspect (object &key ((:frontend *inspect-frontend*) *inspect-frontend*)
                ((:browser *inspect-browser*) *inspect-browser*))
  (let* ((*print-array* nil) (*print-pretty* t)
         (*print-circle* t) (*print-escape* t)
         (*inspect-length* *inspect-length*)
         (*print-lines* *inspect-print-lines*)
         (*print-level* *inspect-print-level*)
         (*print-length* *inspect-print-length*)
         (*inspect-all* (make-array 10 :fill-pointer 0 :adjustable t))
         (tmp-pack (make-package (gensym "INSPECT-TMP-PACKAGE-")))
         (*package* tmp-pack)
         (*inspect-unbound-value* (intern "#<unbound>" tmp-pack)))
    (unwind-protect
         (inspect-frontend (inspect-backend object) *inspect-frontend*)
      (inspect-finalize *inspect-frontend*)
      (delete-package tmp-pack))
    (values)))

;;; inspect.lisp ends here
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./inspect.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./case-sensitive.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Case-Sensitive Packages for CLISP
;;; Bruno Haible 2004-07-14
;;; Sam Steingold 2005

(in-package "SYSTEM")

;; From CS-COMMON-LISP export all standard symbols which don't have a
;; case-sensitive variant (like SYMBOL-NAME etc).
(let ((cs-cl-package (find-package "CS-COMMON-LISP")))
  (do-external-symbols (standard-sym "COMMON-LISP")
    (let ((cs-sym (find-symbol (symbol-name standard-sym) cs-cl-package)))
      (if cs-sym
        ;; Copy the property list (important for STRING et al.).
        (setf (symbol-plist cs-sym) (copy-list (symbol-plist standard-sym)))
        ;; Use the standard-sym unmodified.
        (progn
          (import (list standard-sym) cs-cl-package)
          (setq cs-sym standard-sym)))
      (export (list cs-sym) cs-cl-package))))

;; #<PACKAGE CS-COMMON-LISP-USER> is the default case-sensitive user package.
(use-package '("CS-COMMON-LISP" "EXT") "CS-COMMON-LISP-USER")
(pushnew "CS-COMMON-LISP" custom:*system-package-list* :test #'string=)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./case-sensitive.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./describe.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Apropos, Describe

(common-lisp:in-package "SYSTEM")
(export
 '(custom::*apropos-matcher* custom::*apropos-do-more*)
 "CUSTOM")
(re-export "CUSTOM" "EXT")

;;-----------------------------------------------------------------------------
;; APROPOS

(defvar *apropos-matcher* nil
  "A function of one argument, a pattern (a string),
returning a new function of one argument, a symbol name (also a string),
which returns non-NIL when the symbol name matches the pattern
for the purposes of APROPOS.
When this variable is NIL, SEARCH is used.")

(defun apropos-list (string &optional (package nil))
  (let* ((L nil)
         (matcher (and *apropos-matcher* (funcall *apropos-matcher* string)))
         (fun (if matcher
                  (lambda (sym)
                    (when (funcall matcher (symbol-name sym))
                      (push sym L)))
                  (lambda (sym)
                    (when
                        ;; (search string (symbol-name sym) :test #'char-equal)
                        (sys::search-string-equal string sym) ; 15x faster!
                      (push sym L))))))
    (if package
      (system::map-symbols fun package)
      (system::map-all-symbols fun))
    (stable-sort (delete-duplicates L :test #'eq :from-end t)
                 #'string< :key #'symbol-name)))

(defvar *apropos-do-more* nil
  "Print values of the symbols in `apropos'.
It can be a list of :FUNCTION, :VARIABLE, :TYPE, :CLASS
to print the corresponding values, or T for all of them.")

(defun apropos-do-more (what)
  (or (eq t *apropos-do-more*) (memq what *apropos-do-more*)))

(defun apropos (string &optional (package nil))
  (dolist (sym (apropos-list string package))
    (format t "~&~S~40t" sym)
    (when (fboundp sym)
      #1=(write-string "   ")   ; spacer
      (write-string (fbound-string sym))
      (when (apropos-do-more :function)
        (format t " [~S]" (fdefinition sym))))
    (when (symbol-macro-expand sym)
      #1# (write-string (TEXT "symbol-macro")))
    (when (boundp sym)
      #1# (if (constantp sym)
            (write-string (TEXT "constant"))
            (write-string (TEXT "variable")))
      (when (apropos-do-more :variable)
        (format t " [~S]" (symbol-value sym))))
    (let ((type (or (get sym 'system::type-symbol)
                    (get sym 'system::defstruct-description))))
      (when type
        #1# (write-string (TEXT "type"))
        (when (apropos-do-more :type)
          (format t " [~S]" type))))
    (let ((class (get sym 'clos::closclass)))
      (when class
        #1# (write-string (TEXT "class"))
        (when (apropos-do-more :class)
          (format t " [~S]" class))))
    (elastic-newline))
  (values))

;;-----------------------------------------------------------------------------
;; DESCRIBE

;; Number of recursive calls since the top-level call.
(defvar *describe-nesting*)

; List of objects which have been described during the current top-level call.
(defvar *describe-done*)

(defun describe-slotted-object (object stream)
  (let ((slotnames (clos::slot-names object)))
    (if slotnames
      (let* ((slotstrings (mapcar #'write-to-string slotnames)) more
             (tabpos (+ *print-indent-lists* 4 (reduce #'max (mapcar #'length slotstrings)))))
        (terpri stream)
        (format stream (TEXT "Slots:"))
        (mapc #'(lambda (slotname slotstring)
                  (format stream "~%~V,0T  ~A~VT"
                          *print-indent-lists* slotstring tabpos)
                  (cond ((clos:slot-boundp object slotname)
                         (format stream "=  ~S" (clos:slot-value object slotname))
                         (pushnew (clos:slot-value object slotname) more))
                        ((format stream (TEXT "unbound")))))
              slotnames slotstrings)
        (dolist (vv (nreverse more)) (describe vv stream)))
      (progn
        (terpri stream)
        (format stream (TEXT "No slots."))))))

(defun launch-doc (obj type stream name kind)
  (when (zerop *describe-nesting*)
    (let ((doc (documentation obj type)))
      (when doc
        (if *browser*
            (ext::browse-url doc :out stream)
            (format stream name kind doc))))))

(defvar *squeeze-string-max* 100)
(defvar *squeeze-string-section* 10) ; at most half of *squeeze-string-max*
(defun squeeze-string (string &key (start 0) (end (length string)))
  (let* ((len (length string))
         (prefix (if (= start 0) "" "..."))
         (suffix (if (= end len) "" "...")))
    (cond ((> *squeeze-string-max* len) string)
          ((> *squeeze-string-max* (- end start))
           (string-concat prefix (subseq string start end) suffix))
          (t (string-concat
              prefix (subseq string start (+ start *squeeze-string-section*))
              "..." (subseq string (- end *squeeze-string-section*)) suffix)))))

(clos:defgeneric describe-object (obj stream)
  (declare (dynamically-modifiable))
  (:method ((obj t) (stream stream))
    (ecase (type-of obj)
      #+MT
      (MT:THREAD
       (format stream (TEXT "a thread object.")))
      #+MT
      (MT:MUTEX
       (format stream (TEXT "a mutually exclusive thread lock.")))
      #+MT
      (MT:EXEMPTION
       (format stream (TEXT "a thread condition variable.")))
      #+(or UNIX FFI WIN32)
      (EXT::FOREIGN-POINTER
       (format stream (TEXT "a foreign pointer.")))
      #+FFI
      (FFI::FOREIGN-ADDRESS
       (format stream (TEXT "a foreign address.")))
      #+FFI
      (FFI::FOREIGN-VARIABLE
       (format stream (TEXT "a foreign variable of foreign type ~S.")
               (ffi::deparse-c-type (sys::%record-ref obj 4)))) ; fv_type
      #+SOCKETS
      (SOCKET-SERVER
       (format stream (TEXT "a server socket accepting connections.")))
      (BYTE
       (format stream (TEXT "a byte specifier, denoting the ~S bits starting at bit position ~S of an integer.")
               (byte-size obj) (byte-position obj)))
      (EXT:SPECIAL-OPERATOR
       (format stream (TEXT "a special form handler.")))
      (EXT:LOAD-TIME-EVAL
       (format stream (TEXT "a load-time evaluation promise.")))
      (EXT:SYMBOL-MACRO
       (format stream (TEXT "a symbol macro handler.")))
      (EXT:GLOBAL-SYMBOL-MACRO
       (format stream (TEXT "a global symbol macro handler.")))
      (SYS::MACRO
       (format stream (TEXT "a macro expander."))
       (let ((name (sys::closure-name (sys::macro-expander obj))))
         (describe-arglist stream name)
         (terpri stream)
         (format stream (TEXT "For more information, evaluate ~{~S~^ or ~}.")
                 `((DISASSEMBLE (MACRO-FUNCTION ',name))))))
      (EXT:FUNCTION-MACRO
       (format stream (TEXT "a function with alternative macro expander.")))
      (EXT:ENCODING
       (format stream (TEXT "an encoding.")))
      (EXT:WEAK-POINTER
       (multiple-value-bind (value validp) (weak-pointer-value obj)
         (if validp
           (progn
             (format stream (TEXT "a GC-invisible pointer to ~S.")
                     value)
             (describe value stream))
           (format stream (TEXT "a GC-invisible pointer to a now defunct object.")))))
      (EXT:WEAK-LIST
       (let ((remaining (weak-list-list obj)))
         (if remaining
           (format stream (TEXT "a list of GC-invisible pointers to ~{~S~^, ~}.")
                   remaining)
           (format stream (TEXT "a list of GC-invisible pointers, all defunct by now.")))))
      (EXT:WEAK-AND-RELATION
       (let ((remaining (weak-and-relation-list obj)))
         (if remaining
           (format stream (TEXT "a weak \"and\" relation between ~{~S~^, ~}.")
                   remaining)
           (format stream (TEXT "a weak \"and\" relation, no longer referring to its objects.")))))
      (EXT:WEAK-OR-RELATION
       (let ((remaining (weak-or-relation-list obj)))
         (if remaining
           (format stream (TEXT "a weak \"or\" relation between ~{~S~^, ~}.")
                   remaining)
           (format stream (TEXT "a weak \"or\" relation, all elements defunct by now.")))))
      (EXT:WEAK-MAPPING
       (multiple-value-bind (key value alive) (weak-mapping-pair obj)
         (if alive
           (format stream (TEXT "a weak association from ~S to ~S.") key value)
           (format stream (TEXT "a weak association, the key value being defunct by now.")))))
      (EXT:WEAK-AND-MAPPING
       (multiple-value-bind (keys value alive) (weak-and-mapping-pair obj)
         (if alive
           (format stream (TEXT "a weak \"and\" mapping from ~:S to ~S.") keys value)
           (format stream (TEXT "a weak \"and\" mapping, some key value being defunct by now.")))))
      (EXT:WEAK-OR-MAPPING
       (multiple-value-bind (keys value alive) (weak-or-mapping-pair obj)
         (if alive
           (format stream (TEXT "a weak \"or\" mapping from ~:S to ~S.") keys value)
           (format stream (TEXT "a weak \"or\" mapping, all keys being defunct by now.")))))
      (EXT:WEAK-ALIST
       (let ((type (weak-alist-type obj))
             (remaining (weak-alist-contents obj)))
         (format stream (TEXT "a weak association list, of type ~S ") type)
         (ecase type
           (:KEY    (format stream (TEXT "(i.e. a list of ~S key/value pairs)") 'EXT:WEAK-MAPPING))
           (:VALUE  (format stream (TEXT "(i.e. a list of ~S value/key pairs)") 'EXT:WEAK-MAPPING))
           (:KEY-AND-VALUE (format stream (TEXT "(i.e. a list of (key . value) pairs each combined into a ~S)") 'EXT:WEAK-AND-RELATION))
           (:KEY-OR-VALUE  (format stream (TEXT "(i.e. a list of (key . value) pairs each combined into a ~S)") 'EXT:WEAK-OR-RELATION)))
         (if remaining
           (format stream (TEXT ", containing ~S.") remaining)
           (format stream (TEXT ", no longer referring to any pairs.")))))
      (SYS::READ-LABEL
       (format stream (TEXT "a label used for resolving #~D# references during READ.")
               (logand (sys::address-of obj)
                       (load-time-value (ash most-positive-fixnum -1)))))
      (FRAME-POINTER
       (format stream (TEXT "a pointer into the stack. It points to:"))
       (sys::describe-frame stream obj))
      (SYSTEM-INTERNAL
       (format stream (TEXT "a special-purpose object.")))
      (ADDRESS
       (format stream (TEXT "a machine address.")))))
  (:method ((obj clos:standard-object) (stream stream))
    (format stream (TEXT "an instance of the CLOS class ~S.")
            (clos:class-of obj))
    (describe-slotted-object obj stream))
  (:method ((obj clos:funcallable-standard-object) (stream stream))
    (format stream (TEXT "an instance of the CLOS class ~S, can be used as a function.")
            (clos:class-of obj))
    (describe-slotted-object obj stream))
  (:method ((obj structure-object) (stream stream)) ; CLISP specific
    (format stream (TEXT "a structure of type ~S.")
            (type-of obj))
    (let ((types (butlast (cdr (sys::%record-ref obj 0))))) ; structure_types
      (when types
        (terpri stream)
        (format stream (TEXT "As such, it is also a structure of type ~{~S~^, ~}.")
                types)))
    (describe-slotted-object obj stream))
  (:method ((obj cons) (stream stream))
    (multiple-value-bind (len dotted-p) (list-length-dotted obj)
      (if len
        (if dotted-p
          (if (> len 1)
            (format stream (TEXT "a dotted list of length ~S.")
                    len)
            (progn
              (format stream (TEXT "a cons."))
              (describe (car obj) stream)
              (describe (cdr obj) stream)))
          (format stream (TEXT "a list of length ~S.")
                  len))
        (format stream (TEXT "a cyclic list.")))))
  (:method ((obj null) (stream stream))
    (format stream (TEXT "the empty list, "))
    (clos:call-next-method))
  (:method ((obj symbol) (stream stream))
    (format stream (TEXT "the symbol ~S, ")
            obj)
    (let ((home (symbol-package obj)) mored moree)
      (cond (home
             (format stream (TEXT "lies in ~S")
                     home)
             (pushnew home mored))
            (t (format stream (TEXT "is uninterned"))))
      (let ((accessible-packs nil))
        (let ((*print-escape* t) (*print-readably* nil))
          (let ((normal-printout
                 (if home
                   (let ((*package* home)) (prin1-to-string obj))
                   (let ((*print-gensym* nil)) (prin1-to-string obj)))))
            (dolist (pack (list-all-packages))
              (when ; obj in pack accessible?
                  (string=
                   (let ((*package* pack)) (prin1-to-string obj))
                   normal-printout)
                (push pack accessible-packs)))))
        (when accessible-packs
          (format stream (TEXT ", is accessible in ~:d package~:p ~{~A~^, ~}")
                  (length accessible-packs)
                  (sort (mapcar #'package-name accessible-packs)
                        #'string<))))
      (when (keywordp obj)
        (format stream (TEXT ", is a keyword")))
      (when (symbol-macro-expand obj)
        (format stream (TEXT ", symbol-macro expanding to: ~S")
                (macroexpand-1 obj))
        (push `(macroexpand-1 ',obj) moree))
      (cond ((boundp obj)
             (if (constantp obj)
               (format stream (TEXT ", a constant"))
               (if (sys::special-variable-p obj)
                 (format stream (TEXT ", a variable declared SPECIAL"))
                 (format stream (TEXT ", a variable"))))
             (format stream (TEXT ", value: ~s") (symbol-value obj))
             (pushnew (symbol-value obj) mored))
            ((sys::special-variable-p obj)
             (format stream (TEXT ", an unbound variable declared SPECIAL"))))
      (when (fboundp obj)
        (format stream (TEXT ", names "))
        (cond ((special-operator-p obj)
               (format stream (TEXT "a special operator"))
               (when (macro-function obj)
                 (format stream (TEXT " with macro definition"))))
              ((functionp (symbol-function obj))
               (format stream (TEXT "a~:[~; deprecated~] function")
                       (assoc obj *deprecated-functions-alist* :test #'eq)))
              (t ; (macro-function obj)
               (format stream (TEXT "a~:[~; deprecated~] macro")
                       (assoc obj *deprecated-functions-alist* :test #'eq))))
        (let ((dep (get obj 'deprecated)))
          (when dep
            (format stream (TEXT " (use ~S instead)") dep)))
        (pushnew (symbol-function obj) mored))
      (when (or (get obj 'system::type-symbol)
                (get obj 'system::defstruct-description)
                (get obj 'system::deftype-expander))
        (format stream (TEXT ", names a type"))
        (when (get obj 'system::deftype-expander)
          (push `(type-expand ',obj t) moree)))
      (when (clos::defined-class-p (get obj 'clos::closclass))
        (format stream (TEXT ", names a class")))
      #+FFI
      (multiple-value-bind (expansion found-p)
          (gethash obj ffi::*c-type-table*)
        (when found-p
          (cond ((eq expansion obj)
                 (format stream (TEXT ", names a built-in foreign type")))
                (t (format stream (TEXT ", names a foreign type"))
                   (push `(gethash ',obj ffi::*c-type-table*) moree)))))
      (when (symbol-plist obj)
        (let ((properties
               (do ((l nil) (pl (symbol-plist obj) (cddr pl)))
                   ((null pl) (nreverse l))
                 (push (car pl) l))))
          (format stream (TEXT ", has ~:D propert~@:P ~{~S~^, ~}")
                  (length properties) properties))
        (push `(symbol-plist ',obj) moree))
      (format stream (TEXT "."))
      (dolist (ty '(compiler-macro setf structure type variable function))
        (let ((doc (documentation obj ty)))
          (when doc
            (terpri stream)
            (format stream (TEXT "Documentation as a ~A:") ty)
            (terpri stream)
            (princ doc stream))))
      (launch-doc obj 'ext::clhs ; change to sys::clhs when ext:clhs is finally removed
                  stream (TEXT "~%~A Documentation is at~% ~S") :ansi-cl)
      (launch-doc obj 'sys::impnotes stream
                  (TEXT "~%~A Documentation is at~% ~S") :clisp)
      (when moree
        (terpri stream)
        (format stream (TEXT "For more information, evaluate ~{~S~^ or ~}.")
                moree))
      (dolist (zz (nreverse mored)) (describe zz stream))))
  (:method ((obj integer) (stream stream))
    (format stream (TEXT "an integer, uses ~S bit~:P, is represented as a ~:[bignum~;fixnum~].")
            (integer-length obj) (sys::fixnump obj)))
  (:method ((obj ratio) (stream stream))
    (format stream (TEXT "a rational, not integral number.")))
  (:method ((obj float) (stream stream))
    (format stream (TEXT "a float with ~S bits of mantissa (~(~A~)).")
            (float-digits obj) (type-of obj)))
  (:method ((obj complex) (stream stream))
    (format stream (TEXT "a complex number "))
    (let ((x (realpart obj))
          (y (imagpart obj)))
      (if (zerop y)
        (if (zerop x)
          (format stream (TEXT "at the origin"))
          (format stream (TEXT "on the ~:[posi~;nega~]tive real axis")
                  (minusp x)))
        (if (zerop x)
          (format stream (TEXT "on the ~:[posi~;nega~]tive imaginary axis")
                  (minusp y))
          (format stream (TEXT "in the ~:[~:[first~;fourth~]~;~:[second~;third~]~] quadrant")
                  (minusp x) (minusp y)))))
    (format stream (TEXT " of the Gaussian number plane.")))
  (:method ((obj character) (stream stream))
    (format stream (TEXT "a character"))
    (format stream (TEXT "."))
    #+UNICODE
    (let ((unicode-name (unicode-attributes obj)))
      (terpri stream)
      (if unicode-name
        (format stream (TEXT "Unicode name: ~A") unicode-name)
        (format stream (TEXT "It is not defined by the Unicode standard."))))
    (terpri stream)
    (format stream (TEXT "It is a ~:[non-~;~]printable character.")
            (graphic-char-p obj))
    (unless (standard-char-p obj)
      (terpri stream)
      (format stream (TEXT "Its use is non-portable."))))
  (:method ((obj stream) (stream stream))
    (format stream (TEXT "a~:[~:[ closed ~;n output-~]~;~:[n input-~;n input/output-~]~]stream.")
            (and (input-stream-p obj) (open-stream-p obj))
            (and (output-stream-p obj) (open-stream-p obj)))
    (when (sys::string-stream-p obj)
      (multiple-value-bind (string start end) (sys::string-stream-string obj)
        (if (and start end)     ; STRING-INPUT-STREAM
            (format stream (TEXT " It reads from ~S from ~:D to ~:D at ~:D.")
                    (squeeze-string string :start start :end end)
                    start end (sys::string-input-stream-index obj))
            (format stream (TEXT " It appends to ~S.")
                    (squeeze-string string))))))
  (:method ((obj package) (stream stream))
    (if (package-name obj)
      (progn
        (format stream (TEXT "the package named ~A")
                (package-name obj))
        (let ((nicknames (package-nicknames obj)))
          (when nicknames
            (format stream (TEXT ". It has ~:D nickname~:P ~{~A~^, ~}")
                    (length nicknames) nicknames)))
        (format stream (TEXT "."))
        (let ((use-list (package-use-list obj))
              (used-by-list (package-used-by-list obj)))
          (terpri stream)
          (format stream (TEXT "It "))
          (when use-list
            (format stream (TEXT "imports the external symbols of ~:D package~:P ~{~A~^, ~} and ")
                    (length use-list)
                    (mapcar #'package-name use-list)))
          (let ((L nil) (count 0)) ; maybe list all exported symbols
            (do-external-symbols (s obj) (push s L) (incf count))
            (format stream
                    (TEXT "exports ~[no symbols~:;~:*~:D symbol~:P~]")
                    count)
            (when (zerop *describe-nesting*)
              (format stream (TEXT "~{ ~S~^,~}")
                      (sort L #'string< :key #'symbol-name))))
          (if used-by-list
            (format stream (TEXT " to ~:D package~:P ~{~A~^, ~}")
                    (length used-by-list)
                    (mapcar #'package-name used-by-list))
            (format stream (TEXT ", but no package uses these exports")))
          (format stream (TEXT "."))
          (let ((case-inverted-p (package-case-inverted-p obj))
                (case-sensitive-p (package-case-sensitive-p obj))
                (uses-cl (memq (find-package "COMMON-LISP") use-list))
                (uses-cs-cl (memq (find-package "CS-COMMON-LISP") use-list)))
            (cond ((and (not case-inverted-p) (not case-sensitive-p)
                        (not uses-cs-cl)))
                  ((and case-inverted-p case-sensitive-p (not uses-cl))
                   (terpri stream)
                   (format stream (TEXT "It is a modern case-sensitive package.")))
                  (t
                   (terpri stream)
                   (format stream (TEXT "ATTENTION: "))
                   (if case-inverted-p
                     (if case-sensitive-p
                       (format stream (TEXT "It is a modern case-sensitive package, but uses the symbols from the traditional ~S!")
                               (find-package "COMMON-LISP"))
                       (format stream (TEXT "It is case-inverted, but not case-sensitive!")))
                     (if case-sensitive-p
                       (format stream (TEXT "It is case-sensitive, but not case-inverted!"))
                       (format stream (TEXT "It is a traditional ANSI CL compatible package, but uses the symbols from the modern ~S!")
                               (find-package "CS-COMMON-LISP"))))))))
        (launch-doc obj 'sys::impnotes stream
                    (TEXT "~%~A Documentation is at~% ~S") :clisp))
      (format stream (TEXT "a deleted package."))))
  (:method ((obj hash-table) (stream stream))
    (let ((count (hash-table-count obj)))
      (format stream (TEXT "an ~S hash table with ~[no entries~:;~:*~:D entr~@:P~].")
              (hash-table-test obj) count)))
  (:method ((obj readtable) (stream stream))
    (format stream (TEXT "~:[a~;the Common Lisp~] readtable.")
            (equalp obj (copy-readtable))))
  (:method ((obj pathname) (stream stream))
    (format stream (TEXT "a ~:[~;portable ~]pathname~:[.~;~:*, with the following components:~{~A~}~]")
            (sys::logical-pathname-p obj)
            (mapcan #'(lambda (kw component)
                        (case component
                          ((nil :unspecific)) ; ignore
                          (t (list (format nil "~%~A = ~S" kw component)))))
                    '(:host :device :directory :name :type :version)
                    (list (pathname-host obj)
                          (pathname-device obj)
                          (pathname-directory obj)
                          (pathname-name obj)
                          (pathname-type obj)
                          (pathname-version obj)))))
  (:method ((obj random-state) (stream stream))
    (format stream (TEXT "a random-state.")))
  (:method ((obj array) (stream stream))
    (let ((rank (array-rank obj))
          (eltype (array-element-type obj)))
      (format stream (TEXT "a~:[~; simple~] ~A dimensional array")
              (simple-array-p obj) rank)
      (when (eql rank 1)
        (format stream (TEXT " (vector)")))
      (case eltype
        ((T))
        ((NIL) (write-string (TEXT " with no storage") stream))
        (OTHERWISE (format stream (TEXT " of ~As") eltype)))
      (when (adjustable-array-p obj)
        (format stream (TEXT ", adjustable")))
      (when (plusp rank)
        (format stream (TEXT ", of size ~{~S~^ x ~}")
                (array-dimensions obj))
        (when (array-has-fill-pointer-p obj)
          (format stream (TEXT " and current length (fill-pointer) ~S")
                  (fill-pointer obj))))
      (when (and (stringp obj) (not (eq eltype 'NIL)))
        #-UNICODE
        (format stream (TEXT " (a string)"))
        #+UNICODE
        (multiple-value-bind (bits ro-p realloc) (sys::string-info obj)
          (format stream (TEXT " (a~:[~;n immutable~] ~:[~;reallocated ~]~A string)")
                  ro-p realloc
                  (case bits (8 "ISO-8859-1") (16 "UCS-2") (32 "UCS-4")))))
      (format stream (TEXT "."))))
  (:method ((obj generic-function) (stream stream))
    (format stream (TEXT "a generic function."))
    (unless (clos::generic-function-undeterminedp obj)
      (terpri stream)
      (format stream (TEXT "Argument list: ~:S")
              (clos:generic-function-lambda-list obj)))
    (let ((mc (clos::method-combination-name (clos:generic-function-method-combination obj))))
      (unless (eq mc 'STANDARD)
        (terpri stream)
        (format stream (TEXT "Method combination: ~S") mc)))
    (let ((methods (clos:generic-function-methods obj)))
      (terpri stream)
      (if methods
        (progn
          (format stream (TEXT "Methods:"))
          (dolist (meth (clos:generic-function-methods obj))
            (format stream "~%  ~{~S ~}~S" (clos:method-qualifiers meth)
                    (mapcar #'(lambda (specializer)
                                (setq specializer (clos::specializer-pretty specializer))
                                (if (and (clos::defined-class-p specializer)
                                         (eq (find-class (class-name specializer) nil)
                                             specializer))
                                  (class-name specializer)
                                  specializer))
                            (clos:method-specializers meth)))))
        (format stream (TEXT "No methods.")))))
  (:method ((obj function) (stream stream))
    (ecase (type-of obj)        ; not etypecase!
      #+FFI
      (FFI::FOREIGN-FUNCTION
       (format stream (TEXT "a foreign function of foreign type ~S.")
               (ffi::deparse-c-type
                (vector 'ffi::c-function
                        (sys::%record-ref obj 3) ; ff_resulttype
                        (sys::%record-ref obj 4) ; ff_argtypes
                        (sys::%record-ref obj 5))))) ; ff_flags
      (COMPILED-FUNCTION
       (let ((subrp (sys::subr-info obj)))
         (format stream (if subrp
                            (TEXT "a built-in system function.")
                            (TEXT "a compiled function.")))
         (describe-arglist stream obj)
         (describe-documentation stream obj)
         (let* ((name (sys::function-name obj))
                (funform (cond ((and (symbolp name) (macro-function name))
                                `(MACRO-FUNCTION ',name))
                               ((fboundp name) `(FUNCTION ,name)))))
           (when funform
             (terpri stream)
             (format stream
                     (TEXT "For more information, evaluate ~{~S~^ or ~}.")
                     `((DISASSEMBLE ,funform)))))))
      (FUNCTION
       ;; we do not use ETYPECASE here to ensure that if we do get here,
       ;; we are dealing with an Iclosure object
       (format stream (TEXT "an interpreted function."))
       (describe-arglist stream obj)
       (describe-documentation stream obj)))))

(defun describe1 (obj stream)
  (let ((objstring (sys::write-to-short-string
                    obj (or *print-right-margin* sys::*prin-linelength*))))
    (fresh-line stream)
    (terpri stream) ; blank line
    (if (memq obj *describe-done*)
      (with-stream-s-expression (stream)
        (format stream (TEXT "~A [see above]") objstring))
      (let ((doc (and (symbolp obj) (get obj 'sys::doc))))
        (push obj *describe-done*)
        (with-stream-s-expression (stream)
          (format stream (TEXT "~A is ") objstring))
        (describe-object obj stream)
        (fresh-line stream)
        (when doc
          (terpri stream) ; blank line
          (format stream (TEXT "Documentation:"))
          (do ((tail doc (cddr tail)))
              ((endp tail))
            (format stream "~&~S:~%~S" (car tail) (cadr tail)))
          (fresh-line stream)))))
  (finish-output stream))

;; A private class through which we can distinguish recursive describe calls
;; from top-level calls.
(defclass describe-stream (fill-stream)
  ())

(defun describe (obj &optional stream)
  (cond ((typep stream 'describe-stream) ; Recursive call
         ;; flush the pending output _before_ increasing indentation
         (force-output stream)
         (let ((*describe-nesting* (1+ *describe-nesting*))
               (*print-right-margin*
                (max (- (or *print-right-margin* sys::*prin-linelength*)
                        *print-indent-lists*)
                     1)))
           (describe1 obj stream)))
        (t                      ; Top-level call
         (cond ((eq stream 'nil) (setq stream *standard-output*))
               ((eq stream 't) (setq stream *terminal-io*)))
         (let ((*print-circle* t)
               (*describe-nesting* 0)
               (*describe-done* nil))
           (describe1 obj (clos:make-instance 'describe-stream
                           :stream stream
                           :text-indent '*describe-nesting*)))))
  (values))

;;-----------------------------------------------------------------------------
;; auxiliary functions for DESCRIBE of FUNCTION

(defun arglist (func)
  (cond ((and (symbolp func) (fboundp func)
              (sys::macrop (symbol-function func)))
         (sys::macro-lambda-list (symbol-function func)))
        ((typep (setq func (coerce func 'function)) 'generic-function)
         ;; Generic functions store the original lambda-list.
         (clos:generic-function-lambda-list func))
        ((or (sys::subr-info func) ; built-in
             #+FFI (eq (type-of func) 'FFI::FOREIGN-FUNCTION))
         (sig-to-list (get-signature func)))
        ((sys::%compiled-function-p func) ; compiled closure
         (or (sys::closure-lambda-list func)
             (sig-to-list (get-signature func))))
        ((sys::closurep func) ; interpreted closure?
         (car (sys::%record-ref func 1))))) ; clos_form

(defun describe-arglist (stream function)
  (terpri stream)
  (format stream (TEXT "Argument list: ~:S")
          (handler-case (arglist function)
            (error (c) (princ-to-string c)))))

(defun describe-documentation (stream function)
  (let ((doc (clos::function-documentation function)))
    (when doc
      (terpri stream)
      (format stream (TEXT "Documentation: ~A") doc))))

;;-----------------------------------------------------------------------------
;; auxiliary functions for CLISP metadata

(defun clisp-data-file (name)
  ;; [ $(lisplibdir) == *lib-directory* ]/data/name
  (let ((*merge-pathnames-ansi* t) path
        (data (make-pathname :directory (list :relative "data"))))
    (assert (probe-file
             (setq path (merge-pathnames
                         name (merge-pathnames data *lib-directory*))))
            (*lib-directory*) (TEXT "~S: file ~S does not exist - adjust ~S")
            'clisp-data-file path '*lib-directory*)
    path))

;;-----------------------------------------------------------------------------
;; auxiliary functions for DESCRIBE of CHARACTER

#+UNICODE (progn

;; Return the line associated with a Unicode code in the Unicode data file.
;; Returns a simple-string or nil. Also used by the CHAR-NANE function.
(defun unicode-attributes-line (code)
  (with-open-file (f (clisp-data-file "UnicodeDataFull.txt")
                     :direction :input
                     :element-type 'character
                     :external-format 'charset:ascii)
    ;; We know that the file's lines are sorted according to the code, and
    ;; we use this fact to perform a fast binary search.
    (flet ((code-at-pos ()
             ; Returns the code of the first line contained after the current
             ; position.
             (if (read-line f nil nil)
               (let ((c1 (read-char f nil nil))
                     (c2 (read-char f nil nil))
                     (c3 (read-char f nil nil))
                     (c4 (read-char f nil nil)))
                 (if (and c1 c2 c3 c4)
                   (let ((c5 (read-char f nil nil)))
                     (if (and c5 (digit-char-p c5 16))
                       (let ((c6 (read-char f nil nil)))
                         (if (and c6 (digit-char-p c6 16))
                           (parse-integer
                             (coerce (list c1 c2 c3 c4 c5 c6) 'string)
                             :radix 16
                           )
                           (parse-integer
                             (coerce (list c1 c2 c3 c4 c5) 'string)
                             :radix 16
                       ) ) )
                       (parse-integer
                         (coerce (list c1 c2 c3 c4) 'string)
                         :radix 16
                   ) ) )
                   #x1000000
               ) )
               #x1000000
          )) )
      (let* ((blocksize 1024)
             (f-size (progn (file-position f :end) (file-position f)))
             (lblock 0) ; lower bound for block number
             (rblock (1+ (floor f-size blocksize))))
        ; The block number where the line starts is >= lblock, < rblock.
        (loop
          (when (= (- rblock lblock) 1) (return))
          (let ((mblock (ash (+ lblock rblock) -1)))
            (file-position f (* mblock blocksize))
            (if (> (code-at-pos) code)
              (setq rblock mblock)
              (setq lblock mblock)
        ) ) )
        ; Sequentially read the block, searching for the first line whose
        ; number is >= code.
        (file-position f (* lblock blocksize))
        (when (plusp code) ; hack to make code=0000 work
          (read-line f nil nil)
        )
        (loop
          (let ((line (read-line f nil nil)))
            (unless line (return nil))
            (let* ((four (position #\; line)) ; 4 or 5 or 6
                   (c (parse-integer line :end four :radix 16)))
              ; Treat the range start/end lines specially.
              (when (eql (char line four) #\;)
                (when (eql (char line (+ four 1)) #\<)
                  (let* ((piece1 (subseq line (+ four 1)
                                              (or (position #\; line
                                                            :start (+ four 1))
                                                  (length line))))
                         (n (length piece1)))
                    (cond ((and (= c code)
                                (>= n 8)
                                (string= piece1 ", First>" :start1 (- n 8))
                           )
                           (return
                             (concatenate 'string
                               (format nil "~4,'0X" code)
                               (subseq line four (+ four n -8 1))
                               (subseq line (+ four n))
                          )) )
                          ((and (>= c code)
                                (>= n 7)
                                (string= piece1 ", Last>" :start1 (- n 7))
                           )
                           (return
                             (concatenate 'string
                               (format nil "~4,'0X" code)
                               (subseq line four (+ four n -7 1))
                               (subseq line (+ four n))
                          )) )
              ) ) ) )
              (if (= c code) (return line))
              (if (> c code) (return nil))
        ) ) )
) ) ) )

;; Return the Unicode attributes of a character, as 14 values,
;; or NIL if the character is not defined in the Unicode standard.
;; The values are:
;;  1. Character name.
;;  2. General category.
;;  3. Canonical combining classes.
;;  4. Bidirectional category.
;;  5. Character decomposition.
;;  6. Decimal digit value.
;;  7. Digit value.
;;  8. Numeric value.
;;  9. mirrored-p.
;; 10. Old Unicode 1.0 name.
;; 11. Comment.
;; 12. Upper case equivalent mapping.
;; 13. Lower case equivalent mapping.
;; 14. Title case equivalent mapping.
(defun unicode-attributes (ch)
  (let ((line (unicode-attributes-line (char-code ch))))
    (when line
      (let ((pieces
             (loop :for pos = 0 :then (1+ semicolon-pos)
               :for semicolon-pos = (position #\; line :start pos)
               :collect (subseq line pos (or semicolon-pos (length line)))
               :do (unless semicolon-pos (loop-finish)))))
        (assert (= (parse-integer (nth 0 pieces) :radix 16) (char-code ch)))
        (values-list
         (append
          (mapcar #'(lambda (x) (if (equal x #1="") nil x))
                  (subseq pieces 1 12))
          (mapcar #'(lambda (x)
                      (if (equal x #1#) nil
                          (code-char (parse-integer x :radix 16))))
                  (subseq pieces 12 15))))))))

) ; #+UNICODE

;;-----------------------------------------------------------------------------

;; DOCUMENTATION mit abfragen und ausgeben??
;; function, variable, type, structure, setf
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./describe.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./disassem.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CLISP disassembler
;; Sam Steingold: converted to CLOS 2001-06-16

(in-package "SYS")

(defun orig-fundef (object)
  (unless (fboundp object)
    (error-of-type 'undefined-function
      :name object (TEXT "Undefined function ~S") object))
  (let* ((name (get-funname-symbol object))
         (def (or (get name 'sys::traced-definition)
                  (symbol-function name))))
    (if (macrop def) (macro-expander def) def)))

(defgeneric disassemble (object &key qualifiers specializers)
  (:documentation "disassemble the OBJECT, which should be a function.
if QUALIFIERS or SPECIALIZERS is given, OBJECT should be a generic function.")
  #+UNIX (:method ((object string) &rest junk)
           (declare (ignore junk))
           (disassemble-machine-code
            (sys::program-name) (sys::process-id) nil object))
  (:method ((object method) &key &allow-other-keys)
    (disassemble (method-function object)))
  (:method ((object clos::standard-method) &key &allow-other-keys)
    (disassemble (or (clos::std-method-fast-function object)
                     (clos::std-method-function object))))
  (:method ((object standard-generic-function) &key qualifiers specializers)
    (if (or qualifiers specializers)
        (disassemble (find-method object qualifiers
                                  (mapcar #'find-class specializers)))
        (sys::disassemble-closure object)))
  (:method ((object symbol) &rest opts)
    (apply #'disassemble
           (if (ext:symbol-macro-expand object)
               (coerce `(lambda () ,object) 'function)
               (orig-fundef object))
           opts))
  (:method ((object cons) &rest opts)
    (apply #'disassemble
           (if (function-name-p object)
               (orig-fundef object)
               (coerce (if (eq 'lambda (car object))
                           object `(lambda () ,object))
                       'function))
           opts))
  (:method ((object t) &rest opts)
    (disassemble (coerce object 'function) opts))
  (:method ((object function) &rest junk)
    (declare (ignore junk))
    #+UNIX (when (sys::code-address-of object)
             (return-from disassemble
               (disassemble-machine-code
                (sys::program-name) (sys::process-id) object
                (format nil "0x~X" (sys::code-address-of object)))))
    (unless (sys::closurep object)
      (warn (TEXT "Cannot disassemble natively compiled function ~S") object)
      (return-from disassemble (describe object)))
    ;; the object is a closure.
    (unless (sys::%compiled-function-p object)
      (setq object
            (compile-lambda (sys::closure-name object) ; name
                            (sys::%record-ref object 1) ; lambdabody
                            (sys::%record-ref object 4) ; venv
                            (sys::%record-ref object 5) ; fenv
                            (sys::%record-ref object 6) ; benv
                            (sys::%record-ref object 7) ; genv
                            (sys::%record-ref object 8) ; denv
                            nil)))  ; no error even on failure
    ;; object is a compiled closure.
    (sys::disassemble-closure object) ; disassemble
    nil))

;; Disassemble machine code.
;; Bruno Haible 1995
;; you may customize it to your needs.
#+UNIX
(defun disassemble-machine-code (program-name pid function address)
  ;; This uses gdb.
  (when (shell "gdb --version > /dev/null 2>&1") ; failed
    (when function
      ;; Show at least some basic information about the function.
      (describe function))
    (fresh-line)
    (format t (TEXT "Cannot show machine instructions: gdb not found."))
    (return-from disassemble-machine-code nil))
  (unless (stringp address) (setq address (format nil "~A" address)))
  (let ((tempfilename (format nil "/tmp/gdbcomm~D" pid))
        (outfilename (format nil "/tmp/gdbdis~D" pid))
        ;; On Windows older than Windows XP, we cannot use gdb on the live
        ;; process, due to a limitation of the Win32 API.
        ;; See http://sources.redhat.com/ml/cygwin/2003-06/msg00933.html
        (use-live-process *disassemble-use-live-process*))
    (with-open-file (f tempfilename :direction :output)
      ;; inhibit pausing after every 23 lines
      ;; (remove this if your gdb doesn't understand it)
      (format f "set height 100000~%")
      ;; inhibit line breaking (because we filter the lines later)
      (format f "set width 1000~%")
      (when use-live-process
        ;; attach to the lisp.run process
        (format f "attach ~D~%" pid))
      (if (digit-char-p (char address 0))
          ;; disassemble at numerical address
          (format f "disassemble ~A~%" address)
          ;; disassemble at symbolic address (the "disassemble" command
          ;; does not always work for symbolic arguments)
          (format f "x/10000i ~A~%" address))
      (when use-live-process
        ;; let lisp.run continue
        (format f "detach~%"))
      ;; quit the debugger
      (format f "quit~%"))
    ;; Run gdb, capture only the lines beginning with 0x.
    ;; Let lisp.run continue (in case the debugger did not detach properly)
    (shell
      (if use-live-process
        (format nil "~A -n -batch -x ~A ~A < /dev/null | grep '^0' > ~A ; kill -CONT ~D"
                "gdb" tempfilename program-name outfilename pid)
        (format nil "~A -n -batch -x ~A ~A < /dev/null | grep '^0' > ~A"
                "gdb" tempfilename program-name outfilename)))
    (delete-file tempfilename)
    ;; Now let the user view the listing.
    (if (or (string= (getenv "TERM") "dumb")
            (string= (getenv "TERM") "emacs"))
      ;; do not call a pager when running under Emacs
      (with-open-file (in outfilename :direction :input)
        (do ((line (read-line in nil nil) (read-line in nil nil)))
            ((null line))
          (format t "~a~%" line)))
      (shell (format nil "~A ~A" (or (getenv "PAGER") "more") outfilename)))
    (delete-file outfilename))
  #| ;; This uses SunOS dbx. (Untested.)
  (let ((tempfilename (format nil "/tmp/dbxcomm~D" pid)))
    (with-open-file (f tempfilename :direction :output)
      (format f "~A/100i~%" address) ; disassemble
      (format f "detach~%")          ; let lisp.run continue
      (format f "quit~%"))           ; quit the debugger
    (shell (format nil "~A -s ~A ~A ~D" "dbx"
                   tempfilename program-name pid))) |#
  #| ;; This uses AIX dbx. (Untested.)
  (let ((tempfilename (format nil "/tmp/dbxcomm~D" pid)))
    (with-open-file (f tempfilename :direction :output)
      (format f "~A/100i~%" address) ; disassemble
      (format f "detach~%")          ; let lisp.run continue
      (format f "quit~%"))           ; quit the debugger
    (shell (format nil "~A -c ~A -a ~D ~A" "dbx"
                   tempfilename pid program-name))) |#
  nil)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./disassem.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./format.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; FORMAT - and company.
;; Bruno Haible 22.06.1988
;; CLISP-Version 16.08.1988, 03.09.1988, 04.08.1989
;; Major revision by Bruno Haible  14.02.1990-15.02.1990
;; Further revised and wrote FORMATTER 9.4.1995-11.4.1995
;; German comments translated into English: Stefan Kain 2001-09-09
;; formatter pprint-logical-block ~:> support: John Boyland 2003
;; Sam Steingold 1999-2009

;; FORMAT is a mechanism for producing string output conveniently by,
;; basically, taking a pre-determined string with placeholders and
;; substituting computed values or strings for those placeholders --
;; though it became much more complex than this because the placeholders
;; included iteration primitives for producing lists of results,
;; plurals, and other such exotica.  It may be loosely characterized as
;; FORTRAN FORMAT statements gone berserk.
;; -- Guy L. Steele Jr. and Richard P. Gabriel in "The Evolution of Lisp"

(in-package "SYSTEM")

;;; ---------------------------------------------------------------------------

;; data-structure of control-string-directives:
(defstruct (control-string-directive
             (:copier nil)
             (:conc-name "CSD-")
             (:predicate nil)
             (:constructor make-csd ()))
  (type         0 :type fixnum)
  (cs-index     0 :type fixnum)
  (parm-list    nil :type list)
  (v-or-#-p     nil :type symbol)
  (colon-p      nil :type symbol)
  (atsign-p     nil :type symbol)
  (data         nil)
  (clause-chain nil))
;; Explanation:
;; type=0: directive ~<Newline>, nothing to print.
;;         further components are meaningless
;; type=1: String to be printed,
;;         from *FORMAT-CS* the portion :START cs-index :END data.
;;         further components are meaningless
;; type=2: execute format-directive.
;;         data = name of directive (Symbol),
;;         colon-p states, if there was a ':' ,
;;         atsign-p states, if there was a '@' ,
;;         parm-list = parameter-list for the directive,
;;         v-or-#-p states, if parm-list is to be processed before the call.
;;         clause-chain is a chain of pointers: e.g.  ~[...~;...~;...~]
;;         pointer from the ~[-directive to the list at the first ~;-directive,
;;         from there to the list at the next ~;-directive and so on.
;;         until eventually to the list at the ~]-directive.

;; check whether the character is a whitespace character. -- see io.d
;; (defun whitespacep (char)
;;   (member char '(#\Space #\Newline #\Linefeed #\Tab #\Return #\Page))
;;   (case char
;;     ((#\Space #\Newline #\Linefeed #\Tab #\Return #\Page) t)
;;     (t nil)))

;; (FORMAT-PARSE-CS control-string startindex csdl stop-at)
;; parses a control-string (exactly: (subseq control-string startindex))
;; and stores the resulting control-string-directive list in (cdr csdl) .
;; The parsing must end with the directive stop-at (a Character, or NIL
;; for the end of the String).
;; If stop-at /= NIL, a pointer to the sublist at the next separator is to
;; be stored in (csd-clause-chain (car csdl)). These pointers form
;; a simple list within csdl: from one Separator to the
;; next, finally to the end of the Clause.
(defun format-parse-cs (control-string startindex csdl stop-at)
  (declare (fixnum startindex))
  (macrolet ((errorstring ()
               (TEXT "The control string terminates within a format directive.")))
    (prog* ((index startindex)  ; cs-index of the next character
            ch                  ; current character
            intparam            ; Integer-Parameter
            newcsd              ; current CSD
            (last-separator-csd (car csdl)))
      (declare (type simple-string control-string) (type fixnum index))
      (loop                     ; new directive altogether
        (tagbody
          (when (>= index (length control-string))
            (go string-ended))
          (setq ch (schar control-string index))
          (unless (eql ch #\~)
            ;; possibly transform part of string into a separate directive,
            (setq csdl (setf (cdr csdl) (list (setq newcsd (make-csd)))))
            (setf (csd-type     newcsd) 1)
            (setf (csd-cs-index newcsd) index)
            (setq index (position #\~ control-string :start index))
            (unless index
              (setf (csd-data newcsd) (setq index (length control-string)))
              (go string-ended))
            (setf (csd-data newcsd) index))
          (setq csdl (setf (cdr csdl) (list (setq newcsd (make-csd)))))
          (setf (csd-type         newcsd) 2)
          (setf (csd-cs-index     newcsd) index)
          (setf (csd-parm-list    newcsd) nil)
          (setf (csd-v-or-#-p     newcsd) nil)
          (setf (csd-colon-p      newcsd) nil)
          (setf (csd-atsign-p     newcsd) nil)
          (setf (csd-data         newcsd) nil)
          (setf (csd-clause-chain newcsd) nil)

          param                 ; parameter of a directive may begin
          (incf index)
          (when (>= index (length control-string))
            (format-error 'error control-string index (errorstring))
            (go string-ended))
          (setq ch (schar control-string index))
          (when (digit-char-p ch) (go num-param))
          (case ch
            ((#\+ #\-) (go num-param))
            (#\' (go quote-param))
            ((#\V #\v #\#)
             (push (if (eql ch #\#) ':ARG-COUNT ':NEXT-ARG)
                   (csd-parm-list newcsd))
             (setf (csd-v-or-#-p newcsd) T)
             (go param-ok-1))
            (#\, (push nil (csd-parm-list newcsd)) (go param))
            (#\: (go colon-modifier))
            (#\@ (go atsign-modifier))
            (T (go directive)))

          num-param             ; numerical parameter
          (multiple-value-setq (intparam index)
            (parse-integer control-string :start index :junk-allowed t))
          (unless intparam
            (format-error 'error control-string index
                          (TEXT "~A must introduce a number.")
                          ch))
          (push intparam (csd-parm-list newcsd))
          (go param-ok-2)

          quote-param           ; Quote-Parameter-Treatment
          (incf index)
          (when (>= index (length control-string))
            (format-error 'error control-string index
              (TEXT "The control string terminates in the middle of a parameter."))
            (go string-ended))
          (setq ch (schar control-string index))
          (push ch (csd-parm-list newcsd))

          param-ok-1            ; Parameter OK
          (incf index)
          param-ok-2            ; Parameter OK
          (when (>= index (length control-string))
            (format-error 'error control-string index (errorstring))
            (go string-ended))
          (setq ch (schar control-string index))
          (case ch
            (#\, (go param))
            (#\: (go colon-modifier))
            (#\@ (go atsign-modifier))
            (T (go directive)))

          colon-modifier        ; after :
          (setf (csd-colon-p newcsd) T)
          (go passed-modifier)

          atsign-modifier       ; after @
          (setf (csd-atsign-p newcsd) T)
          (go passed-modifier)

          passed-modifier       ; after : or @
          (incf index)
          (when (>= index (length control-string))
            (format-error 'error control-string index (errorstring))
            (go string-ended))
          (setq ch (schar control-string index))
          (case ch
            (#\: (go colon-modifier))
            (#\@ (go atsign-modifier))
            (T (go directive)))

          directive             ; directive (its Name) reached
          (setf (csd-parm-list newcsd) (nreverse (csd-parm-list newcsd)))
          (let ((directive-name
                  (cdr (assoc (char-upcase ch)
                           ; with function-definition     ; without function-definition
                         '((#\A . FORMAT-ASCII)
                           (#\S . FORMAT-S-EXPRESSION)
                           (#\W . FORMAT-WRITE)
                           (#\D . FORMAT-DECIMAL)
                           (#\B . FORMAT-BINARY)
                           (#\O . FORMAT-OCTAL)
                           (#\X . FORMAT-HEXADECIMAL)
                           (#\R . FORMAT-RADIX)
                           (#\P . FORMAT-PLURAL)
                           (#\C . FORMAT-CHARACTER)
                           (#\F . FORMAT-FIXED-FLOAT)
                           (#\E . FORMAT-EXPONENTIAL-FLOAT)
                           (#\G . FORMAT-GENERAL-FLOAT)
                           (#\$ . FORMAT-DOLLARS-FLOAT)
                           (#\% . FORMAT-TERPRI)
                           (#\_ . FORMAT-PPRINT-NEWLINE)
                           (#\I . FORMAT-PPRINT-INDENT)
                           (#\& . FORMAT-FRESH-LINE)      (#\Newline . #\Newline)
                           (#\| . FORMAT-PAGE)
                           (#\~ . FORMAT-TILDE)
                           (#\T . FORMAT-TABULATE)
                           (#\* . FORMAT-GOTO)
                           (#\? . FORMAT-INDIRECTION)
                           (#\/ . FORMAT-CALL-USER-FUNCTION)
                           (#\( . FORMAT-CASE-CONVERSION) (#\) . FORMAT-CASE-CONVERSION-END)
                           (#\[ . FORMAT-CONDITIONAL)     (#\] . FORMAT-CONDITIONAL-END)
                           (#\{ . FORMAT-ITERATION)       (#\} . FORMAT-ITERATION-END)
                           (#\< . FORMAT-JUSTIFICATION)   (#\> . FORMAT-JUSTIFICATION-END)
                           (#\^ . FORMAT-UP-AND-OUT)      (#\; . FORMAT-SEPARATOR)
                           (#\! . FORMAT-CALL)
                           (#\. . FORMAT-ELASTIC-NEWLINE))))))
            (if directive-name
              (setf (csd-data newcsd) directive-name)
              (format-error 'error control-string index
                (TEXT "Non-existent format directive"))))
          (incf index)
          (case ch
            (#\/
             (let* ((start index)
                    (end (or (position #\/ control-string :start start)
                             (format-error 'error control-string index
                               (TEXT "Closing '/' is missing"))))
                    (pos (position #\: control-string :start start :end end))
                    (name (string-upcase
                            (subseq control-string
                                    (if pos
                                      (if (char= #\: (char control-string (1+ pos))) (+ 2 pos) (1+ pos))
                                      start)
                                    end)))
                    (pack (if pos
                            (let ((packname
                                    (string-upcase
                                      (subseq control-string start pos))))
                              (or (find-package packname)
                                  (format-error 'error control-string index
                                    (TEXT "There is no package with name ~S")
                                    packname)))
                            *common-lisp-user-package*)))
               (push (list (intern name pack)) (csd-parm-list newcsd))
               (setq index (1+ end))))
            (( #\( #\[ #\{)
             (multiple-value-setq (index csdl)
               (format-parse-cs control-string index csdl
                 (case ch (#\( #\)) (#\[ #\]) (#\{ #\}) ))))
            (#\<
             (multiple-value-setq (index csdl)
               (format-parse-cs control-string index csdl #\>))
             ;; (assert (eq (csd-data (car csdl)) 'FORMAT-JUSTIFICATION-END))
             (when (csd-colon-p (car csdl))
               (setf (csd-data newcsd) 'FORMAT-LOGICAL-BLOCK)))
            (( #\) #\] #\} #\> )
             (unless stop-at
               (format-error 'error control-string index
                 (TEXT "The closing format directive '~A' does not have a corresponding opening one.")
                 ch))
             (unless (eql ch stop-at)
               (format-error 'error control-string index
                 (TEXT "The closing format directive '~A' does not match the corresponding opening one. It should read '~A'.")
                 ch stop-at))
             (setf (csd-clause-chain last-separator-csd) csdl)
             (go end))
            (#\;
             (unless (or (eql stop-at #\]) (eql stop-at #\>))
               (format-error 'error control-string index
                 (TEXT "The ~~; format directive is not allowed at this point.")))
             (setf (csd-clause-chain last-separator-csd) csdl)
             (setq last-separator-csd newcsd))
            (#\Newline
             (setf (csd-type newcsd) 0)
             (if (csd-colon-p newcsd)
               (if (csd-atsign-p newcsd)
                 (format-not-both-error "~newline")
                 nil) ; ~:<newline> -> ignore Newline, retain Whitespace
               (progn
                 (when (csd-atsign-p newcsd)
                   ;; ~@<newline> -> part of String with Newline for output
                   (setf (csd-type newcsd) 1)
                   (setf (csd-cs-index newcsd) (1- index))
                   (setf (csd-data newcsd) index))
                 (setq index
                   (or (position-if-not #'whitespacep control-string :start index)
                       (length control-string)))))))
        ) ; tagbody finished
      )   ; loop finished

      string-ended
      (when stop-at
        (format-error 'error control-string index
          (TEXT "An opening format directive is never closed; expecting '~A'.")
          stop-at))

      end
      (return (values index csdl)))))

;;; ---------------------------------------------------------------------------

(defvar *FORMAT-CS*)            ; control-string
(defvar *FORMAT-CSDL*)          ; control-string directive list
(defvar *FORMAT-ARG-LIST*)      ; argument-list
(defvar *FORMAT-NEXT-ARG*)   ; pointer to next argument in argument-list
(defvar *FORMAT-NEXT-ARGLIST*) ; pointer to next sublist in ~:{ iteration
(defvar *FORMAT-UP-AND-OUT* nil) ; reason for up-and-out

;; (format-error type {keyword value}* control-string errorpos errorstring . arguments)
;; signals an Error of the given type, that occurred in FORMAT. The position
;; in the Control-string is marked with an arrow.
(defun format-error (type &rest arguments)
  (let ((type-initargs '()))
    (loop
      (unless (keywordp (car arguments)) (return))
      (push (pop arguments) type-initargs)
      (push (pop arguments) type-initargs))
    (let* ((control-string (pop arguments))
           (errorpos (pop arguments))
           (errorstring (pop arguments)))
      (when control-string
        (unless errorpos (setq errorpos (csd-cs-index (car *FORMAT-CSDL*))))
        (setq errorstring
          (string-concat errorstring "~%"
            (TEXT "Current point in control string:")))
        (let ((pos1 0) (pos2 0))
          (declare (simple-string errorstring) (fixnum pos1 pos2))
          (loop
            (setq pos2 (or (position #\Newline control-string :start pos1)
                           (length control-string)))
            (setq errorstring (string-concat errorstring "~%~2T~S"))
            (setq arguments
              (nconc arguments (list (substring control-string pos1 pos2))))
            (when (<= pos1 errorpos pos2)
              (setq errorstring (string-concat errorstring "~%~VT|"))
              (setq arguments (nconc arguments (list (+ (- errorpos pos1) 3)))))
            (when (= pos2 (length control-string)) (return))
            (setq pos1 (+ pos2 1)))))
      (apply #'error-of-type
             type (nreconc type-initargs (list* errorstring arguments))))))

(defun format-not-both-error (directive)
  (format-error 'error *FORMAT-CS* nil
                (TEXT "The ~A format directive cannot take both modifiers.")
                directive))

;;; ---------------------------------------------------------------------------

(defun format (destination control-string &rest arguments)
  (unless (or (stringp control-string) (functionp control-string))
    (format-cs-error control-string))
  (cond ((null destination)
         (let ((stream (make-string-output-stream)))
           (format-apply stream control-string arguments)
           (get-output-stream-string stream)))
        ((eq destination 'T)
         (format-apply *standard-output* control-string arguments)
         nil)
        ((streamp destination)
         (format-apply destination control-string arguments)
         nil)
        ((stringp destination)
         (if (array-has-fill-pointer-p destination)
           (let ((stream (sys::make-string-push-stream destination)))
             (format-apply stream control-string arguments))
           (error-of-type 'error
             (TEXT "The destination string ~S should have a fill pointer.")
             destination))
         nil)
        (t (error-of-type 'type-error
             :datum destination :expected-type '(or boolean stream string)
             (TEXT "The destination argument ~S is invalid (not NIL or T or a stream or a string).")
             destination))))

(defun format-apply (stream control-string arguments
                     &optional (whole-arguments arguments))
  (cond ((stringp control-string)
         ;; possibly convert control-string into Simple-String ??
         (let ((node (list control-string)))
           (format-parse-cs control-string 0 node nil)
           (let* ((*FORMAT-CS*         (car node))
                  (*FORMAT-CSDL*       (cdr node))
                  (*FORMAT-ARG-LIST*   whole-arguments)
                  (*FORMAT-NEXT-ARG*   arguments)
                  (*FORMAT-NEXT-ARGLIST* nil)
                  (*FORMAT-UP-AND-OUT* nil))
             (format-interpret stream)
             *FORMAT-NEXT-ARG*)))
        ((functionp control-string)
         (apply control-string stream arguments))
        (t (format-cs-error control-string))))

(defun format-cs-error (control-string)
  (error-of-type 'type-error
    :datum control-string :expected-type '(or string function)
    (TEXT "~S: The control-string must be a string, not ~S")
    'format control-string))

;;; ---------------------------------------------------------------------------

;; (next-arg) returns (and consumes) the next argument from the argument-
;; list *FORMAT-NEXT-ARG*.
(defun next-arg ()
  (if (atom *FORMAT-NEXT-ARG*)
    (if (null *FORMAT-NEXT-ARG*)
      (format-error 'error *FORMAT-CS* nil
        (TEXT "There are not enough arguments left for this format directive."))
      (format-error 'type-error :datum *FORMAT-NEXT-ARG* :expected-type 'LIST
        *FORMAT-CS* nil
        (TEXT "The argument list is a dotted list: ~S")
        *FORMAT-ARG-LIST*))
    (pop *FORMAT-NEXT-ARG*)))

;; (format-interpret stream [endmarker]) interprets *FORMAT-CSDL* .
;; Fluid vars:
;;   *FORMAT-ARG-LIST*
;;   *FORMAT-NEXT-ARG*
;;   *FORMAT-NEXT-ARGLIST*
;;   *FORMAT-CS*
;;   *FORMAT-CSDL*
;;   *FORMAT-UP-AND-OUT*
;; Stop interpretation when arriving at the directive endmarker
;; or the directive ~; .
(defun format-interpret (stream &optional (endmarker nil))
  (loop
    (when *FORMAT-UP-AND-OUT* (return))
    (when (endp *FORMAT-CSDL*) (return))
    (let ((csd (car *FORMAT-CSDL*)))
      (case (csd-type csd)
        (0 )
        (1 (write-string *FORMAT-CS* stream
             :start (csd-cs-index csd) :end (csd-data csd)))
        (2 (let ((directive-name (csd-data csd)))
             (if (eq directive-name endmarker) (return))
             (if (eq directive-name 'FORMAT-SEPARATOR) (return))
             (apply directive-name
               stream
               (csd-colon-p csd)
               (csd-atsign-p csd)
               (format-resolve-parms csd))))))
    (setq *FORMAT-CSDL* (cdr *FORMAT-CSDL*))))

;; returns the correct argument-list of a CSD, possibly with substituted
;; parameters: V (as :NEXT-ARG) and # (as :ARG-COUNT) are resolved.
(defun format-resolve-parms (csd)
  (let ((arglist (csd-parm-list csd)))
    (if (csd-v-or-#-p csd)
      (mapcar #'(lambda (arg)
                  (case arg
                    (:NEXT-ARG (next-arg))
                    (:ARG-COUNT (list-length *FORMAT-NEXT-ARG*))
                    (T arg)))
              arglist)
      arglist)))

;; Defines a simple FORMAT-subfunction, i.e. a function that consumes
;; exactly one argument.
(defmacro defformat-simple (name (stream colon atsign . optionals-with-defaults)
                            (arg) &body body)
  (multiple-value-bind (body-rest declarations) (sys::parse-body body)
    (let ((name2 (concat-pnames "DO-" name)) ; in #<PACKAGE SYSTEM>
          (optionals (mapcar #'(lambda (opt) (if (consp opt) (first opt) opt))
                             optionals-with-defaults)))
      `(PROGN
         (DEFUN ,name (,stream ,colon ,atsign &OPTIONAL ,@optionals)
           (,name2 ,stream ,colon ,atsign ,@optionals (next-arg)))
         (DEFUN ,name2 (,stream ,colon ,atsign ,@optionals ,arg)
           ,@(if declarations `((DECLARE ,@declarations)))
           ,@(mapcap #'(lambda (opt)
                         (if (and (consp opt) (not (null (second opt))))
                           `((IF (NULL ,(first opt))
                               (SETQ ,(first opt) ,(second opt))))
                           '()))
                     optionals-with-defaults)
           ,@body-rest)))))

;; Moves the value of "Pointers into the argument-list" in one direction.
(defun format-goto-new-arg (backwardp index)
  (if backwardp
    ;; backwards
    (setq *FORMAT-NEXT-ARG*
          (nthcdr (max (- (list-length *FORMAT-ARG-LIST*)
                          (list-length *FORMAT-NEXT-ARG*)
                          index)
                       0)
                  *FORMAT-ARG-LIST*))
    ;; forwards is easier:
    (setq *FORMAT-NEXT-ARG* (nthcdr index *FORMAT-NEXT-ARG*))))

;; prints arg as old-Roman number to stream, e.g. 4 as IIII.
(defun format-old-roman (arg stream)
  (unless (and (integerp arg) (<= 1 arg 4999))
    (format-error 'type-error :datum arg :expected-type '(INTEGER 1 4999)
      *FORMAT-CS* nil
      (TEXT "The ~~:@R format directive requires an integer in the range 1 - 4999, not ~S")
      arg))
  (do ((charlistr  '(#\M  #\D #\C #\L #\X #\V #\I) (cdr charlistr))
       (valuelistr '(1000 500 100 50  10   5   1) (cdr valuelistr))
       (value arg (multiple-value-bind (multiplicity restvalue)
                      (floor value (first valuelistr))
                    (dotimes (i multiplicity)
                      (write-char (first charlistr) stream))
                    restvalue)))
      ((zerop value))))

;; prints arg as new-Roman number to stream, e.g. 4 as IV.
(defun format-new-roman (arg stream)
  (unless (and (integerp arg) (<= 1 arg 3999))
    (format-error 'type-error :datum arg :expected-type '(INTEGER 1 3999)
      *FORMAT-CS* nil
      (TEXT "The ~~@R format directive requires an integer in the range 1 - 3999, not ~S")
      arg))
  (do ((charlistr       '(#\M #\D #\C #\L #\X #\V #\I) (cdr charlistr))
       (valuelistr     '(1000 500 100 50  10   5   1 ) (cdr valuelistr))
       (lowercharlistr  '(#\C #\C #\X #\X #\I #\I    ) (cdr lowercharlistr))
       (lowervaluelistr '(100 100 10  10   1   1   0 ) (cdr lowervaluelistr))
       (value arg
         (multiple-value-bind (multiplicity restvalue)
             (floor value (first valuelistr))
           (dotimes (i multiplicity) (write-char (first charlistr) stream))
           (let ((loweredvalue (- (first valuelistr) (first lowervaluelistr))))
             (if (>= restvalue loweredvalue)
               (progn
                 (write-char (first lowercharlistr) stream)
                 (write-char (first charlistr) stream)
                 (- restvalue loweredvalue))
               restvalue)))))
      ((zerop value))))

(defconstant FORMAT-CARDINAL-ONES
  '#(NIL "one" "two" "three" "four" "five" "six" "seven" "eight" "nine"
     "ten" "eleven" "twelve" "thirteen" "fourteen" "fifteen" "sixteen"
     "seventeen" "eighteen" "nineteen"))

(defconstant FORMAT-CARDINAL-TENS
  '#(NIL NIL "twenty" "thirty" "forty" "fifty" "sixty" "seventy" "eighty"
     "ninety"))

;; (format-small-cardinal arg stream) prints an 0< integer <1000 in
;; plain English to stream. (arg=0 -> on output.)
(defun format-small-cardinal (arg stream)
  (multiple-value-bind (hundreds tens-and-ones) (truncate arg 100)
    (when (> hundreds 0)
      (write-string (svref FORMAT-CARDINAL-ONES hundreds) stream)
      (write-string " hundred" stream))
    (when (> tens-and-ones 0)
      (when (> hundreds 0) (write-string " and " stream))
      (multiple-value-bind (tens ones) (truncate tens-and-ones 10)
        (if (< tens 2)
          (write-string (svref FORMAT-CARDINAL-ONES tens-and-ones) stream)
          (progn
            (write-string (svref FORMAT-CARDINAL-TENS tens) stream)
            (when (> ones 0)
              (write-char #\- stream)
              (write-string (svref FORMAT-CARDINAL-ONES ones) stream))))))))

;; (format-cardinal arg stream) prints the integer arg in plain English
;; to stream.
(defun format-cardinal (arg stream) ; arg Integer
  (if (zerop arg)
    (write-string "zero" stream)
    (progn
      (when (minusp arg) (write-string "minus " stream) (setq arg (- arg)))
      (labels ((blocks1000 (illions-list arg) ; decomposition in 1000er-Blocks
                 (when (null illions-list)
                   (format-error 'type-error :datum arg :expected-type '(INTEGER 0 999999999999999999999999999999999999999999999999999999999999999999)
                     *FORMAT-CS* nil
                     (TEXT "The argument for the ~~R format directive is too large.")))
                 (multiple-value-bind (thousands small) (truncate arg 1000)
                   (when (> thousands 0)
                     (blocks1000 (cdr illions-list) thousands))
                   (when (> small 0)
                     (when (> thousands 0)
                       (write-string ", " stream))
                     (format-small-cardinal small stream)
                     (write-string (car illions-list) stream)))))
        (blocks1000
          ; American (billion=10^9)
          '("" " thousand" " million" " billion" " trillion" " quadrillion"
            " quintillion" " sextillion" " septillion" " octillion"
            " nonillion" " decillion" " undecillion" " duodecillion"
            " tredecillion" " quattuordecillion" " quindecillion"
            " sexdecillion" " septendecillion" " octodecillion"
            " novemdecillion" " vigintillion")
          arg)))))

(defconstant FORMAT-ORDINAL-ONES
  '#(NIL "first" "second" "third" "fourth" "fifth" "sixth" "seventh" "eighth"
     "ninth" "tenth" "eleventh" "twelfth" "thirteenth" "fourteenth"
     "fifteenth" "sixteenth" "seventeenth" "eighteenth" "nineteenth"))

;; (format-ordinal arg stream) prints an integer arg as an ordinal number in
;; plain English to stream.
(defun format-ordinal (arg stream) ; arg Integer
  (if (zerop arg)
    (write-string "zeroth" stream)
    (progn
      (when (minusp arg) (write-string "minus " stream) (setq arg (- arg)))
      (multiple-value-bind (hundreds tens-and-ones) (floor arg 100)
        (when (> hundreds 0) (format-cardinal (* hundreds 100) stream))
        (if (zerop tens-and-ones)
          (write-string "th" stream)
          (multiple-value-bind (tens ones) (floor tens-and-ones 10)
            (when (> hundreds 0) (write-char #\Space stream))
            (cond ((< tens 2)
                   (write-string (svref FORMAT-ORDINAL-ONES tens-and-ones) stream))
                  ((zerop ones)
                   (write-string
                     (svref '#(NIL "tenth" "twentieth" "thirtieth" "fortieth"
                               "fiftieth" "sixtieth" "seventieth" "eightieth"
                               "ninetieth")
                            tens)
                     stream))
                  (t (write-string (svref FORMAT-CARDINAL-TENS tens) stream)
                     (write-char #\- stream)
                     (write-string (svref FORMAT-ORDINAL-ONES ones)
                                   stream)))))))))

;; (format-padding count char stream) prints count (a Fixnum >=0)
;; characters char to stream.
(defun format-padding (count char stream)
  (dotimes (i count) (write-char char stream)))

;; prints to Stream stream:
;; the String str, possibly filled with padding characters padchar.
;; width is at least mincol. In order to achieve that,
;; at least minpad characters are inserted, possibly additional ones in
;; Blocks of colinc characters. if padleftflag, they are inserted on the left,
;; else right of the String.
(defun format-padded-string (mincol colinc minpad padchar padleftflag
                             str stream)
  (let* ((need (+ (string-width str) minpad)) ; it least that number of columns
         (auxpad (if (< need mincol)
                   (* (ceiling (- mincol need) colinc) colinc)
                   0))) ; this many additional characters
    (unless padleftflag (write-string str stream))
    (format-padding (+ minpad auxpad) padchar stream)
    (when padleftflag (write-string str stream))))

;; prints the Integer arg to Stream:
;; in Base base, with sign (+ only if >=0 and positive-sign-flag), with
;; commaflag, every three digits are separated by the character
;; commachar.  fill on the left with padchar's, so that the total width
;; is at least mincol.
(defun format-integer (base
                       mincol
                       padchar
                       commachar
                       commainterval
                       commaflag
                       positive-sign-flag
                       arg
                       stream)
  (let* ((*print-base* base)
         (*print-radix* nil)
         (*print-readably* nil))
    (if (and (zerop mincol) (not commaflag) (not positive-sign-flag))
      (princ arg stream)        ; normal output does the job
      (let* ((oldstring (princ-to-string arg))
             (oldstring-length (length oldstring))
             (number-of-digits
               (if (minusp arg) (1- oldstring-length) oldstring-length) )
             (number-of-commas
               (if commaflag (floor (1- number-of-digits) commainterval) 0) )
             (positive-sign (and positive-sign-flag (>= arg 0)))
             (newstring-length
               (+ (if positive-sign 1 0) ; sign
                  oldstring-length number-of-commas)) ; digits, commas
             (newstring (make-string newstring-length)) )
        ;; first the sign +:
        (when positive-sign (setf (schar newstring 0) #\+))
        ;; Then convert oldstring in newstring, skipping the commas:
        (let ((oldpos oldstring-length) (newpos newstring-length))
          (loop
            (decf oldpos)
            (when (minusp oldpos) (return))
            (decf newpos)
            (setf (schar newstring newpos) (schar oldstring oldpos))
            (when (and (plusp number-of-commas) ; insert a comma?
                       (zerop (mod (- oldstring-length oldpos) commainterval)))
              (decf newpos)
              (setf (schar newstring newpos) commachar)
              (decf number-of-commas))))
        (if (zerop mincol)
          (write-string newstring stream) ; faster
          (format-padded-string mincol 1 0 padchar t newstring stream))))))

;; non-numeric argument for numeric format instruction is printed with ~A
(defun format-ascii-decimal (arg stream)
  (let ((*print-base* 10.)
        (*print-radix* nil)
        (*print-readably* nil))
    (princ arg stream)))

;; subroutine for ~D, ~B, ~O, ~X:
(defun format-base (base stream colon-modifier atsign-modifier
                    mincol padchar commachar commainterval
                    arg)
  (if (or (and (zerop mincol) (not colon-modifier) (not atsign-modifier))
          (not (integerp arg)))
    (let ((*print-base* base)
          (*print-radix* nil)
          (*print-readably* nil))
      (if (integerp arg)
        (princ arg stream)
        (format-padded-string mincol 1 0 padchar t
                              (princ-to-string arg) stream)))
    (format-integer base mincol padchar commachar commainterval
                    colon-modifier atsign-modifier arg stream)))

;; (format-float-to-string arg width d k dmin)
;; returns a String for Floating-point arg:
;; it has the value of (* (abs arg) (expt 10 k)), with at least d digits behind
;; the decimal point and at most the length width (width=nil -> no limitation).
;; Nevertheless there is no rounding to less than dmin digits.
(let ((digit-string (make-array 20 :element-type 'character
                                :adjustable t :fill-pointer t)))
(defun format-float-to-string (arg width d k dmin)
  (if (zerop arg)
    (let ((places (max (or d 0) (or dmin 0))))
      (when width ; width specified -> places := (min places (1- width))
        (when (>= places width) (setq places (1- width))))
      (values
        (let ((str (make-string (1+ places) :initial-element #\0)))
          (setf (schar str 0) #\.)
          str)                  ; one decimal point and places zeros
        (1+ places)             ; number of digits
        t                       ; decimal point in front
        (zerop places)          ; decimal point at the end?
        0))                     ; position of the decimal point
    (multiple-value-bind (significand expon) (integer-decode-float arg)
      ;; significand : Integer >0
      ;; expon : Integer
      ;; mantprec : number of real Mantissa-bits of significand
      ;; (so 2^mantprec <= significand < 2^(mantprec+1))
      ;; width : number of digits, that the number (including decimal point)
      ;;         is not to overshoot, or NIL
      ;;   at least 2: a digit and the decimal point
      (when width (setq width (max width 2)))
      ;; d : minimum number of digits behind the decimal point or NIL
      ;; k : scaling factor (ref. CLTL p.394)
      ;; dmin : minimum number of digits, that
      ;;        may not be rounded (despite the specification of width or d).
      ;;        (only interesting, if d <= dmin <= (precision of number).)
      ;; converts the number significand*2^expon into a decimal-string.
      ;; There is no exponent present.
      (let* ((mantprec (1- (float-digits arg)))
             (numerator significand)
             (denominator 1)
             (round-down-1 1) ; rounding-off unit:
             ;; rounding off by 1 in the last digit that can be rounded off
             ;; corresponds to the decrease of the numerator by round-down-1.
             (round-up-1 1) ; rounding-up unit:
             ;; rounding up by 1 in the last digit that can be rounded up
             ;; corresponds to the increase of the numerator by round-up-1.
             ;; positions: 0 = 1st. digit in front of the decimal point,
             ;; -1 = 1st. digit behind the decimal point.
             (posn 0) ; position of the next digit to be printed
             (digit-count 0) ; number of the printed digits so far in
                             ; digit-string (excluding the decimal point)
             (point-pos 0) ; decimal-point-position = number of leading digits
                           ; = number of digits in front of the decimal point
             (last-pos nil) ; NIL or position of the last significant digit
                            ;  (if d or width were specified)
             digit              ; the current digit, >=0, <10
             (round-down-p nil) ; T if last digit is to be rounded off
             (round-up-p nil)) ; T if last digit is to be rounded up
        (setf (fill-pointer digit-string) 0) ; empty the digit-string
        (cond ((> expon 0)
               (setq numerator (ash significand expon))
               (setq round-up-1 (setq round-down-1 (ash 1 expon))))
              ((< expon 0)          ; round-up-1 = round-down-1 = 1
               (setq denominator (ash 1 (- expon)))))
        ;; number = numerator/denominator
        (when (= significand (ash 1 mantprec))
          ;; If Significand=2^mantprec, round-down-1 can be halved.
          ;; Instead, the other three items can be doubled:
          (setq round-up-1 (ash round-up-1 1))
          (setq numerator (ash numerator 1))
          (setq denominator (ash denominator 1)))
        ;; default behavior: rounding-unit = one unit in the last
        ;; BINARY-digit.
        ;; number = numerator/denominator
        ;; work scaling factor k into the number (ref. CLTL p.394)
        ;; k<0 -> divide mantissa by 10^(abs k)
        ;; k>0 -> multiply mantissa with 10^k
        ;; Retain ratio between round-up-1/round-down-1 and numerator.
        (when k
          (if (< k 0)
            (let ((scal-factor (expt 10 (- k))))
              (setq denominator (* denominator scal-factor)))
            (let ((scal-factor (expt 10 k)))
              (setq numerator (* numerator scal-factor))
              (setq round-up-1 (* round-up-1 scal-factor))
              (setq round-down-1 (* round-down-1 scal-factor)))))
        ;; adjust to >= 1/10 : (multiply numerator with 10 at a time and
        ;; plan for an additional leading 0)
        (do ()
            ((>= (* numerator 10) denominator))
          (setq posn (1- posn))
          (setq numerator (* numerator 10))
          (setq round-down-1 (* round-down-1 10))
          (setq round-up-1 (* round-up-1 10)))
        ;; posn = position of the final leading 0
        ;;        = 1 + position of the 1st. significant digit
        ;;        or =0, if k>=0
        ;; implementation of the rounding:
        (loop
          ;; so long as the result stays >= 1 even after rounding up,
          ;; plan for one more digit in front of the decimal point:
          (do ()
              ((< (+ (ash numerator 1) round-up-1) (ash denominator 1)))
            (setq denominator (* denominator 10))
            (setq posn (1+ posn)))
          ;; if d or width is specified: calculate last-pos
          (if d
            ;; if dmin is specified: (min (- d) (- dmin)) = (- (max d dmin)).
            ;; else (- d).
            (progn
              (setq last-pos (- d))
              (when (and dmin (> last-pos (- dmin)))
                (setq last-pos (- dmin))))
            ;; if not d, only specify width:
            (when width
              (if (< posn 0)
                ;; leading zeros behind the decimal point -> d:=(1- width)
                (setq last-pos (- 1 width))
                ;; no leading zeros behind the decimal point -> there will
                ;; be posn digits in front of the point, d:=(- (1- width) posn)
                (setq last-pos (1+ (- posn width))))
              ;; last-pos = (- (- (1- width) (max posn 0)))
              ;; take dmin into account again
              (when (and dmin (> last-pos (- dmin)))
                (setq last-pos (- dmin)))))
          (when (or d width)
            (let* ((ziffernzahl (- last-pos posn))
                            ; = - number of significant digits or >=0.
                   (decimal-1 denominator))
                            ; := (ceiling (* decimal-1 (expt 10 ziffernzahl)))
              (if (>= ziffernzahl 0)
                (dotimes (i ziffernzahl)
                  (setq decimal-1 (* decimal-1 10)))
                (dotimes (i (- ziffernzahl))
                  (setq decimal-1 (ceiling decimal-1 10))))
              ;; decimal-1 = amount by which numerator has to be increased
              ;; resp. decreased, therewith the decimal representation is
              ;; changed by exactly 1 at the position last-pos
              (setq round-down-1 (max decimal-1 round-down-1))
              (setq round-up-1 (max decimal-1 round-up-1))
              ;; now rounding may take place by one (half) decimal-1.
              ))
          (when (< (+ (ash numerator 1) round-up-1) (ash denominator 1))
            (return)))
        ;; posn = position of the first significant digit + 1
        ;; print leading point and consecutive zeros:
        (when (< posn 0)
          (setq point-pos digit-count)
          (vector-push-extend #\. digit-string)
          (dotimes (i (- posn))
            (incf digit-count)
            (vector-push-extend #\0 digit-string)))
        ;; print digits of the mantissa:
        (loop
          (when (zerop posn)
            (vector-push-extend #\. digit-string)
            (setq point-pos digit-count))
          (decf posn)
          (multiple-value-setq (digit numerator)
            (truncate (* numerator 10) denominator))
          (setq round-down-1 (* round-down-1 10))
          (setq round-up-1 (* round-up-1 10))
          (setq round-down-p (< (ash numerator 1) round-down-1))
          (setq round-up-p
                (>= (ash numerator 1) (- (ash denominator 1) round-up-1)))
          (when (or round-down-p round-up-p
                    (and last-pos (<= posn last-pos)))
            (return))
          (vector-push-extend (schar #1="0123456789" digit) digit-string)
          (incf digit-count))
        ;; print last significant digit:
        (when (or (null last-pos) (>= posn last-pos))
          (vector-push-extend
           (schar #1#
                  (cond ((and round-down-p (not round-up-p)) digit)
                        ((and round-up-p (not round-down-p)) (1+ digit))
                        ((<= (ash numerator 1) denominator) digit)
                        (t (1+ digit))))
           digit-string)
          (incf digit-count))
        ;; print consecutive zeros and point
        (when (>= posn 0)
          (dotimes (i posn)
            (incf digit-count)
            (vector-push-extend #\0 digit-string))
          (vector-push-extend #\. digit-string)
          (setq point-pos digit-count))
        (when d
          (dotimes (i (- d (- digit-count point-pos)))
            (incf digit-count)
            (vector-push-extend #\0 digit-string)))
        (values                     ; 5 values
          digit-string              ; digits
          (1+ digit-count)          ; number of digits
          (= point-pos 0)           ; leading point?
          (= point-pos digit-count) ; trailing point?
          point-pos)))))            ; position of the decimal point
) ; let

;; (format-float-for-f w d k overflowchar padchar plus-sign-flag arg stream)
;; prints the Floating-Point-Number arg in Fix-Comma-Representation to stream.
(defun format-float-for-f (w d k overflowchar padchar plus-sign-flag
                           arg stream)
  (let ((width (if w (if (or plus-sign-flag (minusp arg)) (1- w) w) nil)))
    ;; width = available characters without sign
    (multiple-value-bind (digits digitslength leadingpoint trailingpoint)
        (format-float-to-string arg width d k 0)
      (when (eql d 0)
        (setq trailingpoint nil)) ; d=0 -> no additional zero behind
      (when w
        (setq width (- width digitslength))
        (when leadingpoint      ; plan possibly additional zero ahead
          (if (> width 0) (setq width (1- width)) (setq leadingpoint nil)))
        (when trailingpoint     ; plan possibly additional zero behind
          (if (> width 0) (setq width (1- width)) (setq trailingpoint nil))))
      ;; width characters still remain.
      (if (and overflowchar w (minusp width))
        (format-padding w overflowchar stream) ; not enough room -> overflow
        (progn
          (when (and w (> width 0)) (format-padding width padchar stream))
          (if (minusp arg)
            (write-char #\- stream)
            (if plus-sign-flag (write-char #\+ stream)))
          (when leadingpoint (write-char #\0 stream))
          (write-string digits stream)
          (when trailingpoint (write-char #\0 stream)))))))

;; (format-float-for-e w d e k overflowchar padchar exponentchar plus-sign-flag
;;                     arg stream)
;; prints the Floating-Point-Number arg
;; in Exponential representation to stream.
;; (compare CLTL p.392-394)
;; partitioning of Mantissa:
;;   if k<=0, first 1 zero (if fits in width), then the point,
;;            then |k| zeros, then d-|k| significant digits;
;;            which is d digits behind the point, altogether.
;;   if k>0,  first k significant digits, then the point,
;;            then d-k+1 further significant digits;
;;            which is d+1 significant digits, altogether.
;;            no zeros in front.
;;   (The default in FORMAT-EXPONENTIAL-FLOAT is k=1.)
;; the sign in front of the Mantissa (a + only if arg>=0 and plus-sign-flag).
;; then the Exponent, prefaced by exponentchar, then sign of the
;; Exponent (always + or -), then e digits for the Exponent.
;; Then fill the whole thing with padchars to w characters.
;; If this results (even after possible suppression of a leading zero) in
;; more than w characters, print w overflowchars instead, or
;; (if overflowchar = nil) print the number with as many digits
;; as necessary.
(defun format-float-for-e (w d e k
       overflowchar padchar exponentchar plus-sign-flag arg stream)
  (multiple-value-bind (oldexponent mantissa) (float-scale-exponent (abs arg))
    (let* ((exponent (if (zerop arg) 0 (- oldexponent k))) ; Exponent to be printed
           (expdigits (write-to-string (abs exponent) :base 10.
                                       :radix nil :readably nil))
           ;; expdigitsneed = number of digits, that are necessary
           ;; for the Exponent.
           (expdigitsneed (if e (max (length expdigits) e) (length expdigits)))
           ;; mantd = number of Mantissa-Digits behind the point
           (mantd (if d (if (> k 0) (1+ (- d k)) d) nil))
           ;; no rounding takes place within the first (+ 1 (abs k)) digits.
           (dmin (if (minusp k) (- 1 k) nil)) ; hereafter: demand, that
           ;; mantwidth = number of available characters (or nil)
           ;; for the Mantissa (incl. sign, point)
           (mantwidth (if w (- w 2 expdigitsneed) nil)))
      (declare (simple-string expdigits) (fixnum exponent expdigitsneed))
      (if (and overflowchar w e (> expdigitsneed e))
        ;; if Overflowchar and w and e being stated, Exponent needs more room:
        (format-padding w overflowchar stream)
        (progn
          (when (and w (or plus-sign-flag (minusp arg)))
            (setq mantwidth (1- mantwidth)))
          ;; mantwidth = number of available characters (or nil)
          ;;  for the Mantissa (without sign,including point)
          (multiple-value-bind (mantdigits mantdigitslength
                                leadingpoint trailingpoint point-pos)
              (format-float-to-string mantissa mantwidth mantd k dmin)
            (when w
              (setq mantwidth (- mantwidth mantdigitslength))
              (when trailingpoint
                (if (or (null mantd) (> mantd 0))
                  (setq mantwidth (- mantwidth 1))
                  (setq trailingpoint nil)))
              (when leadingpoint
                (if (> mantwidth 0)
                  (setq mantwidth (- mantwidth 1))
                  (setq leadingpoint nil))))
            ;; mantwidth characters remain.
            (if (and overflowchar w (minusp mantwidth))
              (format-padding w overflowchar stream) ; not enough room -> overflow
              (progn
                (when (and (plusp k) (< k point-pos))
                  ;; format-float-to-string rounded the mantissa up above 1
                  ;; so that all our assumptions are now wrong and we are
                  ;; about to get (format nil "~8e" .999999d9) => " 10.0d+8"
                  (let* ((shift (- point-pos 1))
                         (new-exponent (+ exponent shift))
                         (new-expdigits
                          (write-to-string (abs new-exponent) :base 10.
                                           :radix nil :readably nil)))
                    ;; shift the decimal point left
                    (dotimes (i shift)
                      (rotatef (char mantdigits (- point-pos i))
                               (char mantdigits (- point-pos i 1))))
                    ;; update for the the exponent change
                    (when mantwidth
                      (incf mantwidth (- (length expdigits)
                                         (length new-expdigits))))
                    (setq exponent new-exponent
                          expdigits new-expdigits)
                    ;; update for the trailing point change
                    (when trailingpoint
                      (setq trailingpoint nil)
                      (when mantwidth (incf mantwidth)))))
                (when (and w (> mantwidth 0))
                  (format-padding mantwidth padchar stream))
                (if (minusp arg)
                  (write-char #\- stream)
                  (if plus-sign-flag (write-char #\+ stream)))
                (when leadingpoint (write-char #\0 stream))
                (write-string mantdigits stream)
                (when trailingpoint (write-char #\0 stream))
                (write-char
                  (cond (exponentchar)
                        ((and (not *PRINT-READABLY*)
                              (typep arg *READ-DEFAULT-FLOAT-FORMAT*))
                         #\E)
                        ((short-float-p arg) #\s)
                        ((single-float-p arg) #\f)
                        ((double-float-p arg) #\d)
                        ((long-float-p arg) #\L))
                  stream)
                (write-char (if (minusp exponent) #\- #\+) stream)
                (when (and e (> e (length expdigits)))
                  (format-padding (- e (length expdigits)) #\0 stream))
                (write-string expdigits stream)))))))))

;; advances *FORMAT-CSDL* until the end of the current ~[ resp. ~{ resp. ~< .
(defun format-skip-to-end ()
  (do ()
      ((null (csd-clause-chain (car *FORMAT-CSDL*))))
    (setq *FORMAT-CSDL* (csd-clause-chain (car *FORMAT-CSDL*)))))

;; (format-justified-segments mincol colinc minpad justify-left justify-right
;;                            piecelist)
;; calculates the positions and the number of spaces between
;; the various Strings in piecelist.
;; Between the various Strings in piecelist (also ahead, if justify-left;
;; also behind, if justify-right) at least minpad padding-characters
;; are inserted. Then, further padding-characters are added, for the
;; total width to become >= mincol. If width > mincol, more
;; padding-characters are added until the width is of the form
;; mincol + k * colinc.
;; These padding-characters are distributed to the various places evenly.
;; 1st value: A vector, that specifies for each position, how many
;;            padding-characters have to be inserted (NIL = none).
;;            First Element: leftmost, Second Element: behind the 1st String,
;;            ..., last: rightmost.
;; 2. value: The resulting total width.
(defun format-justified-segments
       (mincol colinc minpad justify-left justify-right piecelist)
  (declare (fixnum mincol colinc minpad))
  (let ((piecesnumber 0)
        (pieceswidth 0))
    (dolist (piece piecelist)
      (declare (simple-string piece))
      (incf piecesnumber)
      (incf pieceswidth (string-width piece)))
    (let* ((new-justify-left
             (or justify-left (and (= piecesnumber 1) (not justify-right))))
           (padblocks (+ piecesnumber -1       ; number of insertion-points
                         (if new-justify-left 1 0) (if justify-right 1 0)))
           (width-need (+ pieceswidth (* padblocks minpad)))
           (width (+ mincol
                     (if (<= width-need mincol)
                       0
                       (* (ceiling (- width-need mincol) colinc) colinc)))))
      (declare (fixnum piecesnumber pieceswidth padblocks width-need width))
      (multiple-value-bind (padwidth rest)
          (floor (- width pieceswidth) padblocks)
        (let ((padblock-lengths
                (make-array (1+ piecesnumber) :initial-element padwidth)))
          (unless new-justify-left (setf (svref padblock-lengths 0) nil))
          (unless justify-right
            (setf (svref padblock-lengths piecesnumber) nil))
          (do ((i 0 (1+ i)))
              ((zerop rest))
            (when (svref padblock-lengths i)
              (incf (svref padblock-lengths i))
              (decf rest)))
          (values padblock-lengths width))))))

;;; ---------------------------------------------------------------------------

;; ~A, CLTL p.387-388, CLtL2 p. 584, ABI
(defformat-simple format-ascii (stream colon-modifier atsign-modifier
                  (mincol 0) (colinc 1) (minpad 0) (padchar #\Space))
                  (arg)
  (when (and colon-modifier (null arg)) (setq arg "()"))
  (if (and (zerop mincol) (zerop minpad))
    (princ arg stream)
    (format-padded-string mincol colinc minpad padchar
      atsign-modifier ; =: padleftflag
      (princ-to-string arg)
      stream)))

;; preliminary, see fill-out.lisp (defgeneric is not yet available)
(defun stream-start-s-expression (stream)
  (declare (ignore stream)) *print-right-margin*)
(defun stream-end-s-expression (stream) (declare (ignore stream)))

;; ~S, CLTL p.388, CLtL2 p. 584, ABI
(defformat-simple format-s-expression (stream colon-modifier atsign-modifier
                  (mincol 0) (colinc 1) (minpad 0) (padchar #\Space))
                  (arg)
  (let ((*print-right-margin* (stream-start-s-expression stream)))
    (if (and (zerop mincol) (zerop minpad))
      (if (and colon-modifier (null arg))
        (write-string #1="()" stream)
        (prin1 arg stream))
      (format-padded-string mincol colinc minpad padchar
        atsign-modifier ; =: padleftflag
        (if (and colon-modifier (null arg)) #1# (prin1-to-string arg))
        stream)))
  (stream-end-s-expression stream))

;; ~W, ABI
(defformat-simple format-write (stream colon-modifier atsign-modifier
                  (mincol 0) (colinc 1) (minpad 0) (padchar #\Space))
                  (arg)
  (declare (ignore colon-modifier))
  (if (and (zerop mincol) (zerop minpad))
    (write arg :stream stream)
    (format-padded-string mincol colinc minpad padchar
      atsign-modifier ; =: padleftflag
      (write-to-string arg)
      stream)))

;; ~D, CLTL p.388, CLtL2 p. 585, ABI
(defformat-simple format-decimal (stream colon-modifier atsign-modifier
                  (mincol 0) (padchar #\Space) (commachar #\,)
                  (commainterval 3))
                  (arg)
  (format-base 10 stream colon-modifier atsign-modifier mincol
               padchar commachar commainterval arg))

;; ~B, CLTL p.388, CLtL2 p. 585, ABI
(defformat-simple format-binary (stream colon-modifier atsign-modifier
                  (mincol 0) (padchar #\Space) (commachar #\,)
                  (commainterval 3))
                  (arg)
  (format-base 2 stream colon-modifier atsign-modifier mincol
               padchar commachar commainterval arg))

;; ~O, CLTL p.388, CLtL2 p. 585, ABI
(defformat-simple format-octal (stream colon-modifier atsign-modifier
                  (mincol 0) (padchar #\Space) (commachar #\,)
                  (commainterval 3))
                  (arg)
  (format-base 8 stream colon-modifier atsign-modifier mincol
               padchar commachar commainterval arg))

;; ~X, CLTL p.388-389, CLtL2 p. 586, ABI
(defformat-simple format-hexadecimal (stream colon-modifier atsign-modifier
                  (mincol 0) (padchar #\Space) (commachar #\,)
                  (commainterval 3))
                  (arg)
  (format-base 16 stream colon-modifier atsign-modifier mincol
               padchar commachar commainterval arg))

;; ~R, CLTL p.389, CLtL2 p. 586-587, ABI
(defformat-simple format-radix (stream colon-modifier atsign-modifier
                  (radix nil) (mincol 0) (padchar #\Space) (commachar #\,)
                  (commainterval 3))
                  (arg)
  (if radix
    (format-integer radix mincol padchar commachar commainterval
                    colon-modifier atsign-modifier
                    arg stream)
    (if atsign-modifier
      (if (integerp arg)
        (if colon-modifier
          (format-old-roman arg stream)
          (format-new-roman arg stream))
        (format-error 'type-error :datum arg :expected-type 'INTEGER
          *FORMAT-CS* nil
          (TEXT "The ~~R and ~~:R format directives require an integer argument, not ~S")
          arg))
      (if colon-modifier
        (format-ordinal arg stream)
        (format-cardinal arg stream)))))

;; ~P, CLTL p. 389, CLtL2 p. 587-588, ABI
(defun format-plural (stream colon-modifier atsign-modifier)
  (when colon-modifier (format-goto-new-arg t 1))
  (let ((singular (eql (next-arg) 1)))
    (if atsign-modifier
      (write-string (if singular "y" "ies") stream)
      (unless singular (write-char #\s stream)))))

;; ~C, CLTL p.389-390, CLtL2 p. 588, ABI
(defformat-simple format-character (stream colon-modifier atsign-modifier)
                  (arg)
  (unless (characterp arg)
    (format-error 'type-error :datum arg :expected-type 'CHARACTER
      *FORMAT-CS* nil
      (TEXT "The ~~C format directive requires a character argument, not ~S")
      arg))
  (if (not colon-modifier)
    (if (not atsign-modifier)
      ;; ~C
      (write-char arg stream)
      ;; ~@C
      (prin1 arg stream))
    ;; ~:C prints the name of non-printing characters.
    ;; ~:@C prints instructions how to type the character.
    ;; Since characters don't have attributes any more, both do the same.
    (if (and (graphic-char-p arg) (not (eql arg #\Space)))
      (write-char arg stream)
      (let ((name (char-name arg)))
        (if name
          (write-string name stream)
          (write-char arg stream))))))

;; ~F, CLTL p.390-392, CLtL2 p. 588-590, ABI
(defformat-simple format-fixed-float (stream colon-modifier atsign-modifier
                  (w nil) (d nil) (k 0) (overflowchar nil) (padchar #\Space))
                  (arg)
  (declare (ignore colon-modifier))
  (when (rationalp arg) (setq arg (float arg)))
  (if (floatp arg)
    (format-float-for-f w d k overflowchar padchar atsign-modifier arg stream)
    (if w
      (format-padded-string w 1 0 padchar t (princ-to-string arg) stream)
      (format-ascii-decimal arg stream))))

;; ~E, CLTL p.392-395, CLtL2 p. 590-593, ABI
(defformat-simple format-exponential-float (stream
                  colon-modifier atsign-modifier
                  (w nil) (d nil) (e nil) (k 1)
                  (overflowchar nil) (padchar #\Space) (exponentchar nil))
                  (arg)
  (declare (ignore colon-modifier))
  (when (rationalp arg) (setq arg (float arg)))
  (if (floatp arg)
    (format-float-for-e w d e k overflowchar padchar exponentchar
                        atsign-modifier arg stream)
    (if w
      (format-padded-string w 1 0 padchar t (princ-to-string arg) stream)
      (format-ascii-decimal arg stream))))

;; ~G, CLTL p.395-396, CLtL2 p. 594-595, ABI
(defformat-simple format-general-float (stream colon-modifier atsign-modifier
                  (w nil) (d nil) (e nil) (k 1)
                  (overflowchar nil) (padchar #\Space) (exponentchar nil))
                  (arg)
  (declare (ignore colon-modifier))
  (if (rationalp arg) (setq arg (float arg)))
  (if (floatp arg)
    (let ((n (float-scale-exponent (abs arg))))
      (if (null d)
        (setq d
          (multiple-value-bind (digits digitslength)
              (format-float-to-string (abs arg) nil nil nil nil)
            (declare (ignore digits))
            (max (1- digitslength) 1 (min n 7)))))
      (let* ((ee (if e (+ 2 e) 4))
             (dd (- d n)))
        (if (<= 0 dd d)
          (progn
            (format-float-for-f
              (if w (- w ee) nil)
              dd 0
              overflowchar padchar atsign-modifier arg stream)
            (format-padding ee #\Space stream))
          (format-float-for-e w d e k overflowchar padchar exponentchar
                              atsign-modifier arg stream))))
    (if w
      (format-padded-string w 1 0 padchar t (princ-to-string arg) stream)
      (format-ascii-decimal arg stream))))

;; ~$, CLTL p.396-397, CLtL2 p. 595-596, ABI
(defformat-simple format-dollars-float (stream colon-modifier atsign-modifier
                  (d 2) (n 1) (w 0) (padchar #\Space))
                  (arg)
  (when (rationalp arg) (setq arg (float arg)))
  (if (floatp arg)
    (multiple-value-bind (digits digitslength
                          leadingpoint trailingpoint leadings)
        (format-float-to-string arg nil d 0 nil)
      (declare (ignore digitslength leadingpoint trailingpoint))
      (let* ((lefts (max leadings n))
             (totalwidth (+ (if (or atsign-modifier (minusp arg)) 1 0)
                            lefts 1 d))
             (padcount (max (- w totalwidth) 0)))
        (if (not colon-modifier) (format-padding padcount padchar stream))
        (if (minusp arg)
          (write-char #\- stream)
          (if atsign-modifier (write-char #\+ stream)))
        (if colon-modifier (format-padding padcount padchar stream))
        (format-padding (- lefts leadings) #\0 stream)
        (write-string digits stream)))
    (if d
      (format-padded-string d 1 0 padchar t (princ-to-string arg) stream)
      (format-ascii-decimal arg stream))))

;; ~%, CLTL p.397, CLtL2 p. 596, ABI
(defun format-terpri (stream colon-modifier atsign-modifier &optional (count 1))
  (declare (ignore colon-modifier atsign-modifier))
  (if (null count) (setq count 1))
  (dotimes (i count) (terpri stream)))

(defun format-pprint-newline (stream colon-modifier atsign-modifier)
  (pprint-newline (if colon-modifier
                    (if atsign-modifier :mandatory :fill)
                    (if atsign-modifier :miser :linear))
                  stream))

(defun format-pprint-indent (stream colon-modifier atsign-modifier
                             &optional (count 1))
  (declare (ignore atsign-modifier))
  (pprint-indent (if colon-modifier :current :block) (or count 1) stream))

;; ~&, CLTL p.397, CLtL2 p. 596, ABI
(defun format-fresh-line (stream colon-modifier atsign-modifier
                          &optional (count 1))
  (declare (ignore colon-modifier atsign-modifier))
  (if (null count) (setq count 1))
  (when (plusp count)
    (fresh-line stream)
    (dotimes (i (1- count)) (terpri stream))))

;; ~.
(defun format-elastic-newline (stream colon-modifier atsign-modifier
                               &optional (count 1))
  (declare (ignore colon-modifier atsign-modifier))
  (if (null count) (setq count 1))
  (when (plusp count)
    (dotimes (i (1- count)) (terpri stream))
    (ext:elastic-newline stream)))

;; ~|, CLTL p.397, CLtL2 p. 596, ABI
(defun format-page (stream colon-modifier atsign-modifier &optional (count 1))
  (declare (ignore colon-modifier atsign-modifier))
  (if (null count) (setq count 1))
  (dotimes (i count) (write-char #\Page stream)))

;; ~~, CLTL p.397, CLtL2 p. 596, ABI
(defun format-tilde (stream colon-modifier atsign-modifier &optional (count 1))
  (declare (ignore colon-modifier atsign-modifier))
  (if (null count) (setq count 1))
  (dotimes (i count) (write-char #\~ stream)))

#| have to support PPHELP streams separately, so this is in io.d now
;; ~T, CLTL p.398-399, CLtL2 p. 597-598, ABI
 (defun format-tabulate (stream colon-modifier atsign-modifier
                        &optional (colnum 1) (colinc 1))
  (if (null colnum) (setq colnum 1))
  (if (null colinc) (setq colinc 1))
  (let* ((new-colnum (+ (max colnum 0)
                        (if (and colon-modifier (boundp '*prin-indentation*))
                          *prin-indentation*
                          0)))
         (new-colinc (max colinc 1)) ; >0
         (pos (sys::line-position stream))) ; actual position, fixnum>=0 or NIL
    (if atsign-modifier
      (format-padding
        (if pos
          (+ new-colnum (mod (- (+ pos new-colnum)) new-colinc))
          new-colnum)
        #\Space stream)
      (if pos
        (if (< pos new-colnum)
          (format-padding (- new-colnum pos) #\Space stream)
          (unless (zerop colinc)
            (format-padding (+ colinc (mod (- new-colnum pos) (- colinc)))
                            #\Space stream)))
        (format-padding 2 #\Space stream)))))
|#

;; ~*, CLTL p.399, CLtL2 p. 598
(defun format-goto (stream colon-modifier atsign-modifier
                    &optional (index nil))
  (declare (ignore stream))
  (if atsign-modifier
    (setq *FORMAT-NEXT-ARG* (nthcdr (or index 0) *FORMAT-ARG-LIST*))
    (format-goto-new-arg colon-modifier (or index 1))))

;; ~?, CLTL p.399-401, CLtL2 p. 598-599
(defun format-indirection (stream colon-modifier atsign-modifier)
  (declare (ignore colon-modifier))
  (let* ((csarg (next-arg))
         (node (do-format-indirection-1 csarg)))
    (if atsign-modifier
      (if (consp node)
        (let ((*FORMAT-CS* (car node))
              (*FORMAT-CSDL* (cdr node))
             ;(*FORMAT-ARG-LIST* *FORMAT-NEXT-ARG*) ; ??
              (*FORMAT-UP-AND-OUT* nil))
          (format-interpret stream))
        (setq *FORMAT-NEXT-ARG*
          (let ((*FORMAT-CS* nil))
            (apply node stream *FORMAT-NEXT-ARG*))))
      (let ((arglistarg (next-arg)))
        (do-format-indirection-2 stream node arglistarg arglistarg)))))
(defun do-format-indirection (stream csarg arguments) ; ABI
  (unless (or (stringp csarg) (functionp csarg))
    (format-indirection-cserror csarg))
  (unless (listp arguments) (format-indirection-lerror arguments))
  (format-apply stream csarg arguments))
(defun do-format-indirection-1 (csarg) ; ABI
  (cond ((stringp csarg)
         (let ((node (list csarg)))
           (format-parse-cs csarg 0 node nil)
           node))
        ((functionp csarg)
         csarg)
        (t (format-indirection-cserror csarg))))
(defun do-format-indirection-2 (stream node arglistarg wholelistarg) ; ABI
  (unless (listp arglistarg) (format-indirection-lerror arglistarg))
  (if (consp node)
    (let* ((*FORMAT-CS*         (car node))
           (*FORMAT-CSDL*       (cdr node))
           (*FORMAT-ARG-LIST*   wholelistarg)
           (*FORMAT-NEXT-ARG*   arglistarg)
           (*FORMAT-NEXT-ARGLIST* nil)
           (*FORMAT-UP-AND-OUT* nil))
      (format-interpret stream)
      *FORMAT-NEXT-ARG*)
    (let ((*FORMAT-CS* nil))
      (apply node stream arglistarg)))) ; wholelistarg??
(defun format-indirection-cserror (csarg)
  (format-error 'type-error :datum csarg :expected-type '(OR STRING FUNCTION)
    *FORMAT-CS* nil
    (TEXT "The control string argument for the ~~? format directive is invalid: ~S")
    csarg))
(defun format-indirection-lerror (arguments)
  (format-error 'type-error :datum arguments :expected-type 'LIST
    *FORMAT-CS* nil
    (TEXT "The argument list argument for the ~~? format directive is invalid: ~S")
    arguments))

;;; ~// ANSI CL 22.3.5.4 Tilde Slash: Call Function
(defun FORMAT-CALL-USER-FUNCTION (stream colon-p atsign-p symbol-list
                                  &rest more-args)
  (apply (car symbol-list) stream (next-arg) colon-p atsign-p more-args))

;; ~(, CLTL p.401, CLtL2 p. 600-601
(defun format-case-conversion (stream colon-modifier atsign-modifier)
  (setq *FORMAT-CSDL* (cdr *FORMAT-CSDL*))
  (let ((tempstr
          (let ((tempstream (make-string-output-stream
                              :line-position (sys::line-position stream))))
            (format-interpret tempstream 'FORMAT-CASE-CONVERSION-END)
            ;; what does UP-AND-OUT effectuate in ~{...~(...~^...~)...~} ??
            (get-output-stream-string tempstream))))
    (if colon-modifier
      (if atsign-modifier
        (write-string (nstring-upcase tempstr) stream)
        (write-string (nstring-capitalize tempstr) stream))
      (if atsign-modifier
        (write-string (nstring-capitalize1 tempstr) stream)
        (write-string (nstring-downcase tempstr) stream)))))
(defun nstring-capitalize1 (string) ; ABI
  (setq string (nstring-downcase string))
  (dotimes (i (length string)) ; make first character Upcase
    (when (both-case-p (schar string i))
      (setf (schar string i) (char-upcase (schar string i)))
      (return)))
  string)

;; ~[, CLTL p.402-403, CLtL2 p. 601-602
(defun format-conditional (stream colon-modifier atsign-modifier
                           &optional (prefix nil))
  (if colon-modifier
    (if atsign-modifier
      (format-not-both-error "~[")
      (progn
        (when (next-arg)
          (setq *FORMAT-CSDL* (csd-clause-chain (car *FORMAT-CSDL*))))
        (setq *FORMAT-CSDL* (cdr *FORMAT-CSDL*))
        (format-interpret stream 'FORMAT-CONDITIONAL-END)))
    (if atsign-modifier
      (when (next-arg)
        (format-goto-new-arg t 1)
        (setq *FORMAT-CSDL* (cdr *FORMAT-CSDL*))
        (format-interpret stream 'FORMAT-CONDITIONAL-END)
        (unless (null (csd-clause-chain (car *FORMAT-CSDL*)))
          (format-error 'error *FORMAT-CS* nil
            (TEXT "The ~~; format directive is not allowed at this point."))))
      (let ((index (or prefix (next-arg))))
        (unless (integerp index)
          (format-error 'type-error :datum index :expected-type 'INTEGER
            *FORMAT-CS* nil
            (TEXT "The ~~[ parameter must be an integer, not ~S")
            index))
        (dotimes (i (if (minusp index) most-positive-fixnum index))
          (when (eq (csd-data (car *FORMAT-CSDL*)) 'FORMAT-CONDITIONAL-END)
            (return))
          (setq *FORMAT-CSDL* (csd-clause-chain (car *FORMAT-CSDL*)))
          (when (csd-colon-p (car *FORMAT-CSDL*)) (return)))
        (unless (eq (csd-data (car *FORMAT-CSDL*)) 'FORMAT-CONDITIONAL-END)
          (setq *FORMAT-CSDL* (cdr *FORMAT-CSDL*)))
        (format-interpret stream 'FORMAT-CONDITIONAL-END))))
  (format-skip-to-end)) ; skip to the end of ~[...~]-Directive

; ~{, CLTL p.403-404, CLtL2 p. 602-604
(defun format-iteration (stream colon-modifier atsign-modifier
                         &optional (prefix nil))
  (let* ((total-csdl *FORMAT-CSDL*)
         (max-iteration-count prefix))
    (format-skip-to-end) ; skip to the end of ~{...~}-Directive
    (let* ((min-1-iteration (csd-colon-p (car *FORMAT-CSDL*)))
           (inner-cs (if (eq (cdr total-csdl) *FORMAT-CSDL*)
                       (next-arg)
                       *FORMAT-CS*))
           (inner-csdl (if (stringp inner-cs)
                         (if (eq (cdr total-csdl) *FORMAT-CSDL*)
                           (let ((node (list inner-cs)))
                             (format-parse-cs inner-cs 0 node nil)
                             (cdr node))
                           (cdr total-csdl))))
           (arg-list-rest (if (not atsign-modifier)
                            (let ((arg (next-arg)))
                              (unless (listp arg)
                                (format-error 'type-error :datum arg :expected-type 'LIST
                                  *FORMAT-CS* nil
                                  (TEXT "The ~~{ format directive requires a list argument, not ~S")
                                  arg))
                              arg))))
      (do* ((iteration-count 0 (1+ iteration-count)))
           ((or (and max-iteration-count
                     (>= iteration-count max-iteration-count))
                (let ((remaining (if atsign-modifier
                                   *FORMAT-NEXT-ARG*
                                   arg-list-rest)))
                  (if min-1-iteration
                    (and (plusp iteration-count) (null remaining))
                    (null remaining)))))
        (if (stringp inner-cs)
          (if colon-modifier
            (let* ((*FORMAT-ARG-LIST*
                     (if atsign-modifier (next-arg) (pop arg-list-rest)))
                   (*FORMAT-NEXT-ARGLIST* ; for ~:^
                     (if atsign-modifier *FORMAT-NEXT-ARG* arg-list-rest))
                   (*FORMAT-NEXT-ARG* *FORMAT-ARG-LIST*)
                   (*FORMAT-CS* inner-cs)
                   (*FORMAT-CSDL* inner-csdl)
                   (*FORMAT-UP-AND-OUT* nil))
              (format-interpret stream 'FORMAT-ITERATION-END)
              (when (eq *FORMAT-UP-AND-OUT* ':TERMINATE-ALL) (return))
            )
            (if atsign-modifier
              ;; CLtL2 p. 598: "When within a ~{ construct, the "goto" is
              ;; relative to the list of arguments being processed by the
              ;; iteration." Does that mean, that for ~@{, *FORMAT-ARG-LIST*
              ;; has to be freshly bound at the beginning of each Iteration??
              ;; (*FORMAT-ARG-LIST* *FORMAT-NEXT-ARG*) ??
              (let* ((*FORMAT-CS* inner-cs)
                     (*FORMAT-CSDL* inner-csdl)
                     (*FORMAT-UP-AND-OUT* nil))
                (format-interpret stream 'FORMAT-ITERATION-END)
                (when *FORMAT-UP-AND-OUT* (return)))
              (let* ((*FORMAT-ARG-LIST* arg-list-rest)
                     (*FORMAT-NEXT-ARG* *FORMAT-ARG-LIST*)
                     (*FORMAT-CS* inner-cs)
                     (*FORMAT-CSDL* inner-csdl)
                     (*FORMAT-UP-AND-OUT* nil))
                (format-interpret stream 'FORMAT-ITERATION-END)
                (setq arg-list-rest *FORMAT-NEXT-ARG*)
                (when *FORMAT-UP-AND-OUT* (return)))))
          ;; inner-cs may be a function in the ~{~} case
          (if (functionp inner-cs)
            (if colon-modifier
              (let* ((arglist
                       (if atsign-modifier (next-arg) (pop arg-list-rest)))
                     (*FORMAT-CS* nil))
                (apply inner-cs stream arglist))
              (if atsign-modifier
                (setq *FORMAT-NEXT-ARG*
                  (let ((*FORMAT-CS* nil))
                    (apply inner-cs stream *FORMAT-NEXT-ARG*)))
                (setq arg-list-rest
                  (let ((*FORMAT-CS* nil))
                    (apply inner-cs stream arg-list-rest)))))
            (format-indirection-cserror inner-cs)))))))

;; ~<, CLTL p.404-406, CLtL2 p. 604-605
(defun format-justification (stream colon-modifier atsign-modifier
       &optional (mincol 0) (colinc 1) (minpad 0) (padchar #\Space))
  (let* ((saved-csdl *FORMAT-CSDL*)
         (pos (sys::line-position stream))
         (tempstream (make-string-output-stream :line-position pos))
         (check-on-line-overflow nil)
         supplementary-need
         line-length
         (old-piecelist
           (let ((pieces nil))
             (do ((first-piece-flag t nil))
                 ((eq (csd-data (car *FORMAT-CSDL*))
                      'FORMAT-JUSTIFICATION-END))
               (setq *FORMAT-CSDL* (cdr *FORMAT-CSDL*))
               (let ((*FORMAT-UP-AND-OUT* nil))
                 (format-interpret tempstream 'FORMAT-JUSTIFICATION-END)
                 (when (and first-piece-flag
                            (eq (csd-data (car *FORMAT-CSDL*))
                                'FORMAT-SEPARATOR))
                   (when (setq check-on-line-overflow
                               (csd-colon-p (car *FORMAT-CSDL*)))
                     (multiple-value-setq (supplementary-need line-length)
                       (values-list
                         (format-resolve-parms (car *FORMAT-CSDL*))))))
                 (when *FORMAT-UP-AND-OUT*
                   (setq *FORMAT-CSDL* saved-csdl)
                   (format-skip-to-end)
                   (return))
                 (push (get-output-stream-string tempstream) pieces)))
             (nreverse pieces))))
    (do-format-justification stream colon-modifier atsign-modifier
                             mincol colinc minpad padchar
                             pos check-on-line-overflow
                             (if check-on-line-overflow (car old-piecelist))
                             supplementary-need line-length
                             (if check-on-line-overflow
                               (cdr old-piecelist)
                               old-piecelist))))
(defun do-format-justification (stream colon-modifier atsign-modifier
                                mincol colinc minpad padchar
                                pos check-on-line-overflow firstpiece
                                supplementary-need line-length piecelist) ; ABI
  (if (null mincol) (setq mincol 0))
  (if (null colinc) (setq colinc 1))
  (if (null minpad) (setq minpad 0))
  (if (null padchar) (setq padchar #\Space))
  (if piecelist
    (multiple-value-bind (padblocklengths width)
      (format-justified-segments mincol colinc minpad
        colon-modifier atsign-modifier piecelist)
      (when (and check-on-line-overflow
                 (> (+ (or pos 0) width (or supplementary-need 0))
                    (or line-length #|(sys::line-length stream)|# 72)))
        (write-string firstpiece stream))
      (do ((i 0 (1+ i)))
          (nil)
        (when (svref padblocklengths i)
          (format-padding (svref padblocklengths i) padchar stream))
        (when (null piecelist) (return))
        (write-string (pop piecelist) stream)))
    (format-padding mincol padchar stream)))

;; CLtL2 p. 762-763
(defun format-logical-block (stream colon-modifier atsign-modifier)
  ;; (format-error 'error *FORMAT-CS* nil (TEXT "~~<...~~:> not implemented yet"))
  (format-justification stream colon-modifier atsign-modifier))

;; parse the CSDL and return the following values
;; prefix string (or nil)
;; suffix string (or nil)
;; per-line-p non-nil or nil
;; body-csdl csdl
;; add-fill-p t or nil
;; last-csdl csdl
(defun format-logical-block-parse (csdl)
  (let (prefix suffix per-line-p body-csdl add-fill-p temp)
    (when (csd-colon-p (car csdl))
      (setq prefix "(")
      (setq suffix ")"))
    (setq temp (car (csd-clause-chain (car csdl))))
    (unless (eq (csd-data temp) 'FORMAT-JUSTIFICATION-END)
      (pop csdl)
      (setq per-line-p (csd-atsign-p temp))
      (cond ((eq (car csdl) temp)
             (setq prefix ""))
            ((and (eq (car (cdr csdl)) temp)
                  (eql (csd-type (car csdl)) 1))
             (setq prefix (subseq *FORMAT-CS* (csd-cs-index (car csdl))
                                  (csd-data (car csdl))))
             (pop csdl))
            (t (format-error 'error *FORMAT-CS* (csd-cs-index (car csdl))
                 (TEXT "Logical block prefix must be constant")))))
    (setq body-csdl (cdr csdl))
    (setq temp (csd-clause-chain (car csdl)))
    (unless (eq (csd-data (car temp)) 'FORMAT-JUSTIFICATION-END)
      (pop temp)
      (cond ((eql (csd-type (car temp)) 1)
             (setq suffix (subseq *FORMAT-CS* (csd-cs-index (car temp))
                                              (csd-data (car temp))))
             (pop temp))))
    (unless (and (eql (csd-type (car temp)) 2)
                 (eq (csd-data (car temp)) 'FORMAT-JUSTIFICATION-END))
      (format-error 'error *FORMAT-CS* (csd-cs-index (car temp))
        (TEXT "Logical block suffix must be constant")))
    (setq add-fill-p (csd-atsign-p (car temp)))
    (values prefix suffix per-line-p body-csdl add-fill-p temp)))

;; ~^, CLTL p.406-407, CLtL2 p. 605-606
(defun format-up-and-out (stream colon-modifier atsign-modifier
                          &optional (a nil) (b nil) (c nil))
  (declare (ignore stream atsign-modifier))
  (if (up-and-out-p a b c
        (if colon-modifier *FORMAT-NEXT-ARGLIST* *FORMAT-NEXT-ARG*))
    (setq *FORMAT-UP-AND-OUT* (if colon-modifier ':TERMINATE-ALL ':TERMINATE))))
(defun up-and-out-p (a b c &optional args) ; ABI
  (cond ((and (null a) (null b) (null c)) ; no parameters
         (null args))
        ((and (null b) (null c)) (eql a 0)) ; one parameter
        ((null c) (eql a b)) ; two parameters
        ((and (integerp a) (integerp b) (integerp c)) (<= a b c))
        ((and (characterp a) (characterp b) (characterp c)) (char<= a b c))))

;; ~!, a CLISP extension as a replacement for badly designed ~/.../
(defun format-call (stream colon-modifier atsign-modifier &rest more-args)
  (apply (next-arg) stream (next-arg) colon-modifier atsign-modifier
         more-args))

;;; ---------------------------------------------------------------------------
;;; FORMATTER - Compilation of FORMAT-Strings.


;; Fall-back function if control-string cannot be compiled.
(defun formatter-hairy (control-string) ; ABI
  ;; control-string is known to be a string
  #'(lambda (stream &rest args)
      (let ((node (list control-string)))
        (format-parse-cs control-string 0 node nil)
        (let* ((*FORMAT-CS*         (car node))
               (*FORMAT-CSDL*       (cdr node))
               (*FORMAT-ARG-LIST*   args)
               (*FORMAT-NEXT-ARG*   *FORMAT-ARG-LIST*)
               (*FORMAT-NEXT-ARGLIST* nil)
               (*FORMAT-UP-AND-OUT* nil))
          (format-interpret stream)
          *FORMAT-NEXT-ARG*))))


;; Block for ~^
(defvar *format-terminate*)
;; Block for ~:^
(defvar *format-terminate-all*)

;; the block is only provided on demand.
;; In order to avoid unnecessary UNWIND-PROTECTs, a list of the pending
;; UNWIND-PROTECTs is maintained.
;; Each block-name (a Gensym) contains a reference
;; to this list at the moment of its creation.

;; list of pending UNWIND-PROTECTs
(defvar *format-uwps*)

(defun formatter-block (prefix)
  (let ((sym (gensym prefix)))
    (setf (get sym 'uwps) *format-uwps*)
    sym))

(flet ((mark-used (blockname)
         ;; mark the block for not being optimized away.
         (setf (get blockname 'used) t)
         ;; mark all skipped UNWIND-PROTECTs for not being
         ;; optimized away.
         (do ((L1 *format-uwps* (cdr L1))
              (L2 (get blockname 'uwps)))
             ((eq L1 L2))
           (setf (car L1) 'T))
         blockname))
  (defun formatter-terminate ()
    (mark-used *format-terminate*))
  (defun formatter-terminate-all ()
    (mark-used *format-terminate-all*)))

(defmacro formatter-bind-terminator (&body body)
  `(let ((*format-terminate* (formatter-block "TERMINATE-")))
     (formatter-bind-terminator-1 (progn ,@body))))
(defun formatter-bind-terminator-1 (forms)
  (when (get *format-terminate* 'used)
    (setq forms `((BLOCK ,*format-terminate* ,@forms))))
  forms)

(defmacro formatter-bind-terminators (&body body)
  `(let ((*format-terminate* (formatter-block "TERMINATE-"))
         (*format-terminate-all* (formatter-block "TERMINATE-ALL-")))
     (formatter-bind-terminators-1 (progn ,@body))))
(defun formatter-bind-terminators-1 (forms)
  (when (get *format-terminate* 'used)
    (setq forms `((BLOCK ,*format-terminate* ,@forms))))
  (when (get *format-terminate-all* 'used)
    (setq forms `((BLOCK ,*format-terminate-all* ,@forms))))
  forms)


;; Flag, if within ~(...~)
(defvar *format-case*)

;; the argument-list cannot always have the same name ARGS because of ~:^ .
;; your name.
(defvar *args*)

;; name of the argument-list of the enclosing ~:{ Iteration.
(defvar *iterargs*)

;; access to the normal argument-list:
;; normal case:
;;   argument-list &REST ARGS,
;;   access to the next element is (POP ARGS),
;;   ~# is (LENGTH ARGS),
;;   total list for ~:* is WHOLE-ARGS.
;; optimized, if no (LENGTH ARGS) and no WHOLE-ARGS is necessary:
;;   argument-list #:ARG1 #:ARG2 ... &REST ARGS
;;   access to the next element is #:ARGi or (POP ARGS).

;; flag, that indicates, if we are still in the linear processing phase of
;; the arguments (each one exactly once, known position).
(defvar *formatter-linear-args*)

;; number of arguments, that belong to the linear processing phase, so far.
;; Important: It can be decreased afterwards!!
(defvar *formatter-linear-argcount*)

;; position in the argument-list during the linear processing phase.
;; always <= *formatter-linear-argcount*.
(defvar *formatter-linear-position*)

;; flag, if WHOLE-ARGS is to be bound.
(defvar *formatter-whole-args*)

;; starts an iteration, that binds ARGS and possibly WHOLE-ARGS.
(defmacro formatter-bind-args (&body body)
  `(let ((*args* (gensym "ARGS"))
         (*formatter-linear-args* t)
         (*formatter-linear-argcount* 0)
         (*formatter-linear-position* 0)
         (*formatter-whole-args* nil))
     (formatter-bind-args-1 (progn ,@body))))
(defun formatter-bind-args-1 (forms)
  (when *formatter-whole-args*
    (subst-if-then #'(lambda (x) ; x = `(WHOLE-ARGS ,i)
                       (setq *formatter-linear-argcount*
                             (min *formatter-linear-argcount* (second x))))
                   #'(lambda (x) ; x = `(WHOLE-ARGS ,i) ?
                       (and (consp x) (eq (car x) 'WHOLE-ARGS)
                            (consp (cdr x)) (numberp (cadr x)) (null (cddr x))))
                   forms))
  (let ((argsyms nil))
    (dotimes (i *formatter-linear-argcount*) (push (gensym "ARG") argsyms))
    (setq argsyms (nreverse argsyms))
    (setq forms
      (subst-if-then #'(lambda (x) ; x = `(ARG ,i)
                         (if (< (second x) *formatter-linear-argcount*)
                           (nth (second x) argsyms)
                           `(POP ,*args*)))
                     #'(lambda (x) ; x = `(ARG ,i) ?
                         (and (consp x) (eq (car x) 'ARG) (consp (cdr x)) (null (cddr x))))
                     forms))
    (setq forms
      (subst-if-then #'(lambda (x) ; x = `(SETQ-ARGS-WHOLE-ARGS ,old-pos ,new-pos)
                         (let ((old-pos (second x)) (new-pos (third x)))
                           (if (<= old-pos *formatter-linear-argcount*)
                             ; no need for WHOLE-ARGS since ARGS = WHOLE-ARGS at this point
                             (if (<= new-pos *formatter-linear-argcount*)
                               `(PROGN)
                               `(SETQ ,*args* (NTHCDR ,(- new-pos *formatter-linear-argcount*) ,*args*)))
                             (progn
                               (setq *formatter-whole-args* t)
                               `(SETQ ,*args* (WHOLE-ARGS ,(max new-pos *formatter-linear-argcount*)))))))
                     #'(lambda (x) ; x = `(SETQ-ARGS-WHOLE-ARGS ,i ,j) ?
                         (and (consp x) (eq (car x) 'SETQ-ARGS-WHOLE-ARGS)
                              (consp (cdr x)) (consp (cddr x)) (null (cdddr x))))
                     forms))
    (when *formatter-whole-args*
      (setq forms
        (subst-if-then #'(lambda (x) ; x = `(WHOLE-ARGS ,i)
                           (let ((i (- (second x)
                                       *formatter-linear-argcount*)))
                             (if (zerop i)
                               `WHOLE-ARGS
                               `(NTHCDR ,i WHOLE-ARGS))))
                       #'(lambda (x) ; x = `(WHOLE-ARGS ,i) ?
                           (and (consp x) (eq (car x) 'WHOLE-ARGS)
                                (consp (cdr x)) (numberp (cadr x)) (null (cddr x))))
                       forms))
      (setq forms `((LET ((WHOLE-ARGS ,*args*)) ,@forms))))
    (values `(,@argsyms &REST ,*args*)
            `((DECLARE (IGNORABLE ,@argsyms ,*args*)) ,@forms))))

(defmacro formatter-bind-block (&body body)
  `(let ((*args* (gensym "ARGS")) ; not used inside the pprint-logical-block
         (*format-terminate* (formatter-block "TERMINATE-"))
         (*formatter-linear-args* nil)
         (*formatter-whole-args* nil))
     (formatter-bind-block-1 (progn ,@body))))
(defun formatter-bind-block-1 (forms)
  ;; inside the pprint-logical-block, we use the "secret"
  ;; variable for accessing the list as *args*
  ;; rather than try to find and fix all the places
  ;; that use *args* in various ways.
  (setq forms
        (subst-if-then #'(lambda (x) ; x = `(POP OBJ)
                           (declare (ignore x))
                           `(PPRINT-POP))
                       #'(lambda (x) ; x = `(POP OBJ)
                           (and (consp x) (eq (car x) 'POP)
                                (consp (cdr x)) (eq 'OBJ (cadr x))
                                (null (cddr x))))
                       forms))
  (when *formatter-whole-args*
    (setq forms
          (subst-if-then #'(lambda (x) ; x = `(WHOLE-ARGS ,i)
                             `(NTHCDR ,(second x) WHOLE-ARGS))
                         #'(lambda (x) ; x = `(WHOLE-ARGS ,i) ?
                             (and (consp x) (eq (car x) 'WHOLE-ARGS)
                                  (consp (cdr x)) (numberp (cadr x))
                                  (null (cddr x))))
                         forms)))
  (setq forms
        (subst-if-then #'(lambda (x) ; x = `(IF (ENDP OBJ)
                                     ;        (RETURN-FROM ,*format-terminate*))
                           (declare (ignore x))
                           `(PPRINT-EXIT-IF-LIST-EXHAUSTED))
                       #'(lambda (x) ; x = `(IF (ENDP OBJ) (RETURN-FROM ,*format-terminate*))
                           (and (consp x)
                                (eq (car x) 'IF)
                                (consp (cdr x)) (consp (cadr x))
                                (eq (caadr x) 'ENDP) (consp (cdadr x))
                                (eq 'OBJ (cadadr x)) (null (cddadr x))
                                (consp (cddr x)) (consp (caddr x))
                                (eq (caaddr x) 'RETURN-FROM)
                                (eq (car (cdaddr x)) *format-terminate*)
                                (null (cdr (cdaddr x)))
                                (null (cdddr x))))
                       forms))
  ;; the terminate won't be used (I think....)
  (values `(,*args* ,@(if *formatter-whole-args*
                        `(&aux (WHOLE-ARGS ,*args*))))
          `((DECLARE (IGNORABLE ,*args*)) ,@forms)))

;; terminates the linear mode.
;; Hence the argument-list can be accessed as ARGS.
(defun formatter-stop-linear ()
  (when *formatter-linear-args*
    (setq *formatter-linear-argcount*
          (min *formatter-linear-argcount* *formatter-linear-position*))
    ;; Now *formatter-linear-argcount* = *formatter-linear-position*.
    (setq *formatter-linear-args* nil)))

;; Fetches a Form, that returns the length of the argument-list.
(defun formatter-length-args ()
  (formatter-stop-linear)
  `(LENGTH ,*args*))

;; Fetches a Form for the next argument.
;; This form must be substituted with SUBST afterwards.
(defun formatter-next-arg ()
  (if *formatter-linear-args*
    (prog1
      `(ARG ,*formatter-linear-position*)
      (incf *formatter-linear-position*)
      (setq *formatter-linear-argcount*
            (max *formatter-linear-argcount* *formatter-linear-position*)))
    `(POP ,*args*)))

;; Fetches a Form, that returns an nthcdr of the whole argument-list.
;; This form must be substituted with SUBST afterwards.
(defun formatter-whole-args (n)
  (formatter-stop-linear)
  (setq *formatter-whole-args* t)
  `(WHOLE-ARGS ,n))

;; Return a form to get all the rest of the remaining arguments.
(defun formatter-whole-args* ()
  (cond (*formatter-linear-args*
         (formatter-stop-linear)
         (setq *formatter-whole-args* t)
         `(WHOLE-ARGS ,*formatter-linear-position*))
        (t *args*)))

;; Fetches a Form-list for the skipping (forwards/backwards) of arguments.
(defun formatter-goto-arg (absolute-p backward-p n)
  (if absolute-p
    ;; the simplest case: (setq args (nthcdr n whole-args))
    (if (numberp n)
      (progn
        (setq n (max n 0))
        (if *formatter-linear-args*
          (if (< n *formatter-linear-position*)
            (prog1
              `((SETQ-ARGS-WHOLE-ARGS ,*formatter-linear-position* ,n))
              (setq *formatter-linear-position* n))
            ;; n >= *formatter-linear-position*
            (formatter-goto-arg nil nil (- n *formatter-linear-position*)))
          (progn
            (formatter-stop-linear)
            `((SETQ ,*args* ,(formatter-whole-args n))))))
      (let ((n `(OR ,n 0)))
        (formatter-stop-linear)
        `((SETQ ,*args* (NTHCDR ,n ,(formatter-whole-args 0))))))
    (if backward-p
      ;; the simplest case:
      ;; (setq args (nthcdr (max (- (length whole-args) (length args) n) 0) whole-args))
      (if (and (numberp n) *formatter-linear-args*)
        (formatter-goto-arg t nil (- *formatter-linear-position* n))
        (let ((n (if (numberp n) n `(OR ,n 1))))
          (formatter-stop-linear)
          `((SETQ ,*args* ,(if *formatter-linear-args*
                             `(NTHCDR (MAX (- ,*formatter-linear-position* ,n) 0) ,(formatter-whole-args 0))
                             `(LIST-BACKWARD ,n ; first evaluate n, because it can contain (POP ARGS)
                                ,(formatter-whole-args 0) ,*args*))))))
      ;; the simplest case: (setq args (nthcdr n args))
      (if (and (numberp n) (<= n 100) *formatter-linear-args*)
        (do ((l '() (cons (formatter-next-arg) l)) (i 0 (1+ i)))
            ((>= i n) (nreverse l)))
        (let ((n (if (numberp n) n `(OR ,n 1))))
          (formatter-stop-linear)
          `((SETQ ,*args* (NTHCDR ,n ,*args*))))))))
(defun list-backward (n whole-list list) ; ABI
  (nthcdr (max (- (length whole-list) (length list) n) 0) whole-list))

;; Fetches a Form, that returns a Directive-Argument.
(defun formatter-arg (arg)
  (case arg
    (:NEXT-ARG (formatter-next-arg))
    (:ARG-COUNT (formatter-length-args))
    (T     ; arg is NIL or Integer or Character, needs not to be quoted.
     arg)))

;; Main-Compilation-Function. Returns a Form-List.
;; return Fluid: *format-cs* and *format-csdl* (will be advanced).
(defun formatter-main-1 (&optional (endmarker nil))
  (let ((forms '()))
    (loop
      (when (endp *format-csdl*) (return))
      (let ((csd (car *format-csdl*)))
        (case (csd-type csd)
          (0 )
          (1 (push (subseq *format-cs* (csd-cs-index csd) (csd-data csd))
                   forms))
          (2 (let ((directive-name (csd-data csd)))
               (if (eq directive-name endmarker) (return))
               (if (eq directive-name 'FORMAT-SEPARATOR) (return))
               (let ((colon-p (csd-colon-p csd))
                     (atsign-p (csd-atsign-p csd))
                     (arglist (mapcar #'formatter-arg (csd-parm-list csd))))
                 (labels ((simple-arglist (n)
                            (unless (<= (length arglist) n)
                              (format-error 'error *format-cs* nil
                                 (TEXT "Too many arguments for this format directive")))
                            (setq arglist
                                  (append arglist
                                          (make-list (- n (length arglist))
                                                     :initial-element 'NIL))))
                          (trivial-call ()
                            (push `(,directive-name
                                    STREAM
                                    ,colon-p
                                    ,atsign-p
                                    ,@arglist)
                                   forms))
                           (trivial (n)
                             (simple-arglist n)
                             (trivial-call))
                          (simple-call ()
                            (push `(,(intern (string-concat
                                               "DO-" (string directive-name))
                                             (find-package "SYSTEM"))
                                    STREAM
                                    ,colon-p
                                    ,atsign-p
                                    ,@arglist
                                    ;; Pass the actual argument at last because
                                    ;; ,@arglist may contain `(POP ,*args*)
                                    ;; as well.
                                    ,(formatter-next-arg))
                                  forms))
                           (simple (n)
                             (simple-arglist n)
                             (simple-call)))
                   (case directive-name
                     (FORMAT-ASCII                  ; #\A
                      (simple-arglist 4)
                      (if (and (member (first arglist) '(nil 0)) ; mincol
                               (member (third arglist) '(nil 0))) ; minpad
                        (progn
                          (setq forms (revappend (remove 'NIL arglist) forms))
                          (push `(PRINC ,(if colon-p
                                           `(OR ,(formatter-next-arg) "()")
                                           (formatter-next-arg))
                                          STREAM)
                                forms))
                        (simple-call)))
                     (FORMAT-S-EXPRESSION           ; #\S
                      (simple-arglist 4)
                      (if (and (member (first arglist) '(nil 0)) ; mincol
                               (member (third arglist) '(nil 0)) ; minpad
                               (not colon-p))
                        (progn
                          (setq forms (revappend (remove 'NIL arglist) forms))
                          (push `(let ((*print-right-margin*
                                        (STREAM-START-S-EXPRESSION STREAM)))
                                   (PRIN1 ,(formatter-next-arg) STREAM))
                                forms)
                          (push '(STREAM-END-S-EXPRESSION STREAM) forms))
                        (simple-call)))
                     (FORMAT-WRITE                  ; #\W
                      (simple-arglist 4)
                      (if (and (member (first arglist) '(nil 0)) ; mincol
                               (member (third arglist) '(nil 0))) ; minpad
                        (progn
                          (setq forms (revappend (remove 'NIL arglist) forms))
                          (push `(WRITE ,(formatter-next-arg) :STREAM STREAM)
                                forms))
                        (simple-call)))
                     (FORMAT-DECIMAL                ; #\D
                      (simple 4))
                     (FORMAT-BINARY                 ; #\B
                      (simple 4))
                     (FORMAT-OCTAL                  ; #\O
                      (simple 4))
                     (FORMAT-HEXADECIMAL            ; #\X
                      (simple 4))
                     (FORMAT-RADIX                  ; #\R
                      (simple-arglist 5)
                      (if (and (null (first arglist)) (not atsign-p))
                        (progn
                          (setq forms (revappend (remove 'NIL arglist) forms))
                          (push `(,(if colon-p 'FORMAT-ORDINAL 'FORMAT-CARDINAL)
                                  ,(formatter-next-arg) STREAM)
                                forms))
                        (simple-call)))
                     (FORMAT-PLURAL                 ; #\P
                      (simple-arglist 0)
                      (when colon-p
                        (setq forms
                              (revappend (formatter-goto-arg nil t 1) forms)))
                      (push (if atsign-p
                              `(WRITE-STRING
                                 (IF (EQL ,(formatter-next-arg) 1) "y" "ies")
                                 STREAM)
                              `(UNLESS (EQL ,(formatter-next-arg) 1)
                                 (WRITE-CHAR #\s STREAM)))
                            forms))
                     (FORMAT-CHARACTER              ; #\C
                      (simple 0))
                     (FORMAT-FIXED-FLOAT            ; #\F
                      (simple 5))
                     (FORMAT-EXPONENTIAL-FLOAT      ; #\E
                      (simple 7))
                     (FORMAT-GENERAL-FLOAT          ; #\G
                      (simple 7))
                     (FORMAT-DOLLARS-FLOAT          ; #\$
                      (simple 4))
                     (FORMAT-TERPRI                 ; #\%
                      (simple-arglist 1)
                      (if (member (first arglist) '(nil 1))
                        (push #\Newline forms) ; equiv. to `(TERPRI STREAM)
                        (trivial-call)))
                     (FORMAT-PPRINT-NEWLINE         ; #\_
                      (simple-arglist 0)
                      (push `(PPRINT-NEWLINE ,(if colon-p
                                                (if atsign-p :mandatory :fill)
                                                (if atsign-p :miser :linear))
                                             STREAM)
                            forms))
                     (FORMAT-PPRINT-INDENT          ; #\I
                      (simple-arglist 1)
                      (push `(PPRINT-INDENT ,(if colon-p :current :block)
                                            ,(or (first arglist) 0)
                                            STREAM)
                            forms))
                     (FORMAT-FRESH-LINE             ; #\&
                      (simple-arglist 1)
                      (if (member (first arglist) '(nil 1))
                        (push `(FRESH-LINE STREAM) forms)
                        (trivial-call)))
                     (FORMAT-PAGE                   ; #\|
                      (simple-arglist 1)
                      (if (member (first arglist) '(nil 1))
                        (push #\Page forms)
                        (trivial-call)))
                     (FORMAT-TILDE                  ; #\~
                      (simple-arglist 1)
                      (if (member (first arglist) '(nil 1))
                        (push #\~ forms)
                        (trivial-call)))
                     (FORMAT-TABULATE               ; #\T
                      (trivial 2))
                     (FORMAT-GOTO                   ; #\*
                      (simple-arglist 1)
                      (setq forms
                            (revappend (formatter-goto-arg atsign-p colon-p
                                         (or (first arglist) (if atsign-p 0 1)))
                                       forms)))
                     (FORMAT-INDIRECTION            ; #\?
                      (simple-arglist 0)
                      (if atsign-p
                        (push `(SETQ ,*args*
                                 (DO-FORMAT-INDIRECTION STREAM
                                   ,(formatter-next-arg)
                                   ,(progn (formatter-stop-linear) `,*args*)))
                              forms)
                        (push `(DO-FORMAT-INDIRECTION
                                 STREAM ,(formatter-next-arg)
                                 ,(formatter-next-arg))
                              forms)))
                     (FORMAT-CALL-USER-FUNCTION     ; #\/
                      (let* ((func (car (pop arglist)))
                             (argsvars (gensym-list arglist))
                             (inner-form
                               `(,func STREAM ,(formatter-next-arg) ,colon-p
                                       ,atsign-p ,@argsvars)))
                        (push (if argsvars
                                `(LET ,(mapcar #'list argsvars arglist)
                                   ,inner-form)
                                inner-form)
                              forms)))
                     (FORMAT-CASE-CONVERSION        ; #\(
                      (simple-arglist 0)
                      (setq *format-csdl* (cdr *format-csdl*))
                      (if *format-case*
                        ;; Richard Waters notes: It is possible for ~(...~) to
                        ;; be nested in a format string, but note that inner
                        ;; nested modes never have any effect. You can just
                        ;; ignore them.
                        (let ((inner-forms
                                ;; no need to bind *format-case* to t here
                                (formatter-main-1 'FORMAT-CASE-CONVERSION-END)))
                          (setq forms (revappend inner-forms forms)))
                        (push `(LET ((ORIG-STREAM STREAM)
                                     (STREAM (MAKE-STRING-OUTPUT-STREAM
                                               :LINE-POSITION (SYS::LINE-POSITION STREAM))))
                                 ,@(let* ((*format-uwps*
                                            (cons 'NIL *format-uwps*))
                                          (inner-forms
                                            (let ((*format-case* t))
                                              (formatter-main
                                                'FORMAT-CASE-CONVERSION-END)))
                                          (cleanup-forms
                                            `((WRITE-STRING
                                                (,(if colon-p
                                                    (if atsign-p
                                                      'NSTRING-UPCASE
                                                      'NSTRING-CAPITALIZE)
                                                    (if atsign-p
                                                      'SYS::NSTRING-CAPITALIZE1
                                                      'NSTRING-DOWNCASE))
                                                 (GET-OUTPUT-STREAM-STRING STREAM))
                                                ORIG-STREAM))))
                                     (if (car *format-uwps*)
                                       `((UNWIND-PROTECT (PROGN ,@inner-forms) ,@cleanup-forms))
                                       `(,@inner-forms ,@cleanup-forms))))
                              forms)))
                     (FORMAT-CONDITIONAL            ; #\[
                      (if colon-p
                        (if atsign-p
                          (format-not-both-error "~[")
                          (progn
                            (simple-arglist 0)
                            (push `(IF (NOT ,(formatter-next-arg))
                                     (PROGN ,@(progn
                                                (formatter-stop-linear)
                                                (setq *format-csdl*
                                                      (cdr *format-csdl*))
                                                (formatter-main
                                                  'FORMAT-CONDITIONAL-END)))
                                     (PROGN ,@(progn
                                                (formatter-stop-linear)
                                                (setq *format-csdl*
                                                      (cdr *format-csdl*))
                                                (formatter-main
                                                  'FORMAT-CONDITIONAL-END))))
                                  forms)))
                        (if atsign-p
                          (progn
                            (simple-arglist 0)
                            (formatter-stop-linear)
                            (push `(IF (CAR ,*args*)
                                     (PROGN ,@(progn
                                                (setq *format-csdl*
                                                      (cdr *format-csdl*))
                                                (formatter-main
                                                  'FORMAT-CONDITIONAL-END)))
                                     (SETQ ,*args* (CDR ,*args*)))
                                  forms)
                            (unless (null (csd-clause-chain (car *format-csdl*)))
                              (format-error 'error *format-cs* nil
                                (TEXT "The ~~; format directive is not allowed at this point."))))
                          (progn
                            (simple-arglist 1)
                            (push `(CASE ,(or (first arglist)
                                              (formatter-next-arg))
                                     ,@(let ((index 0) (cases '()))
                                         (formatter-stop-linear)
                                         (loop
                                           (when (null (csd-clause-chain
                                                         (car *format-csdl*)))
                                             (return))
                                           (when (csd-colon-p (car *format-csdl*))
                                             (setq index 'T))
                                           (setq *format-csdl* (cdr *format-csdl*))
                                           (push `(,index ,@(formatter-main 'FORMAT-CONDITIONAL-END))
                                                 cases)
                                           (if (eq index 'T) (return) (incf index)))
                                         (nreverse cases)))
                                  forms)))))
                     (FORMAT-ITERATION              ; #\{
                      (simple-arglist 1)
                      (setq *format-csdl* (cdr *format-csdl*))
                      (let ((max-n-iterations (first arglist))
                            (min-1-iteration (csd-colon-p (car (csd-clause-chain csd))))
                            (indirect (eq (csd-clause-chain csd) *format-csdl*)))
                        (flet ((compute-innermost ()
                                 (if indirect
                                   (progn
                                     (formatter-stop-linear)
                                     `((SETQ ,*args*
                                             (DO-FORMAT-INDIRECTION-2 STREAM NODE
                                                                      ,*args*
                                                                      ,(formatter-whole-args 0)))))
                                   (formatter-main 'FORMAT-ITERATION-END))))
                          (flet ((compute-inner ()
                                   (if colon-p
                                     (let ((*iterargs* *args*))
                                       (formatter-bind-terminator
                                         (multiple-value-bind (lambdalist innermost)
                                             (formatter-bind-args (compute-innermost))
                                           `((APPLY #'(LAMBDA ,lambdalist ,@innermost)
                                               ,(formatter-next-arg))))))
                                     (let ((*iterargs* nil))
                                       ;; CLtL2 p. 598: "When within a ~{ construct, the "goto" is
                                       ;; relative to the list of arguments being processed by the
                                       ;; iteration." Does that mean, that for ~@{, WHOLE-ARGS has to
                                       ;; be freshly bound to ARGS at the beginning of each Iteration??
                                       ;; (if atsign-p
                                       ;;   (progn (formatter-stop-linear)
                                       ;;     `((LET ((WHOLE-ARGS ,*args*)) ,@(compute-innermost)))
                                       ;;   )
                                       ;;   (compute-innermost)
                                       ;; )
                                       (compute-innermost)))))
                            (flet ((compute-middle ()
                                     (if (eql max-n-iterations 0)
                                       '()
                                       (progn
                                         (unless (and (eql max-n-iterations 1) min-1-iteration)
                                           (formatter-stop-linear))
                                         (if (eql max-n-iterations 1)
                                           (if min-1-iteration
                                             (compute-inner)
                                             `((UNLESS (ENDP ,*args*) ,@(compute-inner))))
                                           `((BLOCK NIL
                                               (TAGBODY
                                                 L
                                                 ,@(if max-n-iterations
                                                     `((WHEN ,(if (numberp max-n-iterations)
                                                                `(>= I N)
                                                                `(AND N (>= I N)))
                                                         (RETURN))
                                                       (INCF I)))
                                                 ,@(if (not min-1-iteration)
                                                     `((WHEN (ENDP ,*args*) (RETURN))))
                                                 ,@(compute-inner)
                                                 ,@(if min-1-iteration
                                                     `((WHEN (ENDP ,*args*) (RETURN))))
                                                 (GO L)))))))))
                              (flet ((compute-outer ()
                                       (formatter-bind-terminators
                                         ;; *format-terminate-all* and *format-terminate* will be
                                         ;; bound, but if colon-p, *format-terminate* will be
                                         ;; shadowed further inside (see above).
                                         (if atsign-p
                                           (compute-middle)
                                           (multiple-value-bind (lambdalist inner-forms)
                                               (formatter-bind-args (compute-middle))
                                             `((APPLY #'(LAMBDA ,lambdalist ,@inner-forms)
                                                 ,(formatter-next-arg))))))))
                                (flet ((compute-outermost ()
                                         (if indirect
                                           `((LET ((NODE (DO-FORMAT-INDIRECTION-1 ,(formatter-next-arg))))
                                               ,@(compute-outer)))
                                           (compute-outer))))
                                  (let ((new-forms
                                          (if (and max-n-iterations (not (member max-n-iterations '(0 1))))
                                            `((LET ((N ,(first arglist)) (I 0))
                                                ,@(compute-outermost)))
                                            (compute-outermost))))
                                    (setq forms
                                          (revappend new-forms forms))))))))))
                     (FORMAT-JUSTIFICATION          ; #\<
                      (simple-arglist 4)
                      (let* ((firstseparator (car (csd-clause-chain csd)))
                             (check-on-line-overflow
                               (and (eq (csd-data firstseparator)
                                        'FORMAT-SEPARATOR)
                                    (csd-colon-p firstseparator)))
                             (bindings
                               `((POS (SYS::LINE-POSITION STREAM))
                                 (ORIG-STREAM STREAM)
                                 (STREAM (MAKE-STRING-OUTPUT-STREAM
                                           :LINE-POSITION POS))))
                             (justify-args
                               `(ORIG-STREAM
                                 ,colon-p
                                 ,atsign-p
                                 ,@arglist
                                 POS
                                 ,check-on-line-overflow
                                 ,(when check-on-line-overflow
                                    (setq *format-csdl* (cdr *format-csdl*))
                                    `(PROGN
                                       ,@(formatter-main 'FORMAT-JUSTIFICATION-END)
                                       (GET-OUTPUT-STREAM-STRING STREAM)))
                                 ,(when check-on-line-overflow
                                    (formatter-arg (first (csd-parm-list firstseparator))))
                                 ,(when check-on-line-overflow
                                    (formatter-arg (second (csd-parm-list firstseparator))))))
                             (new-forms
                               (formatter-bind-terminator
                                 (let* ((*format-uwps* (cons 'NIL *format-uwps*))
                                        (pieces-forms '()))
                                   (loop
                                     (when (null (csd-clause-chain (car *format-csdl*))) (return))
                                     (setq *format-csdl* (cdr *format-csdl*))
                                     (push (formatter-main 'FORMAT-JUSTIFICATION-END) pieces-forms))
                                   (setq pieces-forms (nreverse pieces-forms))
                                   (list
                                     (if (car *format-uwps*)
                                       `(LET* (,@bindings
                                               (JARGS (LIST ,@justify-args))
                                               (PIECES '()))
                                          (UNWIND-PROTECT
                                              (PROGN
                                                ,@(mapcap #'(lambda (piece-forms)
                                                              `(,@piece-forms
                                                                (PUSH (GET-OUTPUT-STREAM-STRING STREAM) PIECES)))
                                                          pieces-forms))
                                            (APPLY #'DO-FORMAT-JUSTIFICATION
                                                   (NCONC JARGS (LIST (SYS::LIST-NREVERSE PIECES))))))
                                       `(LET* (,@bindings)
                                          (DO-FORMAT-JUSTIFICATION
                                            ,@justify-args
                                            (LIST
                                              ,@(mapcar #'(lambda (piece-forms)
                                                            `(PROGN ,@piece-forms (GET-OUTPUT-STREAM-STRING STREAM)))
                                                        pieces-forms))))))))))
                        (setq forms (revappend new-forms forms))))
                     (FORMAT-LOGICAL-BLOCK          ; #\< ending with ~:>
                      (simple-arglist 0)
                      (multiple-value-bind (prefix suffix per-line-p
                                            body-csdl add-fill last-csdl)
                          (format-logical-block-parse *FORMAT-CSDL*)
                       ;(when add-fill
                       ;  (format-error 'error *FORMAT-CS*
                       ;      (csd-cs-index (car *FORMAT-CSDL*))
                       ;    (TEXT "Error: ~~:@> not implemented")))
                       (setq *FORMAT-CSDL* body-csdl)
                       (labels ((compute-inner ()
                                  `((PPRINT-LOGICAL-BLOCK
                                      ;; *args* refers to things *after*
                                      ;; anything used in the body.
                                      ;; I need some way to refer to
                                      ;; all the list.
                                      (STREAM
                                       ,*args*
                                       ,@(and prefix
                                           (if per-line-p
                                             `(:per-line-prefix ,prefix)
                                             `(:prefix ,prefix)))
                                       ,@(and suffix `(:suffix ,suffix)))
                                       ,@(let ((*args* 'OBJ))
                                           (formatter-main
                                             'FORMAT-JUSTIFICATION-END)))))
                                (compute-outer ()
                                  (multiple-value-bind (lambdalist inner)
                                      (formatter-bind-block (compute-inner))
                                    `(((LAMBDA ,lambdalist ,@inner)
                                         ,(if atsign-p
                                            (formatter-whole-args*)
                                            (formatter-next-arg)))))))
                         (let ((body (compute-outer)))
                           (setq *format-csdl* last-csdl)
                           (setq forms (append body forms))))))
                     (FORMAT-UP-AND-OUT             ; #\^
                      (simple-arglist 3)
                      (formatter-stop-linear)
                      (let ((argsvar (if colon-p *iterargs* *args*)))
                        (push `(IF ,(if (some #'(lambda (x) (and (constantp x) x)) arglist)
                                      `(UP-AND-OUT-P ,@arglist)
                                      (if (and (null (second arglist)) (null (third arglist)))
                                        (let ((first-arg (first arglist)))
                                          (if (null first-arg)
                                            `(ENDP ,argsvar)
                                            (if (and (consp first-arg) (eq (car first-arg) 'LENGTH))
                                              `(ENDP ,(second first-arg)) ; (EQL (LENGTH x) 0) == (ENDP x)
                                              `(CASE ,first-arg ((NIL) (ENDP ,argsvar)) ((0) T) (T NIL)))))
                                          `(UP-AND-OUT-P ,@arglist ,argsvar)))
                                 (RETURN-FROM ,(if colon-p (formatter-terminate-all) (formatter-terminate))))
                              forms)))
                     (FORMAT-CALL                   ; #\!
                      (let* ((argsvars (gensym-list arglist))
                             (inner-form
                               `(FUNCALL ,(formatter-next-arg)
                                  STREAM ,(formatter-next-arg) ,colon-p ,atsign-p
                                  ,@argsvars)))
                        (push (if argsvars
                                `(LET ,(mapcar #'list argsvars arglist)
                                   ,inner-form)
                                inner-form)
                              forms)))
                     (FORMAT-ELASTIC-NEWLINE        ; #\.
                      (simple-arglist 1)
                      (if (member (first arglist) '(nil 1))
                        (push `(EXT:ELASTIC-NEWLINE STREAM) forms)
                        (trivial-call)))
                     (t ;; Huh? Someone implemented a new format directive,
                        ;; but forgot it here! Bail out.
                      (throw 'formatter-hairy nil)))))))))
      (setq *format-csdl* (cdr *format-csdl*)))
    ;; Combine adjacent strings:
    (let ((new-forms '()))
      (dolist (form forms)
        (when (characterp form) (setq form (string form)))
        (if (and (consp new-forms) (stringp (car new-forms)) (stringp form))
          (setf (car new-forms) (string-concat form (car new-forms)))
          (push form new-forms)))
      new-forms)))
(defun formatter-main (&optional (endmarker nil))
  (let ((new-forms (formatter-main-1 endmarker)))
    ;; Convert strings to WRITE-STRING forms:
    (mapcap #'(lambda (form)
                (if (stringp form)
                  (case (length form)
                    (0 )
                    (1 (setq form (char form 0))
                       `(,(if (eq form #\Newline)
                            `(TERPRI STREAM)
                            `(WRITE-CHAR ,form STREAM))))
                    (t `((WRITE-STRING ,form STREAM))))
                  (list form)))
            new-forms)))

;; FORMATTER, CLtL2 p. 764
(defmacro formatter (control-string)
  (unless (stringp control-string)
    (error-of-type 'type-error
      :datum control-string :expected-type 'string
      (TEXT "~S: The control-string must be a string, not ~S")
      'formatter control-string))
  ;; possibly convert control-string to Simple-String ??
  (or
    (catch 'formatter-hairy
      (let ((node (list control-string)))
        (format-parse-cs control-string 0 node nil)
        (let ((*FORMAT-CS* (car node))
              (*FORMAT-CSDL* (cdr node))
              (*format-case* nil)
              (*format-uwps* '())
              (*iterargs* nil))
          (multiple-value-bind (lambdalist forms)
              (formatter-bind-args
                `(,@(formatter-bind-terminators
                      (formatter-main))
                  ,(progn (formatter-stop-linear) `,*args*)))
            `(FUNCTION
               (LAMBDA (STREAM ,@lambdalist)
                 (DECLARE (IGNORABLE STREAM))
                 (let ((*FORMAT-CS* nil)) ; format-error cannot point to the position anymore
                   ,@forms)))))))
    `(FORMATTER-HAIRY ,(coerce control-string 'simple-string))))

;;; ---------------------------------------------------------------------------

;; (FORMAT-QUOTE string)
;; returns a format-string that yields exactly the given string.
(defun format-quote (string)
  (let ((qstring (make-array 10 :element-type 'character
                                :adjustable t :fill-pointer 0)))
    (map nil #'(lambda (c)
                 (when (eql c #\~) (vector-push-extend #\~ qstring))
                 (vector-push-extend c qstring))
         string)
    qstring))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./format.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./pprint.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; 22.2 The Lisp Pretty Printer
;;; Sam Steingold 2001-07-26 - 2007

(in-package "LISP")
(export
 '(*print-pprint-dispatch* pprint-dispatch copy-pprint-dispatch
   set-pprint-dispatch
   pprint-logical-block pprint-pop pprint-exit-if-list-exhausted
   pprint-fill pprint-linear pprint-tabular)
 "LISP")

(in-package "EXT")

;; used here and in inspect.lisp
(defmacro with-gensyms ((title &rest names) &body body)
  "Bind symbols in NAMES to gensyms.  TITLE is a string - `gensym' prefix.
Inspired by Paul Graham, <On Lisp>, p. 145."
  `(let (,@(mapcar (lambda (sy)
                     `(,sy (gensym ,(concatenate 'string title
                                                 (symbol-name sy) "-"))))
                   names))
     ,@body))

(export '(with-gensyms) "EXT")

(in-package "SYS")

;; ---------------------- Dispatch Tables ----------------------
;; a Dispatch Table is a cons of `*PRINT-PPRINT-DISPATCH*'
;; and an alist of (type priority function)
;; if you modify the structure of Dispatch Tables,
;; you have to change DISPATCH_TABLE_VALID_P in pretty_print_call() in io.d
;; since it checks whether the Dispatch Table contains any valid entries

(defun make-pprint-dispatch () (list '*print-pprint-dispatch*))

(defun pprint-dispatch-p (obj)
  (and (consp obj) (eq (car obj) '*print-pprint-dispatch*)))

(defparameter *print-pprint-dispatch* (make-pprint-dispatch))

(defun default-print-dispatch-function (stream object)
  (print-object object stream))

(defun pprint-dispatch (object &optional (table *print-pprint-dispatch*))
  ;; object   ---an object.
  ;; table    ---a pprint dispatch table, or nil.
  ;;             The default is the value of *print-pprint-dispatch*.
  ;; values:
  ;;  function---a function designator.
  ;;  found-p ---a generalized boolean.
  (let ((tail (cdr table)) top)
    (loop (setq tail (member object tail :test #'typep :key #'car))
          (when (endp tail)
            (return (if top
                        (values (third top) t)
                        (values #'default-print-dispatch-function nil))))
          (when (or (null top) (> (cadar tail) (second top)))
            (setq top (car tail)))
          (pop tail))))

(defun copy-pprint-dispatch (&optional (table *print-pprint-dispatch*)) ; ABI
  ;; table     ---a pprint dispatch table, or nil.
  ;; value:
  ;;  new-table---a fresh pprint dispatch table.
  ;; Creates and returns a copy of the specified table,
  ;; or of the value of *print-pprint-dispatch* if no table is specified,
  ;; or of the initial value of *print-pprint-dispatch* if nil is specified.
  (if table
      (if (pprint-dispatch-p table)
          (copy-alist table)
          (error-of-type 'type-error
            :datum table :expected-type '(satisfies pprint-dispatch-p)
            (TEXT "~S: ~S is not a valid print dispatch table")
            'copy-pprint-dispatch table))
      (make-pprint-dispatch)))

(defun set-pprint-dispatch (type-specifier function &optional (priority 0)
                            (table *print-pprint-dispatch*))
  ;; type-specifier---a type specifier.
  ;; function      ---a function, a function name, or nil.
  ;; priority      ---a real. The default is 0.
  ;; table         ---a pprint dispatch table.
  ;;                  The default is the value of *print-pprint-dispatch*.
  (unless (realp priority)
    (error-of-type 'type-error
      :datum priority :expected-type 'real
      (TEXT "~S: priority must be a real number, not ~S")
      'set-pprint-dispatch priority))
  (let ((rec (member type-specifier (cdr table) :test #'equal :key #'car)))
    (if rec
        (if function
            ;; replace record
            (setf (cdar rec) (list priority function))
            ;; remove record
            (if (cdr rec)
                (setf (car rec) (cadr rec)
                      (cdr rec) (cddr rec))
                (setf (cdr table)
                      (delete type-specifier (cdr table) :test #'equal
                              :key #'car))))
        (when function
          (setf (cdr table)
                (acons type-specifier (list priority function)
                       (cdr table)))))
    (values nil)))

;; ---------------------- pprint-logical-block ----------------------

(defmacro pprint-logical-block ((stream-symbol object
                                 &key prefix per-line-prefix suffix)
                                &body body)
  (let ((out (case stream-symbol
               ((t) '*terminal-io*)
               ((nil) '*standard-output*)
               (otherwise stream-symbol)))
        (idx (gensym "PPLB-IDX-"))
        (pre (gensym "PPLB-PREF-"))
        (suf (gensym "PPLB-SUFF-")))
    `(let ((,pre ,prefix)
           (,suf ,suffix)
           (*prin-line-prefix* ,per-line-prefix)
           (*prin-miserp*
            (and *print-miser-width*
                 (> (line-position ,out)
                    (- (or *print-right-margin* *prin-linelength*)
                       *print-miser-width*))))
           (*prin-indentation*
            (if (boundp '*prin-indentation*)
                (+ *prin-indentation* *print-indent-lists*)
                0)))
      (when (and ,pre *prin-line-prefix*)
        (pprint-logical-block-both-error ,pre))
      (when (and ,pre (not (stringp ,pre)))
        (pprint-logical-block-prefix-not-string-error ,pre))
      (when (and ,suf (not (stringp ,suf)))
        (pprint-logical-block-suffix-not-string-error ,suf))
      (when (and *prin-line-prefix* (not (stringp *prin-line-prefix*)))
        (pprint-logical-block-prefix-not-string-error *prin-line-prefix*))
      (%pprint-logical-block
       (lambda (,out obj)
         (declare (ignorable obj))
         (let ((,idx 0) (*prin-level* (1+ *prin-level*)))
           (macrolet ((pprint-pop ()
                        '(cond
                          ((and *print-length* (>= ,idx *print-length*))
                           (write-string "..." ,out)
                           (go pprint-logical-block-end))
                          ((and (/= 0 ,idx) (%circlep obj ,out))
                           (go pprint-logical-block-end))
                          ((listp obj) (incf ,idx) (pop obj))
                          (t (write-string ". " ,out)
                           (write obj :stream ,out)
                           (go pprint-logical-block-end))))
                      (pprint-exit-if-list-exhausted ()
                        '(unless obj (go pprint-logical-block-end))))
             (when ,pre
               (write-string ,pre ,out)
               (pprint-indent :current 0 ,out))
             (tagbody ,@body
              pprint-logical-block-end
                (when ,suf
                  ;; to avoid suffix being attached to the last string
                  (pprint-newline :fill ,out)
                  (write-string ,suf ,out))))))
       ,object ,out))))
(defun pprint-logical-block-both-error (prefix) ; ABI
  (error (TEXT "~S: cannot supply both ~S (~S) and ~S (~S)")
         'pprint-logical-block ':prefix prefix
         ':per-line-prefix *prin-line-prefix*))
(defun pprint-logical-block-prefix-not-string-error (prefix) ; ABI
  (error-of-type 'type-error
    :datum prefix :expected-type 'string
    (TEXT "~S: ~S must be a string, not ~S")
    'pprint-logical-block ':prefix prefix))
(defun pprint-logical-block-suffix-not-string-error (suffix) ; ABI
  (error-of-type 'type-error
    :datum suffix :expected-type 'string
    (TEXT "~S: ~S must be a string, not ~S")
    'pprint-logical-block ':suffix suffix))

;; ---------------------- utilities ----------------------

(defun pprint-tab (kind colnum colinc &optional stream)
  ;; kind  ---one of :line, :section, :line-relative, or :section-relative.
  ;; colnum---a non-negative integer.
  ;; colinc---a non-negative integer.
  ;; stream---an output stream designator.
  (format-tabulate stream
                   (ecase kind
                     ((:line :line-relative) nil)
                     ((:section :section-relative) t))
                   (ecase kind
                     ((:line :section) nil)
                     ((:line-relative :section-relative) t))
                   colnum colinc))

;; ---------------------- list printing ----------------------

(defun pprint-fill (out list &optional (colon-p t) at-sign-p)
  ;; out      ---an output stream designator.
  ;; list     ---an object.
  ;; colon-p  ---a generalized boolean. The default is true.
  ;; at-sign-p---a generalized boolean. ignored
  (declare (ignore at-sign-p))
  (pprint-logical-block (out list :prefix (if colon-p "(" "")
                             :suffix (if colon-p ")" ""))
    (pprint-exit-if-list-exhausted)
    (loop (write (pprint-pop) :stream out)
          (pprint-exit-if-list-exhausted)
          (write-char #\Space out)
          (pprint-newline :fill out))))

(defun pprint-linear (out list &optional (colon-p t) at-sign-p)
  ;; out      ---an output stream designator.
  ;; list     ---an object.
  ;; colon-p  ---a generalized boolean. The default is true.
  ;; at-sign-p---a generalized boolean. ignored
  (declare (ignore at-sign-p))
  (pprint-logical-block (out list :prefix (if colon-p "(" "")
                             :suffix (if colon-p ")" ""))
    (pprint-exit-if-list-exhausted)
    (loop (write (pprint-pop) :stream out)
          (pprint-exit-if-list-exhausted)
          (write-char #\Space out)
          (pprint-newline :linear out))))

;; lifted verbatim from CLHS
(defun pprint-tabular (out list &optional (colon-p t) at-sign-p (tabsize nil))
  ;; out      ---an output stream designator.
  ;; list     ---an object.
  ;; colon-p  ---a generalized boolean. The default is true.
  ;; at-sign-p---a generalized boolean. ignored
  ;; tabsize  ---a non-negative integer. The default is 16.
  (declare (ignore at-sign-p))
  (when (null tabsize) (setq tabsize 16))
  (pprint-logical-block (out list :prefix (if colon-p "(" "")
                             :suffix (if colon-p ")" ""))
    (pprint-exit-if-list-exhausted)
    (loop (write (pprint-pop) :stream out)
          (pprint-exit-if-list-exhausted)
          (write-char #\Space out)
          (pprint-tab :section-relative 0 tabsize out)
          (pprint-newline :fill out))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./pprint.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./foreign1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Foreign function interface for CLISP
;;; Bruno Haible 19.2.1995
;;; Sam Steingold 1998-2010, 2017

#+UNICODE
(progn
  (in-package "EXT")
  (export '(custom::*foreign-encoding*) "CUSTOM")
  (export '(custom::*foreign-encoding*) "EXT"))

(use-package '("COMMON-LISP" "EXT") "FFI")
(in-package "FFI")

(export '(def-c-type def-c-var def-c-const parse-c-type deparse-c-type
          def-c-call-out def-call-out
          def-c-call-in def-call-in default-foreign-language
          c-lines *output-c-functions* *output-c-variables* *foreign-guard*
          nil boolean character char uchar short ushort int uint long ulong
          uint8 sint8 uint16 sint16 uint32 sint32 uint64 sint64
          single-float double-float default-foreign-library
          c-pointer c-string c-struct c-union c-array c-array-max
          c-function c-ptr c-ptr-null c-array-ptr
          size_t ssize_t |file|
          def-c-enum def-c-struct element deref slot cast typeof
          sizeof bitsizeof c-var-object c-var-address offset
          validp with-c-place foreign-value enum-from-value enum-to-value
          foreign-address foreign-address-unsigned unsigned-foreign-address
          with-foreign-object with-c-var with-foreign-string
          foreign-allocate allocate-deep allocate-shallow foreign-free
          foreign-pointer set-foreign-pointer foreign-pointer-info
          open-foreign-library close-foreign-library memory-as
          foreign-variable foreign-function))

(eval-when (load compile eval)
  (import (intern "*COUTPUT-FILE*" "SYSTEM"))
  (import (intern "*COUTPUT-STREAM*" "SYSTEM"))
  (import (intern "*FFI-MODULE*" "SYSTEM"))
  (import (intern "FINALIZE-COUTPUT-FILE" "SYSTEM"))
  (import (intern "TEXT" "SYSTEM")) ; messages
  (import (intern "SYMBOL-TO-KEYWORD" "SYSTEM"))
  (import (intern "CHECK-SYMBOL" "SYSTEM")) ; error checking
  (import (intern "FOREIGN-FUNCTION-IN-ARG-COUNT" "SYSTEM")) ; called by SYS::FUNCTION-SIGNATURE
)

;; These constants are defined in spvw.d.
;; We declare them here only to avoid warnings.
#-FFI
(progn
  (defvar fv-flag-readonly)
  (defvar fv-flag-malloc-free)
  (defvar ff-flag-alloca)
  (defvar ff-flag-malloc-free)
  (defvar ff-flag-out)
  (defvar ff-flag-in-out)
  (defvar ff-language-asm)
  (defvar ff-language-c)
  (defvar ff-language-ansi-c)
  (defvar ff-language-stdcall)
)

;; ===========================================================================

#+UNICODE
(progn
  (define-symbol-macro *foreign-encoding* (system::foreign-encoding))
  (defsetf system::foreign-encoding system::set-foreign-encoding))

;; ============================ helper functions ============================

; Determines whether a name is a valid C identifier.
(defun c-ident-p (name)
  (and (> (length name) 0)
       (every #'(lambda (c)
                 ;(and (standard-char-p ch)
                 ;     (or (alphanumericp ch) (eql ch #\_)) ; don't allow #\$
                 ;)
                  (or (char<= #\A c #\Z) (char<= #\a c #\z) (char<= #\0 c #\9)
                      (char= #\_ c) (char= #\@ c)
                ) )
              name
       )
       (not (char<= #\0 (char name 0) #\9))
       ; must not be a reserved word:
       (not (gethash name
                     (load-time-value
                      (let* ((reserved-list
                               '("auto" "break" "case" "char" "continue"
                                 "default" "do" "double" "else" "enum" "extern"
                                 "float" "for" "goto" "if" "int" "long"
                                 "register" "return" "short" "sizeof" "static"
                                 "struct" "switch" "typedef" "union" "unsigned"
                                 "void" "while"))
                             (reserved-table
                               (make-hash-table :key-type 'string :value-type '(eql t)
                                                :test #'equal)))
                        (dolist (w reserved-list)
                          (setf (gethash w reserved-table) 'T))
                        reserved-table))))))

; Given a string, return it in C syntax.
(defun to-c-string (string)
  (with-output-to-string (s)
    (write-char #\" s)
    (map nil #'(lambda (c)
                 (cond ((eql c #\Null)
                        (error (TEXT "Cannot map string ~S to C since it contains a character ~S")
                               string c))
                       ((eq c #\Newline)
                        (write-char #\\ s) (write-char #\n s))
                       ((or (eql c #\") (eql c #\\))
                        (write-char #\\ s) (write-char c s))
                       (t (write-char c s))))
             string)
    (write-char #\" s)))

;; ============================ C types ============================

;: The table of C types.
(defvar *c-type-table*
  (make-hash-table :key-type 'symbol :test 'stablehash-eq))

; simple C types
(dolist (c-type
          '(nil boolean character char uchar short ushort int uint long ulong
            uint8 sint8 uint16 sint16 uint32 sint32 uint64 sint64
            single-float double-float
            c-pointer c-string))
  (setf (gethash c-type *c-type-table*) c-type))
(dolist (c-type '(size_t ssize_t)) ; see foreign.d:init_ffi()
  (setf (gethash c-type *c-type-table*)
        (CS-CL:symbol-name c-type))) ; prefer lower case
;; FILE* is used by modern ffi packages
(setf (gethash '|file| *c-type-table*) 'c-pointer) ; (def-c-type FILE c-pointer)

;; parse the components of a C-STRUCT or C-UNION
(defun parse-components (typespec)
  (let* ((form-type (first typespec))
         (spec-list
           (ecase form-type
             (C-STRUCT (cddr typEspec))
             (C-UNION (cdr typespec)))))
    (mapcar (lambda (subspec)
              (unless (and (consp subspec)
                           (eql (length subspec) 2)
                           (symbolp (first subspec)))
                (error (TEXT "Invalid ~S component: ~S")
                       form-type subspec))
              (parse-c-type (second subspec)))
            spec-list)))

;; return the constructor function for this structure
(defun c-struct-constructor (typespec)
  (let ((class (second typespec)))
    (when (consp class) (setq class (car class)))  ; name+options -> name
    (case class
      (VECTOR #'vector)
      (LIST #'list)
      (t (let* ((slots (mapcar #'first (cddr typespec)))
                (vars (mapcar #'(lambda (x) (gensym (symbol-name x))) slots))
                h)
           (eval `(FUNCTION
                   (LAMBDA ,vars
                    (DECLARE (COMPILE ,(intern (string-concat "MAKE-" (symbol-name class)) (symbol-package class))))
                    ,(if (and (setq h (get class 'clos::closclass))
                              (typep h clos::<structure-class>)
                              (setq h (clos::class-kconstructor h)))
                       ;; h is the keyword constructor for the structure
                       `(,h ,@(mapcan #'(lambda (s v)
                                          (list (symbol-to-keyword s) v))
                                      slots vars))
                       ;; no keyword constructor found ->
                       ;; use CLOS:SLOT-VALUE instead
                       (let ((ivar (gensym)))
                         `(LET ((,ivar (CLOS:MAKE-INSTANCE ',class)))
                           ,@(mapcar #'(lambda (s v)
                                         `(SETF (CLOS:SLOT-VALUE ,ivar ', s)
                                           ,v))
                                     slots vars)
                           ,ivar)))))))))))

(defmacro with-name/options ((name options name+options) &body body)
  (multiple-value-bind (body-rest declarations) (system::parse-body body)
    (let ((no (gensym "NAME+OPTIONS-")))
      `(LET ((,no ,name+options))
         (MULTIPLE-VALUE-BIND (,name ,options)
             (IF (CONSP ,no) (VALUES (FIRST ,no) (REST ,no)) (VALUES ,no NIL))
           (DECLARE (IGNORABLE ,name ,options) ,@declarations)
           ,@body-rest)))))

(defmacro with-defining-c-type ((name c-type len) &body body)
  (multiple-value-bind (body-rest declarations) (system::parse-body body)
    `(LET ((,c-type (MAKE-ARRAY ,len)))
       ,@(if declarations `((DECLARE ,@declarations)))
       (UNWIND-PROTECT
           (PROGN
             (WHEN ,name
               (SETF (GETHASH ,name *C-TYPE-TABLE*) ,c-type))
             ,@body-rest)
         (WHEN ,name
           (SETF (GETHASH ,name *C-TYPE-TABLE*) NIL)))
       (WHEN ,name
         (SETF (GETHASH ,name *C-TYPE-TABLE*) ,c-type))
       ,c-type)))

;; Parse a C type specification.
;; If name is non-NIL, it will be assigned to name.
(defun parse-c-type (typespec &optional (name nil))
  (if (atom typespec)
    (if (symbolp typespec)
      (multiple-value-bind (c-type found) (gethash typespec *c-type-table*)
        (unless found
          (error (TEXT "Incomplete FFI type ~S is not allowed here.")
                 typespec))
        (when name (setf (gethash name *c-type-table*) c-type))
        c-type)
      (if (stringp typespec)
        (let ((c-type (parse-foreign-inttype typespec t)))
          (when name (setf (gethash name *c-type-table*) c-type))
          c-type)
        (error (TEXT "FFI type should be a symbol, not ~S")
               typespec)))
    (flet ((invalid (typespec)
             (error (TEXT "Invalid FFI type: ~S")
                    typespec))
           (dimp (dim) (typep dim '(integer 0 *))))
      (case (first typespec)
        (C-STRUCT
         (with-defining-c-type (name c-type (max 5 (+ 3 (length typespec))))
           (setf (svref c-type 0) (first typespec)) ; c-struct
           (with-name/options (name options (second typespec))
             (setf (svref c-type 1) name)
             (setf (svref c-type 2) options))
           (setf (svref c-type 3) (map 'vector #'first (cddr typespec)))
           (setf (svref c-type 4) ; constructor
                 (c-struct-constructor typespec))
           (setf (subseq c-type 5) (parse-components typespec))))
        (C-UNION
         (with-defining-c-type (name c-type (1+ (length typespec)))
           (setf (svref c-type 0) (first typespec))
           (setf (svref c-type 1) (map 'vector #'first (rest typespec)))
           (setf (subseq c-type 2) (parse-components typespec))))
        (C-ARRAY
          (unless (eql (length typespec) 3) (invalid typespec))
          (let ((dimensions (third typespec)))
            (unless (listp dimensions) (setq dimensions (list dimensions)))
            (unless (every #'dimp dimensions)
              (invalid typespec))
            (with-defining-c-type (name c-type (+ 2 (length dimensions)))
              (setf (svref c-type 0) 'C-ARRAY)
              (setf (svref c-type 1) (parse-c-type (second typespec)))
              (setf (subseq c-type 2) dimensions))))
        (C-ARRAY-MAX
          (unless (eql (length typespec) 3) (invalid typespec))
          (let ((maxdim (third typespec)))
            (unless (dimp maxdim) (invalid typespec))
            (with-defining-c-type (name c-type 3)
              (setf (svref c-type 0) 'C-ARRAY-MAX)
              (setf (svref c-type 1) (parse-c-type (second typespec)))
              (setf (svref c-type 2) maxdim))))
        (C-FUNCTION
         (let ((c-type
                 (parse-c-function
                   (parse-options (rest typespec)
                                  '(:arguments :return-type :language)
                                  typespec)
                   typespec)))
            (when name (setf (gethash name *c-type-table*) c-type))
            c-type))
        (C-PTR
         (unless (eql (length typespec) 2) (invalid typespec))
         (with-defining-c-type (name c-type 2)
           (setf (svref c-type 0) 'C-PTR)
           (setf (svref c-type 1) (parse-c-type (second typespec)))))
        (C-PTR-NULL
          (unless (eql (length typespec) 2) (invalid typespec))
          (with-defining-c-type (name c-type 2)
            (setf (svref c-type 0) 'C-PTR-NULL)
            (setf (svref c-type 1) (parse-c-type (second typespec)))))
        (C-POINTER
          (unless (eql (length typespec) 2) (invalid typespec))
          (with-defining-c-type (name c-type 2)
            (setf (svref c-type 0) 'C-POINTER)
            (setf (svref c-type 1) (parse-c-type (second typespec)))))
        (C-ARRAY-PTR
          (unless (eql (length typespec) 2) (invalid typespec))
          (with-defining-c-type (name c-type 2)
            (setf (svref c-type 0) 'C-ARRAY-PTR)
            (setf (svref c-type 1) (parse-c-type (second typespec)))))
        (t (invalid typespec))))))

;; Primitive types (symbols) can be safely inlined at compile-time.
;; Handle (parse-c-type 'uint8) as well as
;; (def-c-type PGconn c-pointer) (parse-c-type 'pgconn)
;; In addition, `(c-array uint8 ,(length foo))
;;  -> (vector 'c-array (parse-c-type 'uint8) (length foo))
;;  -> (vector 'c-array 'uint8 (length foo))
;; As a result, execution time is nearly halved.
(define-compiler-macro parse-c-type (&whole form typespec &optional name)
  (unless name
    (cond
      ((typep typespec '(CONS (EQL QUOTE) (CONS SYMBOL NULL)))
       (let* ((typespec (second typespec))
              (internal (gethash typespec *c-type-table* 0)))
         (when (symbolp internal)
           (return-from parse-c-type `',internal))))
      ;; Under Kaz Kylheku's backquote reader, `(c-array x ,l) yields
      ;;(SYSTEM::BACKQUOTE (C-ARRAY X (SYSTEM::UNQUOTE L)))
      ;; which is optimized because it is costly, yet a common pattern.
      ((typep typespec
              '(CONS (EQL SYS::BACKQUOTE)
                (CONS
                 (CONS (MEMBER C-ARRAY C-ARRAY-MAX)
                  (CONS ATOM ; do not match (SYSTEM::UNQUOTE #) here
                        (CONS (CONS (EQL SYS::UNQUOTE)
                                    (CONS * NULL)) NULL))) NULL)))
       (return-from parse-c-type
         (let ((typespec (second typespec)))
           `(VECTOR
             ',(first typespec)
             (PARSE-C-TYPE ',(second typespec))
             (EXT:ETHE UNSIGNED-BYTE ,(second (third typespec)))))))))
  form)

(defun parse-options (options keywords whole)
  (let ((alist '()))
    (dolist (option options)
      (unless (and (consp option) (member (first option) keywords))
        (error (TEXT "Invalid option in ~S: ~S")
               whole option))
      (when (assoc (first option) alist)
        (error (TEXT "Only one ~S option is allowed: ~S")
              (first option) whole))
      (push option alist))
    ;; maximize sharing: return accepted options, not alist
    options))

;; check whether C-TYPE is a C type spec and return the type
(defun ctype-type (c-type)
  (and (simple-vector-p c-type) (plusp (length c-type)) (svref c-type 0)))

;; check whether the flag is set in the variable
(defun flag-set-p (var flag) (not (zerop (logand var flag))))

(defun flag-to-language (flag)
  (append (if (flag-set-p flag ff-language-c) '(:C) '())
          (if (flag-set-p flag ff-language-ansi-c)
              (if (flag-set-p flag ff-language-stdcall)
                '(:STDC-STDCALL)
                '(:STDC))
              '())))

(defun language-to-flag (lang)
  (ecase lang
    (:C ff-language-c)
    (:STDC ff-language-ansi-c)
    (:STDC-STDCALL (+ ff-language-ansi-c ff-language-stdcall))))

;; the default foreign language
(defvar *foreign-language* nil) ; ABI

(defmacro default-foreign-language (lang)
  (language-to-flag lang)       ; error checking
  `(eval-when (load compile eval)
     (without-package-lock ("FFI") (setq *foreign-language* ',lang))))

;; the default foreign library for this compilation unit
(defvar *foreign-library* nil) ; ABI

(defmacro default-foreign-library (library)
  `(eval-when (load compile eval)
     (without-package-lock ("FFI") (setq *foreign-library* ,library))))

;; get the even (start=0) or odd (start=1) elements of the simple vector
(defun split-c-fun-arglist (args start)
  (do ((ii start (+ ii 2)) (res '()))
      ((>= ii (length args)) (nreverse res))
    (push (svref args ii) res)))

(defun parse-c-function (alist whole) ; ABI
  (vector
    'C-FUNCTION
    (parse-c-type (or (second (assoc ':return-type alist)) 'nil))
    (coerce (mapcap (lambda (argspec)
                      (unless (and (listp argspec)
                                   (symbolp (first argspec))
                                   (<= 2 (length argspec) 4))
                        (error (TEXT "Invalid parameter specification in ~S: ~S")
                               whole argspec))
                      (let* ((argtype (parse-c-type (second argspec)))
                             (argmode (if (cddr argspec) (third argspec) ':IN))
                             (argalloc (if (cdddr argspec)
                                         (fourth argspec)
                                         (if (or (eq argtype 'C-STRING)
                                                 (case (ctype-type argtype) ((C-PTR C-PTR-NULL C-ARRAY-PTR) t))
                                                 (eq argmode ':OUT))
                                           ':ALLOCA
                                           ':NONE))))
                        ;; see FOREIGN-CALL-OUT in foreign.d
                        (when (and (or (eq argmode :OUT) (eq argmode :IN-OUT))
                                   (not (eq (ctype-type argtype) 'C-PTR)))
                          (warn (TEXT "~S argument ~S is not a pointer in ~S")
                                argmode argtype whole))
                        (list argtype
                              (+ (sys::mecase whole argmode
                                   ((:IN :READ-ONLY) 0)
                                   ((:OUT :WRITE-ONLY) ff-flag-out)
                                   ((:IN-OUT :READ-WRITE) ff-flag-in-out))
                                 (sys::mecase whole argalloc
                                   (:NONE 0)
                                   (:ALLOCA ff-flag-alloca)
                                   (:MALLOC-FREE ff-flag-malloc-free))))))
                    (or (rest (assoc ':arguments alist)) '()))
            'simple-vector)
    (+ (let ((rettype (assoc ':return-type alist)))
         (if (cddr rettype)
           (sys::mecase whole (third rettype)
             (:NONE 0)
             (:MALLOC-FREE ff-flag-malloc-free))
           0))
       (let ((languages (assoc ':language alist)))
         (if languages
           (reduce #'+ (rest languages) :key #'language-to-flag)
           (language-to-flag
            (or *foreign-language*
                (progn
                  (warn (TEXT "~S: No ~S argument and no ~S form in this compilation unit; ~S assumed now and for the rest of this unit")
                        whole :language 'default-foreign-language :stdc)
                  (setq *foreign-language* :STDC))))))))) ; Default is ANSI C

(defun parse-foreign-name (name)
  (unless (stringp name)
    (error (TEXT "The name must be a string, not ~S")
           name))
  (if (c-ident-p name)
    name
    (error (TEXT "The name ~S is not a valid C identifier")
           name)))

(defmacro DEF-C-TYPE (&whole whole-form name &optional typespec)
  (setq name (check-symbol name (first whole-form)))
  `(EVAL-WHEN (LOAD COMPILE EVAL)
     ,(if typespec
          `(PARSE-C-TYPE ',typespec ',name)
          `(SETF (GETHASH ',name FFI::*C-TYPE-TABLE*)
                 ;; prefer lower case
                 (CS-CL:symbol-name ',name)))
     ',name))

;; Convert back a C type from internal (vector) to external (list)
;; representation. Both representations may be circular.
(defun deparse-c-type (ctype)
  (let ((alist '()))
    (labels ((new-type (ctype typespec)
               (setq alist (acons ctype typespec alist))
               ctype)
             (deparse-slot (slot slottype)
               (list slot (deparse slottype)))
             (deparse (ctype)
               (or (cdr (assoc ctype alist :test #'eq))
                   (if (or (symbolp ctype) (stringp ctype))
                     ;; <simple-c-type>, c-pointer, c-string
                     (new-type ctype ctype)
                     (let ((typespec (list (svref ctype 0))))
                       (new-type ctype typespec)
                       (setf (rest typespec) ; fill the rest
                             (ecase (svref ctype 0)
                               ;; #(c-struct name options slots
                               ;;            constructor <c-type>*)
                               (C-STRUCT
                                (let* ((constructor (svref ctype 4))
                                       (options (svref ctype 2))
                                       (name (cond ((eql constructor #'vector)
                                                    'vector)
                                                   ((eql constructor #'list)
                                                    'list)
                                                   (t (svref ctype 1)))))
                                  (cons (if options (cons name options) name)
                                        (map 'list #'deparse-slot
                                             (svref ctype 3)
                                             (subseq ctype 5)))))
                               ;; #(c-union alternatives <c-type>*)
                               (C-UNION
                                (map 'list #'deparse-slot
                                     (svref ctype 1) (subseq ctype 2)))
                               ;; #(c-array <c-type> number*)
                               (C-ARRAY
                                (list (deparse (svref ctype 1))
                                      (let ((dimensions (subseq ctype 2)))
                                        (if (eql (length dimensions) 1)
                                          (elt dimensions 0)
                                          (coerce dimensions 'list)))))
                               ;; #(c-array-max <c-type> number)
                               (C-ARRAY-MAX
                                (list (deparse (svref ctype 1))
                                      (svref ctype 2)))
                               ;; #(c-function <c-type> #({<c-type> flags}*)
                               ;;               flags)
                               (C-FUNCTION
                                (list (list ':arguments
                                            (do ((args (coerce (svref ctype 2) 'list) (cddr args))
                                                 (i 1 (+ i 1))
                                                 (argspecs '()))
                                                ((null args) (nreverse argspecs))
                                              (let ((argtype (first args))
                                                    (argflags (second args)))
                                                (push `(,(intern (format nil "arg~D" i) system::*keyword-package*)
                                                        ,(deparse argtype)
                                                        ,(cond ((flag-set-p argflags ff-flag-out) ':OUT)
                                                               ((flag-set-p argflags ff-flag-in-out) ':IN-OUT)
                                                               (t ':IN))
                                                        ,(cond ((flag-set-p argflags ff-flag-alloca) ':ALLOCA)
                                                               ((flag-set-p argflags ff-flag-malloc-free) ':MALLOC-FREE)
                                                               (t ':NONE)))
                                                      argspecs))))
                                      (list ':return-type
                                            (deparse (svref ctype 1))
                                            (if (flag-set-p (svref ctype 3) ff-flag-malloc-free) ':MALLOC-FREE ':NONE))
                                      (cons ':language
                                            (flag-to-language (svref ctype 3)))))
                               ;; #(c-ptr <c-type>), #(c-ptr-null <c-type>)
                               ;; #(c-array-ptr <c-type>), #(c-pointer <c-type>)
                               ((C-PTR C-PTR-NULL C-POINTER C-ARRAY-PTR)
                                (list (deparse (svref ctype 1))))))
                       typespec)))))
      (deparse ctype))))

;; ============================ module ============================

; Data belonging to the FFI module being compiled:
(defvar *ffi-module* nil)

; We put everything into a structure, so that COMPILE-FILE needs to bind only
; a single variable at compile time.
(defstruct ffi-module
  name
  c-name
  (object-table (make-hash-table :key-type '(or string symbol) :value-type '(cons string fixnum)
                                 :test 'stablehash-equal :warn-if-needs-rehash-after-gc t))
  (type-table (make-hash-table :key-type 'symbol :value-type '(or null string)
                               :test 'stablehash-eq :warn-if-needs-rehash-after-gc t))
  (init-once '())
  (init-always '())
  (fini '())
  ;; type -> (function-name . #(const1 const2 const3 ...))
  (constant-table (make-hash-table :test 'stablehash-eq :key-type 'symbol
                                   :value-type '(cons string vector)
                                   :warn-if-needs-rehash-after-gc t))
  (variable-list '())
  (function-list '()))
(define-symbol-macro *name*
    (ffi-module-name *ffi-module*))
(define-symbol-macro *c-name*
    (ffi-module-c-name *ffi-module*))
(define-symbol-macro *object-table*
    (ffi-module-object-table *ffi-module*))
(define-symbol-macro *type-table*
    (ffi-module-type-table *ffi-module*))
(define-symbol-macro *init-once*
    (ffi-module-init-once *ffi-module*))
(define-symbol-macro *init-always*
    (ffi-module-init-always *ffi-module*))
(define-symbol-macro *fini*
    (ffi-module-fini *ffi-module*))
(define-symbol-macro *constant-table*
    (ffi-module-constant-table *ffi-module*))
(define-symbol-macro *variable-list*
    (ffi-module-variable-list *ffi-module*))
(define-symbol-macro *function-list*
    (ffi-module-function-list *ffi-module*))

; Convert a file name to a C module name.
; This must agree with some sed command in clisp-link.in.
(defun to-module-name (name)
  (map 'string #'(lambda (c)
                   (if (or (char<= #\A c #\Z) (char<= #\a c #\z) (char<= #\0 c #\9) (char= c #\_))
                     c
                     #\_
                 ) )
       name
) )

; Convert a Lisp name to a C name.
; (Doesn't really matter how. This must just be a deterministic function.)
(defun to-c-name (name)
  (setq name (if (and (symbolp name)
                      (symbol-package name)
                      (package-case-inverted-p (symbol-package name)))
               (cs-cl:string name)
               (let ((nm (string name)))
                 (if (some #'lower-case-p nm)
                     nm (string-downcase name)))))
  (if (c-ident-p name)
    name
    (with-output-to-string (s)
      (format s "_lisp__")
      (map nil
           #'(lambda (ch)
               (if (and (standard-char-p ch) (alphanumericp ch))
                 (write-char ch s)
                 (format s "_~2X" (char-code ch))))
           name))))

; Prepare the conversion of a C type to its C representation.
; Calling this will generate a "typedef" declaration for some C types.
; This is needed if you want to call `to-c-typedecl' more than once on
; the same type.
; This must be called before `to-c-typedecl', at a point where global
; declarations in the *coutput-stream* are acceptable.
(defun prepare-c-typedecl (c-type)
  (unless (gethash c-type *type-table*)
    (case (ctype-type c-type)
      ((C-STRUCT C-UNION C-ARRAY C-ARRAY-MAX)
       (let ((new-typename (symbol-name (gensym "g"))))
         (format *coutput-stream* "~%typedef ~A;~%"
                 (to-c-typedecl c-type new-typename))
         (setf (gethash c-type *type-table*) new-typename))))))

; Convert a C type to its C representation.
(defun to-c-typedecl (c-type name)
  (case c-type
    ((nil) (format nil "void ~A" name))
    ((boolean int) (format nil "int ~A" name))
    (character (format nil "char ~A" name))
    ((char sint8) (format nil "sint8 ~A" name))
    ((uchar uint8) (format nil "uint8 ~A" name))
    ((short sint16) (format nil "sint16 ~A" name))
    ((ushort uint16) (format nil "uint16 ~A" name))
    (uint (format nil "unsigned int ~A" name))
    (long (format nil "long ~A" name))
    (ulong (format nil "unsigned long ~A" name))
    (sint32 (format nil "sint32 ~A" name))
    (uint32 (format nil "uint32 ~A" name))
    (sint64 (format nil "sint64 ~A" name))
    (uint64 (format nil "uint64 ~A" name))
    (single-float (format nil "float ~A" name))
    (double-float (format nil "double ~A" name))
    (c-string (format nil "char* ~A" name))
    (c-pointer (format nil "void* ~A" name))
    (t (if (gethash c-type *type-table*)
         (format nil "~A ~A" (gethash c-type *type-table*) name)
         (macrolet ((with-to-c ((class typename &key (tname '(gensym "t")))
                                &body body)
                      `(let ((,typename (format nil "~A ~A" ,class ,tname)))
                         (unwind-protect
                              (progn (setf (gethash c-type *type-table*)
                                           ,typename)
                                     ,@body)
                           (setf (gethash c-type *type-table*) nil)))))
           (case (ctype-type c-type)
             (c-struct
              (cond ((sys::memq :typedef (svref c-type 2))
                     (format nil "~A ~A" (svref c-type 1) name))
                    ((sys::memq :external (svref c-type 2))
                     (format nil "struct ~A ~A" (svref c-type 1) name))
                    (t (with-to-c ("struct" type :tname (svref c-type 1))
                         (format nil "~a { ~{~A; ~}} ~A"
                                 type (map 'list #'to-c-typedecl
                                           (subseq c-type 5)
                                           (svref c-type 3))
                                 name)))))
             (c-union
              (with-to-c ("union" type)
                (format nil "~A { ~{~A; ~}} ~A"
                        type (map 'list #'to-c-typedecl
                                  (cddr (coerce c-type 'list))
                                  (svref c-type 1))
                        name)))
             (c-array
              (to-c-typedecl (svref c-type 1)
                             (format nil "(~A)~{[~D]~}" name
                                     (cddr (coerce c-type 'list)))))
             (c-array-max
              (to-c-typedecl (svref c-type 1)
                             (format nil "(~A)[~D]" name (svref c-type 2))))
             ((c-ptr c-ptr-null c-pointer c-array-ptr)
              (to-c-typedecl (svref c-type 1) (format nil "* ~A" name)))
             (c-function
              (to-c-typedecl (svref c-type 1)
                             (format nil "(~A) (~{~A~^,~})" name
                                     (mapcar (lambda (c-t)
                                               (to-c-typedecl
                                                c-t (gensym "arg")))
                                             (split-c-fun-arglist
                                              (svref c-type 2) 0)))))
             (t (error (TEXT "illegal foreign data type ~S")
                       c-type))))))))

(defvar *output-c-functions* nil)
(defvar *output-c-variables* nil)
(defvar *foreign-guard* nil)

(defun prepare-module ()
  (unless *ffi-module*
    (setq *ffi-module*
          (let ((module-name (pathname-name *coutput-file*)))
            (make-ffi-module :name module-name
                             :c-name (to-module-name module-name))))
    (format *coutput-stream* "extern gcv_object_t module__~A__object_tab[];~%"
            *c-name*)))
(defun finalize-coutput-file ()
  (when *ffi-module*
    (format *coutput-stream* "~%subr_t module__~A__subr_tab[1];~%~
            uintC module__~A__subr_tab_size = 0;~%~
            subr_initdata_t module__~A__subr_tab_initdata[1];~2%"
            *c-name* *c-name* *c-name*)
    (let ((count (hash-table-count *object-table*)))
      (if (zerop count)
        (format *coutput-stream* "gcv_object_t module__~A__object_tab[1];~%~
                object_initdata_t module__~A__object_tab_initdata[1];~%"
                *c-name* *c-name*)
        (let ((v (make-array count)))
          (format *coutput-stream* "gcv_object_t module__~A__object_tab[~D];~%~
                  object_initdata_t module__~A__object_tab_initdata[~D] = {~%"
                  *c-name* count *c-name* count)
          (dohash (key value *object-table*)
            (declare (ignore key))
            (setf (svref v (cdr value)) (car value)))
          (map nil #'(lambda (initstring)
                       (format *coutput-stream* "  { ~A },~%"
                               (to-c-string initstring)))
               v)
          (format *coutput-stream* "};~%")))
      (format *coutput-stream* "uintC module__~A__object_tab_size = ~D;~%"
              *c-name* count))
    (format *coutput-stream* "~%")
    (maphash (lambda (type fun-vec)
               (let* ((fun (first fun-vec)) (vec (second fun-vec))
                      (c-decl (to-c-typedecl type fun)))
                 (when (eq type 'c-string)
                   ;; avoid warning:
                   ;; deprecated conversion from string constant to 'char*'
                   (setq c-decl (string-concat "const " c-decl)))
                 (format *coutput-stream* "~A (int number, int *definedp);~%~
                                           ~A (int number, int *definedp) {
  *definedp=1;~%  switch (number) {~%"
                         c-decl c-decl)
                 (dotimes (num (length vec))
                   (destructuring-bind (const . guard) (aref vec num)
                     (when guard
                       (format *coutput-stream* "#  if ~A~%" guard))
                     (format *coutput-stream* "    case ~D: return ~A;~%"
                             num const)
                     (when guard
                       (format *coutput-stream* "#  endif~%"))))
                 (format *coutput-stream* "    default: *definedp=0; return 0;
  }~%}~%")))
             *constant-table*)
    (setq *variable-list*
          (nreverse (delete-duplicates
                     *variable-list* :key #'first :test #'equal)))
    (when *output-c-variables*
      (dolist (variable *variable-list*)
        ;;(prepare-c-typedecl (second variable))
        (format *coutput-stream* "extern ~A;~%"
                (to-c-typedecl (second variable) (first variable)))))
    (setq *function-list*
          (nreverse (delete-duplicates
                     *function-list* :key #'first :test #'equal)))
    (when *output-c-functions*
      (dolist (function *function-list*)
        ;;(prepare-c-typedecl (svref (second function) 1))
        (format *coutput-stream* "extern ~A"
                (to-c-typedecl (svref (second function) 1)
                               (format nil "(~A)(" (first function))))
        (when (third function)    ; built-in, requires full arglist
          (do* ((parameters (svref (second function) 2))
                (length (length parameters)) (i 0 (+ 2 i))
                (parameter (svref parameters i)))
               ((>= i length))
            (unless (zerop i)
              (write-string ", " *coutput-stream*))
            (write-string (to-c-typedecl parameter "")
                          *coutput-stream*)))
        (format *coutput-stream* ");~%")))
    (format *coutput-stream*
            "~2%void module__~A__init_function_1 (module_t* module)~%~
            {~%  (void)module; /* avoid -Wunused-parameter */~%~{~%  ~A~}~%"
            *c-name* *init-once*)
    (let ((done (make-hash-table :test 'equal)))
      (maphash (lambda (type spec)
                 (declare (ignore type))
                 (when (and (stringp spec) (not (gethash spec done))
                            (eq 0 (parse-foreign-inttype spec nil)))
                   (setf (gethash spec done) spec)
                   (when *foreign-guard*
                     (format *coutput-stream* "# if HAVE_~A~%"
                             (string-upcase spec)))
                   (format *coutput-stream* "  register_foreign_inttype(~S,sizeof(~A),(~A)-1<=(~A)0);~%" spec spec spec spec)
                   (when *foreign-guard* (format *coutput-stream* "# endif~%"))))
               *c-type-table*))
    (format *coutput-stream*
            "}~2%void module__~A__init_function_2 (module_t* module)~%~
            {~%  (void)module; /* avoid -Wunused-parameter */~%~{~%  ~A~}~%"
             *c-name* *init-always*)
    (dolist (variable *variable-list*)
      (let ((c-name (first variable)))
        (when *foreign-guard*
          (format *coutput-stream* "# if HAVE_DECL_~A~%"
                  (string-upcase c-name)))
        (format *coutput-stream*
                "  register_foreign_variable((void*)&~A,~A,~D,sizeof(~A));~%"
                c-name (to-c-string c-name) (third variable) (first variable))
        (when *foreign-guard* (format *coutput-stream* "# endif~%"))))
    (dolist (function *function-list*)
      (let ((c-name (first function))
            (guard (fourth function)))
        (when guard
          (format *coutput-stream* "# if ~A~%"
                  (if (eq guard t)
                      (format nil "defined(HAVE_~A)" (string-upcase c-name))
                      guard)))
        (format *coutput-stream*
                "  register_foreign_function((void*)&~A,~A,~D);~%"
                c-name (to-c-string c-name) (svref (second function) 3))
        (when guard (format *coutput-stream* "# endif~%"))))
    (maphash (lambda (type fun-vec)
               (declare (ignore type))
               (let ((c-name (to-c-name (car fun-vec))))
                 (format *coutput-stream*
                         "  register_foreign_function((void*)&~A,\"~A\",~D);~%"
                         c-name c-name (svref (third fun-vec) 3))))
             *constant-table*)
    (format *coutput-stream*
            "}~2%void module__~A__fini_function (module_t* module)~%~
            {~%  (void)module; /* avoid -Wunused-parameter */~%~{~%  ~A~}~%}~%"
            *c-name* *fini*)))

; Allocate a new object in the module's object_tab.
(defun new-object (read-only-p initstring)
  (when read-only-p
    (let ((h (gethash initstring *object-table*)))
      (when h
        (return-from new-object (cdr h))))) ; no need to allocate a new one
  (let ((index (hash-table-count *object-table*)))
    (setf (gethash (if read-only-p initstring (gensym)) *object-table*)
          (cons initstring index))
    index))

; Pass an object from the compilation environment to the module.
(defun pass-object (object)
  (new-object t
              (let ((*package* system::*keyword-package*))
                (write-to-string object :readably t :pretty nil))))

; Convert an object's index to a C lvalue.
(defun object-to-c-value (index)
  (format nil "module__~A__object_tab[~D]" *c-name* index))

; Output some C text literally.
(defmacro C-LINES (format-string &rest args)
  `(EVAL-WHEN (COMPILE)
     (DO-C-LINES ,format-string ,@args)))
(defun do-c-lines (format-string &rest args) ; ABI
  (when (system::prepare-coutput-file)
    (prepare-module)
    (etypecase format-string
      ((or string function)
       (apply #'format *coutput-stream* format-string args))
      ((member :init-always :init-once :fini)
       (let ((code (apply #'format nil args)))
         (ecase format-string
           (:init-always (push code *init-always*))
           (:init-once (push code *init-once*))
           (:fini (push code *fini*))))))))

;; ============================ named C variables ============================

(defun foreign-name (lisp-name name-option)
  (if name-option
    (parse-foreign-name (second name-option))
    (to-c-name lisp-name)))

(defun get-assoc (key alist default)
  (let ((pair (assoc key alist)))
    (if pair (second pair) default)))

(defun maximize-integer-type (type)
  (case type
    ((char short int long sint8 sint16 sint32 sint64) 'long)
    ((uchar ushort uint ulong uint8 uint16 uint32 uint64) 'ulong)
    (t type)))

;; CPP consts (#define'd in an *.h file):
;; for each type (int, string, pointer) there is a C function (and a
;;  foreign-function created when the first constant of this type is
;;  encountered) mapping a number (assigned at _compile_ time) into the value
;; when loading a compiled file, the C function has already been writted
;;  into the C file and compiled, so the numbers have to be pre-assigned
(defmacro DEF-C-CONST (&whole whole-form name &rest options)
  (setq name (check-symbol name (first whole-form)))
  (let* ((alist (parse-options options '(:name :type :documentation :guard)
                               whole-form))
         (doc (cdr (assoc ':documentation alist))) ; ("doc string") or NIL
         (c-type (maximize-integer-type (get-assoc :type alist 'ffi:long)))
         (c-name (get-assoc :name alist name))
         (guard (get-assoc :guard alist (format nil "defined(~A)" c-name)))
         (cftype (parse-c-function
                  `((:arguments (number int) (defined-p (c-ptr int) :out))
                    (:return-type ,c-type))
                  whole-form)))
    (check-type c-type (member ffi:long ffi:ulong ffi:c-string ffi:c-pointer)
                "an integer, a string or a pointer")
    `(let ((f-name&c-number
            (compile-time-value (note-c-const ',c-name ',c-type
                                              ',cftype ',guard))))
       (let ((f-name (first f-name&c-number))
             (c-number (second f-name&c-number)))
         ;; c-number == 0 ==> need to output the def-call-out form
         (when (zerop c-number)
           (SYSTEM::%SET-SYMBOL-FUNCTION
            ;; we do not really need to name this foreign function; this is just
            ;; to avoid an HT lookup in FIND-FOREIGN-FUNCTION for each C const
            f-name (FIND-FOREIGN-FUNCTION (to-c-name f-name)
                                          ,cftype NIL NIL NIL NIL)))
         (defconstant ,name (c-const-value f-name c-number ',name ',c-name)
           ,@doc)))))

(defun note-c-const (c-name c-type cftype guard) ; ABI
  (unless (system::prepare-coutput-file)
    (error (TEXT "~S(~S) requires writing to a C file") 'def-c-const c-name))
  (prepare-module)
  (let ((f-name (intern
                 (format nil "module__~A__constant_map_~A" *name*
                         (nstring-downcase
                          (nsubstitute #\_ #\-
                                       (copy-seq (symbol-name c-type))))))))
    (list f-name
          (vector-push-extend
           (cons c-name guard)
           (second (or (gethash c-type *constant-table*)
                       (setf (gethash c-type *constant-table*)
                             (list f-name (make-array 10 :adjustable t
                                                      :fill-pointer 0)
                                   cftype))))))))

(defun c-const-value (f-name c-number name c-name) ; ABI
  (multiple-value-bind (value value-p) (funcall f-name c-number)
    (if (plusp value-p) value
        (progn
          (warn (TEXT "~S(~S): CPP constant ~A is not defined")
                'def-c-const name c-name)
          (sys::%unbound)))))

(defmacro DEF-C-VAR (&whole whole-form
                     name &rest options)
  (setq name (check-symbol name (first whole-form)))
  (let* ((alist (parse-options options '(:name :type :read-only :alloc
                                         :library :version :documentation)
                               whole-form))
         (doc (assoc ':documentation alist))
         (c-name (foreign-name name (assoc ':name alist)))
         (type (second (or (assoc ':type alist)
                           (sys::error-of-type 'ext:source-program-error
                             :form whole-form
                             :detail whole-form
                             (TEXT "~S: ~S option missing in ~S")
                             'def-c-var ':type whole-form))))
         (read-only (second (assoc ':read-only alist)))
         (flags (+ (if read-only fv-flag-readonly 0)
                   (let ((alloc (assoc ':alloc alist)))
                     (if (cdr alloc)
                       (sys::mecase whole-form (second alloc)
                         (:NONE 0)
                         (:MALLOC-FREE fv-flag-malloc-free))
                       0))))
         (library (get-assoc :library alist '*foreign-library*))
         (version (second (assoc :version alist)))
         #|
         (getter-function-name (sys::symbol-suffix name "%GETTER%"))
         (setter-function-name (sys::symbol-suffix name "%SETTER%"))
         |#
         (def (gensym "DEF-C-VAR-")))
    `(LET ((,def (LOAD-TIME-VALUE
                  (FIND-FOREIGN-VARIABLE
                   ',c-name (PARSE-C-TYPE ',type) ,library ,version NIL))))
       #|
       (LET ((FVAR (LOOKUP-FOREIGN-VARIABLE ',c-name (PARSE-C-TYPE ',type))))
         (DEFUN ,getter-function-name () (FOREIGN-VALUE FVAR))
         ; Install a setter even if the variable is read-only.
         ; When called, it will print a comprehensible error message.
         (DEFUN ,setter-function-name (VALUE) (SET-FOREIGN-VALUE FVAR VALUE))
       )
       (DEFSETF ,getter-function-name ,setter-function-name)
       (DEFINE-SYMBOL-MACRO ,name (,getter-function-name))
       |#
       (EVAL-WHEN (COMPILE)
         (UNLESS ,LIBRARY (NOTE-C-VAR ',c-name ',type ',flags)))
       (when ,def
         (SYSTEM::%PUT ',name 'FOREIGN-VARIABLE ,def)
         ,@(when doc `((SETF (DOCUMENTATION ',name 'VARIABLE) ',(second doc))))
         (DEFINE-SYMBOL-MACRO ,name
             (FOREIGN-VALUE (LOAD-TIME-VALUE (GET ',name 'FOREIGN-VARIABLE)))))
       ',name)))

(defun note-c-var (c-name type flags) ; ABI
  (when (system::prepare-coutput-file)
    (prepare-module)
    (push (list c-name (parse-c-type type) flags) *variable-list*)))

(defsetf foreign-value set-foreign-value) ; ABI
;(defsetf foreign-pointer set-foreign-pointer) ; no, incompatible with SETF
(defsetf validp set-validp) ; ABI

(defmacro with-c-place ((var fvar) &body body)
  (let ((fv (gensym (symbol-name var))))
    `(LET ((,fv ,fvar))
       (SYMBOL-MACROLET ((,var (FOREIGN-VALUE ,fv)))
         ,@body))))

;; ============================ Stack allocation ============================

;; Allocate arbitrarily complex structure on the stack,
;; but allocate only (sizeof c-type) bytes when called without initarg!
;; C-ARRAY-MAX, "" and #() are thus your friends for creation of empty arrays.
;; (with-c-var (v '(c-ptr  (c-array     uint8 32)))     (cast v 'c-pointer))
;;                -> null-pointer, 4 bytes
;; (with-c-var (v '(c-ptr  (c-array-max uint8 32)) #()) (cast v 'c-pointer))
;;                -> non-null,  4+32 bytes
;; (with-c-var (v '(c-ptr-null (c-array uint8 32)) nil) (cast v 'c-pointer))
;;                -> null-pointer, 4 bytes

;; c-type is evaluated. This is particularly useful for variable sized arrays
;; using: `(c-array uint8 ,(length foo))
(defmacro with-foreign-object ((var c-type &optional (init nil init-p))
                               &body body)
  `(EXEC-ON-STACK
     #'(LAMBDA (,var) ,@body)
     (PARSE-C-TYPE ,c-type)
     ,@(if init-p `(,init))))

;; symbol-macro based interface (like DEF-C-VAR)
;; WITH-C-VAR appears as a composition of WITH-FOREIGN-OBJECT and WITH-C-PLACE
(defmacro with-c-var ((var c-type &optional (init nil init-p)) &body body)
  (let ((fv (gensym (symbol-name var))))
    `(EXEC-ON-STACK
       #'(LAMBDA (,fv)
           (SYMBOL-MACROLET ((,var (FOREIGN-VALUE ,fv)))
             ,@body))
       (PARSE-C-TYPE ,c-type)
       ,@(if init-p `(,init)))))

(defun exec-with-foreign-string (thunk string ; ABI
                                 &key (encoding #+UNICODE custom:*foreign-encoding*
                                                #-UNICODE custom:*default-file-encoding*)
                                      (null-terminated-p t) (start 0) (end nil))
  (call-with-foreign-string thunk encoding string start end
                            (if null-terminated-p
                                (sys::encoding-zeroes encoding)
                                0)))

(defmacro with-foreign-string ((foreign-variable char-count byte-count string
                                &rest keywords
                                &key encoding null-terminated-p start end)
                               &body body)
  (declare (ignore encoding null-terminated-p start end)) ; get them via keywords
  `(EXEC-WITH-FOREIGN-STRING
     #'(LAMBDA (,foreign-variable ,char-count ,byte-count) ,@body)
     ,string ,@keywords))

;; ============================ heap allocation ============================

(defmacro allocate-deep (ffi-type initval &rest keywords &key count read-only)
  (declare (ignore count read-only)) ; to be accessed via keywords
  `(foreign-allocate (parse-c-type ,ffi-type)
                     :initial-contents ,initval
                     ,@keywords))

(defmacro allocate-shallow (ffi-type &rest keywords &key count read-only)
  (declare (ignore count read-only)) ; to be accessed via keywords
  `(foreign-allocate (parse-c-type ,ffi-type) ,@keywords))

;; =========================== low-level interface ===========================

(sys::def-setf-alias memory-as write-memory-as) ; ABI

;; ============================ named C functions ============================

(defmacro DEF-C-CALL-OUT (name &rest options)
  (warn (TEXT "~S is deprecated, use ~S instead")
        'def-c-call-out 'def-call-out)
  `(DEF-CALL-OUT ,name ,@options (:LANGUAGE :STDC)))

(defmacro DEF-CALL-OUT (&whole whole-form name &rest options)
  (setq name (check-symbol name (first whole-form)))
  (let* ((alist
          (parse-options options '(:name :arguments :return-type :language :guard
                                   :built-in :library :version :documentation)
                         whole-form))
         (def (gensym "DEF-CALL-OUT-"))
         (properties (and (>= 1 (system::declared-optimize
                                 'space (and (boundp 'system::*denv*)
                                             system::*denv*)))
                          (assoc ':documentation alist)))
         (library (get-assoc :library alist '*foreign-library*))
         (version (second (assoc :version alist)))
         (c-name (foreign-name name (assoc :name alist)))
         (built-in (second (assoc :built-in alist)))
         (guard (get-assoc :guard alist '*foreign-guard*))
         ;; Maximize sharing in .fas file, reuse options
         ;; parse-c-function ignores unknown options, e.g. :name
         (ctype `(PARSE-C-FUNCTION ',options ',whole-form)))
    `(LET ((,def (FIND-FOREIGN-FUNCTION
                  ',c-name ,ctype ',properties ,library ,version NIL)))
       (EXT:COMPILER-LET ((,def ,ctype))
         (EVAL-WHEN (COMPILE)
           (UNLESS ,LIBRARY (NOTE-C-FUN ',c-name ,def ',built-in ,guard)))
         (SYSTEM::EVAL-WHEN-COMPILE
           (SYSTEM::C-DEFUN ',name (C-TYPE-TO-SIGNATURE ,ctype))))
       (WHEN ,def                       ; found library function
         (SYSTEM::REMOVE-OLD-DEFINITIONS ',name)
         (SYSTEM::%SET-SYMBOL-FUNCTION ',name ,def))
       ',name)))

(defun note-c-fun (c-name ctype built-in guard) ; not ABI, compile-time only
  (when (system::prepare-coutput-file)
    (prepare-module)
    (push (list c-name ctype built-in guard)
          *function-list*)))

(defun count-inarguments (arg-vector)
  (do* ((l (length arg-vector))
        (inargcount 0)
        (i 1 (+ i 2)))
       ((>= i l)
        inargcount)
    (unless (flag-set-p ff-flag-out (svref arg-vector i))
      (incf inargcount))))

(defun c-type-to-signature (ctype) ; not ABI, compile-time only
  (sys::make-signature :req-num (count-inarguments (svref ctype 2))))

; Called by SYS::FUNCTION-SIGNATURE.
(defun foreign-function-in-arg-count (obj)
  (count-inarguments (sys::%record-ref obj 4))) ; ff_argtypes

(defmacro DEF-C-CALL-IN (name &rest options)
  (warn (TEXT "~S is deprecated, use ~S instead")
        'def-c-call-in 'def-call-in)
  `(DEF-CALL-IN ,name ,@options (:LANGUAGE :STDC)))

(defmacro DEF-CALL-IN (&whole whole-form name &rest options)
  (setq name (check-symbol name (first whole-form)))
  (let* ((alist (parse-options options
                               '(:name :arguments :return-type :language)
                               whole-form))
         (c-name (foreign-name name (assoc ':name alist))))
    (setq alist (remove (assoc ':name alist) alist))
    `(PROGN
       (EVAL-WHEN (COMPILE)
         (NOTE-C-CALL-IN ',name ',c-name ',alist ',whole-form))
       ',name)))

;; convert-from-foreign & convert-to-foreign inline
;; foreign.d:convert_from_foreign and foreign.d:convert_to_foreign
;; for callbacks into lisp.
;; we inline only a few most common cases - those used in the supplied modules.
(defun convert-from-foreign (argtype argname)
  ;; keep in sync with foreign.d:convert_from_foreign
  (case argtype
    (nil "NIL")
    (boolean (format nil "~A ? T : NIL" argname))
    ;; (character ...) too hairy
    ((char sint8) (format nil "sint8_to_I(~A)" argname))
    ((uchar uint8) (format nil "uint8_to_I(~A)" argname))
    (sint16 (format nil "sint16_to_I(~A)" argname))
    (uint16 (format nil "uint16_to_I(~A)" argname))
    (sint32 (format nil "sint32_to_I(~A)" argname))
    (uint32 (format nil "uint32_to_I(~A)" argname))
    (sint64 (format nil "sint64_to_I(~A)" argname))
    (uint64 (format nil "uint64_to_I(~A)" argname))
    (int (format nil "sint_to_I(~A)" argname))
    (uint (format nil "uint_to_I(~A)" argname))
    (long (format nil "slong_to_I(~A)" argname))
    (ulong (format nil "ulong_to_I(~A)" argname))
    (single-float (format nil "c_float_to_FF((const ffloatjanus*)&~A)" argname))
    (double-float (format nil "c_double_to_DF((const dfloatjanus*)&~A)" argname))
    (c-pointer
     (let ((addr (format nil "(uintP)(*(void* const *) ~A)" argname)))
       (format nil "~A == 0 ? NIL : make_faddress(GLO(fp_zero),~A)"
               addr addr)))
    (c-string (format nil "~A == NULL ? NIL : asciz_to_string(~A,GLO(foreign_encoding))" argname argname))
    (t (format nil "convert_from_foreign(~A,&~A)"
               (object-to-c-value (pass-object argtype)) argname))))

(defun convert-to-foreign (rettype lispobj retaddr flags)
  ;; keep in sync with foreign.d:convert_to_foreign
  (case rettype
    (int (format nil "if (sint_p(~A)) *~A=I_to_sint(~A); else error_sint(~A)"
                 lispobj retaddr lispobj lispobj))
    (uint (format nil "if (uint_p(~A)) *~A=I_to_uint(~A); else error_uint(~A)"
                  lispobj retaddr lispobj lispobj))
    (long
     (format nil "if (slong_p(~A)) *~A=I_to_slong(~A); else error_slong(~A)"
             lispobj retaddr lispobj lispobj))
    (ulong
     (format nil "if (ulong_p(~A)) *~A=I_to_ulong(~A); else error_ulong(~A)"
             lispobj retaddr lispobj lispobj))
    (single-float
     (format nil "if (!single_float_p(~A)) ~A=coerce_float(~A,S(single_float)); FF_to_c_float(~A,(ffloatjanus*)~A)"
             lispobj lispobj lispobj lispobj retaddr))
    (double-float
     (format nil "if (!double_float_p(~A)) ~A=coerce_float(~A,S(double_float)); FF_to_c_float(~A,(ffloatjanus*)~A)"
             lispobj lispobj lispobj lispobj retaddr))
    (t (format nil "convert_to_foreign(~A,~A,~A,&~A)"
               (object-to-c-value (pass-object rettype)) lispobj retaddr
               (if (flag-set-p flags ff-flag-malloc-free)
                   "mallocing" "nomalloc")))))

(defun note-c-call-in (name c-name alist whole) ; ABI
  (when (system::prepare-coutput-file)
    (prepare-module)
    (let* ((fvd (parse-c-function alist whole))
           (rettype (svref fvd 1))
           (args (svref fvd 2))
           (flags (svref fvd 3))
           (argtypes (split-c-fun-arglist args 0))
           (argflags (split-c-fun-arglist args 1))
           (argnames (mapcar #'(lambda (argtype) (declare (ignore argtype))
                                 (symbol-name (gensym "g")))
                             argtypes))
           (par-list (mapcar #'to-c-typedecl argtypes argnames))
           (par-string (format nil "(~{~A~^, ~})" (or par-list '("void"))))
           (fun+type (to-c-typedecl rettype (format nil "(~A)" c-name))))
      (prepare-c-typedecl rettype)
      ;(mapc #'prepare-c-typedecl argtypes)
      ;; prototype + start
      (format *coutput-stream* "~%~A ~A;~%~A " fun+type par-string fun+type)
      (if (flag-set-p flags ff-language-ansi-c)
        ;; ANSI C parameter declarations
        (format *coutput-stream* "~A" par-string)
        ;; K&R C parameter declarations
        (progn
          (format *coutput-stream* "(")
          (do ((argnamesr argnames (cdr argnamesr)))
              ((null argnamesr))
            (format *coutput-stream* "~A" (car argnamesr))
            (when (cdr argnamesr) (format *coutput-stream* ", ")))
          (format *coutput-stream* ")")
          (dolist (par par-list)
            (format *coutput-stream* "~%  ~A;" par))))
      (format *coutput-stream* "~%{~%  begin_callback();~%")
      (let ((inargcount 0) (outargcount (if (eq rettype 'NIL) 0 1))
            (flag-output (logior ff-flag-out ff-flag-in-out)))
        (mapc #'(lambda (argtype argflag argname)
                  (unless (flag-set-p argflag ff-flag-out)
                    (format *coutput-stream* "  pushSTACK(~A);~%"
                            (convert-from-foreign argtype argname))
                    (incf inargcount))
                  (when (flag-set-p argflag flag-output)
                    (incf outargcount)))
              argtypes argflags argnames)
        (format *coutput-stream* "  funcall(~A,~D);~%"
                (object-to-c-value (pass-object name)) inargcount)
        (unless (eq rettype 'NIL)
          (format *coutput-stream* " {~%  ~A;~%  ~A;~%"
                  (to-c-typedecl rettype "retval")
                  (convert-to-foreign rettype "value1" "&retval" flags)))
        (let ((outargcount (if (eq rettype 'NIL) 0 1)))
          (mapc #'(lambda (argtype argflag argname)
                    (when (flag-set-p argflag flag-output)
                      (unless (eq (ctype-type argtype) 'C-PTR)
                        (error (TEXT "~S: :OUT argument is not a pointer: ~S")
                               'DEF-CALL-IN argtype))
                      (format *coutput-stream* "  ~A~A;~%"
                              (if (eql outargcount 0) ""
                                (format nil "if (mv_count >= ~D) "
                                        (+ outargcount 1)))
                              (convert-to-foreign
                               (svref argtype 1)
                               (if (eql outargcount 0) "value1"
                                   (format nil "mv_space[~D]" outargcount))
                               argname argflag))
                      (incf outargcount)))
                argtypes argflags argnames))
        (format *coutput-stream* "  end_callback();~%")
        (unless (eq rettype 'NIL)
          (format *coutput-stream* "  return retval;~% }~%")))
      (format *coutput-stream* "}~%"))))

;; ===========================================================================

(defun form-1+ (form name)
  "if form is a number, return a number, otherwise return `(1+ ,form)"
  (typecase form
    (number (1+ form))
    (symbol `(1+ ,form))
    (cons (case (first form)
            (1+ `(+ 2 ,@(rest form)))
            (+ (if (numberp (second form))
                   `(+ ,(1+ (second form)) ,@(cddr form))
                   `(+ 1 ,@(rest form))))
            (t `(1+ ,form))))
    (t (error "~S(~S): invalid value ~S" 'def-c-enum name form))))

(defmacro def-c-enum (&whole whole-form name &rest items)
  (setq name (check-symbol name (first whole-form)))
  (let ((forms '()) (next-value 0) (this-val 0)
        (ht (make-hash-table :test 'equal :key-type 'fixnum
                             :value-type 'symbol)))
    (dolist (item items)
      (when (consp item)
        (when (rest item)
          (let ((value (second item)))
            (when (constantp value)
              (setq value (eval value)))
            (setq next-value value
                  this-val value)))
        (setq item (first item)))
      (push `(DEFCONSTANT ,item ,next-value) forms)
      (when (gethash this-val ht)
        (warn (TEXT "~S (~S): value ~S will be assigned to both ~S and ~S")
              'def-c-enum name this-val (gethash this-val ht) item))
      (setf (gethash this-val ht) item)
      (setq next-value `(1+ ,item) this-val (form-1+ this-val name)))
    `(PROGN ,@(nreverse forms) (setf (get ',name 'def-c-enum) ,ht)
            (def-c-type ,name int))))

(defun enum-table (enum)
  (or (get enum 'def-c-enum)
      (error (TEXT "~S does not name a C enum type") enum)))
(defun enum-to-value (enum symbol)
  (let ((val (dohash (k v (enum-table enum)
                      (error (TEXT "~S is not of C enum type ~S") symbol enum))
               (when (eq v symbol) (return k)))))
    (unless (= val (symbol-value symbol))
      (error
       (TEXT "~S symbol value (~S) does not match its table value (~S) in ~S")
       symbol (symbol-value symbol) val enum))
    val))
(defun enum-from-value (enum value)
  (or (gethash value (enum-table enum))
      (error (TEXT "~S is not a valid value of type ~S") value enum)))

(defmacro def-c-struct (name+options &rest slots)
  (with-name/options (name options name+options)
    `(PROGN
       (DEFSTRUCT ,name ,@(mapcar #'first slots))
       (DEF-C-TYPE ,name (C-STRUCT ,name+options ,@slots)))))

;; In order for ELEMENT, DEREF, SLOT to be SETFable, I make them macros.
;; (element (foreign-value x) ...) --> (foreign-value (%element x ...))
;; (deref (foreign-value x))       --> (foreign-value (%deref x))
;; (slot (foreign-value x) ...)    --> (foreign-value (%slot x ...))
;; (cast (foreign-value x) ...)    --> (foreign-value (%cast x ...))
;; (offset (foreign-value x) ...)  --> (foreign-value (%offset x ...))
(flet ((err (whole-form reconsed-form)
         (sys::error-of-type 'ext:source-program-error
           :form whole-form
           :detail reconsed-form
           (TEXT "~S is only allowed after ~S: ~S")
           (first whole-form) 'FOREIGN-VALUE whole-form))
       (foreign-place-p (place type)
         (and (consp place) (eq (first place) type) (eql (length place) 2))))

  (defmacro element (&whole whole-form
                     place &rest indices &environment env)
    (setq place (macroexpand place env))
    (if (foreign-place-p place 'FOREIGN-VALUE)
      `(FOREIGN-VALUE (%ELEMENT ,(second place) ,@indices))
      (err whole-form `(element ,place ,@indices))))

  (defmacro deref (&whole whole-form
                   place &environment env)
    (setq place (macroexpand place env))
    (if (foreign-place-p place 'FOREIGN-VALUE)
      `(FOREIGN-VALUE (%DEREF ,(second place)))
      (err whole-form `(deref ,place))))

  (defmacro slot (&whole whole-form
                  place slotname &environment env)
    (setq place (macroexpand place env))
    (if (foreign-place-p place 'FOREIGN-VALUE)
      `(FOREIGN-VALUE (%SLOT ,(second place) ,slotname))
      (err whole-form `(slot ,place ,slotname))))

  (defmacro cast (&whole whole-form
                  place type &environment env)
    (setq place (macroexpand place env))
    (if (foreign-place-p place 'FOREIGN-VALUE)
      `(FOREIGN-VALUE (%CAST ,(second place) (PARSE-C-TYPE ,type)))
      (err whole-form `(cast ,place ,type))))

  (defmacro offset (&whole whole-form
                    place offset type &environment env)
    (setq place (macroexpand place env))
    (if (foreign-place-p place 'FOREIGN-VALUE)
      `(FOREIGN-VALUE (%OFFSET ,(second place) ,offset (PARSE-C-TYPE ,type)))
      (err whole-form `(offset ,place ,offset ,type))))

  ;; Extract FOREIGN-VARIABLE object underlying the place
  (defmacro c-var-object (&whole whole-form
                          place &environment env)
    (setq place (macroexpand place env))
    (if (foreign-place-p place 'FOREIGN-VALUE)
      (second place)
      (err whole-form `(c-var-object ,place))))

  ;; The equivalent of (FOREIGN-ADDRESS fvar) for c-places:
  ;; (c-var-address (foreign-value x)) --> (foreign-address x)
  (defmacro c-var-address (&whole whole-form
                           place &environment env)
    (setq place (macroexpand place env))
    (if (foreign-place-p place 'FOREIGN-VALUE)
      `(FOREIGN-ADDRESS ,(second place))
      (err whole-form `(c-var-address ,place))))

  ;; Similarly for TYPEOF.
  ;; (typeof (foreign-value x)) --> (deparse-c-type (foreign-type x))
  (defmacro typeof (&whole whole-form
                    place &environment env)
    (setq place (macroexpand place env))
    (if (foreign-place-p place 'FOREIGN-VALUE)
      `(DEPARSE-C-TYPE (FOREIGN-TYPE ,(second place)))
      (err whole-form `(typeof ,place))))

  ;; Similar tricks are being played for SIZEOF, BITSIZEOF.
  ;; They are macros which work on <c-place>s.
  ;; If the argument is not a <c-place>, they behave like
  ;; ordinary functions.
  ;; (sizeof (foreign-value x))  --> (sizeof (typeof (foreign-value x)))
  ;;                             --> (sizeof (deparse-c-type (foreign-type x)))
  ;;                             --> (%sizeof (foreign-type x))
  ;; (sizeof (deparse-c-type y)) --> (%sizeof y)
  ;; (sizeof z)                  --> (%sizeof (parse-c-type z))
  (defmacro sizeof (place &environment env)
    (setq place (macroexpand place env))
    (if (foreign-place-p place 'FOREIGN-VALUE)
      `(%SIZEOF (FOREIGN-TYPE ,(second place)))
      (if (foreign-place-p place 'DEPARSE-C-TYPE)
        `(%SIZEOF ,(second place))
        `(%SIZEOF (PARSE-C-TYPE ,place)))))

  (defmacro bitsizeof (place &environment env)
    (setq place (macroexpand place env))
    (if (foreign-place-p place 'FOREIGN-VALUE)
      `(%BITSIZEOF (FOREIGN-TYPE ,(second place)))
      (if (foreign-place-p place 'DEPARSE-C-TYPE)
        `(%BITSIZEOF ,(second place))
        `(%BITSIZEOF (PARSE-C-TYPE ,place))))))

;; ===========================================================================

;;; for self-test
;;; commented out since CLISP does not need them;
;;; they are defined by the test suite.
;; (def-call-out ffi_identity (:arguments (obj int))
;;   (:return-type int) (:language :stdc))
;; (def-c-var ffi_user_pointer (:type c-pointer))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./foreign1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./screen.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SCREEN is actually conditionally defined in constpack.d,
;; but the condition (in lispbibl.d) is too hairy
;; to duplicate it in makemake.in, so this file is always compiled
;; (even when it is not subsequently loaded by init.lisp),
;; thus we have to use DEFPACKAGE here just in case

(defpackage "SCREEN"
  (:documentation "http://clisp.org/impnotes/screen.html")
  (:use "COMMON-LISP" "EXT")
  (:export ;; exported functions and macros:
   #:make-window #:window-size
   #:window-cursor-position #:set-window-cursor-position
   #:clear-window #:clear-window-to-eot #:clear-window-to-eol
   #:delete-window-line #:insert-window-line
   #:highlight-on #:highlight-off #:window-cursor-on #:window-cursor-off
   #:with-window #:*window*))

(in-package "SCREEN")

(defvar *window*) ; ABI

(defmacro with-window (&body body)
  `(LET ((*WINDOW* (MAKE-WINDOW)))
     (UNWIND-PROTECT (PROGN ,@body) (CLOSE *WINDOW*))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./screen.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./threads.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; multithreading for CLISP

(defpackage "THREADS"
  (:nicknames "MT" "MP")
  (:use "COMMON-LISP" "EXT")
  (:export "THREAD" "MAKE-THREAD" "THREADP" "THREAD-YIELD"
           "THREAD-INTERRUPT" "THREAD-NAME" "THREAD-ACTIVE-P"
           "THREAD-JOIN" "CURRENT-THREAD" "LIST-THREADS"
           "MUTEX" "MUTEXP" "MAKE-MUTEX" "MUTEX-LOCK" "MUTEX-UNLOCK"
           "MUTEX-OWNER" "MUTEX-RECURSIVE-P" "WITH-MUTEX-LOCK" "MUTEX-NAME"
           "EXEMPTION" "EXEMPTIONP" "MAKE-EXEMPTION" "EXEMPTION-SIGNAL"
           "EXEMPTION-WAIT" "EXEMPTION-BROADCAST" "EXEMPTION-NAME"
           "Y-OR-N-P-TIMEOUT" "YES-OR-NO-P-TIMEOUT" "WITH-TIMEOUT"
           "SYMBOL-VALUE-THREAD" "*DEFAULT-SPECIAL-BINDINGS*"
           "WITH-DEFERRED-INTERRUPTS"))

(in-package "MT")

(use-package '("MT") "EXT")
(re-export "MT" "EXT")

;; definitions

;; default value (lisp stack) size is very small -  1MB
;; 0 - leaves the OS to decide (basically bad option)
(defvar *DEFAULT-CONTROL-STACK-SIZE* 1048576 "C stack in bytes")
;; the vstack size will be inherited from the parent thread.
;; this is the number of gcv_object_t on the stack
;; 0 - means - inherit from creation thread.
;; the value will be initialized from the runtime
(defvar *DEFAULT-VALUE-STACK-SIZE*)

;; deferred interrupts.
;; in other implementations it is called without-interrupts
(defvar *defer-interrupts* nil)
(defvar *deferred-interrupts* '()) ; list of pending interrupts

;; TODO: add more variables (something should be done about the
;; standard input/output streams).
(defvar *DEFAULT-SPECIAL-BINDINGS*
  `((sys::*active-restarts*
     . '(,(sys::make-restart
           :name 'abort
           :invoke-function
           (lambda ()
             (thread-interrupt
              (current-thread)
              :function t
              :arguments (list :abort
                               (get-internal-real-time)))))))
    (*random-state* . *random-state*)
    (ext::*command-index* . ext::*command-index*)
    (*print-base* . *print-base*)
    (*print-length* . *print-length*)
    (*print-level* . *print-level*)
    (*print-circle* . *print-circle*)
    (*print-radix* . *print-radix*)
    (*print-case* . *print-case*)
    (*print-gensym* . *print-gensym*)
    (*print-pretty* . *print-pretty*)
    (*print-readably* . *print-readably*)
    (*read-suppress* . *read-suppress*)
    (*read-default-float-format* . *read-default-float-format*)
    (*readtable* . (copy-readtable))))

(defmacro with-deferred-interrupts (&body body)
  (let ((intr (gensym "WDI-")))
    `(unwind-protect
          (let ((*defer-interrupts* t)) ,@body)
       (unless *defer-interrupts*
         (loop while *deferred-interrupts* do
              (let ((,intr (pop *deferred-interrupts*)))
                (apply (car ,intr) (nreverse (cdr ,intr)))))))))

(defsetf SYMBOL-VALUE-THREAD MT::SET-SYMBOL-VALUE-THREAD)

(defmacro with-timeout ((seconds &body timeout-forms) &body body)
  "Execute BODY; if execution takes more than SECONDS seconds,
terminate and evaluate TIMEOUT-FORMS."
  `(call-with-timeout ,seconds (lambda () ,@timeout-forms) (lambda () ,@body)))

(defun timeout-message (default localinfo)
  (write-string (SYS::TEXT "[Timed out] "))
  (write-string (string (car (funcall (if default #'cdr #'car) localinfo))))
  (terpri)
  default)

(defun y-or-n-p-timeout (seconds default &rest args)
  "Y-OR-N-P with timeout."
  (declare (ignorable seconds default))
  (with-timeout (seconds (timeout-message default (localized 'sys::y-or-n)))
    (apply #'y-or-n-p args)))

(defun yes-or-no-p-timeout (seconds default &rest args)
  "YES-OR-NO-P with timeout."
  (declare (ignorable seconds default))
  (with-timeout (seconds (timeout-message default (localized 'sys::yes-or-no)))
    (apply #'yes-or-no-p args)))

;;; locks

(defmacro with-mutex-lock ((mutex) &body body)
  "Execute BODY with MUTEX locked. "
  (let ((lk (gensym "WL-"))
        (cthr (gensym "THR-"))
        (prev-owner (gensym "PO-"))
        (owner (gensym "CO-"))
        (prev-rec-count (gensym "PRC-"))
        (rec-count (gensym "CRC-")))
    `(let ((,lk ,mutex)
           (,cthr (current-thread)))
       (multiple-value-bind (,prev-owner ,prev-rec-count)
           (mutex-owner ,lk)
         (unwind-protect (progn (mutex-lock ,lk) ,@body)
           (with-deferred-interrupts ;; defer interrupts while cleanup
             (multiple-value-bind (,owner ,rec-count)
                 (mutex-owner ,lk)
               ;; release the mutex only if has been acquired.
               ;; thread-interrupt with non-local exit may bring us here
               ;; before we got the mutex
               (when (and (eq ,cthr ,owner)
                          (or (not (eq ,cthr ,prev-owner))
                              (> ,rec-count ,prev-rec-count)))
                 (mutex-unlock ,lk)))))))))


;; helper function for thread interruption
(defun %throw-tag (tag &optional result)
  (throw tag result))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./threads.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./deprecated.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; deprecated CLISP functionality
;;; present for now, will be removed later
;;; (except for CLHS and CLtL2 names which will be kept forever because
;;; of the old unmaintained packages we want to keep working).
;;;
;;; Sam Steingold 2001, 2007, 2009, 2017

;; the standard way to deprecate a function is to define a
;; compiler-macro for it which will issue a warning

(in-package "SYSTEM")

(defun deprecate (symbol superseded &optional (def (fdefinition superseded)))
  (export symbol (symbol-package symbol))
  (sys::%set-symbol-function symbol def)
  (push (list symbol "Use ~S instead." superseded)
        system::*deprecated-functions-alist*)
  symbol)

;; ------------------------------------------------
;; http://www.lisp.org/HyperSpec/Issues/iss321.html
;; `special-form-p' -- renamed to `special-operator-p'

(deprecate 'ext::special-form-p 'special-operator-p)

;; ------------------------------------------------
;; http://www.lisp.org/HyperSpec/Issues/iss308.html
;; `get-setf-method-multiple-value' -- renamed to `get-setf-expansion'
;; `define-setf-method' -- renamed to `define-setf-expander'

(deprecate 'ext::get-setf-method-multiple-value 'get-setf-expansion)
(deprecate 'ext::define-setf-method 'define-setf-expander)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./deprecated.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;








;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./reploop.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Debugger, Stepper, Errors

(in-package "EXT")
(export
 '(custom::*prompt-start* custom::*prompt-step* custom::*prompt-break*
   custom::*prompt-body* custom::*prompt-finish* custom::*user-commands*)
 "CUSTOM")
(ext:re-export "CUSTOM" "EXT")
(export
 '(*command-index* prompt-new-package
   break-level step-level)
 "EXT")
(in-package "SYSTEM")

;;;--------------------------------------------------------------------------
;;;                                 Debugger

;; Number of active break-loops (Fixnum >=0)
(defvar *break-count* 0)

;; Defines how many frames will be displayed.
;; Initially nil, this means all frames will be printed.
(defvar *debug-print-frame-limit* nil)


;; Counter to avoid infinite recursion due to *error-output*
(defvar *recurse-count-error-output* 0)

;; Counter to avoid infinite recursion due to *debug-io*
(defvar *recurse-count-debug-io* 0)

; The number of commands received so far.
(defvar *command-index* 0)

;; The starting package of this session (used here and in SAVEINITMEM)
(defvar *home-package* nil)

;; Returns the current package or NIL if it never changed.
(defun prompt-new-package ()
  (unless *home-package* (setq *home-package* *package*))
  (unless (eq *home-package* *package*) *package*))

(defmacro prompt-to-string (variable)
  `(typecase ,variable
     (string ,variable)
     (function
      (multiple-value-bind (value error) (ignore-errors (funcall ,variable))
        (if error
            (string-concat ,(symbol-name variable) "->"
                           (symbol-name (type-of error)))
            (if (stringp value) value
                (princ-to-string value)))))
     (t (princ-to-string ,variable))))

;; Prompt - first part:
(defvar *prompt-start* ""
  "The initial part of the prompt, defaults to an empty string.")
(defun prompt-start () (prompt-to-string *prompt-start*))

(defun break-level () *break-count*)
(defvar *prompt-break*
  (lambda () (string-concat "Break " (princ-to-string (break-level)) " "))
  "The break level part of the prompt, may use `EXT:BREAK-LEVEL'.")
(defun prompt-break () (prompt-to-string *prompt-break*))

(defvar *prompt-body*
  (lambda ()
    ;; prompt with *package* when it is different from the initial one
    ;; or when it doesn't contain standard LISP symbols, like T.
    (if (and (packagep *package*) (package-name *package*))
        (format nil "~@[~a~][~:d]"
                (if (or (not (find-symbol "T" *package*))
                        (prompt-new-package))
                    ;; use symbol so that ~A will respect *PRINT-CASE*
                    (make-symbol (package-shortest-name *package*)))
                (incf *command-index*))
        (TEXT "[*package* invalid]")))
  "The main top level prompt.")
(defun prompt-body () (prompt-to-string *prompt-body*))

;; Prompt: last part
(defvar *prompt-finish* "> "
  "The final part of the prompt")
(defun prompt-finish () (prompt-to-string *prompt-finish*))

;; https://sourceforge.net/p/clisp/bugs/438/ infinite recursive error reporting
(defun safe-wr-st (string &optional (stream *standard-output*))
  (handler-case (write-string string stream)
    (system::charset-type-error ()
      (format stream "Unprintable message: change ~S or ~S" '*current-language*
              '*terminal-encoding*))))

;; Help-function:
(defvar *key-bindings* nil)     ; list of key-bindings and help strings
(defun help ()
  (dolist (s *key-bindings*)
    (when (stringp s)
      (safe-wr-st s #|*debug-io*|#))))

(defun show-local-symbols (argline)
  (setq argline (trim-if #'whitespacep argline))
  (let ((l '())
        (package (if (equal argline "") *package*
                     (or (find-package argline)
                         argline)))) ; for error reporting
    (do-symbols (s package)
      (when (eq package (symbol-package s))
        (push s l)))
    (princ l)
    (throw 'debug 'continue)))

(defvar *saved-debug-package* *common-lisp-user-package*)
(defvar *saved-debug-readtable* (copy-readtable nil))
(defun debug-reset-io (a)
  (declare (ignore a))
  (rotatef *package* *saved-debug-package*)
  (rotatef *readtable* *saved-debug-readtable*)
  (fresh-line *debug-io*)
  (format *debug-io* (TEXT "Reset *PACKAGE* to ~s") *package*)
  (throw 'debug 'continue))

;; Components of the Break-Loop:
(defvar *debug-frame*)
(defvar *stack-mode* 4)
; lower bound for frame-down
(defvar *frame-limit-down* nil)
; upper bound for frame-up
(defvar *frame-limit-up* nil)

(defun frame-limit-down (frames-to-skip)
  (let ((frame (the-frame)))
    (let ((*frame-limit-down* nil)
          (*frame-limit-up* nil))
      (dotimes (i frames-to-skip) (setq frame (frame-up 1 frame 1))))
    frame))

(defun frame-limit-up ()
  (let ((frame (the-frame)))
    (let ((*frame-limit-down* nil)
          (*frame-limit-up* nil))
      (loop
       (let ((nextframe (frame-up 1 frame 1)))
         (when (or (eq nextframe frame) (driver-frame-p nextframe)) (return))
         (setq frame nextframe)))
      (dotimes (i 2) (setq frame (frame-down 1 frame 1))))
    frame))

(defun debug-help (a) (declare (ignore a))  (help) (throw 'debug 'continue))
(defun debug-unwind (a) (declare (ignore a)) (throw 'debug 'unwind))
(defun debug-quit (a) (declare (ignore a)) (throw 'debug 'abort-to-top))
(defun stack-mode (argline &key (start 0) (end (length argline)))
  (multiple-value-bind (mode pos)
      (read-from-string argline nil *stack-mode* :start start :end end)
    (check-type mode (integer 1 5))
    (values mode pos)))
(defun debug-mode (argline)
  (setq *stack-mode* (stack-mode argline)) (throw 'debug 'continue))

(defun debug-where (a)
  (declare (ignore a))
  (describe-frame *standard-output* *debug-frame*)
  (throw 'debug 'continue))

(defun debug-up (a)
  (declare (ignore a))
  (describe-frame *standard-output*
                  (setq *debug-frame* (frame-up 1 *debug-frame* *stack-mode*)))
  (throw 'debug 'continue))

(defun debug-top (a)
  (declare (ignore a))
  (describe-frame *standard-output*
                  (setq *debug-frame* (frame-up t *debug-frame* *stack-mode*)))
  (throw 'debug 'continue))

(defun debug-down (a)
  (declare (ignore a))
  (describe-frame *standard-output*
                  (setq *debug-frame* (frame-down 1 *debug-frame*
                                                  *stack-mode*)))
  (throw 'debug 'continue))

(defun debug-bottom (a)
  (declare (ignore a))
  (describe-frame *standard-output*
                  (setq *debug-frame* (frame-down t *debug-frame*
                                                  *stack-mode*)))
  (throw 'debug 'continue))

(defun frame-limit (argline &key (start 0) (end (length argline)))
  (multiple-value-bind (limit pos)
      (read-from-string argline nil *debug-print-frame-limit*
                        :start start :end end)
    (check-type limit (or null (eql :all) integer))
    (values (if (eq limit :all) nil limit)
            pos)))

;;; sets the limit for frames to print in a backtrace
(defun debug-frame-limit (argline)
  (setq *debug-print-frame-limit* (frame-limit argline))
  (throw 'debug 'continue))

(defun frame-up-down (limit mode) (frame-down 1 (frame-up 1 limit mode) mode))

(defun print-backtrace (&key ((:out *standard-output*) *standard-output*)
                        (mode *stack-mode*) (limit *debug-print-frame-limit*))
  ;; SHOW-STACK prints its output to *STANDARD-OUTPUT*, so we bind that
  (let ((frame-count
         (show-stack
          mode limit
          (frame-up-down (or *frame-limit-down* (frame-limit-down 13)) mode))))
    (fresh-line *standard-output*)
    (format *standard-output* (TEXT "Printed ~D frame~:P") frame-count)
    (elastic-newline *standard-output*)))

;;; debug-backtrace with-optional 'print-limit'
(defun debug-backtrace (argline)
  (multiple-value-bind (mode pos) (stack-mode argline)
    (print-backtrace :out *debug-io* :mode mode
                     :limit (frame-limit argline :start pos)))
  (throw 'debug 'continue))

(defun debug-trap-on (a)
  (declare (ignore a))
  (trap-eval-frame *debug-frame* t)
  (throw 'debug 'continue))

(defun debug-trap-off (a)
  (declare (ignore a))
  (trap-eval-frame *debug-frame* nil)
  (throw 'debug 'continue))

(defun debug-redo (a)
  (declare (ignore a))
  (redo-eval-frame *debug-frame*)
  (throw 'debug 'continue))

(defun debug-return (argline)
  (return-from-eval-frame *debug-frame* (read-from-string argline))
  (throw 'debug 'continue))
(defun debug-continue (a) (declare (ignore a)) (throw 'debug 'quit))

;;; New command to print the error message again
(defun debug-print-error (a)
  (declare (ignore a))
  ;; condition is local to break-loop so have to go back there
  (throw 'debug 'print-error))
(defun debug-inspect-error (a)
  (declare (ignore a))
  (throw 'debug 'inspect-error))

;;; print it
(defun print-error (condition)
  (fresh-line *debug-io*)
  (safe-wr-st (TEXT "The last error:") *debug-io*)
  (pretty-print-condition condition *debug-io* :text-indent 3)
  (elastic-newline *debug-io*))

(defvar *user-commands* nil
  "The list of functions, each of which should return a list of bindings.
A `binding' is either a doc string (printed by `Help' or `:h')
or a pair (STRING . FUNCTION) so that typing STRING will call FUNCTION.")

(defun wrap-user-commands (functions)
  "wrap user commands in THROWs"
  (mapcar (lambda (binding)
            (etypecase binding
              (string binding)
              (cons (cons (car binding)
                          (lambda (argline)
                            (funcall (cdr binding) argline)
                            (throw 'debug 'continue))))))
          (mapcap #'funcall functions)))

;; extended commands
(defun commands0 ()
  (list*
   (TEXT "You are in the top-level Read-Eval-Print loop.
Help (abbreviated :h) = this list
Use the usual editing capabilities.
\(quit) or (exit) leaves CLISP.")

   (cons "Help"         #'debug-help)
   (cons ":h"           #'debug-help)
   (cons "?"            #'debug-help)
   (cons "LocalSymbols" #'show-local-symbols)
   (cons ":ls"          #'show-local-symbols)
   (wrap-user-commands *user-commands*)))

(defun commands1 ()
  (list
   (TEXT "
Commands may be abbreviated as shown in the second column.
COMMAND        ABBR     DESCRIPTION
Help           :h, ?    print this command list
Error          :e       print the last error message
Inspect        :i       inspect the last error
Abort          :a       abort to the next recent input loop
Unwind         :uw      abort to the next recent input loop
Reset          :re      toggle *PACKAGE* and *READTABLE* between the
                          local bindings and the sane values
Quit           :q       quit to the top-level input loop
Where          :w       inspect this frame
Up             :u       go up one frame, inspect it
Top            :t       go to top frame, inspect it
Down           :d       go down one frame, inspect it
Bottom         :b       go to bottom (most recent) frame, inspect it
Mode mode      :m       set stack mode for Backtrace: 1=all the stack elements
             2=all the frames                         3=only lexical frames
             4=only EVAL and APPLY frames (default)   5=only APPLY frames
Frame-limit n  :fl      set the frame-limit for Backtrace. This many frames
                          will be printed in a backtrace at most.
Backtrace [mode [limit]] :bt  inspect the stack
Break+         :br+     set breakpoint in EVAL frame
Break-         :br-     disable breakpoint in EVAL frame
Redo           :rd      re-evaluate form in EVAL frame
Return value   :rt      leave EVAL frame, prescribing the return values")
   (cons "Help"         #'debug-help  )
   (cons ":h"           #'debug-help  )
   (cons "?"            #'debug-help  )
   (cons "LocalSymbols" #'show-local-symbols)
   (cons ":ls"          #'show-local-symbols)
   (cons "Error"        #'debug-print-error)
   (cons ":e"           #'debug-print-error)
   (cons "Inspect"      #'debug-inspect-error)
   (cons ":i"           #'debug-inspect-error)
   (cons "Abort"        #'debug-unwind)
   (cons ":a"           #'debug-unwind)
   (cons "Unwind"       #'debug-unwind)
   (cons ":uw"          #'debug-unwind)
   (cons "Reset"        #'debug-reset-io)
   (cons ":re"          #'debug-reset-io)
   (cons "Quit"         #'debug-quit)
   (cons ":q"           #'debug-quit)
   (cons "Where"        #'debug-where )
   (cons ":w"           #'debug-where )
   (cons "Up"           #'debug-up    )
   (cons ":u"           #'debug-up    )
   (cons "Top"          #'debug-top   )
   (cons ":t"           #'debug-top   )
   (cons "Down"         #'debug-down  )
   (cons ":d"           #'debug-down  )
   (cons "Bottom"       #'debug-bottom)
   (cons ":b"           #'debug-bottom)
   (cons "Mode"         #'debug-mode)
   (cons ":m"           #'debug-mode)
   (cons "Frame-limit"  #'debug-frame-limit)
   (cons ":fl"          #'debug-frame-limit)
   (cons "Backtrace"    #'debug-backtrace)
   (cons ":bt"          #'debug-backtrace)))

(defun commands2 ()
  (list
   (cons "Break+"       #'debug-trap-on )
   (cons ":br+"         #'debug-trap-on )
   (cons "Break-"       #'debug-trap-off)
   (cons ":br-"         #'debug-trap-off)
   (cons "Redo"         #'debug-redo  )
   (cons ":rd"          #'debug-redo  )
   (cons "Return"       #'debug-return)
   (cons ":rt"          #'debug-return)))

(defun commands3 ()
  (list
   (TEXT "
Continue       :c       continue evaluation")
   (cons "Continue"     #'debug-continue)
   (cons ":c"           #'debug-continue)))

(defun commands4 ()
  (list
   (TEXT "
Step           :s       step into form: evaluate this form in single step mode
Next           :n       step over form: evaluate this form at once
Over           :o       step over this level: evaluate at once up to the next return
Continue       :c       switch off single step mode, continue evaluation
-- Step-until :su, Next-until :nu, Over-until :ou, Continue-until :cu --
           same as above, specify a condition when to stop")
   (cons "Step"         #'(lambda (a) (declare (ignore a))
                                  (throw 'stepper 'into)))
   (cons ":s"           #'(lambda (a) (declare (ignore a))
                                  (throw 'stepper 'into)))
   (cons "Next"         #'(lambda (a) (declare (ignore a))
                                  (throw 'stepper 'over)))
   (cons ":n"           #'(lambda (a) (declare (ignore a))
                                  (throw 'stepper 'over)))
   (cons "Over"         #'(lambda (a) (declare (ignore a))
                                  (throw 'stepper 'over-this-level)))
   (cons ":o"           #'(lambda (a) (declare (ignore a))
                                  (throw 'stepper 'over-this-level)))
   (cons "Continue"     #'(lambda (a) (declare (ignore a))
                                  (throw 'stepper 'continue)))
   (cons ":c"           #'(lambda (a) (declare (ignore a))
                                  (throw 'stepper 'continue)))
   (cons "Step-until"   #'(lambda (a) (declare (ignore a))
                                  (throw 'stepper (values 'into t))))
   (cons ":su"          #'(lambda (a) (declare (ignore a))
                                  (throw 'stepper (values 'into t))))
   (cons "Next-until"   #'(lambda (a) (declare (ignore a))
                                  (throw 'stepper (values 'over t))))
   (cons ":nu"          #'(lambda (a) (declare (ignore a))
                                  (throw 'stepper (values 'over t))))
   (cons "Over-until"   #'(lambda (a) (declare (ignore a))
                                  (throw 'stepper (values 'over-this-level t))))
   (cons ":ou"          #'(lambda (a) (declare (ignore a))
                                  (throw 'stepper (values 'over-this-level t))))
   (cons "Continue-until" #'(lambda (a) (declare (ignore a))
                                    (throw 'stepper (values 'continue t))))
   (cons ":cu"          #'(lambda (a) (declare (ignore a))
                                  (throw 'stepper (values 'continue t))))))

(defun commands (may-continue commandsr)
  (nconc (commands1)
         (when (eval-frame-p *debug-frame*)
           (commands2))
         (when may-continue
           (commands3))
         commandsr
         (wrap-user-commands *user-commands*)))

;; establish the DEBUG catcher and the ABORT restart
(defmacro with-abort-restart ((&key report) &body body)
  `(catch 'debug
     (with-restarts ((ABORT () :report (lambda (s) (write-string ,report s))
                       (throw 'debug 'continue)))
       ,@body)))

;; Main-Loop with additional help-command
(defun main-loop (&optional (exit t))
  (setq *break-count* 0)
  (driver                 ; build driver-frame; do #'lambda "infinitely"
   #'(lambda ()
       (with-abort-restart (:report (TEXT "Abort main loop"))
         ;; ANSI CL wants an ABORT restart to be available.
         (when (read-eval-print   ; read-eval-print INPUT-line
                (string-concat (prompt-start) (prompt-body) (prompt-finish))
                (commands0))
           ;; T -> #<EOF>
           ;; NIL -> form is already evaluated
           ;;        result has been printed
           (if exit
               ;; if you want to change this logic, you need to make sure that
               ;; 1. "clisp -x (1+ 2) -repl" prints "3" and then the prompt
               ;; 2. "cat script | clisp" and "clisp < script" do not hang
               (exit)
               (progn (setq *command-index* 0) ; reset *command-index*
                      (handler-case (return-from main-loop)
                        (error () (exit 1))))))))))

(setq *driver* #'main-loop)

(defun break-loop (continuable &optional (condition nil) (print-it nil)
                   &aux
                   (may-continue
                    (or continuable
                        (and condition
                             (let ((restart
                                     (find-restart 'CONTINUE condition)))
                               (and restart
                                    ;; Ignore the CONTINUE restart if it is not
                                    ;; useful without prior corrective action,
                                    ;; otherwise it leads to user frustration.
                                    (restart-meaningfulp restart)
                                    restart)))))
                   (interactive-p (interactive-stream-p *debug-io*))
                   (commandsr '()))
  (when (and print-it (typep condition (clos:find-class 'condition)))
    (symbol-stream '*error-output* :output)

    ;; print something on *error-output* but catch infinite recursion.
    (let ((*recurse-count-error-output* (1+ *recurse-count-error-output*)))
      (when (> *recurse-count-error-output* 3)
        (setq *recurse-count-error-output* 0)
        (makunbound '*error-output*)
        (let ((*recurse-count-debug-io* (1+ *recurse-count-debug-io*)))
          (when (> *recurse-count-debug-io* 3)
            (setq *recurse-count-debug-io* 0)
            (makunbound '*debug-io*)
            (symbol-stream '*debug-io* :io))
          (symbol-stream '*error-output* :output)))
      (terpri *error-output*))

    (if may-continue
      (progn
        (write-string "** - " *error-output*)
        (safe-wr-st (TEXT "Continuable Error") *error-output*)
        (terpri *error-output*))
      (write-string "*** - " *error-output*))

    ;; Output the error message, but don't trap into recursive errors.
    (let ((*recursive-error-count* (1+ *recursive-error-count*)))
      (if (> *recursive-error-count* 3)
        (progn
          (setq *recursive-error-count* 0)
          (write-string (TEXT "Unprintable error message")
                        *error-output*))
        (pretty-print-condition condition *error-output*
                                :text-indent (if may-continue 5 6))))

    ;; Now the error message is on the screen; give the user some information
    ;; how to continue from continuable errors.
    (symbol-stream '*debug-io* :io)
    (when may-continue
      (if continuable
        (when interactive-p
          (fresh-line *debug-io*)
          (safe-wr-st (TEXT "You can continue (by typing 'continue').")
                      *debug-io*)
          (elastic-newline *debug-io*))
        (progn
          (fresh-line *debug-io*)
          (when interactive-p
            (safe-wr-st (TEXT "If you continue (by typing 'continue'): ")
                        *debug-io*))
          (princ may-continue *debug-io*)
          (elastic-newline *debug-io*)))))

  (when condition
    (let ((restarts (remove may-continue (compute-restarts condition)))
          (restarts-help (if may-continue
                           (TEXT "The following restarts are also available:")
                           (TEXT "The following restarts are available:"))))
      (when restarts
        (when interactive-p
          (fresh-line *debug-io*)
          (safe-wr-st restarts-help *debug-io*)
          (elastic-newline *debug-io*))
        (let ((counter 0))
          (dolist (restart restarts)
            (let* ((command
                    (string-concat ":R" (sys::decimal-string (incf counter))))
                   (name (string (restart-name restart)))
                   (helpstring (format nil "~A~15T~A~24T~A" name command
                                       (princ-to-string restart)))
                   (restart restart)  ; for FUNC
                   (func #'(lambda (a) (declare (ignore a))
                                   (invoke-restart-interactively restart))))
              ;; display the restarts:
              (when interactive-p
                (fresh-line *debug-io*)
                (safe-wr-st helpstring *debug-io*)
                (elastic-newline *debug-io*))
              (push (string-concat (string #\Newline) helpstring) commandsr)
              ;; put it into the commandsr list.
              (push (cons command func) commandsr)
              (push (cons name func) commandsr)))
          (setq commandsr (cons (string-concat (string #\Newline) restarts-help)
                                (nreverse commandsr)))))))
  (force-output *debug-io*)

  (tagbody
    (makunbound '*terminal-read-stream*)
    (makunbound '*terminal-read-open-object*)
    (clear-input *debug-io*) ; because the user did not expect a break loop
    (let* ((*break-count* (1+ *break-count*))
           (stream (make-synonym-stream '*debug-io*))
           (*standard-input* stream)
           (*standard-output* stream)
           (prompt (string-concat (prompt-start) (prompt-break)
                                  (prompt-body) (prompt-finish)))
           (*frame-limit-down* (frame-limit-down 13))
           (*frame-limit-up* (frame-limit-up))
           (*stack-mode* *stack-mode*)
           (*debug-frame* (frame-up-down *frame-limit-down* *stack-mode*))
           (*saved-debug-package* *saved-debug-package*)
           (*saved-debug-readtable* *saved-debug-readtable*)
           (commands-list (commands may-continue commandsr)))
      (driver
       ;; build driver frame and repeat #'lambda (infinitely; ...)
       #'(lambda ()
           (case (with-abort-restart (:report (TEXT "Abort debug loop"))
                   ;; ANSI CL wants an ABORT restart to be available.
                   ;; build environment *debug-frame*
                   ;; which is valid/equal for/to *debug-frame*
                   (same-env-as *debug-frame*
                     #'(lambda ()
                         (if (read-eval-print prompt commands-list)
                           ;; T -> #<EOF>
                           ;; NIL -> form is already evaluated;
                           ;;        result has been printed
                           (throw 'debug (if may-continue 'quit 'unwind))))))
             ((print-error) (print-error condition))
             ((inspect-error) (inspect condition))
             ((unwind) (go unwind))
             ((abort-to-top) (go abort-to-top))
             ((quit)            ; reached only if may-continue is T
              (if continuable
                (go quit)
                (invoke-restart-interactively may-continue)))
             (t )))))           ; other cases, especially continue
    unwind (unwind-to-driver nil)
    abort-to-top (unwind-to-driver t)
    quit))

(setq *break-driver* #'break-loop)


;;;--------------------------------------------------------------------------
;;;        convenient Stepper. (runs only if compiled!)

(defvar *step-level* 0 "current Step-depth") ; ABI
(defvar *step-quit* most-positive-fixnum "critical Step-depth") ; ABI
;; the stepper wakes up, as soon as *step-level* <= *step-quit*

(defvar *step-watch* nil)               ; terminating condition ; ABI

(defmacro step (form)
  "(STEP form), CLTL p. 441"
  `(let* ((*step-level* 0)
          (*step-quit* most-positive-fixnum)
          (*step-watch* nil)
          (*evalhook* #'step-hook-fn))
    ,form))

(defun step-values (values)
  (let ((*standard-output* *debug-io*))
    (fresh-line #|*debug-io*|#)
    (safe-wr-st (TEXT "step ") #|*debug-io*|#)
    (write *step-level* #|:stream *debug-io*|#)
    (write-string " ==> " #|*debug-io*|#)
    (case (length values)
      (0 (safe-wr-st (TEXT "no values") #|*debug-io*|#))
      (1 (safe-wr-st (TEXT "value: ") #|*debug-io*|#)
         (write (car values) #|:stream *debug-io*|#))
      (t (write (length values) #|:stream *debug-io*|#)
         (safe-wr-st (TEXT " values: ") #|*debug-io*|#)
         (do ((L values))
             ((endp L))
           (write (pop L) #|:stream *debug-io*|#)
           (unless (endp L) (write-string ", " #|*debug-io*|#)))))
    (elastic-newline #|*debug-io*|#))
  (values-list values))

(defun step-level () *step-level*)
(defvar *prompt-step*
  (lambda () (string-concat "Step " (princ-to-string (step-level)) " "))
  "The stepper part of the prompt, may use `EXT:STEP-LEVEL'." )
(defun prompt-step () (prompt-to-string *prompt-step*))

(defun step-hook-fn (form &optional (env *toplevel-environment*))
  (let ((*step-level* (1+ *step-level*)))
    (when (>= *step-level* *step-quit*) ; while *step-level* >= *step-quit*
      (if (and *step-watch* (funcall *step-watch*)) ; and no Breakpoint,
        (setq *step-quit* most-positive-fixnum)
        (return-from step-hook-fn       ; the Stepper remains passive
          (evalhook form nil nil env)))) ; (e.g. it simply evaluates the Form)
    (tagbody
      (let* ((stream (make-synonym-stream '*debug-io*))
             (*standard-input* stream)
             (*standard-output* stream)
             (prompt (string-concat (prompt-start) (prompt-step)
                                    (prompt-body) (prompt-finish)))
             (*frame-limit-down* (frame-limit-down 11))
             (*frame-limit-up* (frame-limit-up))
             (*stack-mode* *stack-mode*)
             (*debug-frame* (frame-up-down *frame-limit-down* *stack-mode*))
             (commands-list (commands nil (commands4))))
        (fresh-line #|*debug-io*|#)
        (safe-wr-st (TEXT "step ") #|*debug-io*|#)
        (write *step-level* #|:stream *debug-io*|#)
        (write-string " --> " #|*debug-io*|#)
        (write form #|:stream *debug-io*|# :length 4 :level 3)
        (loop
          (multiple-value-bind (what watchp)
              (catch 'stepper
                ;; catch the (throw 'stepper ...) and analyse ...
                (driver
                  ;;  build driver frame and repeat #'lambda (infinitely ...)
                  #'(lambda ()
                      ;; catch the (throw 'debug ...) and analyse
                      (case (with-abort-restart (:report (TEXT "Abort stepper"))
                              ;; ANSI CL wants an ABORT restart to be available.
                              (same-env-as *debug-frame*
                                ;; build environment *debug-frame* that
                                ;; is valid/equal for/to *debug-frame*
                                #'(lambda ()
                                    (if (read-eval-print prompt commands-list)
                                      ;; T -> #<EOF>
                                      (go continue)
                                      ;; NIL -> form is already evaluated;
                                      ;;        result has been printed
                                      #|(throw 'debug 'continue)|#
                                      ))))
                        ((unwind) (go unwind))
                        ((abort-to-top) (go abort-to-top))
                        (t ))))) ; other cases, especially continue
            (when watchp
              (let ((form (read-form (TEXT "condition when to stop: "))))
                (setq *step-watch*
                      ;; function which evaluates 'form' in/with *debug-frame*
                      (eval-at *debug-frame* `(function (lambda () ,form))))))
            (case what
              (into (go into))
              (over (go over))
              (over-this-level (go over-this-level))
              (continue (go continue))))))
     unwind (unwind-to-driver nil)
     abort-to-top (unwind-to-driver t)
     into
      (return-from step-hook-fn
        (step-values
         (multiple-value-list (evalhook form #'step-hook-fn nil env))))
     over-this-level
      (setq *step-quit* *step-level*)   ; keep the Stepper sleeping
     over
      (return-from step-hook-fn
        (step-values
         (multiple-value-list (evalhook form nil nil env))))
     continue
      (setq *step-quit* 0)
      (go over))))

;;;--------------------------------------------------------------------------

;; Now that condition.lisp is loaded and *break-driver* has a value:
;; Activate the Condition System.
(setq *use-clcs* t)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./reploop.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./type.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; TYPEP and friends
;;;; Michael Stoll, 21. 10. 1988
;;;; Bruno Haible, 10.6.1989
;;;; Sam Steingold 2000-2010

;;; Datenstrukturen fr TYPEP:
;;; - Ein Type-Specifier-Symbol hat auf seiner Propertyliste unter dem
;;;   Indikator SYS::TYPE-SYMBOL eine Funktion von einem Argument, die
;;;   testet, ob ein Objekt vom richtigen Typ ist.
;;; - Ein Symbol, das eine Type-Specifier-Liste beginnen kann, hat auf seiner
;;;   Propertyliste unter dem Indikator SYS::TYPE-LIST eine Funktion von
;;;   einem Argument fr das zu testende Objekt und zustzlichen Argumenten
;;;   fr die Listenelemente.
;;; - Ein Symbol, das als Typmacro definiert wurde, hat auf seiner Property-
;;;   liste unter dem Indikator SYSTEM::DEFTYPE-EXPANDER den zugehrigen
;;;   Expander: eine Funktion, die den zu expandierenden Type-Specifier (eine
;;;   mindestens einelementige Liste) als Argument bekommt.

(in-package "EXT")
(export '(type-expand))
(in-package "SYSTEM")

; vorlufig, solange bis clos.lisp geladen wird:
(eval-when (eval)
  (predefun clos::built-in-class-p (object) (declare (ignore object)) nil))
(unless (fboundp 'clos::class-name)
  (defun clos::class-name (c) (declare (ignore c)) nil)
)

(defun typespec-error (fun type)
  (error-of-type 'error
    (TEXT "~S: invalid type specification ~S")
    fun type
) )

;; ============================================================================

;; return the CLOS class named by TYPESPEC or NIL
(defun clos-class (typespec)
  (let ((cc (get typespec 'CLOS::CLOSCLASS)))
    (when (and cc (clos::defined-class-p cc) (eq (clos:class-name cc) typespec))
      cc)))

;;; TYPEP, CLTL S. 72, S. 42-51
(defun typep (x y &optional env &aux f) ; x = Objekt, y = Typ
  (declare (ignore env))
  (setq y (expand-deftype y))
  (cond
    ((symbolp y)
       (cond ((setq f (get y 'TYPE-SYMBOL)) (funcall f x))
             ((setq f (get y 'TYPE-LIST)) (funcall f x))
             ((setq f (get y 'DEFSTRUCT-DESCRIPTION)) (ds-typep x y f))
             ((setq f (clos-class y))
              ; It's not worth handling structure classes specially here.
              (clos::typep-class x f))
             (t (typespec-error 'typep y))
    )  )
    ((and (consp y) (symbolp (first y)))
       (cond
         ((and (eq (first y) 'SATISFIES) (eql (length y) 2))
            (unless (symbolp (second y))
              (error-of-type 'error
                (TEXT "~S: argument to SATISFIES must be a symbol: ~S")
                'typep (second y)
            ) )
            (if (funcall (symbol-function (second y)) x) t nil)
         )
         ((eq (first y) 'MEMBER)
            (if (member x (rest y)) t nil)
         )
         ((and (eq (first y) 'EQL) (eql (length y) 2))
            (eql x (second y))
         )
         ((and (eq (first y) 'NOT) (eql (length y) 2))
            (not (typep x (second y)))
         )
         ((eq (first y) 'AND)
            (dolist (type (rest y) t)
              (unless (typep x type) (return nil))
         )  )
         ((eq (first y) 'OR)
            (dolist (type (rest y) nil)
              (when (typep x type) (return t))
         )  )
         ((setq f (get (first y) 'TYPE-LIST)) (apply f x (rest y)))
         (t (typespec-error 'typep y))
    )  )
    ((clos::defined-class-p y) (clos::typep-class x y))
    ((clos::eql-specializer-p y) (eql x (clos::eql-specializer-singleton y)))
    ((encodingp y) (charset-typep x y))
    (t (typespec-error 'typep y))
) )

;; ----------------------------------------------------------------------------

;; UPGRADED-ARRAY-ELEMENT-TYPE is a lattice homomorphism, see
;; ANSI CL 15.1.2.1.
(defun upgraded-array-element-type (type &optional environment)
  (declare (ignore environment))
  ;; see array.d
  (case type
    ((BIT) 'BIT)
    ((CHARACTER) 'CHARACTER)
    ((T) 'T)
    ((NIL) 'NIL)
    (t (if (subtypep type 'NIL)
         'NIL
         (multiple-value-bind (low high) (sys::subtype-integer type)
           ; Es gilt (or (null low) (subtypep type `(INTEGER ,low ,high)))
           (if (and (integerp low) (not (minusp low)) (integerp high))
             (let ((l (integer-length high)))
               ; Es gilt (subtypep type `(UNSIGNED-BYTE ,l))
               (cond ((<= l 1) 'BIT)
                     ((<= l 2) '(UNSIGNED-BYTE 2))
                     ((<= l 4) '(UNSIGNED-BYTE 4))
                     ((<= l 8) '(UNSIGNED-BYTE 8))
                     ((<= l 16) '(UNSIGNED-BYTE 16))
                     ((<= l 32) '(UNSIGNED-BYTE 32))
                     (t 'T)))
             (if (subtypep type 'CHARACTER)
               'CHARACTER
               'T)))))))

;; ----------------------------------------------------------------------------

;; UPGRADED-COMPLEX-PART-TYPE is a lattice homomorphism, see
;; HyperSpec/Body/fun_complex.html and HyperSpec/Body/syscla_complex.html,
;; and an idempotent. Therefore
;;   (subtypep (upgraded-complex-part-type T1) (upgraded-complex-part-type T2))
;; is equivalent to
;;   (subtypep T1 (upgraded-complex-part-type T2))
;; (Proof: Let U T be an abbreviation for (upgraded-complex-part-type T).
;;  If U T1 <= U T2, then T1 <= U T1 <= U T2.
;;  If T1 <= U T2, then by homomorphism U T1 <= U U T2 = U T2.)
;;
;; For _any_ CL implementation, you could define
;;   (defun upgraded-complex-part-type (type) 'REAL)
;; Likewise for _any_ CL implementation, you could define
;;   (defun upgraded-complex-part-type (type) type)
;; or - again for _any_ CL implementation:
;;   (defun upgraded-complex-part-type (type)
;;     (cond ((subtypep type 'NIL) 'NIL)
;;           ((subtypep type 'SHORT-FLOAT) 'SHORT-FLOAT)
;;           ((subtypep type 'SINGLE-FLOAT) 'SINGLE-FLOAT)
;;           ((subtypep type 'DOUBLE-FLOAT) 'DOUBLE-FLOAT)
;;           ((subtypep type 'LONG-FLOAT) 'LONG-FLOAT)
;;           ((subtypep type 'RATIONAL) 'RATIONAL)
;;           ((subtypep type 'REAL) 'REAL)
;;           (t (error ...))))
;; The reason is that a complex number is immutable: no setters for the
;; realpart and imagpart exist.
;;
;; We choose the second implementation because it allows the most precise
;; type inference.
(defun upgraded-complex-part-type (type &optional environment)
  (declare (ignore environment))
  (if (subtypep type 'REAL)
    type
    (error-of-type 'error
      (TEXT "~S: type ~S is not a subtype of ~S")
      'upgraded-complex-part-type type 'real)))

;; ----------------------------------------------------------------------------

;; Macros for defining the various built-in "atomic type specifier"s and
;; "compound type specifier"s. The following macros add information for both
;; the TYPEP function above and the c-TYPEP in the compiler.

; Alist symbol -> funname, used by the compiler.
(defparameter c-typep-alist1 '())
; Alist symbol -> lambdabody, used by the compiler.
(defparameter c-typep-alist2 '())
; Alist symbol -> expander function, used by the compiler.
(defparameter c-typep-alist3 '())

; (def-atomic-type symbol function-name)
; defines an atomic type. The function-name designates a function taking one
; argument and returning a generalized boolean value. It can be either a
; symbol or a lambda expression.
(defmacro def-atomic-type (symbol funname)
  (let ((lambdap (and (consp funname) (eq (car funname) 'LAMBDA))))
    `(PROGN
       (SETF (GET ',symbol 'TYPE-SYMBOL)
             ,(if lambdap
                `(FUNCTION ,(concat-pnames "TYPE-SYMBOL-" symbol) ,funname)
                `(FUNCTION ,funname)
              )
       )
       ,(if lambdap
          `(SETQ C-TYPEP-ALIST2
                 (NCONC C-TYPEP-ALIST2 (LIST (CONS ',symbol ',(cdr funname))))
           )
          `(SETQ C-TYPEP-ALIST1
                 (NCONC C-TYPEP-ALIST1 (LIST (CONS ',symbol ',funname)))
           )
        )
       ',symbol
     )
) )

; (def-compound-type symbol lambda-list (x) check-form typep-form c-typep-form)
; defines a compound type. The lambda-list is of the form (&optional ...)
; where the arguments come from the CDR of the type specifier.
; For typep-form, x is an object.
; For c-typep-form, x is a multiply evaluatable form (actually a gensym).
; check-form is a form performing error checking, may call `error'.
; typep-form should return a generalized boolean value.
; c-typep-form should produce a form returning a generalized boolean value.
(defmacro def-compound-type (symbol lambdalist (var) check-form typep-form c-typep-form)
  `(PROGN
     (SETF (GET ',symbol 'TYPE-LIST)
           (FUNCTION ,(concat-pnames "TYPE-LIST-" symbol)
             (LAMBDA (,var ,@lambdalist)
               ,@(if check-form
                   `((MACROLET ((ERROR (&REST ERROR-ARGS)
                                  (LIST* 'ERROR-OF-TYPE ''ERROR ERROR-ARGS)
                               ))
                       ,check-form
                    ))
                 )
               ,typep-form
     )     ) )
     (SETQ C-TYPEP-ALIST3
           (NCONC C-TYPEP-ALIST3
                  (LIST (CONS ',symbol
                              #'(LAMBDA (,var ,@lambdalist &REST ILLEGAL-ARGS)
                                  (DECLARE (IGNORE ILLEGAL-ARGS))
                                  ,@(if check-form
                                      `((MACROLET ((ERROR (&REST ERROR-ARGS)
                                                     (LIST 'PROGN
                                                           (LIST* 'C-WARN ERROR-ARGS)
                                                           '(THROW 'C-TYPEP NIL)
                                                  )) )
                                          ,check-form
                                       ))
                                    )
                                  ,c-typep-form
                                )
     )     )      )     )
     ',symbol
   )
)

; CLtL1 p. 43
(def-atomic-type ARRAY arrayp)
(def-atomic-type ATOM atom)
(def-atomic-type BASE-CHAR
  #+BASE-CHAR=CHARACTER
  characterp
  #-BASE-CHAR=CHARACTER
  (lambda (x) (and (characterp x) (base-char-p x)))
)
(def-atomic-type BASE-STRING
  (lambda (x)
    (and (stringp x)
         (eq (array-element-type x)
             #+BASE-CHAR=CHARACTER 'CHARACTER #-BASE-CHAR=CHARACTER 'BASE-CHAR
) ) )    )
(def-atomic-type BIGNUM (lambda (x) (and (integerp x) (not (fixnump x)))))
(def-atomic-type BIT (lambda (x) (or (eql x 0) (eql x 1))))
(def-atomic-type BIT-VECTOR bit-vector-p)
(def-atomic-type BOOLEAN (lambda (x) (or (eq x 'nil) (eq x 't))))
(def-atomic-type BYTE bytep)
(def-atomic-type CHARACTER characterp)
(def-atomic-type COMPILED-FUNCTION compiled-function-p)
(def-atomic-type COMPLEX complexp)
(def-atomic-type CONS consp)
(def-atomic-type DOUBLE-FLOAT double-float-p)
(def-atomic-type ENCODING encodingp)
(def-atomic-type EXTENDED-CHAR
  #+BASE-CHAR=CHARACTER
  (lambda (x) (declare (ignore x)) nil)
  #-BASE-CHAR=CHARACTER
  (lambda (x) (and (characterp x) (not (base-char-p x))))
)
(def-atomic-type FIXNUM fixnump)
(def-atomic-type FLOAT floatp)
(def-atomic-type FUNCTION functionp)
(def-atomic-type HASH-TABLE hash-table-p)
(def-atomic-type INTEGER integerp)
(def-atomic-type KEYWORD keywordp)
(def-atomic-type LIST listp)
#+LOGICAL-PATHNAMES
(def-atomic-type LOGICAL-PATHNAME logical-pathname-p)
(def-atomic-type LONG-FLOAT long-float-p)
(def-atomic-type NIL
  (lambda (x) (declare (ignore x)) nil)
)
(def-atomic-type NULL null)
(def-atomic-type NUMBER numberp)
(def-atomic-type PACKAGE packagep)
(def-atomic-type PATHNAME pathnamep)
(def-atomic-type RANDOM-STATE random-state-p)
(def-atomic-type RATIO
  (lambda (x) (and (rationalp x) (not (integerp x))))
)
(def-atomic-type RATIONAL rationalp)
(def-atomic-type READTABLE readtablep)
(def-atomic-type REAL realp)
(def-atomic-type SEQUENCE sequencep)
(def-atomic-type SHORT-FLOAT short-float-p)
(def-atomic-type SIMPLE-ARRAY simple-array-p)
(def-atomic-type SIMPLE-BASE-STRING
  (lambda (x)
    (and (simple-string-p x)
         (eq (array-element-type x)
             #+BASE-CHAR=CHARACTER 'CHARACTER #-BASE-CHAR=CHARACTER 'BASE-CHAR
) ) )    )
(def-atomic-type SIMPLE-BIT-VECTOR simple-bit-vector-p)
(def-atomic-type SIMPLE-STRING simple-string-p)
(def-atomic-type SIMPLE-VECTOR simple-vector-p)
(def-atomic-type SINGLE-FLOAT single-float-p)
(defun %standard-char-p (x) (and (characterp x) (standard-char-p x))) ; ABI
(def-atomic-type STANDARD-CHAR %standard-char-p)
(def-atomic-type CLOS:STANDARD-OBJECT clos::std-instance-p)
(def-atomic-type STREAM streamp)
(def-atomic-type FILE-STREAM file-stream-p)
(def-atomic-type SYNONYM-STREAM synonym-stream-p)
(def-atomic-type BROADCAST-STREAM broadcast-stream-p)
(def-atomic-type CONCATENATED-STREAM concatenated-stream-p)
(def-atomic-type TWO-WAY-STREAM two-way-stream-p)
(def-atomic-type ECHO-STREAM echo-stream-p)
(def-atomic-type STRING-STREAM string-stream-p)
(def-atomic-type STRING stringp)
(def-atomic-type STRING-CHAR characterp)
(def-atomic-type CLOS:STRUCTURE-OBJECT clos::structure-object-p)
(def-atomic-type SYMBOL symbolp)
(def-atomic-type T (lambda (x) (declare (ignore x)) t))
;; foreign1.lisp is loaded after this file,
;; so these symbols are not external yet
#+ffi
(def-atomic-type ffi::foreign-function
  (lambda (x) (eq 'ffi::foreign-function (type-of x))))
#+ffi
(def-atomic-type ffi::foreign-variable
  (lambda (x) (eq 'ffi::foreign-variable (type-of x))))
#+ffi
(def-atomic-type ffi::foreign-address
  (lambda (x) (eq 'ffi::foreign-address (type-of x))))
;; see lispbibl.d (#define FOREIGN) and predtype.d (TYPE-OF):
#+(or unix ffi win32)
(def-atomic-type foreign-pointer
  (lambda (x) (eq 'foreign-pointer (type-of x))))
;; threads.lisp is loaded after this file,
;; so these symbols are not external yet
#+mt (def-atomic-type threads::thread threads::threadp)
#+mt (def-atomic-type threads::mutex threads::mutexp)
#+mt (def-atomic-type threads::exemption threads::exemptionp)
(def-atomic-type VECTOR vectorp)
(def-atomic-type PLIST
    (lambda (x) (multiple-value-bind (length tail) (list-length-dotted x)
                  (and (null tail) (evenp length)))))

(defmacro ensure-dim (type dim)
  ;; make sure DIM is a valid dimension
  `(unless (or (eq ,dim '*) (typep ,dim `(INTEGER 0 (,ARRAY-DIMENSION-LIMIT))))
     (error (TEXT "~S: dimension ~S is invalid") ',type ,dim)))

(defmacro ensure-rank (type rank)
  ;; make sure RANK is a valid rank
  `(unless (typep ,rank `(INTEGER 0 (,ARRAY-RANK-LIMIT)))
     (error (TEXT "~S: rank ~S is invalid") ',type ,rank)))

; CLtL1 p. 46-50
(defun c-typep-array (tester el-type dims x)
  `(AND (,tester ,x)
        ,@(if (eq el-type '*)
            '()
            `((EQUAL (ARRAY-ELEMENT-TYPE ,x) ',(upgraded-array-element-type el-type)))
          )
        ,@(if (eq dims '*)
            '()
            (if (numberp dims)
              `((EQL ,dims (ARRAY-RANK ,x)))
              `((EQL ,(length dims) (ARRAY-RANK ,x))
                ,@(let ((i 0))
                    (mapcap #'(lambda (dim)
                                (prog1
                                  (if (eq dim '*)
                                    '()
                                    `((EQL ',dim (ARRAY-DIMENSION ,x ,i)))
                                  )
                                  (incf i)
                              ) )
                            dims
                  ) )
               )
          ) )
   )
)
(defun c-typep-vector (tester size x)
  `(AND (,tester ,x)
        ,@(if (eq size '*)
            '()
            `((EQL ',size (ARRAY-DIMENSION ,x 0)))
          )
   )
)
(progn                          ; to reuse error string
(defun typep-number-test (x low high test type)
  (and (funcall test x)
       (cond ((eq low '*))
             ((funcall test low) (<= low x))
             ((and (consp low) (null (rest low)) (funcall test (first low)))
                (< (first low) x)
             )
             (t (error-of-type 'error
                  #1=(TEXT "~S: argument to ~S must be *, ~S or a list of ~S: ~S")
                  'typep type type type low
       )     )  )
       (cond ((eq high '*))
             ((funcall test high) (>= high x))
             ((and (consp high) (null (rest high)) (funcall test (first high)))
                (> (first high) x)
             )
             (t (error-of-type 'error #1# 'typep type type type high)))))
(defun c-typep-number (caller tester low high x)
  `(AND (,tester ,x)
        ,@(cond ((eq low '*) '())
                ((funcall tester low) `((<= ,low ,x)))
                ((and (consp low) (null (rest low)) (funcall tester (first low)))
                 `((< ,(first low) ,x))
                )
                (t (c-warn #1# 'typep caller caller caller low)
                   (throw 'c-TYPEP nil)
          )     )
        ,@(cond ((eq high '*) '())
                ((funcall tester high) `((>= ,high ,x)))
                ((and (consp high) (null (rest high)) (funcall tester (first high)))
                 `((> ,(first high) ,x))
                )
                (t (c-warn #1# 'typep caller caller caller high)
                   (throw 'c-TYPEP nil)
          )     )
   )
))
(def-compound-type ARRAY (&optional (el-type '*) (dims '*)) (x)
  (unless (eq dims '*)
    (if (numberp dims)
      (ensure-rank ARRAY dims)
      (dolist (dim dims) (ensure-dim ARRAY dim))))
  (and (arrayp x)
       (or (eq el-type '*)
           (equal (array-element-type x) (upgraded-array-element-type el-type))
       )
       (or (eq dims '*)
           (if (numberp dims)
             (eql dims (array-rank x))
             (and (eql (length dims) (array-rank x))
                  (every #'(lambda (a b) (or (eq a '*) (eql a b)))
                         dims (array-dimensions x)
  )    )   ) )    )
  (c-typep-array 'ARRAYP el-type dims x)
)
(def-compound-type SIMPLE-ARRAY (&optional (el-type '*) (dims '*)) (x)
  (unless (eq dims '*)
    (if (numberp dims)
      (ensure-rank SIMPLE-ARRAY dims)
      (dolist (dim dims) (ensure-dim SIMPLE-ARRAY dim))))
  (and (simple-array-p x)
       (or (eq el-type '*)
           (equal (array-element-type x) (upgraded-array-element-type el-type))
       )
       (or (eq dims '*)
           (if (numberp dims)
             (eql dims (array-rank x))
             (and (eql (length dims) (array-rank x))
                  (every #'(lambda (a b) (or (eq a '*) (eql a b)))
                         dims (array-dimensions x)
  )    )   ) )    )
  (c-typep-array 'SIMPLE-ARRAY-P el-type dims x)
)
(def-compound-type VECTOR (&optional (el-type '*) (size '*)) (x)
  (ensure-dim VECTOR size)
  (and (vectorp x)
       (or (eq el-type '*)
           (equal (array-element-type x) (upgraded-array-element-type el-type))
       )
       (or (eq size '*) (eql (array-dimension x 0) size))
  )
  `(AND (VECTORP ,x)
        ,@(if (eq el-type '*)
            '()
            `((EQUAL (ARRAY-ELEMENT-TYPE ,x) ',(upgraded-array-element-type el-type)))
          )
        ,@(if (eq size '*)
            '()
            `((EQL (ARRAY-DIMENSION ,x 0) ',size))
          )
   )
)
(def-compound-type SIMPLE-VECTOR (&optional (size '*)) (x)
  (ensure-dim SIMPLE-VECTOR size)
  (and (simple-vector-p x)
       (or (eq size '*) (eql size (array-dimension x 0)))
  )
  (c-typep-vector 'SIMPLE-VECTOR-P size x)
)
(def-compound-type COMPLEX (&optional (rtype '*) (itype rtype)) (x)
  nil
  (and (complexp x)
       (or (eq rtype '*)
           (typep (realpart x) (upgraded-complex-part-type rtype)))
       (or (eq itype '*)
           (typep (imagpart x) (upgraded-complex-part-type itype))))
  `(AND (COMPLEXP ,x)
        ,@(if (eq rtype '*)
            '()
            `((TYPEP (REALPART ,x) ',(upgraded-complex-part-type rtype))))
        ,@(if (eq itype '*)
            '()
            `((TYPEP (IMAGPART ,x) ',(upgraded-complex-part-type itype))))))
(def-compound-type INTEGER (&optional (low '*) (high '*)) (x)
  nil
  (typep-number-test x low high #'integerp 'INTEGER)
  (c-typep-number 'INTEGER 'INTEGERP low high x)
)
(def-compound-type MOD (n) (x)
  (unless (integerp n)
    (error (TEXT "~S: argument to MOD must be an integer: ~S")
           'typep n
  ) )
  (and (integerp x) (<= 0 x) (< x n))
  `(AND (INTEGERP ,x) (NOT (MINUSP ,x)) (< ,x ,n))
)
(def-compound-type SIGNED-BYTE (&optional (n '*)) (x)
  (unless (or (eq n '*) (integerp n))
    (error (TEXT "~S: argument to ~S must be an integer or * : ~S")
           'typep 'signed-byte n))
  (and (integerp x) (or (eq n '*) (< (integer-length x) n)))
  `(AND (INTEGERP ,x)
        ,@(if (eq n '*) '() `((< (INTEGER-LENGTH ,x) ,n)))
   )
)
(def-compound-type UNSIGNED-BYTE (&optional (n '*)) (x)
  (unless (or (eq n '*) (integerp n))
    (error (TEXT "~S: argument to ~S must be an integer or * : ~S")
           'typep 'unsigned-byte n))
  (and (integerp x)
       (not (minusp x))
       (or (eq n '*) (<= (integer-length x) n))
  )
  `(AND (INTEGERP ,x) (NOT (MINUSP ,x))
        ,@(if (eq n '*) '() `((<= (INTEGER-LENGTH ,x) ,n)))
   )
)
(def-compound-type REAL (&optional (low '*) (high '*)) (x)
  nil
  (typep-number-test x low high #'realp 'REAL)
  (c-typep-number 'REAL 'REALP low high x)
)
(def-compound-type RATIONAL (&optional (low '*) (high '*)) (x)
  nil
  (typep-number-test x low high #'rationalp 'RATIONAL)
  (c-typep-number 'RATIONAL 'RATIONALP low high x)
)
(def-compound-type FLOAT (&optional (low '*) (high '*)) (x)
  nil
  (typep-number-test x low high #'floatp 'FLOAT)
  (c-typep-number 'FLOAT 'FLOATP low high x)
)
(def-compound-type SHORT-FLOAT (&optional (low '*) (high '*)) (x)
  nil
  (typep-number-test x low high #'short-float-p 'SHORT-FLOAT)
  (c-typep-number 'SHORT-FLOAT 'SHORT-FLOAT-P low high x)
)
(def-compound-type SINGLE-FLOAT (&optional (low '*) (high '*)) (x)
  nil
  (typep-number-test x low high #'single-float-p 'SINGLE-FLOAT)
  (c-typep-number 'SINGLE-FLOAT 'SINGLE-FLOAT-P low high x)
)
(def-compound-type DOUBLE-FLOAT (&optional (low '*) (high '*)) (x)
  nil
  (typep-number-test x low high #'double-float-p 'DOUBLE-FLOAT)
  (c-typep-number 'DOUBLE-FLOAT 'DOUBLE-FLOAT-P low high x)
)
(def-compound-type LONG-FLOAT (&optional (low '*) (high '*)) (x)
  nil
  (typep-number-test x low high #'long-float-p 'LONG-FLOAT)
  (c-typep-number 'LONG-FLOAT 'LONG-FLOAT-P low high x)
)
(def-compound-type STRING (&optional (size '*)) (x)
  (ensure-dim STRING size)
  (and (stringp x)
       (or (eq size '*) (eql size (array-dimension x 0)))
  )
  (c-typep-vector 'STRINGP size x)
)
(def-compound-type SIMPLE-STRING (&optional (size '*)) (x)
  (ensure-dim SIMPLE-STRING size)
  (and (simple-string-p x)
       (or (eq size '*) (eql size (array-dimension x 0)))
  )
  (c-typep-vector 'SIMPLE-STRING-P size x)
)
(def-compound-type BASE-STRING (&optional (size '*)) (x)
  (ensure-dim BASE-STRING size)
  (and (stringp x)
       (or (eq size '*) (eql size (array-dimension x 0)))
  )
  (c-typep-vector 'STRINGP size x)
)
(def-compound-type SIMPLE-BASE-STRING (&optional (size '*)) (x)
  (ensure-dim SIMPLE-BASE-STRING size)
  (and (simple-string-p x)
       (or (eq size '*) (eql size (array-dimension x 0)))
  )
  (c-typep-vector 'SIMPLE-STRING-P size x)
)
(def-compound-type BIT-VECTOR (&optional (size '*)) (x)
  (ensure-dim BIT-VECTOR size)
  (and (bit-vector-p x)
       (or (eq size '*) (eql size (array-dimension x 0)))
  )
  (c-typep-vector 'BIT-VECTOR-P size x)
)
(def-compound-type SIMPLE-BIT-VECTOR (&optional (size '*)) (x)
  (ensure-dim SIMPLE-BIT-VECTOR size)
  (and (simple-bit-vector-p x)
       (or (eq size '*) (eql size (array-dimension x 0)))
  )
  (c-typep-vector 'SIMPLE-BIT-VECTOR-P size x)
)
(def-compound-type CONS (&optional (car-type '*) (cdr-type '*)) (x)
  nil
  (and (consp x)
       (or (eq car-type '*) (typep (car x) car-type))
       (or (eq cdr-type '*) (typep (cdr x) cdr-type))
  )
  `(AND (CONSP ,x)
        ,@(if (eq car-type '*) '() `((TYPEP (CAR ,x) ',car-type)))
        ,@(if (eq cdr-type '*) '() `((TYPEP (CDR ,x) ',cdr-type)))
   )
)

(fmakunbound 'def-compound-type)

;; ----------------------------------------------------------------------------

; Typtest ohne Gefahr einer Fehlermeldung. Fr SIGNAL und HANDLER-BIND.
(defun safe-typep (x y &optional env)
  (let ((*error-handler*
          #'(lambda (&rest error-args)
              (declare (ignore error-args))
              (return-from safe-typep (values nil nil))
       ))   )
    (values (typep x y env) t)
) )

; Umwandlung eines "type for declaration" in einen "type for discrimination".
(defun type-for-discrimination (y &optional (notp nil) &aux f)
  (cond ((symbolp y)
           (cond ((get y 'TYPE-SYMBOL) y)
                 ((get y 'TYPE-LIST) y)
                 ((setq f (get y 'DEFTYPE-EXPANDER))
                  (let* ((z (funcall f (list y)))
                         (zx (type-for-discrimination z notp)))
                    (if (eql zx z) y zx)
                 ))
                 (t y)
        )  )
        ((and (consp y) (symbolp (first y)))
           (case (first y)
             ((SATISFIES MEMBER EQL) y)
             (NOT
              (let* ((z (second y))
                     (zx (type-for-discrimination z (not notp))))
                (if (eql zx z) y `(NOT ,zx))
             ))
             ((AND OR COMPLEX VALUES)
              (let* ((z (rest y))
                     (zx (mapcar #'(lambda (x) (type-for-discrimination x notp)) z)))
                (if (every #'eql z zx) y (cons (first y) zx))
             ))
             (FUNCTION
              ;; (FUNCTION arg-types res-type) is somewhere between
              ;; NIL and FUNCTION, but undecidable.
              (if notp 'NIL 'FUNCTION)
             )
             (t (cond ((get (first y) 'TYPE-LIST) y)
                      ((setq f (get (first y) 'DEFTYPE-EXPANDER))
                       (let* ((z (funcall f y))
                              (zx (type-for-discrimination z notp)))
                         (if (eql zx z) y zx)
                      ))
                      (t y)
        )  ) )  )
        (t y)
) )

; Testet eine Liste von Werten auf Erfllen eines Type-Specifiers. Fr THE.
(defun %the (values type) ; ABI
  (macrolet ((near-typep (objform typform)
               ;; near-typep ist wie typep, nur dass das Objekt auch ein
               ;; Read-Label sein darf. Das tritt z.B. auf bei
               ;; (read-from-string "#1=#S(FOO :X #1#)")
               ;; im Konstruktor MAKE-FOO. Die Implementation ist aber
               ;; nicht gezwungen, bei fehlerhaftem THE zwingend einen
               ;; Fehler zu melden, darum ist ein lascherer Typcheck hier
               ;; erlaubt.
               (let ((g (gensym)))
                 `(let ((,g ,objform))
                    (or (typep ,g ,typform) (eq (type-of ,g) 'READ-LABEL))))))
    (if (and (consp type) (eq (car type) 'VALUES))
      ;; The VALUES type specifier is ill-defined in ANSI CL.
      ;;
      ;; There are two possibilities to define a VALUES type specifier in a
      ;; sane way:
      ;; - (EXACT-VALUES type1 ... [&optional ...]) describes the exact shape
      ;;   of the values list, as received by MULTIPLE-VALUE-LIST.
      ;;   For example, (EXACT-VALUES SYMBOL) is matched by (values 'a) but not
      ;;   by (values 'a 'b) or (values).
      ;; - (ASSIGNABLE-VALUES type1 ... [&optional ...]) describes the values
      ;;   as received by a set of variables through MULTIPLE-VALUE-BIND or
      ;;   MULTIPLE-VALUE-SETQ. For example, (ASSIGNABLE-VALUES SYMBOL) is
      ;;   defined by whether
      ;;     (MULTIPLE-VALUE-BIND (var1) values (DECLARE (TYPE SYMBOL var1)) ...)
      ;;   is valid or not; therefore (ASSIGNABLE-VALUES SYMBOL) is matched by
      ;;   (values 'a) and (values 'a 'b) and (values).
      ;;   Note that &OPTIONAL is actually redundant here:
      ;;     (ASSIGNABLE-VALUES type1 ... &optional otype1 ...)
      ;;   is equivalent to
      ;;     (ASSIGNABLE-VALUES type1 ... (OR NULL otype1) ...)
      ;; HyperSpec/Body/typspe_values.html indicates that VALUES means
      ;; EXACT-VALUES; however, HyperSpec/Body/speope_the.html indicates that
      ;; VALUES means ASSIGNABLE-VALUES.
      ;;
      ;; SBCL interprets the VALUES type specifier to mean EXACT-VALUES when
      ;; it contains &OPTIONAL or &REST, but ASSIGNABLE-VALUES when it has
      ;; only a tuple of type specifiers. This is utter nonsense, in particular
      ;; because it makes (VALUES type1 ... typek &OPTIONAL)
      ;; different from   (VALUES type1 ... typek).
      ;;
      ;; Here we use the ASSIGNABLE-VALUES interpretation.
      ;; In SUBTYPEP we just punt and don't assume any interpretation.
      (let ((vals values) (types (cdr type)))
        ;; required:
        (loop
          (when (or (atom types) (atom vals)) (return-from %the t))
          (when (memq (car types) lambda-list-keywords) (return))
          (unless (near-typep (pop vals) (pop types))
            (return-from %the nil)))
        ;; &optional:
        (when (and (consp types) (eq (car types) '&optional))
          (setq types (cdr types))
          (loop
            (when (or (atom types) (atom vals)) (return-from %the t))
            (when (memq (car types) lambda-list-keywords) (return))
            (unless (near-typep (pop vals) (pop types))
              (return-from %the nil))))
        ;; &rest &key:
        (case (car types)
          (&rest
           (setq types (cdr types))
           (when (atom types) (typespec-error 'the type))
           (unless (near-typep (pop vals) (pop types))
             (return-from %the nil)))
          (&key)
          (t (typespec-error 'the type)))
        (if (eq (car types) '&key)
          (progn
            (setq types (cdr types))
            (when (oddp (length vals)) (return-from %the nil))
            (let ((keywords nil))
              (loop
                (when (or (atom types) (atom vals)) (return-from %the t))
                (when (memq (car types) lambda-list-keywords) (return))
                (let ((item (pop types)))
                  (unless (and (listp item) (eql (length item) 2)
                               (symbolp (first item)))
                    (typespec-error 'the type))
                  (let ((kw (symbol-to-keyword (first item))))
                    (unless (near-typep (getf vals kw) (second item))
                      (return-from %the nil))
                    (push kw keywords))))
              (if (and (consp types) (eq (car types) '&allow-other-keys))
                (setq types (cdr types))
                (unless (getf vals ':allow-other-keys)
                  (do ((L vals (cddr L)))
                      ((atom L))
                    (unless (memq (car L) keywords)
                      (return-from %the nil)))))))
          (when (consp types) (typespec-error 'the type)))
        t)
      (near-typep (if (consp values) (car values) nil) type))))

;;; ===========================================================================

;; SUBTYPEP
(load "subtypep")


;; Returns the number of bytes that are needed to represent #\Null in a
;; given encoding.
(defun encoding-zeroes (encoding)
  #+UNICODE
  ;; this should use min_bytes_per_char for cache, not the hash table
  (let ((name (ext:encoding-charset encoding))
        (table #.(make-hash-table :key-type '(or string symbol) :value-type 'fixnum
                                  :test 'stablehash-equal :warn-if-needs-rehash-after-gc t
                                  :initial-contents '(("UTF-7" . 1))))
        (tester #.(make-string 2 :initial-element (code-char 0))))
    (or (gethash name table)
        (setf (gethash name table)
              (- (length (ext:convert-string-to-bytes tester encoding))
                 (length (ext:convert-string-to-bytes tester encoding
                                                      :end 1))))))
  #-UNICODE 1)

;; Determines two values low,high such that
;;   (subtypep type `(INTEGER ,low ,high))
;; holds and low is as large as possible and high is as small as possible.
;; low = * means -infinity, high = * means infinity.
;; When (subtypep type 'INTEGER) is false, the values NIL,NIL are returned.
;; We need this function only for MAKE-ARRAY, UPGRADED-ARRAY-ELEMENT-TYPE and
;; OPEN and can therefore w.l.o.g. replace
;;   type  with  `(OR ,type (MEMBER 0))
#| ;; The original implementation calls canonicalize-type and then applies
   ;; a particular SUBTYPE variant:
 (defun subtype-integer (type)
  (macrolet ((yes () '(return-from subtype-integer (values low high)))
             (no () '(return-from subtype-integer nil))
             (unknown () '(return-from subtype-integer nil)))
    (setq type (canonicalize-type type))
    (if (consp type)
      (case (first type)
        (MEMBER ; (MEMBER &rest objects)
          ;; All elements must be of type INTEGER.
          (let ((low 0) (high 0)) ; wlog!
            (dolist (x (rest type) (yes))
              (unless (typep x 'INTEGER) (return (no)))
              (setq low (min low x) high (max high x)))))
        (OR ; (OR type*)
          ;; Every type must be subtype of INTEGER.
          (let ((low 0) (high 0)) ; wlog!
            (dolist (type1 (rest type) (yes))
              (multiple-value-bind (low1 high1) (subtype-integer type1)
                (unless low1 (return (no)))
                (setq low (if (or (eq low '*) (eq low1 '*)) '* (min low low1))
                      high (if (or (eq high '*) (eq high1 '*))
                               '* (max high high1)))))))
        (AND ; (AND type*)
          ;; If one of the types is subtype of INTEGER, then yes,
          ;; otherwise unknown.
          (let ((low nil) (high nil))
            (dolist (type1 (rest type))
              (multiple-value-bind (low1 high1) (subtype-integer type1)
                (when low1
                  (if low
                    (setq low (if (eq low '*) low1 (if (eq low1 '*) low (max low low1)))
                          high (if (eq high '*) high1 (if (eq high1 '*) high (min high high1))))
                    (setq low low1 high high1)))))
            (if low
              (progn
                (when (and (numberp low) (numberp high) (not (<= low high)))
                  (setq low 0 high 0) ; type equivalent to NIL)
                (yes))
              (unknown)))))
      (setq type (list type)))
    (if (eq (first type) 'INTEGER)
      (let ((low (if (rest type) (second type) '*))
            (high (if (cddr type) (third type) '*)))
        (when (consp low)
          (setq low (first low))
          (when (numberp low) (incf low)))
        (when (consp high)
          (setq high (first high))
          (when (numberp high) (decf high)))
        (when (and (numberp low) (numberp high) (not (<= low high))) ; type leer?
          (setq low 0 high 0))
        (yes))
      (if (and (eq (first type) 'INTERVALS) (eq (second type) 'INTEGER))
        (let ((low (third type))
              (high (car (last type))))
          (when (consp low)
            (setq low (first low))
            (when (numberp low) (incf low)))
          (when (consp high)
            (setq high (first high))
            (when (numberp high) (decf high)))
          (yes))
        (unknown)))))
|# ;; This implementation inlines the (tail-recursive) canonicalize-type
   ;; function. Its advantage is that it doesn't cons as much.
   ;; (For example, (subtype-integer '(UNSIGNED-BYTE 8)) doesn't cons.)
(defun subtype-integer (type)
  (macrolet ((yes () '(return-from subtype-integer (values low high)))
             (no () '(return-from subtype-integer nil))
             (unknown () '(return-from subtype-integer nil)))
    (setq type (expand-deftype type))
    (cond ((symbolp type)
           (case type
             (BIT (let ((low 0) (high 1)) (yes)))
             (FIXNUM
              (let ((low '#,most-negative-fixnum)
                    (high '#,most-positive-fixnum))
                (yes)))
             ((INTEGER BIGNUM SIGNED-BYTE)
              (let ((low '*) (high '*)) (yes)))
             (UNSIGNED-BYTE
              (let ((low 0) (high '*)) (yes)))
             ((NIL)
              (let ((low 0) (high 0)) (yes))) ; wlog!
             (t (no))))
          ((and (consp type) (symbolp (first type)))
           (unless (and (list-length type) (null (cdr (last type))))
             (typespec-error 'subtypep type))
           (case (first type)
             (MEMBER ; (MEMBER &rest objects)
              ;; All elements must be of type INTEGER.
              (let ((low 0) (high 0)) ; wlog!
                (dolist (x (rest type) (yes))
                  (unless (typep x 'INTEGER) (return (no)))
                  (setq low (min low x) high (max high x)))))
             (EQL ; (EQL object)
              (let ((x (second type)))
                (if (typep x 'INTEGER)
                  (let ((low (min 0 x)) (high (max 0 x))) (yes))
                  (no))))
             (OR ; (OR type*)
              ;; Every type must be subtype of INTEGER.
              (let ((low 0) (high 0)) ; wlog!
                (dolist (type1 (rest type) (yes))
                  (multiple-value-bind (low1 high1) (subtype-integer type1)
                    (unless low1 (return (no)))
                    (setq low (if (or (eq low '*) (eq low1 '*))
                                  '* (min low low1))
                          high (if (or (eq high '*) (eq high1 '*))
                                   '* (max high high1)))))))
             (AND ; (AND type*)
              ;; If one of the types is subtype of INTEGER, then yes,
              ;; otherwise unknown.
              (let ((low nil) (high nil))
                (dolist (type1 (rest type))
                  (multiple-value-bind (low1 high1) (subtype-integer type1)
                    (when low1
                      (if low
                        (setq low (if (eq low '*) low1
                                      (if (eq low1 '*) low
                                          (max low low1)))
                              high (if (eq high '*) high1
                                       (if (eq high1 '*) high
                                           (min high high1))))
                        (setq low low1
                              high high1)))))
                (if low
                  (progn
                    (when (and (numberp low) (numberp high)
                               (not (<= low high)))
                      (setq low 0 high 0)) ; type equivalent to NIL
                    (yes))
                  (unknown))))
             (INTEGER
              (let ((low (if (rest type) (second type) '*))
                    (high (if (cddr type) (third type) '*)))
                (when (consp low)
                  (setq low (first low))
                  (when (numberp low) (incf low)))
                (when (consp high)
                  (setq high (first high))
                  (when (numberp high) (decf high)))
                (when (and (numberp low) (numberp high) (not (<= low high)))
                  (setq low 0 high 0)) ; type equivalent to NIL
                (yes)))
             (INTERVALS
              (if (eq (second type) 'INTEGER)
                (let ((low (third type))
                      (high (car (last type))))
                  (when (consp low)
                    (setq low (first low))
                    (when (numberp low) (incf low)))
                  (when (consp high)
                    (setq high (first high))
                    (when (numberp high) (decf high)))
                  (yes))
                (unknown)))
             (MOD ; (MOD n)
              (let ((n (second type)))
                (unless (and (integerp n) (>= n 0))
                  (typespec-error 'subtypep type))
                (if (eql n 0)
                  (no)
                  (let ((low 0) (high (1- n)))
                    (yes)))))
             (SIGNED-BYTE ; (SIGNED-BYTE &optional s)
              (let ((s (if (cdr type) (second type) '*)))
                (if (eq s '*)
                  (let ((low '*) (high '*)) (yes))
                  (progn
                    (unless (and (integerp s) (plusp s))
                      (typespec-error 'subtypep type))
                    (let ((n (ash 1 (1- s)))) ; (ash 1 *) == (expt 2 *)
                      (let ((low (- n)) (high (1- n)))
                        (yes)))))))
             (UNSIGNED-BYTE ; (UNSIGNED-BYTE &optional s)
              (let ((s (if (cdr type) (second type) '*)))
                (if (eq s '*)
                    (let ((low 0) (high '*)) (yes))
                    (progn
                      (unless (and (integerp s) (>= s 0))
                        (typespec-error 'subtypep type))
                      (let ((n (ash 1 s))) ; (ash 1 *) == (expt 2 *)
                        (let ((low 0) (high (1- n)))
                          (yes)))))))
             (t (no))))
          ((clos::defined-class-p type)
           (if (and (clos::built-in-class-p type)
                    (eq (get (clos:class-name type) 'CLOS::CLOSCLASS) type))
             (return-from subtype-integer
               (subtype-integer (clos:class-name type)))
             (no)))
          ((clos::eql-specializer-p type)
           (let ((x (clos::eql-specializer-singleton type)))
             (if (typep x 'INTEGER)
               (let ((low (min 0 x)) (high (max 0 x))) (yes))
               (no))))
          ((encodingp type) (no))
          (t (typespec-error 'subtypep type)))))

#| TODO: Fix subtype-integer such that this works.
Henry Baker:
 (defun type-null (x)
  (values (and (eq 'bit (upgraded-array-element-type `(or bit ,x)))
               (not (typep 0 x))
               (not (typep 1 x)))
          t))
 (type-null '(and symbol number))
 (type-null '(and integer symbol))
 (type-null '(and integer character))
|#

;; Determines a sequence kind (an atom, as defined in defseq.lisp: one of
;;   LIST - stands for LIST
;;   VECTOR - stands for (VECTOR T)
;;   STRING - stands for (VECTOR CHARACTER)
;;   1, 2, 4, 8, 16, 32 - stands for (VECTOR (UNSIGNED-BYTE n))
;;   0 - stands for (VECTOR NIL))
;; that indicates the sequence type meant by the given type. Other possible
;; return values are
;;   SEQUENCE - denoting a type whose intersection with (OR LIST VECTOR) is not
;;              subtype of LIST or VECTOR, or
;;   NIL - indicating a type whose intersection with (OR LIST VECTOR) is empty.
;; When the type is (OR (VECTOR eltype1) ... (VECTOR eltypeN)), the chosen
;; element type is the smallest element type that contains all of eltype1 ...
;; eltypeN.
;;
;; User-defined sequence types are not supported here.
;;
;; This implementation inlines the (tail-recursive) canonicalize-type
;; function. Its advantage is that it doesn't cons as much. Also it employs
;; some heuristics and does not have the full power of SUBTYPEP.
(defun subtype-sequence (type)
  (setq type (expand-deftype type))
  (cond ((symbolp type)
         (case type
           ((LIST CONS NULL) 'LIST)
           ((NIL) 'NIL)
           ((BIT-VECTOR SIMPLE-BIT-VECTOR) '1)
           ((STRING SIMPLE-STRING BASE-STRING SIMPLE-BASE-STRING) 'STRING)
           ((VECTOR SIMPLE-VECTOR ARRAY SIMPLE-ARRAY) 'VECTOR)
           ((SEQUENCE) 'SEQUENCE)
           (t 'NIL)))
        ((and (consp type) (symbolp (first type)))
         (unless (and (list-length type) (null (cdr (last type))))
           (typespec-error 'subtypep type))
         (case (first type)
           (MEMBER ; (MEMBER &rest objects)
            (let ((kind 'NIL))
              (dolist (x (rest type))
                (setq kind (sequence-type-union kind (type-of-sequence x))))
              kind))
           (EQL ; (EQL object)
            (unless (eql (length type) 2)
              (typespec-error 'subtypep type))
            (type-of-sequence (second type)))
           (OR ; (OR type*)
            (let ((kind 'NIL))
              (dolist (x (rest type))
                (setq kind (sequence-type-union kind (subtype-sequence x))))
              kind))
           (AND ; (AND type*)
            (let ((kind 'SEQUENCE))
              (dolist (x (rest type))
                (setq kind (sequence-type-intersection kind (subtype-sequence x))))
              kind))
           ((SIMPLE-BIT-VECTOR BIT-VECTOR) ; (SIMPLE-BIT-VECTOR &optional size)
            (when (cddr type)
              (typespec-error 'subtypep type))
            '1)
           ((SIMPLE-STRING STRING SIMPLE-BASE-STRING BASE-STRING) ; (SIMPLE-STRING &optional size)
            (when (cddr type)
              (typespec-error 'subtypep type))
            'STRING)
           (SIMPLE-VECTOR ; (SIMPLE-VECTOR &optional size)
            (when (cddr type)
              (typespec-error 'subtypep type))
            'VECTOR)
           ((VECTOR ARRAY SIMPLE-ARRAY) ; (VECTOR &optional el-type size), (ARRAY &optional el-type dimensions)
            (when (cdddr type)
              (typespec-error 'subtypep type))
            (let ((el-type (if (cdr type) (second type) '*)))
              (if (eq el-type '*)
                'VECTOR
                (let ((eltype (upgraded-array-element-type el-type)))
                  (cond ((eq eltype 'T) 'VECTOR)
                        ((eq eltype 'CHARACTER) 'STRING)
                        ((eq eltype 'BIT) '1)
                        ((and (consp eltype) (eq (first eltype) 'UNSIGNED-BYTE)) (second eltype))
                        ((eq eltype 'NIL) '0)
                        (t (error (TEXT "~S is not up-to-date with ~S for element type ~S")
                                  'subtypep-sequence 'upgraded-array-element-type eltype)))))))
           ((CONS) ; (CONS &optional cartype cdrtype)
            (when (cdddr type)
              (typespec-error 'subtypep type))
            'LIST)
           (t 'NIL)))
        ((clos::defined-class-p type)
         (if (and (clos::built-in-class-p type)
                  (eq (get (clos:class-name type) 'CLOS::CLOSCLASS) type))
           (subtype-sequence (clos:class-name type))
           'NIL))
        ((clos::eql-specializer-p type)
         (type-of-sequence (clos::eql-specializer-singleton type)))
        (t 'NIL)))
(defun type-of-sequence (x)
  (cond ((listp x) 'LIST)
        ((vectorp x)
         (let ((eltype (array-element-type x)))
           (cond ((eq eltype 'T) 'VECTOR)
                 ((eq eltype 'CHARACTER) 'STRING)
                 ((eq eltype 'BIT) '1)
                 ((and (consp eltype) (eq (first eltype) 'UNSIGNED-BYTE)) (second eltype))
                 ((eq eltype 'NIL) '0)
                 (t (error (TEXT "~S is not up-to-date with ~S for element type ~S")
                           'type-of-sequence 'array-element-type eltype)))))
        (t 'NIL)))
(defun sequence-type-union (t1 t2)
  (cond ; Simple general rules.
        ((eql t1 t2) t1)
        ((eq t1 'NIL) t2)
        ((eq t2 'NIL) t1)
        ; Now the union of two different types.
        ((or (eq t1 'SEQUENCE) (eq t2 'SEQUENCE)) 'SEQUENCE)
        ((or (eq t1 'LIST) (eq t2 'LIST))
         ; union of LIST and a vector type
         'SEQUENCE)
        ((or (eq t1 'VECTOR) (eq t2 'VECTOR)) 'VECTOR)
        ((eql t1 0) t2)
        ((eql t2 0) t1)
        ((or (eq t1 'STRING) (eq t2 'STRING))
         ; union of STRING and an integer-vector type
         'VECTOR)
        (t (max t1 t2))))
(defun sequence-type-intersection (t1 t2)
  (cond ; Simple general rules.
        ((eql t1 t2) t1)
        ((or (eq t1 'NIL) (eq t2 'NIL)) 'NIL)
        ; Now the intersection of two different types.
        ((eq t1 'SEQUENCE) t2)
        ((eq t2 'SEQUENCE) t1)
        ((or (eq t1 'LIST) (eq t2 'LIST))
         ; intersection of LIST and a vector type
         'NIL)
        ((eq t1 'VECTOR) t2)
        ((eq t2 'VECTOR) t1)
        ((or (eql t1 0) (eql t2 0)) '0)
        ((or (eq t1 'STRING) (eq t2 'STRING))
         ; intersection of STRING and an integer-vector type
         '0)
        (t (min t1 t2))))

;; ============================================================================

(defun type-expand (typespec &optional once-p)
  (multiple-value-bind (expanded user-defined-p)
      (expand-deftype typespec once-p)
    (if user-defined-p (values expanded user-defined-p)
      (cond ((symbolp typespec)
             (cond ((or (get typespec 'TYPE-SYMBOL) (get typespec 'TYPE-LIST))
                    (values typespec nil))
                   ((or (get typespec 'DEFSTRUCT-DESCRIPTION)
                        (clos-class typespec))
                    (values typespec nil))
                   (t (typespec-error 'type-expand typespec))))
            ((and (consp typespec) (symbolp (first typespec)))
             (case (first typespec)
               ((SATISFIES MEMBER EQL NOT AND OR) (values typespec nil))
               (t (cond ((get (first typespec) 'TYPE-LIST)
                         (values typespec nil))
                        (t (typespec-error 'type-expand typespec))))))
            ((clos::defined-class-p typespec) (values typespec nil))
            (t (typespec-error 'type-expand typespec))))))

;; ============================================================================

(unless (clos::funcallable-instance-p #'clos::class-name)
  (fmakunbound 'clos::class-name))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./type.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-stablehash2.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP
;;;; Objects with stable hash code
;;;; Part 2: Final class definition, make/initialize-instance methods.
;;;; Bruno Haible 2004-05-15

(in-package "CLOS")

;;; ===========================================================================

;;; Lift the initialization protocol.

(defmethod shared-initialize ((object standard-stablehash) situation &rest args
                              &key)
  (apply #'shared-initialize-<standard-stablehash> object situation args))

;;; ===========================================================================

;; Definition of <structure-stablehash>.
;; Used for (make-hash-table :test 'stablehash-eq).
(defstruct (structure-stablehash (:predicate nil) (:copier nil))
  (hashcode (sys::random-posfixnum))) ; GC invariant hash code

;;; ===========================================================================
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-stablehash2.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-stablehash1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP
;;;; Objects with stable hash code
;;;; Part 1: Class definition.
;;;; Bruno Haible 2004-05-15

(in-package "CLOS")

;;; ===========================================================================

;;; The class <standard-stablehash> allows CLOS instances to have a
;;; GC-invariant EQ hash code.
;;; Used for (make-hash-table :test 'stablehash-eq).

(defvar *<standard-stablehash>-defclass*
  '(defclass standard-stablehash ()
     (($hashcode :initform (sys::random-posfixnum))) ; GC invariant hash code
     (:fixed-slot-locations t)))

;; Fixed slot locations.
(defconstant *<standard-stablehash>-hashcode-location* 1)

;; No need for accessors. The hashcode is used by hashtabl.d.

;; Initialization of a <standard-stablehash> instance.
(defun shared-initialize-<standard-stablehash> (object situation &rest args
                                                &key &allow-other-keys)
  (if *classes-finished*
    (apply #'%shared-initialize object situation args) ; == (call-next-method)
    ; Bootstrapping: Simulate the effect of #'%shared-initialize.
    (when (eq situation 't) ; called from initialize-instance?
      (setf (standard-instance-access object *<standard-stablehash>-hashcode-location*)
            (sys::random-posfixnum))))
  object)

;;; ===========================================================================
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-stablehash1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-specializer3.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP
;;;; Specializers
;;;; Part n-1: Generic functions specified in the MOP.
;;;; Bruno Haible 2004-05-15
;;;; Sam Steingold 2017

(in-package "CLOS")


;; Make creation of <specializer> instances customizable.
(setf (fdefinition 'initialize-instance-<eql-specializer>) #'initialize-instance)
(setf (fdefinition 'make-instance-<eql-specializer>) #'make-instance)


;; Optimized accessors, with type checking.

(defun specializer-direct-methods-table (specializer)
  (accessor-typecheck specializer 'specializer 'specializer-direct-methods-table)
  (sys::%record-ref specializer *<specializer>-direct-methods-location*))
(defun (setf specializer-direct-methods-table) (new-value specializer)
  (accessor-typecheck specializer 'specializer '(setf specializer-direct-methods-table))
  (setf (sys::%record-ref specializer *<specializer>-direct-methods-location*) new-value))

(defun eql-specializer-singleton (specializer)
  (accessor-typecheck specializer 'eql-specializer 'eql-specializer-singleton)
  (sys::%record-ref specializer *<eql-specializer>-singleton-location*))
(defun (setf eql-specializer-singleton) (new-value specializer)
  (accessor-typecheck specializer 'eql-specializer '(setf eql-specializer-singleton))
  (setf (sys::%record-ref specializer *<eql-specializer>-singleton-location*) new-value))


;; MOP p. 103
(defgeneric specializer-direct-generic-functions (specializer)
  (declare (dynamically-modifiable))
  (:method ((specializer specializer))
    (compute-direct-generic-functions specializer)))

;; MOP p. 31
(defgeneric add-direct-method (specializer method)
  (declare (dynamically-modifiable))
  (:method ((specializer specializer) (method method))
    (add-direct-method-<specializer>-<method> specializer method)))

;; MOP p. 89
(defgeneric remove-direct-method (specializer method)
  (declare (dynamically-modifiable))
  (:method ((specializer specializer) (method method))
    (remove-direct-method-internal specializer method)))

;; MOP p. 103
(defgeneric specializer-direct-methods (specializer)
  (declare (dynamically-modifiable))
  (:method ((specializer specializer))
    (list-direct-methods specializer)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-specializer3.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-specializer2.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP
;;;; Specializers
;;;; Part n-2: Final class definitions, make/initialize-instance methods.
;;;; Bruno Haible 2004-05-15

(in-package "CLOS")

;;; ===========================================================================

(defmethod shared-initialize ((specializer specializer) situation &rest args)
  (apply #'shared-initialize-<specializer> specializer situation args))

(defmethod reinitialize-instance ((instance specializer) &rest initargs)
  (declare (ignore initargs))
  (error (TEXT "~S: It is not allowed to reinitialize ~S")
         'reinitialize-instance instance))

;;; ===========================================================================

(defmethod shared-initialize ((specializer eql-specializer) situation &rest args
                              &key ((singleton singleton) nil))
  (declare (ignore singleton))
  (apply #'shared-initialize-<eql-specializer> specializer situation args))

;;; ===========================================================================
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-specializer2.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-specializer1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP
;;;; Specializers
;;;; Part 1: Class definitions, preliminary accessors, utility functions.
;;;; Bruno Haible 2004-05-15

(in-package "CLOS")

;;; ===========================================================================

;;; The abstract class <specializer> allows specializers for methods in
;;; generic functions (i.e. classes and EQL-specializers) to be treated in a
;;; homogenous way.

(defvar *<specializer>-defclass*
  '(defclass specializer (standard-stablehash metaobject)
     (($direct-methods          ; weak-list or weak-hash-table of methods that
                                ; use this specializer
       :initform nil))
    (:fixed-slot-locations t)))

;; Fixed slot locations.
(defconstant *<specializer>-direct-methods-location* 2)

;; Preliminary accessors.
(predefun specializer-direct-methods-table (object)
  (sys::%record-ref object *<specializer>-direct-methods-location*))
(predefun (setf specializer-direct-methods-table) (new-value object)
  (setf (sys::%record-ref object *<specializer>-direct-methods-location*) new-value))

;; Initialization of a <specializer> instance.
(defun shared-initialize-<specializer> (specializer situation &rest args
                                        &key &allow-other-keys)
  (apply #'shared-initialize-<standard-stablehash> specializer situation args)
  (unless *classes-finished*
    ; Bootstrapping: Simulate the effect of #'%shared-initialize.
    (when (eq situation 't) ; called from initialize-instance?
      (setf (specializer-direct-methods-table specializer) nil)))
  specializer)

;;; ===========================================================================

;;; The class <eql-specializer> represents an EQL-specializer.

(defvar <eql-specializer> 'eql-specializer)
(defvar *<eql-specializer>-defclass*
  '(defclass eql-specializer (specializer)
     (($singleton :initarg singleton))
     (:fixed-slot-locations t)))
(defvar *<eql-specializer>-class-version* (make-class-version))

;; Fixed slot locations.
(defconstant *<eql-specializer>-singleton-location* 3)

;; Preliminary accessors.
(predefun eql-specializer-singleton (object)
  (sys::%record-ref object *<eql-specializer>-singleton-location*))
(predefun (setf eql-specializer-singleton) (new-value object)
  (setf (sys::%record-ref object *<eql-specializer>-singleton-location*) new-value))

(defconstant *<eql-specializer>-instance-size* 4)

;; Initialization of an <eql-specializer> instance.
(defun shared-initialize-<eql-specializer> (specializer situation &rest args
                                            &key ((singleton singleton) nil singleton-p)
                                            &allow-other-keys)
  (apply #'shared-initialize-<specializer> specializer situation args)
  (unless *classes-finished*
    ; Bootstrapping: Simulate the effect of #'%shared-initialize.
    (when singleton-p
      (setf (eql-specializer-singleton specializer) singleton)))
  specializer)

(defun initialize-instance-<eql-specializer> (specializer &rest args
                                              &key &allow-other-keys)
  ;; Don't add functionality here! This is a preliminary definition that is
  ;; replaced with #'initialize-instance later.
  (apply #'shared-initialize-<eql-specializer> specializer 't args))

(defun make-instance-<eql-specializer> (class &rest args
                                        &key &allow-other-keys)
  ;; class = <eql-specializer>
  ;; Don't add functionality here! This is a preliminary definition that is
  ;; replaced with #'make-instance later.
  (declare (ignore class))
  (let ((specializer (allocate-metaobject-instance *<eql-specializer>-class-version* *<eql-specializer>-instance-size*)))
    (apply #'initialize-instance-<eql-specializer> specializer args)))

;; Type test.
(defun eql-specializer-p (object)
  (and (std-instance-p object)
       (let ((cv (sys::%record-ref object 0)))
         ; Treat the most frequent case first, for bootstrapping.
         (or (eq cv *<eql-specializer>-class-version*)
             (gethash <eql-specializer>
                      (class-all-superclasses (class-of object)))))))

;;; ===========================================================================

;; We don't store the list of generic functions that use a given specializer
;; in the specializer, but instead compute it on the fly, because
;; 1. For good asymptotic performance the generic-functions list would have to
;;    be stored as a weak set or a weak multiset, thus requiring that
;;    <generic-function> inherits from <standard-stable-hash> - but this gives
;;    a collision with <funcallable-instance>.
;; 2. The generic-functions list of a specializer is generally not much
;;    shorter than the methods list of the specializer, and is redundant.

(defun compute-direct-generic-functions (specializer)
  (let* ((methods (specializer-direct-methods specializer))
         (gfs (delete-duplicates (mapcar #'method-generic-function methods) :test #'eq)))
    (when (memq nil gfs)
      (error (TEXT "~S: Some methods have been removed from their generic function, but the list in the ~S specializer was not updated.")
             'specializer-direct-generic-functions specializer))
    gfs))

;; MOP p. 103
(predefun specializer-direct-generic-functions (specializer)
  (compute-direct-generic-functions specializer))

#|
;; Adds a method to the list of direct methods.
(defun add-direct-method (specializer method) ...)
;; Removes a method from the list of direct methods.
(defun remove-direct-method (specializer method) ...)
;; Returns the currently existing direct methods, as a freshly consed list.
(defun list-direct-methods (specializer) ...)
|#
(def-weak-set-accessors specializer-direct-methods-table method
  add-direct-method-internal
  remove-direct-method-internal
  list-direct-methods)

(defun add-direct-method-<specializer>-<method> (specializer method)
  (add-direct-method-internal specializer method)
  (when (eql-specializer-p specializer)
    (let ((its-class (class-of (eql-specializer-singleton specializer))))
      (when (semi-standard-class-p its-class)
        (add-direct-instance-specializer its-class specializer)))))

;; Preliminary.
(predefun add-direct-method (specializer method)
  (add-direct-method-<specializer>-<method> specializer method))

(predefun remove-direct-method (specializer method)
  (remove-direct-method-internal specializer method))

;; MOP p. 103
(predefun specializer-direct-methods (specializer)
  (list-direct-methods specializer))

;;; ===========================================================================

;; EQL-specializers for numbers.
(defvar *eql-specializer-table*
  (make-hash-table :key-type 'number :value-type 'eql-specializer
                   :test 'ext:fasthash-eql :warn-if-needs-rehash-after-gc t))

;; EQL-specializers for other kinds of objects.
(defvar *eq-specializer-table*
  (make-hash-table :key-type '(not number) :value-type 'eql-specializer
                   :test 'ext:stablehash-eq
                   :weak :key))

;; MOP p. 70
(defun intern-eql-specializer (object)
  (let ((table (if (numberp object) *eql-specializer-table* *eq-specializer-table*)))
    (or (gethash object table)
        (setf (gethash object table)
              (make-instance-<eql-specializer> <eql-specializer>
                                               'singleton object)))))

;; Returns the eql-specializer for the given object only if it already exists,
;; otherwise nil.
(defun existing-eql-specializer (object)
  (let ((table (if (numberp object) *eql-specializer-table* *eq-specializer-table*)))
    (gethash object table)))

;; MOP p. 52
(defun eql-specializer-object (specializer)
  (eql-specializer-singleton specializer))

(defun print-object-<eql-specializer> (specializer stream)
  (print-unreadable-object (specializer stream :type t)
    (write (eql-specializer-object specializer) :stream stream)))

;;; ===========================================================================

;; Converts a specializer to a pretty printing type.
(defun specializer-pretty (specializer)
  (if (eql-specializer-p specializer)
    `(EQL ,(eql-specializer-object specializer))
    specializer))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-specializer1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-slots2.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP: Slots
;;;; Bruno Haible 21.8.1993 - 2004
;;;; Sam Steingold 1998 - 2004, 2017
;;;; German comments translated into English: Stefan Kain 2002-04-08

(in-package "CLOS")

;;; ===========================================================================

(defgeneric slot-missing (class instance slot-name operation
                          &optional new-value)
  (declare (dynamically-modifiable))
  (:method ((class t) instance slot-name operation &optional new-value)
    (declare (ignore instance new-value))
    (error-of-type 'error
      (TEXT "~S: The class ~S has no slot named ~S")
      operation class slot-name)))

(defgeneric slot-unbound (class instance slot-name)
  (declare (dynamically-modifiable))
  (:method ((class t) instance slot-name)
    (declare (ignore class))
    (multiple-value-bind (new-value store-p)
        (sys::check-value `(slot-value ,instance ',slot-name)
          (make-condition 'sys::simple-unbound-slot
            :name slot-name
            :instance instance
            :format-control (TEXT "~S: The slot ~S of ~S has no value")
            :format-arguments (list 'slot-value slot-name instance)))
      (when store-p
        (setf (slot-value instance slot-name) new-value))
      new-value)))

;;; ===========================================================================

;; Optimization of SLOT-VALUE and its brothers.
;; They are optimized to work as follows:
;; Step 1: (class-of instance) -> a class object. Take its slot-location-table.
;; Step 2: Lookup the slot name in the table. The result is an object that
;; encodes the behaviour of
;;   (slot-value-using-class this-class any-direct-instance slot)
;;   ((setf slot-value-using-class) any-new-value this-class any-direct-instance slot)
;;   (slot-boundp-using-class this-class any-direct-instance slot)
;;   (slot-makunbound-using-class this-class any-direct-instance slot)
;; for the slot with the given name. In the particular case that these generic
;; functions' effective methods are the predefined ones, the object is just the
;; slot location (a cons or nonnegative fixnum).

(defun invalidate-slot-value-info (class-specializer instance-specializer slot-specializer)
  ;; Step 1: Determine all affected classes that satisfy the instance-specializer.
  (let ((affected-classes
          (if (defined-class-p instance-specializer)
            (if (= (class-initialized instance-specializer) 6) ; finalized?
              (list-all-finalized-subclasses instance-specializer)
              '())
            (list (class-of (eql-specializer-object instance-specializer))))))
    ;; Step 2: Filter out those that don't satisfy the class-specializer.
    (setq affected-classes
          (remove-if-not #'(lambda (c) (typep c class-specializer))
                         affected-classes))
    ;; Step 3: Iterate over the affected classes and recompute the relevant
    ;; entries in the slot-location-table.
    (dolist (class affected-classes)
      (let ((ht (class-slot-location-table class)))
        (dolist (slot (class-slots class))
          (when (typep slot slot-specializer)
            (setf (gethash (slot-definition-name slot) ht)
                  (compute-slot-location-table-entry class slot))))))))

(defun note-svuc-change (method)
  (apply #'invalidate-slot-value-info (method-specializers method)))

(defun note-ssvuc-change (method)
  (apply #'invalidate-slot-value-info (cdr (method-specializers method))))

(defun note-sbuc-change (method)
  (apply #'invalidate-slot-value-info (method-specializers method)))

(defun note-smuc-change (method)
  (apply #'invalidate-slot-value-info (method-specializers method)))

;; MOP p. 97
(defgeneric slot-value-using-class (class object slot)
  (declare (dynamically-modifiable)))
(setq |#'slot-value-using-class| #'slot-value-using-class)
#|
(defmethod slot-value-using-class ((class semi-standard-class) instance (slot standard-effective-slot-definition))
  (let ((slot-name (slot-definition-name slot))
        (slot-location (slot-definition-location slot)))
    ((lambda (value)
       (if (eq value unbound)
         (slot-unbound class instance slot-name)
         value))
     (cond ((null slot-location)
            (slot-missing class instance slot-name 'slot-value))
           ((atom slot-location) ; access local slot
            (sys::%record-ref instance slot-location))
           (t ; access shared slot
            (svref (cv-shared-slots (car slot-location))
                   (cdr slot-location)))))))
|#
;; The main work is done by a SUBR:
(do-defmethod 'slot-value-using-class
  (make-instance-<standard-method> <standard-method>
    :specializers (list (find-class 'semi-standard-class)
                        (find-class 't)
                        (find-class 'standard-effective-slot-definition))
    'fast-function #'clos::%slot-value-using-class
    'wants-next-method-p nil
    :qualifiers '()
    :lambda-list '(class instance slot)
    'signature #s(system::signature :req-num 3)))

;; MOP p. 93
(defgeneric (setf slot-value-using-class) (new-value class object slot)
  (declare (dynamically-modifiable)))
(setq |#'(setf slot-value-using-class)| #'(setf slot-value-using-class))
#|
(defmethod (setf slot-value-using-class) (new-value (class semi-standard-class) instance (slot standard-effective-slot-definition))
  (let ((slot-name (slot-definition-name slot))
        (slot-location (slot-definition-location slot)))
    (cond ((null slot-location)
           (slot-missing class instance slot-name 'setf new-value))
          ((atom slot-location) ; access local slot
           (sys::%record-store instance slot-location new-value))
          (t ; access shared slot
           (setf (svref (cv-shared-slots (car slot-location))
                        (cdr slot-location))
                 new-value)))))
|#
;; The main work is done by a SUBR:
(do-defmethod '(setf slot-value-using-class)
  (make-instance-<standard-method> <standard-method>
    :specializers (list (find-class 't)
                        (find-class 'semi-standard-class)
                        (find-class 't)
                        (find-class 'standard-effective-slot-definition))
    'fast-function #'clos::%set-slot-value-using-class
    'wants-next-method-p nil
    :qualifiers '()
    :lambda-list '(new-value class instance slot)
    'signature #s(system::signature :req-num 4)))

;; MOP p. 94
(defgeneric slot-boundp-using-class (class object slot)
  (declare (dynamically-modifiable)))
(setq |#'slot-boundp-using-class| #'slot-boundp-using-class)
#|
(defmethod slot-boundp-using-class ((class semi-standard-class) instance (slot standard-effective-slot-definition))
  (let ((slot-name (slot-definition-name slot))
        (slot-location (slot-definition-location slot)))
    (cond ((null slot-location)
           (slot-missing class instance slot-name 'slot-boundp))
          ((atom slot-location) ; access local slot
           (not (eq (sys::%record-ref instance slot-location) unbound)))
          (t ; access shared slot
           (not (eq (svref (cv-shared-slots (car slot-location))
                           (cdr slot-location))
                    unbound))))))
|#
;; The main work is done by a SUBR:
(do-defmethod 'slot-boundp-using-class
  (make-instance-<standard-method> <standard-method>
    :specializers (list (find-class 'semi-standard-class)
                        (find-class 't)
                        (find-class 'standard-effective-slot-definition))
    'fast-function #'clos::%slot-boundp-using-class
    'wants-next-method-p nil
    :qualifiers '()
    :lambda-list '(class instance slot)
    'signature #s(system::signature :req-num 3)))

;; MOP p. 96
(defgeneric slot-makunbound-using-class (class object slot)
  (declare (dynamically-modifiable)))
(setq |#'slot-makunbound-using-class| #'slot-makunbound-using-class)
#|
(defmethod slot-makunbound-using-class ((class semi-standard-class) instance (slot standard-effective-slot-definition))
  (let ((slot-name (slot-definition-name slot))
        (slot-location (slot-definition-location slot)))
    (cond ((null slot-location)
           (slot-missing class instance slot-name 'slot-makunbound))
          ((atom slot-location) ; access local slot
           (sys::%record-store instance slot-location unbound))
          (t ; access shared slot
           (setf (svref (cv-shared-slots (car slot-location))
                        (cdr slot-location))
                 unbound)))))
|#
;; The main work is done by a SUBR:
(do-defmethod 'slot-makunbound-using-class
  (make-instance-<standard-method> <standard-method>
    :specializers (list (find-class 'semi-standard-class)
                        (find-class 't)
                        (find-class 'standard-effective-slot-definition))
    'fast-function #'clos::%slot-makunbound-using-class
    'wants-next-method-p nil
    :qualifiers '()
    :lambda-list '(class instance slot)
    'signature #s(system::signature :req-num 3)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-slots2.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-slots1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP: Slots
;;;; Bruno Haible 21.8.1993 - 2004
;;;; Sam Steingold 1998 - 2004
;;;; German comments translated into English: Stefan Kain 2002-04-08

(in-package "CLOS")


#||
;; The access functions could look like this, if we use
;; SLOT-VALUE-USING-CLASS.

 ;; Access to the slots of objects of the metaclass <standard-class>.
 ;; Note that all functions that refer to #<UNBOUND> must be compiled.
 (defun std-slot-value (instance slot-name)
   (declare (compile))
   (let* ((class (class-of instance))
          (slot-location (gethash slot-name (class-slot-location-table class))))
     ((lambda (value)
        (if (eq value unbound)
          (slot-unbound class instance slot-name)
          value))
      (cond ((null slot-location)
             (slot-missing class instance slot-name 'slot-value))
            ((atom slot-location) ; access local slot
             (sys::%record-ref instance slot-location))
            (t ; access shared slot
             (svref (cv-shared-slots (car slot-location))
                    (cdr slot-location)))))))
 (defun std-setf-slot-value (instance slot-name new-value)
   (let* ((class (class-of instance))
          (slot-location (gethash slot-name (class-slot-location-table class))))
     (cond ((null slot-location)
            (slot-missing class instance slot-name 'setf new-value))
           ((atom slot-location) ; access local slot
            (sys::%record-store instance slot-location new-value))
           (t ; access shared slot
            (setf (svref (cv-shared-slots (car slot-location))
                         (cdr slot-location))
                  new-value)))))
 (defun std-slot-boundp (instance slot-name)
   (declare (compile))
   (let* ((class (class-of instance))
          (slot-location (gethash slot-name (class-slot-location-table class))))
     (cond ((null slot-location)
            (slot-missing class instance slot-name 'slot-boundp))
           ((atom slot-location) ; access local slot
            (not (eq (sys::%record-ref instance slot-location) unbound)))
           (t ; access shared slot
            (not (eq (svref (cv-shared-slots (car slot-location))
                            (cdr slot-location))
                     unbound))))))
 (defun std-slot-makunbound (instance slot-name)
   (declare (compile))
   (let* ((class (class-of instance))
          (slot-location (gethash slot-name (class-slot-location-table class))))
     (cond ((null slot-location)
            (slot-missing class instance slot-name 'slot-makunbound))
           ((atom slot-location) ; access local slot
            (sys::%record-store instance slot-location unbound))
           (t ; access shared slot
            (setf (svref (cv-shared-slots (car slot-location))
                         (cdr slot-location))
                  unbound)))))
 (defun std-slot-exists-p (instance slot-name)
   (and (gethash slot-name (class-slot-location-table (class-of instance))) t))

 ;; General access to slots:
 (defun slot-value (object slot-name)
   (let ((class (class-of object)))
     ;; Treat metaclass <standard-class> separately for efficiency reasons
     ;; and because of bootstrapping.
     (if (eq (class-of class) <standard-class>)
       (std-slot-value object slot-name)
       (slot-value-using-class class object slot-name))))
 (defun (setf slot-value) (new-value object slot-name)
   (let ((class (class-of object)))
     ;; Treat metaclass <standard-class> separately for efficiency reasons
     ;; and because of bootstrapping.
     (if (eq (class-of class) <standard-class>)
       (std-setf-slot-value object slot-name new-value)
       (setf-slot-value-using-class new-value class object slot-name))))
 (defun slot-boundp (object slot-name)
   (let ((class (class-of object)))
     ;; Treat metaclass <standard-class> separately for efficiency reasons
     ;; and because of bootstrapping.
     (if (eq (class-of class) <standard-class>)
       (std-slot-boundp object slot-name)
       (slot-boundp-using-class class object slot-name))))
 (defun slot-makunbound (object slot-name)
   (let ((class (class-of object)))
     ;; Treat metaclass <standard-class> separately for efficiency reasons
     ;; and because of bootstrapping.
     (if (eq (class-of class) <standard-class>)
       (std-slot-makunbound object slot-name)
       (slot-makunbound-using-class class object slot-name))))
 (defun slot-exists-p (object slot-name)
   (let ((class (class-of object)))
     ;; Treat metaclass <standard-class> separately for efficiency reasons
     ;; and because of bootstrapping.
     (if (eq (class-of class) <standard-class>)
       (std-slot-exists-p object slot-name)
       (slot-exists-p-using-class class object slot-name))))

 (defun slot-value-using-class (class object slot-name)
   (no-slot-error class object slot-name))
 (defun setf-slot-value-using-class (new-value class object slot-name)
   (declare (ignore new-value))
   (no-slot-error class object slot-name))
 (defun slot-boundp-using-class (class object slot-name)
   (no-slot-error class object slot-name))
 (defun slot-makunbound-using-class (class object slot-name)
   (no-slot-error class object slot-name))
 (defun slot-exists-p-using-class (class object slot-name)
   (no-slot-error class object slot-name))

 (defun no-slot-error (class object slot-name)
   (declare (ignore slot-name))
   (error-of-type 'error
     (TEXT "instance ~S of class ~S has no slots (wrong metaclass)")
     object class))
||#

;; For efficiency - we want to circumvent the test for <standard-class> -,
;; all classes (no matter if standard- or built-in-) get a
;; slot-location-table.
;; Furthermore, we can deal here with unbound only very badly.
;; Hence,
;;   slot-value, set-slot-value, slot-boundp, slot-makunbound, slot-exists-p
;; are now contained already in RECORD.D.

(defsetf slot-value set-slot-value)

;; WITH-SLOTS
(defmacro with-slots (&whole whole-form
                      slot-entries instance-form &body body)
  (let ((vars '())
        (slots '()))
    (unless (listp slot-entries)
      (error-of-type 'ext:source-program-error
        :form whole-form
        :detail slot-entries
        (TEXT "~S: not a list of slots: ~S")
        'with-slots slot-entries))
    (dolist (slot slot-entries)
      (let ((var slot))
        (when (consp slot)
          (unless (eql (length slot) 2)
            (error-of-type 'ext:source-program-error
              :form whole-form
              :detail slot
              (TEXT "~S: invalid slot and variable specification ~S")
              'with-slots slot))
          (setq var (first slot) slot (second slot))
          (unless (symbolp var)
            (error-of-type 'ext:source-program-error
              :form whole-form
              :detail var
              (TEXT "~S: variable ~S should be a symbol")
              'with-slots var)))
        (unless (symbolp slot)
          (error-of-type 'ext:source-program-error
            :form whole-form
            :detail slot
            (TEXT "~S: slot name ~S should be a symbol")
            'with-slots slot))
        (push var vars)
        (push slot slots)))
    (multiple-value-bind (body-rest declarations) (sys::parse-body body)
      (let ((instance-var (gensym)))
        `(LET ((,instance-var ,instance-form))
           (SYMBOL-MACROLET
             ,(mapcar #'(lambda (var slot)
                          `(,var (SLOT-VALUE ,instance-var ',slot)))
                      (nreverse vars) (nreverse slots))
             ,@(if declarations `((DECLARE ,@declarations)))
             ,@body-rest))))))

;; WITH-ACCESSORS
(defmacro with-accessors (&whole whole-form
                          slot-entries instance-form &body body)
  (unless (listp slot-entries)
    (error-of-type 'ext:source-program-error
      :form whole-form
      :detail slot-entries
      (TEXT "~S: not a list of slots: ~S")
      'with-accessors slot-entries))
  (dolist (slot-entry slot-entries)
    (unless (and (consp slot-entry) (eql (length slot-entry) 2))
      (error-of-type 'ext:source-program-error
        :form whole-form
        :detail slot-entry
        (TEXT "~S: invalid slot and accessor specification ~S")
        'with-accessors slot-entry))
    (unless (symbolp (first slot-entry))
      (error-of-type 'ext:source-program-error
        :form whole-form
        :detail (first slot-entry)
        (TEXT "~S: variable ~S should be a symbol")
        'with-accessors (first slot-entry)))
    (unless (symbolp (second slot-entry))
      (error-of-type 'ext:source-program-error
        :form whole-form
        :detail (second slot-entry)
        (TEXT "~S: accessor name ~S should be a symbol")
        'with-accessors (second slot-entry))))
  (multiple-value-bind (body-rest declarations) (sys::parse-body body)
    (let ((instance-var (gensym)))
      `(LET ((,instance-var ,instance-form))
         (SYMBOL-MACROLET
           ,(mapcar #'(lambda (slot-entry)
                        `(,(first slot-entry)
                           (,(second slot-entry) ,instance-var)))
                    slot-entries)
           ,@(if declarations `((DECLARE ,@declarations)))
           ,@body-rest)))))

;; Low-level instance access. MOP p. 100, p. 55.
;; In standard-instance-access and funcallable-standard-instance-access,
;; - the instance can be any standard-object instance (funcallable or not),
;; - the instance can be a non-updated obsolete instance,
;; - the location can refer to a local slot or to a shared slot,
;; - when the slot is not bound, #<UNBOUND> is returned.
;; A setter function is also provided.
(setf (fdefinition 'funcallable-standard-instance-access)
      #'standard-instance-access)
(system::%put 'funcallable-standard-instance-access 'SYSTEM::SETF-FUNCTION
              '|(SETF STANDARD-INSTANCE-ACCESS)|)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-slots1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-slotdef3.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP
;;;; Slot Definition metaobjects
;;;; Part n-1: Generic functions specified in the MOP.
;;;; Bruno Haible 2004-04-18
;;;; Sam Steingold 2017

(in-package "CLOS")


;; Make creation of <slot-definition> instances customizable.
(setf (fdefinition 'make-instance-<standard-direct-slot-definition>) #'make-instance)
(setf (fdefinition 'make-instance-<standard-effective-slot-definition>) #'make-instance)
(setf (fdefinition 'make-instance-<structure-direct-slot-definition>) #'make-instance)
(setf (fdefinition 'make-instance-<structure-effective-slot-definition>) #'make-instance)


#| ;;; Unoptimized slot-definition-xxx accessors.

;; MOP p. 84
(defgeneric slot-definition-name (slotdef)
  (:method ((slotdef slot-definition))
    (slot-value slotdef '$name)))
(initialize-extended-method-check #'slot-definition-name)
(defun (setf slot-definition-name) (new-value slotdef)
  (accessor-typecheck slotdef 'slot-definition '(setf slot-definition-name))
  (setf (slot-value slotdef '$name) new-value))

(defun slot-definition-inheritable-initer (slotdef)
  (accessor-typecheck slotdef 'slot-definition 'slot-definition-inheritable-initer)
  (slot-value slotdef '$inheritable-initer))

;; MOP p. 84
(defgeneric slot-definition-initform (slotdef)
  (:method ((slotdef slot-definition))
    (inheritable-slot-definition-initform (slot-value slotdef '$inheritable-initer))))
(initialize-extended-method-check #'slot-definition-initform)
(defun (setf slot-definition-initform) (new-value slotdef)
  (accessor-typecheck slotdef 'slot-definition '(setf slot-definition-initform))
  (setf (inheritable-slot-definition-initform (slot-value slotdef '$inheritable-initer)) new-value))

;; MOP p. 84
(defgeneric slot-definition-initfunction (slotdef)
  (:method ((slotdef slot-definition))
    (inheritable-slot-definition-initfunction (slot-value slotdef '$inheritable-initer))))
(initialize-extended-method-check #'slot-definition-initfunction)
(defun (setf slot-definition-initfunction) (new-value slotdef)
  (accessor-typecheck slotdef 'slot-definition '(setf slot-definition-initfunction))
  (setf (inheritable-slot-definition-initfunction (slot-value slotdef '$inheritable-initer)) new-value))

;; MOP p. 84
(defgeneric slot-definition-initargs (slotdef)
  (:method ((slotdef slot-definition))
    (slot-value slotdef '$initargs)))
(initialize-extended-method-check #'slot-definition-initargs)
(defun (setf slot-definition-initargs) (new-value slotdef)
  (accessor-typecheck slotdef 'slot-definition '(setf slot-definition-initargs))
  (setf (slot-value slotdef '$initargs) new-value))

;; MOP p. 85
(defgeneric slot-definition-type (slotdef)
  (:method ((slotdef slot-definition))
    (slot-value slotdef '$type)))
(initialize-extended-method-check #'slot-definition-type)
(defun (setf slot-definition-type) (new-value slotdef)
  (accessor-typecheck slotdef 'slot-definition '(setf slot-definition-type))
  (setf (slot-value slotdef '$type) new-value))

;; MOP p. 84
(defgeneric slot-definition-allocation (slotdef)
  (:method ((slotdef slot-definition))
    (slot-value slotdef '$allocation)))
(initialize-extended-method-check #'slot-definition-allocation)
(defun (setf slot-definition-allocation) (new-value slotdef)
  (accessor-typecheck slotdef 'slot-definition '(setf slot-definition-allocation))
  (setf (slot-value slotdef '$allocation) new-value))

(defun slot-definition-inheritable-doc (slotdef)
  (accessor-typecheck slotdef 'slot-definition 'slot-definition-inheritable-doc)
  (slot-value slotdef '$inheritable-doc))

(defun slot-definition-documentation (slotdef)
  (accessor-typecheck slotdef 'slot-definition 'slot-definition-documentation)
  (inheritable-slot-definition-documentation (slot-value slotdef '$inheritable-doc)))
(defun (setf slot-definition-documentation) (new-value slotdef)
  (accessor-typecheck slotdef 'slot-definition '(setf slot-definition-documentation))
  (setf (inheritable-slot-definition-documentation (slot-value slotdef '$inheritable-doc)) new-value))

;; MOP p. 85
(defgeneric slot-definition-readers (slotdef)
  (:method ((slotdef direct-slot-definition))
    (slot-value slotdef '$readers)))
(initialize-extended-method-check #'slot-definition-readers)
(defun (setf slot-definition-readers) (new-value slotdef)
  (accessor-typecheck slotdef 'direct-slot-definition '(setf slot-definition-readers))
  (setf (slot-value slotdef '$readers) new-value))

;; MOP p. 85
(defgeneric slot-definition-writers (slotdef)
  (:method ((slotdef direct-slot-definition))
    (slot-value slotdef '$writers)))
(initialize-extended-method-check #'slot-definition-writers)
(defun (setf slot-definition-writers) (new-value slotdef)
  (accessor-typecheck slotdef 'direct-slot-definition '(setf slot-definition-writers))
  (setf (slot-value slotdef '$writers) new-value))

;; MOP p. 86
(defgeneric slot-definition-location (slotdef)
  (:method ((slotdef effective-slot-definition))
    (slot-value slotdef '$location)))
(initialize-extended-method-check #'slot-definition-location)
(defun (setf slot-definition-location) (new-value slotdef)
  (accessor-typecheck slotdef 'effective-slot-definition '(setf slot-definition-location))
  (setf (slot-value slotdef '$location) new-value))

(defun slot-definition-efm-svuc (slotdef)
  (accessor-typecheck slotdef 'effective-slot-definition 'slot-definition-efm-svuc)
  (slot-value slotdef '$efm-svuc))
(defun (setf slot-definition-efm-svuc) (new-value slotdef)
  (accessor-typecheck slotdef 'effective-slot-definition '(setf slot-definition-efm-svuc))
  (setf (slot-value slotdef '$efm-svuc) new-value))

(defun slot-definition-efm-ssvuc (slotdef)
  (accessor-typecheck slotdef 'effective-slot-definition 'slot-definition-efm-ssvuc)
  (slot-value slotdef '$efm-ssvuc))
(defun (setf slot-definition-efm-ssvuc) (new-value slotdef)
  (accessor-typecheck slotdef 'effective-slot-definition '(setf slot-definition-efm-ssvuc))
  (setf (slot-value slotdef '$efm-ssvuc) new-value))

(defun slot-definition-efm-sbuc (slotdef)
  (accessor-typecheck slotdef 'effective-slot-definition 'slot-definition-efm-sbuc)
  (slot-value slotdef '$efm-sbuc))
(defun (setf slot-definition-efm-sbuc) (new-value slotdef)
  (accessor-typecheck slotdef 'effective-slot-definition '(setf slot-definition-efm-sbuc))
  (setf (slot-value slotdef '$efm-sbuc) new-value))

(defun slot-definition-efm-smuc (slotdef)
  (accessor-typecheck slotdef 'effective-slot-definition 'slot-definition-efm-smuc)
  (slot-value slotdef '$efm-smuc))
(defun (setf slot-definition-efm-smuc) (new-value slotdef)
  (accessor-typecheck slotdef 'effective-slot-definition '(setf slot-definition-efm-smuc))
  (setf (slot-value slotdef '$efm-smuc) new-value))

|#

;;; Optimized slot-definition-xxx accessors.
;;; These are possible thanks to the :fixed-slot-locations class option.

;; MOP p. 84
(defgeneric slot-definition-name (slotdef)
  (:method ((slotdef slot-definition))
    (sys::%record-ref slotdef *<slot-definition>-name-location*)))
(initialize-extended-method-check #'slot-definition-name)
;; Not in MOP.
(defun (setf slot-definition-name) (new-value slotdef)
  (accessor-typecheck slotdef 'slot-definition '(setf slot-definition-name))
  (setf (sys::%record-ref slotdef *<slot-definition>-name-location*) new-value))

;; Not in MOP.
(defun slot-definition-inheritable-initer (slotdef)
  (accessor-typecheck slotdef 'slot-definition 'slot-definition-inheritable-initer)
  (sys::%record-ref slotdef *<slot-definition>-inheritable-initer-location*))
(defun (setf slot-definition-inheritable-initer) (new-value slotdef)
  (accessor-typecheck slotdef 'slot-definition '(setf slot-definition-inheritable-initer))
  (setf (sys::%record-ref slotdef *<slot-definition>-inheritable-initer-location*) new-value))

;; MOP p. 84
(defgeneric slot-definition-initform (slotdef)
  (:method ((slotdef slot-definition))
    (inheritable-slot-definition-initform (sys::%record-ref slotdef *<slot-definition>-inheritable-initer-location*))))
(initialize-extended-method-check #'slot-definition-initform)
;; Not in MOP.
(defun (setf slot-definition-initform) (new-value slotdef)
  (accessor-typecheck slotdef 'slot-definition '(setf slot-definition-initform))
  (setf (inheritable-slot-definition-initform (sys::%record-ref slotdef *<slot-definition>-inheritable-initer-location*)) new-value))

;; MOP p. 84
(defgeneric slot-definition-initfunction (slotdef)
  (:method ((slotdef slot-definition))
    (inheritable-slot-definition-initfunction (sys::%record-ref slotdef *<slot-definition>-inheritable-initer-location*))))
(initialize-extended-method-check #'slot-definition-initfunction)
;; Not in MOP.
(defun (setf slot-definition-initfunction) (new-value slotdef)
  (accessor-typecheck slotdef 'slot-definition '(setf slot-definition-initfunction))
  (setf (inheritable-slot-definition-initfunction (sys::%record-ref slotdef *<slot-definition>-inheritable-initer-location*)) new-value))

;; MOP p. 84
(defgeneric slot-definition-initargs (slotdef)
  (:method ((slotdef slot-definition))
    (sys::%record-ref slotdef *<slot-definition>-initargs-location*)))
(initialize-extended-method-check #'slot-definition-initargs)
;; Not in MOP.
(defun (setf slot-definition-initargs) (new-value slotdef)
  (accessor-typecheck slotdef 'slot-definition '(setf slot-definition-initargs))
  (setf (sys::%record-ref slotdef *<slot-definition>-initargs-location*) new-value))

;; MOP p. 85
(defgeneric slot-definition-type (slotdef)
  (:method ((slotdef slot-definition))
    (sys::%record-ref slotdef *<slot-definition>-type-location*)))
(initialize-extended-method-check #'slot-definition-type)
;; Not in MOP.
(defun (setf slot-definition-type) (new-value slotdef)
  (accessor-typecheck slotdef 'slot-definition '(setf slot-definition-type))
  (setf (sys::%record-ref slotdef *<slot-definition>-type-location*) new-value))

;; MOP p. 84
(defgeneric slot-definition-allocation (slotdef)
  (:method ((slotdef slot-definition))
    (sys::%record-ref slotdef *<slot-definition>-allocation-location*)))
(initialize-extended-method-check #'slot-definition-allocation)
;; Not in MOP.
(defun (setf slot-definition-allocation) (new-value slotdef)
  (accessor-typecheck slotdef 'slot-definition '(setf slot-definition-allocation))
  (setf (sys::%record-ref slotdef *<slot-definition>-allocation-location*) new-value))

;; Not in MOP.
(defun slot-definition-inheritable-doc (slotdef)
  (accessor-typecheck slotdef 'slot-definition 'slot-definition-inheritable-doc)
  (sys::%record-ref slotdef *<slot-definition>-inheritable-doc-location*))
(defun (setf slot-definition-inheritable-doc) (new-value slotdef)
  (accessor-typecheck slotdef 'slot-definition '(setf slot-definition-inheritable-doc))
  (setf (sys::%record-ref slotdef *<slot-definition>-inheritable-doc-location*) new-value))

;; Not in MOP.
(defun slot-definition-documentation (slotdef)
  (accessor-typecheck slotdef 'slot-definition 'slot-definition-documentation)
  (inheritable-slot-definition-documentation (sys::%record-ref slotdef *<slot-definition>-inheritable-doc-location*)))
(defun (setf slot-definition-documentation) (new-value slotdef)
  (accessor-typecheck slotdef 'slot-definition '(setf slot-definition-documentation))
  (setf (inheritable-slot-definition-documentation (sys::%record-ref slotdef *<slot-definition>-inheritable-doc-location*)) new-value))

;; MOP p. 85
(defgeneric slot-definition-readers (slotdef)
  (:method ((slotdef direct-slot-definition))
    (sys::%record-ref slotdef *<direct-slot-definition>-readers-location*)))
(initialize-extended-method-check #'slot-definition-readers)
;; Not in MOP.
(defun (setf slot-definition-readers) (new-value slotdef)
  (accessor-typecheck slotdef 'direct-slot-definition '(setf slot-definition-readers))
  (setf (sys::%record-ref slotdef *<direct-slot-definition>-readers-location*) new-value))

;; MOP p. 85
(defgeneric slot-definition-writers (slotdef)
  (:method ((slotdef direct-slot-definition))
    (sys::%record-ref slotdef *<direct-slot-definition>-writers-location*)))
(initialize-extended-method-check #'slot-definition-writers)
;; Not in MOP.
(defun (setf slot-definition-writers) (new-value slotdef)
  (accessor-typecheck slotdef 'direct-slot-definition '(setf slot-definition-writers))
  (setf (sys::%record-ref slotdef *<direct-slot-definition>-writers-location*) new-value))

;; MOP p. 86
(defgeneric slot-definition-location (slotdef)
  (:method ((slotdef effective-slot-definition))
    (sys::%record-ref slotdef *<effective-slot-definition>-location-location*)))
(initialize-extended-method-check #'slot-definition-location)
;; Not in MOP.
(defun (setf slot-definition-location) (new-value slotdef)
  (accessor-typecheck slotdef 'effective-slot-definition '(setf slot-definition-location))
  (setf (sys::%record-ref slotdef *<effective-slot-definition>-location-location*) new-value))

;; Not in MOP.
(defun slot-definition-efm-svuc (slotdef)
  (accessor-typecheck slotdef 'effective-slot-definition 'slot-definition-efm-svuc)
  (sys::%record-ref slotdef *<effective-slot-definition>-efm-svuc-location*))
(defun (setf slot-definition-efm-svuc) (new-value slotdef)
  (accessor-typecheck slotdef 'effective-slot-definition '(setf slot-definition-efm-svuc))
  (setf (sys::%record-ref slotdef *<effective-slot-definition>-efm-svuc-location*) new-value))

;; Not in MOP.
(defun slot-definition-efm-ssvuc (slotdef)
  (accessor-typecheck slotdef 'effective-slot-definition 'slot-definition-efm-ssvuc)
  (sys::%record-ref slotdef *<effective-slot-definition>-efm-ssvuc-location*))
(defun (setf slot-definition-efm-ssvuc) (new-value slotdef)
  (accessor-typecheck slotdef 'effective-slot-definition '(setf slot-definition-efm-ssvuc))
  (setf (sys::%record-ref slotdef *<effective-slot-definition>-efm-ssvuc-location*) new-value))

;; Not in MOP.
(defun slot-definition-efm-sbuc (slotdef)
  (accessor-typecheck slotdef 'effective-slot-definition 'slot-definition-efm-sbuc)
  (sys::%record-ref slotdef *<effective-slot-definition>-efm-sbuc-location*))
(defun (setf slot-definition-efm-sbuc) (new-value slotdef)
  (accessor-typecheck slotdef 'effective-slot-definition '(setf slot-definition-efm-sbuc))
  (setf (sys::%record-ref slotdef *<effective-slot-definition>-efm-sbuc-location*) new-value))

;; Not in MOP.
(defun slot-definition-efm-smuc (slotdef)
  (accessor-typecheck slotdef 'effective-slot-definition 'slot-definition-efm-smuc)
  (sys::%record-ref slotdef *<effective-slot-definition>-efm-smuc-location*))
(defun (setf slot-definition-efm-smuc) (new-value slotdef)
  (accessor-typecheck slotdef 'effective-slot-definition '(setf slot-definition-efm-smuc))
  (setf (sys::%record-ref slotdef *<effective-slot-definition>-efm-smuc-location*) new-value))


;; MOP p. 45
(defgeneric direct-slot-definition-class (class &rest initargs)
  (declare (dynamically-modifiable))
  (:method ((class semi-standard-class) &rest initargs)
    (declare (ignore initargs))
    <standard-direct-slot-definition>)
  (:method ((class structure-class) &rest initargs)
    (declare (ignore initargs))
    <structure-direct-slot-definition>))

;; MOP p. 45
(defgeneric effective-slot-definition-class (class &rest initargs)
  (declare (dynamically-modifiable))
  (:method ((class semi-standard-class) &rest initargs)
    (declare (ignore initargs))
    <standard-effective-slot-definition>)
  (:method ((class structure-class) &rest initargs)
    (declare (ignore initargs))
    <structure-effective-slot-definition>))

;; Customizable function used to compare two slots of given objects belonging
;; to the same class.
;; Arguments: class is a subclass of <direct-slot-definition>,
;;            (class-of object1) = class,
;;            (class-of object2) = class,
;;            slot is a slot of class,
;;            value1 = (slot-value object1 (slot-definition-name slot)),
;;            value2 = (slot-value object2 (slot-definition-name slot)).
(defgeneric slot-equal-using-class (class object1 object2 slot value1 value2)
  (:method (class (object1 standard-direct-slot-definition) (object2 standard-direct-slot-definition) slot value1 value2)
    (declare (ignore class object1 object2 slot))
    (equal value1 value2)))

;; Test two direct slots for equality, except for the inheritable slots,
;; where only the presence is compared.
(defun equal-direct-slot (slot1 slot2 &aux slot-class)
  (and (eq (setq slot-class (class-of slot1)) (class-of slot2))
       (eq (slot-definition-name slot1) (slot-definition-name slot2))
       (eq (null (slot-definition-initfunction slot1)) (null (slot-definition-initfunction slot2)))
       (eq (null (slot-definition-documentation slot1)) (null (slot-definition-documentation slot2)))
       ;; The MOP doesn't specify an equality method that the user could define,
       ;; therefore we use the generic "compare all slots" approach.
       (dolist (s (class-slots slot-class) t)
         (let ((n (slot-definition-name s)))
           ;; $inheritable-initer covers the :initform :initfunction slot options.
           ;; $inheritable-doc covers the :documentation slot option.
           (unless (memq n '($inheritable-initer $inheritable-doc))
             (let ((unboundp1 (not (slot-boundp slot1 n)))
                   (unboundp2 (not (slot-boundp slot2 n))))
               (unless (and (eq unboundp1 unboundp2)
                            (or unboundp1
                                (slot-equal-using-class slot-class slot1 slot2 s
                                                        (slot-value slot1 n)
                                                        (slot-value slot2 n))))
                 (return nil))))))))

#|
;; Tell the compiler how to serialize <structure-effective-slot-definition>
;; instances. This is needed for DEFSTRUCT.
(defmethod make-load-form ((object structure-effective-slot-definition) &optional environment)
  (declare (ignore environment))
  (make-load-form-<structure-effective-slot-definition> object))
|#
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-slotdef3.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-slotdef2.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP
;;;; Slot Definition metaobjects
;;;; Part n-2: Final class definitions, make/initialize-instance methods.
;;;; Bruno Haible 2004-04-18

(in-package "CLOS")

;;; ===========================================================================

;;; Lift the initialization protocol.

(defmethod initialize-instance ((slotdef slot-definition) &rest args
                                &key name initform initfunction initargs
                                     type allocation documentation
                                     ((inheritable-initer inheritable-initer))
                                     ((inheritable-doc inheritable-doc)))
  (declare (ignore name initform initfunction initargs type allocation
                   documentation inheritable-initer inheritable-doc))
  (apply #'initialize-instance-<slot-definition> slotdef args))

(defmethod initialize-instance ((slotdef direct-slot-definition) &rest args
                                &key name initform initfunction initargs
                                     type allocation documentation
                                     ((inheritable-initer inheritable-initer))
                                     ((inheritable-doc inheritable-doc))
                                     readers writers
                                     ((defclass-form defclass-form)))
  (declare (ignore name initform initfunction initargs type allocation
                   documentation inheritable-initer inheritable-doc readers
                   writers defclass-form))
  (apply #'initialize-instance-<direct-slot-definition> slotdef args))

(defmethod initialize-instance ((slotdef effective-slot-definition) &rest args
                                &key name initform initfunction initargs
                                     type allocation documentation
                                     ((inheritable-initer inheritable-initer))
                                     ((inheritable-doc inheritable-doc)))
  (declare (ignore name initform initfunction initargs type allocation
                   documentation inheritable-initer inheritable-doc))
  (apply #'initialize-instance-<effective-slot-definition> slotdef args))

(defmethod reinitialize-instance ((instance slot-definition) &rest initargs)
  (declare (ignore initargs))
  (error (TEXT "~S: The MOP does not allow reinitializing ~S")
         'reinitialize-instance instance))


;;; ===========================================================================

;;; Now the concrete classes for <standard-class> and <structure-class> slots.

;;; ---------------------------------------------------------------------------

(defmethod initialize-instance ((slotdef standard-direct-slot-definition) &rest args)
  (apply #'initialize-instance-<standard-direct-slot-definition> slotdef args))

;;; ---------------------------------------------------------------------------

(defmethod initialize-instance ((slotdef standard-effective-slot-definition) &rest args)
  (apply #'initialize-instance-<standard-effective-slot-definition> slotdef args))

;;; ---------------------------------------------------------------------------

(defmethod initialize-instance ((slotdef structure-direct-slot-definition) &rest args)
  (apply #'initialize-instance-<structure-direct-slot-definition> slotdef args))

;;; ---------------------------------------------------------------------------

(defun structure-effective-slot-definition-readonly (slotdef)
  (slot-value slotdef '$readonly))
(defun (setf structure-effective-slot-definition-readonly) (new-value slotdef)
  (setf (slot-value slotdef '$readonly) new-value))
(defmethod initialize-instance ((slotdef structure-effective-slot-definition) &rest args)
  (apply #'initialize-instance-<structure-effective-slot-definition> slotdef args))

;;; ===========================================================================

;; Now that all the predefined subclasses of <slot-definition> have been
;; defined, CLASS-OF can work on all existing <slot-definition> instances.
;; Therefore now, not earlier, it's possible to pass these <slot-definition>
;; instances to generic functions.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-slotdef2.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-slotdef1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP
;;;; Slot Definition metaobjects
;;;; Part 1: Class definitions, preliminary accessors, utility functions.
;;;; Bruno Haible 2004-04-18

(in-package "CLOS")

;;; ===========================================================================

;;; The parts of a slot-definition that can be inherited to subclasses, in
;;; such a way that a modification of these values in a superclass can be
;;; adopted by the subclasses without any notification.
;;; We are allowed to do this trick because the functions
;;;   (setf slot-definition-initform)
;;;   (setf slot-definition-initfunction)
;;;   (setf slot-definition-documentation)
;;; are not part of the MOP, i.e. the user is not allowed to modify a
;;; slot-definition after it has been created and initialized.
(defvar *<inheritable-slot-definition-initer>-defclass*
  '(defclass inheritable-slot-definition-initer ()
     ((initform      :type t                  :initarg :initform)
      (initfunction  :type (or null function) :initarg :initfunction))
     (:metaclass structure-class)
     ; (:type cons)
   )
)
(defvar *<inheritable-slot-definition-doc>-defclass*
  '(defclass inheritable-slot-definition-doc ()
     ((documentation :type (or null string)   :initarg :documentation))
     (:metaclass structure-class)
     ; (:type cons)
   )
)

(defmacro inheritable-slot-definition-initform (inheritable)
  `(car ,inheritable))
(defmacro inheritable-slot-definition-initfunction (inheritable)
  `(cdr ,inheritable))
(defun make-inheritable-slot-definition-initer (initform initfunction)
  (cons initform initfunction))

(defmacro inheritable-slot-definition-documentation (inheritable)
  `(car ,inheritable))
(defun make-inheritable-slot-definition-doc (documentation)
  (list documentation))


;;; ===========================================================================

;;; The slot-definition abstract class.

;; Note that the C code can use constant offsets to access the components
;; of <slot-definition> and its subclasses, because
;;   1) The user is not allowed to override methods of the slot-definition-xxx
;;      accessors. (MOP p. 10, 85-86)
;;   2) The user is not allowed to use multiple inheritance between different
;;      categories of metaobjects (MOP p. 3) This allows us to use the
;;      :fixed-slot-locations class option.
;; If this were not possible, we would have to wrap every
;; effective-slot-definition instance in a simple-vector that caches its
;; components. (This is possible because the (setf slot-definition-xxx)
;; functions are not part of the MOP.)

;; Information about a slot, as specified in a DEFCLASS form and kept
;; at runtime.
(defvar *<slot-definition>-defclass*
  '(defclass slot-definition (metaobject)
     (($name         :type symbol             :initarg :name)
      ($initargs     :type list               :initarg :initargs)
      ($type         :type t                  :initarg :type)
      ($allocation   :type symbol             :initarg :allocation)
      ($inheritable-initer :type #| inheritable-slot-definition-initer |# cons
                                              :initarg inheritable-initer)
      ($inheritable-doc :type #| inheritable-slot-definition-doc |# cons
                                              :initarg inheritable-doc))
     (:fixed-slot-locations t)))

;; Information about a slot, as specified in a DEFCLASS form.
(defvar <direct-slot-definition> 'direct-slot-definition)
(defvar *<direct-slot-definition>-defclass*
  '(defclass direct-slot-definition (slot-definition)
     (($readers      :type list               :initarg :readers)
      ($writers      :type list               :initarg :writers))
     (:fixed-slot-locations t)))

;; Information about a slot that is still significant at runtime.
(defvar <effective-slot-definition> 'effective-slot-definition)
(defvar *<effective-slot-definition>-defclass*
  '(defclass effective-slot-definition (slot-definition)
     (($location     :type (or null integer cons)
                                              :initarg location)
      ; effective method for slot-value-using-class
      ($efm-svuc     :type function)
      ; effective method for (setf slot-value-using-class)
      ($efm-ssvuc    :type function)
      ; effective method for slot-boundp-using-class
      ($efm-sbuc     :type function)
      ; effective method for slot-makunbound-using-class
      ($efm-smuc     :type function))
     (:fixed-slot-locations t)))

;; Fixed slot locations.
(defconstant *<slot-definition>-name-location* 1)
(defconstant *<slot-definition>-initargs-location* 2)
(defconstant *<slot-definition>-type-location* 3)
(defconstant *<slot-definition>-allocation-location* 4)
(defconstant *<slot-definition>-inheritable-initer-location* 5)
(defconstant *<slot-definition>-inheritable-doc-location* 6)
(defconstant *<direct-slot-definition>-readers-location* 7)
(defconstant *<direct-slot-definition>-writers-location* 8)
(defconstant *<effective-slot-definition>-location-location* 7)
(defconstant *<effective-slot-definition>-efm-svuc-location* 8)
(defconstant *<effective-slot-definition>-efm-ssvuc-location* 9)
(defconstant *<effective-slot-definition>-efm-sbuc-location* 10)
(defconstant *<effective-slot-definition>-efm-smuc-location* 11)

;; Preliminary accessors.
(predefun slot-definition-name (object)
  (sys::%record-ref object *<slot-definition>-name-location*))
(predefun (setf slot-definition-name) (new-value object)
  (setf (sys::%record-ref object *<slot-definition>-name-location*) new-value))
(predefun slot-definition-inheritable-initer (object)
  (sys::%record-ref object *<slot-definition>-inheritable-initer-location*))
(predefun (setf slot-definition-inheritable-initer) (new-value object)
  (setf (sys::%record-ref object *<slot-definition>-inheritable-initer-location*) new-value))
(predefun slot-definition-initform (object)
  (inheritable-slot-definition-initform (sys::%record-ref object *<slot-definition>-inheritable-initer-location*)))
(predefun (setf slot-definition-initform) (new-value object)
  (setf (inheritable-slot-definition-initform (sys::%record-ref object *<slot-definition>-inheritable-initer-location*)) new-value))
(predefun slot-definition-initfunction (object)
  (inheritable-slot-definition-initfunction (sys::%record-ref object *<slot-definition>-inheritable-initer-location*)))
(predefun (setf slot-definition-initfunction) (new-value object)
  (setf (inheritable-slot-definition-initfunction (sys::%record-ref object *<slot-definition>-inheritable-initer-location*)) new-value))
(predefun slot-definition-initargs (object)
  (sys::%record-ref object *<slot-definition>-initargs-location*))
(predefun (setf slot-definition-initargs) (new-value object)
  (setf (sys::%record-ref object *<slot-definition>-initargs-location*) new-value))
(predefun slot-definition-type (object)
  (sys::%record-ref object *<slot-definition>-type-location*))
(predefun (setf slot-definition-type) (new-value object)
  (setf (sys::%record-ref object *<slot-definition>-type-location*) new-value))
(predefun slot-definition-allocation (object)
  (sys::%record-ref object *<slot-definition>-allocation-location*))
(predefun (setf slot-definition-allocation) (new-value object)
  (setf (sys::%record-ref object *<slot-definition>-allocation-location*) new-value))
(predefun slot-definition-inheritable-doc (object)
  (sys::%record-ref object *<slot-definition>-inheritable-doc-location*))
(predefun (setf slot-definition-inheritable-doc) (new-value object)
  (setf (sys::%record-ref object *<slot-definition>-inheritable-doc-location*) new-value))
(predefun slot-definition-documentation (object)
  (inheritable-slot-definition-documentation (sys::%record-ref object *<slot-definition>-inheritable-doc-location*)))
(predefun (setf slot-definition-documentation) (new-value object)
  (setf (inheritable-slot-definition-documentation (sys::%record-ref object *<slot-definition>-inheritable-doc-location*)) new-value))
(predefun slot-definition-readers (object)
  (sys::%record-ref object *<direct-slot-definition>-readers-location*))
(predefun (setf slot-definition-readers) (new-value object)
  (setf (sys::%record-ref object *<direct-slot-definition>-readers-location*) new-value))
(predefun slot-definition-writers (object)
  (sys::%record-ref object *<direct-slot-definition>-writers-location*))
(predefun (setf slot-definition-writers) (new-value object)
  (setf (sys::%record-ref object *<direct-slot-definition>-writers-location*) new-value))
(predefun slot-definition-location (object)
  (sys::%record-ref object *<effective-slot-definition>-location-location*))
(predefun (setf slot-definition-location) (new-value object)
  (setf (sys::%record-ref object *<effective-slot-definition>-location-location*) new-value))
(predefun slot-definition-efm-svuc (object)
  (sys::%record-ref object *<effective-slot-definition>-efm-svuc-location*))
(predefun (setf slot-definition-efm-svuc) (new-value object)
  (setf (sys::%record-ref object *<effective-slot-definition>-efm-svuc-location*) new-value))
(predefun slot-definition-efm-ssvuc (object)
  (sys::%record-ref object *<effective-slot-definition>-efm-ssvuc-location*))
(predefun (setf slot-definition-efm-ssvuc) (new-value object)
  (setf (sys::%record-ref object *<effective-slot-definition>-efm-ssvuc-location*) new-value))
(predefun slot-definition-efm-sbuc (object)
  (sys::%record-ref object *<effective-slot-definition>-efm-sbuc-location*))
(predefun (setf slot-definition-efm-sbuc) (new-value object)
  (setf (sys::%record-ref object *<effective-slot-definition>-efm-sbuc-location*) new-value))
(predefun slot-definition-efm-smuc (object)
  (sys::%record-ref object *<effective-slot-definition>-efm-smuc-location*))
(predefun (setf slot-definition-efm-smuc) (new-value object)
  (setf (sys::%record-ref object *<effective-slot-definition>-efm-smuc-location*) new-value))

;; Initialization of a <slot-definition> instance.
(defun initialize-instance-<slot-definition> (slotdef &rest args
                                              &key (name nil name-p)
                                                   (initform nil initform-p)
                                                   (initfunction nil initfunction-p)
                                                   (initargs '())
                                                   (type 'T)
                                                   (allocation ':instance)
                                                   (documentation nil)
                                                   ((inheritable-initer inheritable-initer) nil)
                                                   ((inheritable-doc inheritable-doc) nil)
                                              &allow-other-keys)
  (when *classes-finished*
    (apply #'%initialize-instance slotdef args)) ; == (call-next-method)
  (unless name-p
    (error (TEXT "(~S ~S): The slot name is not specified.")
           'initialize-instance 'slot-definition))
  (unless (symbolp name)
    (error (TEXT "(~S ~S): The slot name should be a symbol, not ~S")
           'initialize-instance 'slot-definition name))
  (unless (eq initform-p initfunction-p)
    (error (TEXT "(~S ~S) for slot ~S: The ~S and ~S arguments can only be specified together.")
           'initialize-instance 'slot-definition name ':initform ':initfunction))
  (when initfunction-p
    (when initfunction ; FIXME: defstruct.lisp passes :initfunction nil
      (unless (functionp initfunction)
        (error (TEXT "(~S ~S) for slot ~S: The ~S argument should be a function, not ~S")
               'initialize-instance 'slot-definition name ':initfunction initfunction))))
  (unless (symbolp allocation)
    (error (TEXT "(~S ~S) for slot ~S: The ~S argument should be a symbol, not ~S")
           'initialize-instance 'slot-definition name ':allocation allocation))
  (unless (and (proper-list-p initargs) (every #'symbolp initargs))
    (error (TEXT "(~S ~S) for slot ~S: The ~S argument should be a proper list of symbols, not ~S")
           'initialize-instance 'slot-definition name ':initargs initargs))
  (unless (or (null documentation) (stringp documentation))
    (error (TEXT "(~S ~S) for slot ~S: The ~S argument should be a string or NIL, not ~S")
           'initialize-instance 'slot-definition name :documentation documentation))
  (unless inheritable-initer
    (setq inheritable-initer
          (make-inheritable-slot-definition-initer initform initfunction)))
  (unless inheritable-doc
    (setq inheritable-doc
          (make-inheritable-slot-definition-doc documentation)))
  (setf (slot-definition-name slotdef)               name)
  (setf (slot-definition-initargs slotdef)           initargs)
  (setf (slot-definition-type slotdef)               type)
  (setf (slot-definition-allocation slotdef)         allocation)
  (setf (slot-definition-inheritable-initer slotdef) inheritable-initer)
  (setf (slot-definition-inheritable-doc slotdef)    inheritable-doc)
  slotdef)

;; Initialization of a <direct-slot-definition> instance.
(defun initialize-instance-<direct-slot-definition> (slotdef &rest args
                                                     &key (readers '())
                                                          (writers '())
                                                          ((defclass-form defclass-form))
                                                     &allow-other-keys)
  (declare (ignore defclass-form))
  (apply #'initialize-instance-<slot-definition> slotdef args)
  (unless (and (proper-list-p readers) (every #'sys::function-name-p readers))
    (error (TEXT "(~S ~S) for slot ~S: The ~S argument should be a proper list of function names, not ~S")
           'initialize-instance 'slot-definition (slot-definition-name slotdef) ':readers readers))
  (unless (and (proper-list-p writers) (every #'sys::function-name-p writers))
    (error (TEXT "(~S ~S) for slot ~S: The ~S argument should be a proper list of function names, not ~S")
           'initialize-instance 'slot-definition (slot-definition-name slotdef) ':writers writers))
  (setf (slot-definition-readers slotdef) readers)
  (setf (slot-definition-writers slotdef) writers)
  slotdef)

;; Initialization of a <effective-slot-definition> instance.
(defun initialize-instance-<effective-slot-definition> (slotdef &rest args
                                                        &key ((location location) nil)
                                                        &allow-other-keys)
  (apply #'initialize-instance-<slot-definition> slotdef args)
  (setf (slot-definition-location slotdef) location)
  slotdef)


;;; ===========================================================================

;;; Now the concrete classes for <standard-class> and <structure-class> slots.


;;; ---------------------------------------------------------------------------

;; Common superclass of <standard-direct-slot-definition> and
;; <standard-effective-slot-definition>. Not used otherwise.
(defvar *<standard-slot-definition>-defclass*
  '(defclass standard-slot-definition (slot-definition)
     ()
     (:fixed-slot-locations t)))

;;; ---------------------------------------------------------------------------

;; Information about a slot of <standard-class> in DEFCLASS.
(defvar <standard-direct-slot-definition> 'standard-direct-slot-definition)
(defvar *<standard-direct-slot-definition>-defclass*
  '(defclass standard-direct-slot-definition (direct-slot-definition standard-slot-definition)
     ()
     (:fixed-slot-locations t)))
(defvar *<standard-direct-slot-definition>-class-version* (make-class-version))

;; Initialization of a <standard-direct-slot-definition> instance.
(defun initialize-instance-<standard-direct-slot-definition> (slotdef &rest args
                                                              &key
                                                              &allow-other-keys)
  (apply #'initialize-instance-<direct-slot-definition> slotdef args)
  slotdef)

(defun make-instance-<standard-direct-slot-definition> (class &rest args
                                                        &key &allow-other-keys)
  ;; class = <standard-direct-slot-definition>
  ;; Don't add functionality here! This is a preliminary definition that is
  ;; replaced with #'make-instance later.
  (declare (ignore class))
  (let ((slotdef (allocate-metaobject-instance *<standard-direct-slot-definition>-class-version* 9)))
    (apply #'initialize-instance-<standard-direct-slot-definition> slotdef args)))


;;; ---------------------------------------------------------------------------

;; Information about a slot of <standard-class> at runtime.
(defvar <standard-effective-slot-definition> 'standard-effective-slot-definition)
(defvar *<standard-effective-slot-definition>-defclass*
  '(defclass standard-effective-slot-definition (effective-slot-definition standard-slot-definition)
     ()
     (:fixed-slot-locations t)))
(defvar *<standard-effective-slot-definition>-class-version* (make-class-version))

;; Initialization of a <standard-effective-slot-definition> instance.
(defun initialize-instance-<standard-effective-slot-definition> (slotdef &rest args
                                                                 &key
                                                                 &allow-other-keys)
  (apply #'initialize-instance-<effective-slot-definition> slotdef args)
  slotdef)

(defun make-instance-<standard-effective-slot-definition> (class &rest args
                                                           &key &allow-other-keys)
  ;; class = <standard-effective-slot-definition>
  ;; Don't add functionality here! This is a preliminary definition that is
  ;; replaced with #'make-instance later.
  (declare (ignore class))
  (let ((slotdef (allocate-metaobject-instance *<standard-effective-slot-definition>-class-version* 12)))
    (apply #'initialize-instance-<standard-effective-slot-definition> slotdef args)))


;;; ---------------------------------------------------------------------------

;; Information about a slot of <structure-class> in DEFCLASS.
(defvar <structure-direct-slot-definition> 'structure-direct-slot-definition)
(defvar *<structure-direct-slot-definition>-defclass*
  '(defclass structure-direct-slot-definition (direct-slot-definition)
     ()
     (:fixed-slot-locations t)))
(defvar *<structure-direct-slot-definition>-class-version* (make-class-version))

;; Initialization of a <structure-direct-slot-definition> instance.
(defun initialize-instance-<structure-direct-slot-definition> (slotdef &rest args
                                                               &key &allow-other-keys)
  (apply #'initialize-instance-<direct-slot-definition> slotdef args)
  slotdef)

; ABI
(defun make-instance-<structure-direct-slot-definition> (class &rest args
                                                         &key &allow-other-keys)
  ;; class = <structure-direct-slot-definition>
  ;; Don't add functionality here! This is a preliminary definition that is
  ;; replaced with #'make-instance later.
  (declare (ignore class))
  (let ((slotdef (allocate-metaobject-instance *<structure-direct-slot-definition>-class-version* 9)))
    (apply #'initialize-instance-<structure-direct-slot-definition> slotdef args)))


;;; ---------------------------------------------------------------------------

;; Information about a slot of <structure-class> at runtime.
(defvar <structure-effective-slot-definition> 'structure-effective-slot-definition)
(defvar *<structure-effective-slot-definition>-defclass*
  '(defclass structure-effective-slot-definition (effective-slot-definition)
     (; Inherited slots with different initform.
      ($efm-svuc  :type function :initform #'%slot-value-using-class)
      ($efm-ssvuc :type function :initform #'%set-slot-value-using-class)
      ($efm-sbuc  :type function :initform #'%slot-boundp-using-class)
      ($efm-smuc  :type function :initform #'%slot-makunbound-using-class)
      ; New slots:
      ($readonly :type boolean :initarg readonly))
     (:fixed-slot-locations t)))
(defvar *<structure-effective-slot-definition>-class-version* (make-class-version))

(predefun structure-effective-slot-definition-readonly (object)
  (sys::%record-ref object 12))
(predefun (setf structure-effective-slot-definition-readonly) (new-value object)
  (setf (sys::%record-ref object 12) new-value))

;; Initialization of a <structure-effective-slot-definition> instance.
(defun initialize-instance-<structure-effective-slot-definition> (slotdef &rest args
                                                                  &key ((readonly readonly) nil)
                                                                  &allow-other-keys)
  (apply #'initialize-instance-<effective-slot-definition> slotdef args)
  (setf (slot-definition-efm-svuc slotdef) #'%slot-value-using-class)
  (setf (slot-definition-efm-ssvuc slotdef) #'%set-slot-value-using-class)
  (setf (slot-definition-efm-sbuc slotdef) #'%slot-boundp-using-class)
  (setf (slot-definition-efm-smuc slotdef) #'%slot-makunbound-using-class)
  (setf (structure-effective-slot-definition-readonly slotdef) readonly)
  slotdef)

; ABI
(defun make-instance-<structure-effective-slot-definition> (class &rest args
                                                            &key &allow-other-keys)
  ;; class = <structure-effective-slot-definition>
  ;; Don't add functionality here! This is a preliminary definition that is
  ;; replaced with #'make-instance later.
  (declare (ignore class))
  (let ((slotdef (allocate-metaobject-instance *<structure-effective-slot-definition>-class-version* 13)))
    (apply #'initialize-instance-<structure-effective-slot-definition> slotdef args)))


;;; ===========================================================================

(defun print-object-<slot-definition> (slotdef stream)
  (print-unreadable-object (slotdef stream :type t :identity t)
    (write (slot-definition-name slotdef) :stream stream)))

;; Preliminary.
(predefun compute-direct-slot-definition-initargs (class &rest slot-spec)
  (declare (ignore class))
  slot-spec)

;; Preliminary.
(predefun direct-slot-definition-class (class &rest initargs)
  (declare (ignore class initargs))
  'standard-direct-slot-definition)

;; Converts a list of direct slot specifications (plists) to a list of
;; direct-slot-definition instances.
(defun convert-direct-slots (class direct-slots)
  (mapcar #'(lambda (slot-spec)
              (let ((slot-initargs
                      (apply #'compute-direct-slot-definition-initargs class slot-spec)))
                (unless (and (listp slot-initargs) (evenp (length slot-initargs)))
                  (error (TEXT "Wrong ~S result for class ~S: not a property list: ~S")
                         'compute-direct-slot-definition-initargs (class-name class) slot-initargs))
                (unless (eq (getf slot-initargs ':NAME) (getf slot-spec ':NAME))
                  (error (TEXT "Wrong ~S result for class ~S, slot ~S: value of ~S is wrong: ~S")
                         'compute-direct-slot-definition-initargs (class-name class)
                         (getf slot-spec ':NAME) ':NAME slot-initargs))
                (let ((slot-definition-class
                        (apply #'direct-slot-definition-class class slot-initargs)))
                  (cond ((semi-standard-class-p class)
                         (unless (or ; for bootstrapping
                                     (eq slot-definition-class 'standard-direct-slot-definition)
                                     (and (defined-class-p slot-definition-class)
                                          (subclassp slot-definition-class <standard-direct-slot-definition>)))
                           (error (TEXT "Wrong ~S result for class ~S: not a subclass of ~S: ~S")
                                  'direct-slot-definition-class (class-name class)
                                  'standard-direct-slot-definition slot-definition-class)))
                        ((structure-class-p class)
                         (unless (and (defined-class-p slot-definition-class)
                                      (subclassp slot-definition-class <structure-direct-slot-definition>))
                           (error (TEXT "Wrong ~S result for class ~S: not a subclass of ~S: ~S")
                                  'direct-slot-definition-class (class-name class)
                                  'structure-direct-slot-definition slot-definition-class))))
                  (let ((defclass-form (getf slot-spec 'DEFCLASS-FORM)))
                    (when defclass-form
                      ;; Provide good error messages. The error message from
                      ;; MAKE-INSTANCE later is unintelligible.
                      (let ((valid-keywords
                              (class-valid-initialization-keywords slot-definition-class)))
                        (unless (eq valid-keywords 'T)
                          ;; The valid-keywords contain at least
                          ;; :NAME :READERS :WRITERS :ALLOCATION :INITARGS
                          ;; :INITFORM :INITFUNCTION :TYPE :DOCUMENTATION DEFCLASS-FORM.
                          (do ((specr slot-spec (cddr specr)))
                              ((endp specr))
                            (let ((optionkey (car specr)))
                              (unless (member optionkey valid-keywords)
                                (error-of-type 'ext:source-program-error
                                  :form defclass-form
                                  :detail optionkey
                                  (TEXT "~S ~S, slot option for slot ~S: ~S is not a valid slot option")
                                  'defclass (second defclass-form) (getf slot-spec ':NAME) optionkey))))))))
                  (apply (cond ((eq slot-definition-class 'standard-direct-slot-definition)
                                #'make-instance-<standard-direct-slot-definition>)
                               (t #'make-instance))
                         slot-definition-class slot-initargs))))
          direct-slots))

;; Test two direct slots for equality, except for the inheritable slots,
;; where only the presence is compared.
;; Preliminary.
(predefun equal-direct-slot (slot1 slot2)
  (and (eq (class-of slot1) (class-of slot2))
       (eq (slot-definition-name slot1) (slot-definition-name slot2))
       (equal (slot-definition-initargs slot1) (slot-definition-initargs slot2))
       (equal (slot-definition-type slot1) (slot-definition-type slot2))
       (equal (slot-definition-allocation slot1) (slot-definition-allocation slot2))
       (eq (null (slot-definition-initfunction slot1)) (null (slot-definition-initfunction slot2)))
       (eq (null (slot-definition-documentation slot1)) (null (slot-definition-documentation slot2)))
       (equal (slot-definition-readers slot1) (slot-definition-readers slot2))
       (equal (slot-definition-writers slot1) (slot-definition-writers slot2))))

;; Type test.
(defun direct-slot-definition-p (object)
  (and (std-instance-p object)
       (let ((cv (sys::%record-ref object 0)))
         ; Treat the most frequent case first, for speed and bootstrapping.
         (cond ((eq cv *<standard-direct-slot-definition>-class-version*) t)
               (t ; Now a slow, but general instanceof test.
                 (gethash <direct-slot-definition>
                          (class-all-superclasses (class-of object))))))))

;; Preliminary.
(predefun effective-slot-definition-class (class &rest initargs)
  (declare (ignore class initargs))
  'standard-effective-slot-definition)

;; Type test.
(defun effective-slot-definition-p (object)
  (and (std-instance-p object)
       (let ((cv (sys::%record-ref object 0)))
         ; Treat the most frequent case first, for speed and bootstrapping.
         (cond ((eq cv *<standard-effective-slot-definition>-class-version*) t)
               (t ; Now a slow, but general instanceof test.
                 (gethash <effective-slot-definition>
                          (class-all-superclasses (class-of object))))))))

;; Type test.
(defun standard-effective-slot-definition-p (object)
  (and (std-instance-p object)
       (let ((cv (sys::%record-ref object 0)))
         ; Treat the most frequent case first, for speed and bootstrapping.
         (cond ((eq cv *<standard-effective-slot-definition>-class-version*) t)
               (t ; Now a slow, but general instanceof test.
                 (gethash <standard-effective-slot-definition>
                          (class-all-superclasses (class-of object))))))))

;; To avoid function calls when calling the initfunction of constants, we use
;; a specially tagged function.
(defun make-initfunction-form (form slotname)
  (if (constantp form)
    `(SYS::MAKE-CONSTANT-INITFUNCTION ,form)
    `(FUNCTION ,(sys::concat-pnames "DEFAULT-" slotname)
       (LAMBDA () ,form))))

;; Needed by DEFSTRUCT.
(defun make-load-form-<structure-direct-slot-definition> (object &optional initff)
  `(make-instance-<structure-direct-slot-definition>
    <structure-direct-slot-definition>
    :name               ',(slot-definition-name object)
    :initargs           ',(slot-definition-initargs object)
    :type               ',(slot-definition-type object)
    :allocation         ',(slot-definition-allocation object)
    'inheritable-initer ;; The initfunction is serializable only by virtue
                        ;; of the initfunctionform.
                        ;; It's not necessary to preserve the EQ-ness of
                        ;; the initer between the slot in the class and
                        ;; the slot in its subclasses, because structure
                        ;; classes don't support class redefinition.
                        (make-inheritable-slot-definition-initer
                          ',(slot-definition-initform object)
                          ,initff)
    'inheritable-doc    ',(slot-definition-inheritable-doc object)
    :readers            ',(slot-definition-readers object)
    :writers            ',(slot-definition-writers object)))

;; Needed by DEFSTRUCT.
(defun make-load-form-<structure-effective-slot-definition> (object &optional initff)
  `(make-instance-<structure-effective-slot-definition>
    <structure-effective-slot-definition>
    :name               ',(slot-definition-name object)
    :initargs           ',(slot-definition-initargs object)
    :type               ',(slot-definition-type object)
    :allocation         ',(slot-definition-allocation object)
    'inheritable-initer ;; The initfunction is serializable only by virtue
                        ;; of the initfunctionform.
                        ;; It's not necessary to preserve the EQ-ness of
                        ;; the initer between the slot in the class and
                        ;; the slot in its subclasses, because structure
                        ;; classes don't support class redefinition.
                        (make-inheritable-slot-definition-initer
                          ',(slot-definition-initform object)
                          ,initff)
    'inheritable-doc    ',(slot-definition-inheritable-doc object)
    'location           ',(slot-definition-location object)
    'readonly           ',(structure-effective-slot-definition-readonly object)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-slotdef1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-print.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP: Classes
;;;; Bruno Haible 21.8.1993 - 2004
;;;; Sam Steingold 1998 - 2007, 2017
;;;; German comments translated into English: Stefan Kain 2002-04-08

(in-package "CLOS")


(defgeneric print-object (object stream)
  (declare (dynamically-modifiable))
  (:method ((object t) stream)
    (unless (eq (class-of (class-of object)) <built-in-class>)
      ;; this method exists for things like (PRINT-OBJECT 2 *STANDARD-OUTPUT*)
      ;; and thus this error should never be reached
      (error-of-type 'ext::source-program-error
        :form (list 'print-object object stream) :detail object
        (TEXT "No ~S method for ~S (~S (~S))")
        'print-object object (class-of object) (class-of (class-of object))))
    ;; WRITE does not call PRINT-OBJECT for built-in objects
    ;; thus there will be no infinite recursion
    (write object :stream stream))
  (:method ((object standard-object) stream)
    (if *print-readably*
      (let ((form (make-init-form object)))
        (if form
          (write (sys::make-load-time-eval form) :stream stream)
          (print-unreadable-object (object stream :type t :identity t))))
      (print-unreadable-object (object stream :type t :identity t)))
    object)
  (:method ((object structure-object) stream)
    (system::print-structure object stream)
    object)
  (:method ((object potential-class) stream)
    (print-object-<potential-class> object stream)
    object)
  (:method ((object forward-reference-to-class) stream)
    (print-object-<forward-reference-to-class> object stream)
    object)
  (:method ((object slot-definition) stream)
    (print-object-<slot-definition> object stream)
    object)
  (:method ((object eql-specializer) stream)
    (print-object-<eql-specializer> object stream)
    object)
  (:method ((object method-combination) stream)
    (print-object-<method-combination> object stream)
    object)
  (:method ((object standard-method) stream)
    (print-object-<standard-method> object stream)
    object)
  (:method ((object funcallable-standard-object) stream)
    (print-object-<funcallable-standard-object> object stream)
    object))

#| ;; Commented out because the example in the CLHS description of
   ;; PRINT-UNREADABLE-OBJECT leaves doubts about whether the
   ;;   "print-object object stream => object"
   ;; specification was meant as it is.
   ;; CLISP's printer ignores the value of PRINT-OBJECT anyway.

;; Check that all user-defined print-object methods return the object.
(define-condition print-object-method-warning (warning) ())
(define-condition simple-print-object-method-warning (simple-condition print-object-method-warning) ())
(defun print-object-method-warning (method object result)
  (clos-warn 'simple-print-object-method-warning
    (TEXT "~S: invalid method ~S. ANSI CL requires that every ~S method returns the object as value. Expected ~S, but it returned ~S.")
    'print-object method 'print-object object result))
(defmethod compute-effective-method ((gf (eql #'print-object))
                                     method-combination methods)
  (declare (ignore method-combination))
  (multiple-value-bind (form options) (call-next-method)
    (let ((object-var (gensym))
          (result-var (gensym)))
      (values `(LET ((,result-var ,form))
                 (UNLESS (EQL ,result-var ,object-var)
                   (PRINT-OBJECT-METHOD-WARNING ',(first methods) ,object-var ,result-var))
                 ,object-var)
              (cons `(:ARGUMENTS ,object-var) options)))))
|#

;; Another DEFSTRUCT hook.
(defun defstruct-remove-print-object-method (name) ; ABI
  (let ((method (find-method #'print-object nil
                             (list (find-class name) <t>) nil)))
    (when method (remove-method #'print-object method))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-print.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-package.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP
;;;; Bruno Haible 21.8.1993 - 2004
;;;; Sam Steingold 1998 - 2007, 2009-2010, 2017

;; to use it: (USE-PACKAGE "CLOS").

(in-package "COMMON-LISP")
(pushnew ':mop *features*)
(pushnew ':clos *features*)

(in-package "SYSTEM") ; necessary despite DEFPACKAGE!

;; Defined later, in functions.lisp.
(import 'make-signature)
(import 'sig-req-num)
(import 'sig-opt-num)
(import 'sig-rest-p)
(import 'sig-keys-p)
(import 'sig-keywords)
(import 'sig-allow-p)
(import 'check-function-name)

;; Defined later, in compiler.lisp.
(import '%generic-function-lambda)
(import '%optimize-function-lambda)

(defpackage "CLOS"
  (:nicknames "MOP")
  (:documentation "http://www.lisp.org/HyperSpec/Body/chap-7.html")
  (:import-from "EXT" ext:mapcap ext:proper-list-p)
  (:import-from "SYSTEM"
    ;; Import:
    sys::text                   ; for error messages (i18n.d)
    sys::error-of-type          ; defined in error.d
    sys::check-function-name    ; defined in control.d
    sys::check-symbol           ; defined in control.d
    sys::function-name-p        ; defined in control.d
    sys::function-block-name    ; defined in eval.d
    sys::memq                   ; defined in list.d
    sys::predefun               ; defined in init.lisp
    sys::gensym-list            ; defined in macros2.lisp
    sys::analyze-lambdalist     ; defined in lambdalist.lisp
    sys::make-signature         ; defined in functions.lisp
    sys::sig-req-num sys::sig-opt-num sys::sig-rest-p ; likewise
    sys::sig-keys-p sys::sig-keywords sys::sig-allow-p ; likewise
    ;; clos::class-p clos::defined-class-p ; defined in predtype.d
    ;; clos:class-of clos:find-class ; defined in predtype.d
    ;; clos::typep-class        ; defined in predtype.d
    ;; clos::structure-object-p ; defined in record.d
    ;; clos::std-instance-p clos::allocate-std-instance ; defined in record.d
    ;; clos::%allocate-instance ; defined in record.d
    ;; clos:slot-value clos::set-slot-value ; defined in record.d
    ;; clos:slot-boundp clos:slot-makunbound ; defined in record.d
    ;; clos:slot-exists-p ; defined in record.d
    ;; clos::class-gethash clos::class-tuple-gethash ; defined in hashtabl.d
    sys::%generic-function-lambda ; defined in compiler.lisp
    sys::%optimize-function-lambda ; defined in compiler.lisp
    ;; clos:generic-flet clos:generic-labels ; treated in compiler.lisp
    ;; Export:
    ;; clos::closclass ; property in predtype.d, type.lisp, compiler.lisp
    ;; clos:class      ; used in record.d
    ;; clos:generic-function ; used in type.lisp, compiler.lisp
    ;; clos:standard-generic-function ; used in predtype.d, type.lisp, compiler.lisp
    ;; clos:slot-missing clos:slot-unbound  ; called by record.d
    ;; clos::*make-instance-table*          ; used in record.d
    ;; clos::*reinitialize-instance-table*  ; used in record.d
    ;; clos::initial-reinitialize-instance  ; called by record.d
    ;; clos::initial-initialize-instance    ; called by record.d
    ;; clos::initial-make-instance          ; called by record.d
    ;; clos:print-object                    ; called by io.d
    ;; clos:describe-object                 ; called by user2.lisp
    ;; clos::define-structure-class         ; called by defstruct.lisp
    ;; clos::defstruct-remove-print-object-method ; called by defstruct.lisp
    ;; clos::built-in-class-p               ; called by type.lisp
    ;; clos::subclassp  ; called by type.lisp, used in compiler.lisp
    ;; clos:class-name                      ; used in type.lisp, compiler.lisp
    ;; clos:find-class                      ; used in compiler.lisp
    ;; clos::defgeneric-lambdalist-callinfo ; called by compiler.lisp
    ;; clos::make-generic-function-form     ; called by compiler.lisp
    )) ; defpackage

(in-package "CLOS")

;;; exports: ** also in init.lisp ** !
(export
 '(;; names of functions and macros:
   slot-value slot-boundp slot-makunbound slot-exists-p with-slots
   with-accessors documentation
   find-class class-of defclass defmethod call-next-method next-method-p
   defgeneric generic-function generic-flet generic-labels
   class-name no-applicable-method no-next-method no-primary-method
   find-method add-method remove-method
   compute-applicable-methods method-qualifiers function-keywords
   slot-missing slot-unbound
   print-object describe-object
   make-instance allocate-instance initialize-instance reinitialize-instance
   shared-initialize ensure-generic-function
   make-load-form make-load-form-saving-slots
   change-class update-instance-for-different-class
   update-instance-for-redefined-class make-instances-obsolete
   ;; names of classes:
   class standard-class structure-class built-in-class
   standard-object structure-object
   generic-function standard-generic-function method standard-method
   ;; method combinations
   standard method-combination define-method-combination
   method-combination-error invalid-method-error
   call-method make-method))

;;; MOP exports: ** also in init.lisp ** !
(export '(metaobject
          ;; MOP for dependents
          add-dependent remove-dependent map-dependents update-dependent
          ;; MOP for slot definitions
          slot-definition standard-slot-definition
          direct-slot-definition standard-direct-slot-definition
          effective-slot-definition standard-effective-slot-definition
          slot-definition-name
          slot-definition-initform slot-definition-initfunction
          slot-definition-type slot-definition-allocation
          slot-definition-initargs
          slot-definition-readers slot-definition-writers
          slot-definition-location
          ;; MOP for slot access
          slot-value-using-class slot-boundp-using-class
          slot-makunbound-using-class
          standard-instance-access funcallable-standard-instance-access
          ;; MOP for classes
          class forward-referenced-class
          built-in-class structure-class standard-class
          class-name class-direct-superclasses class-precedence-list
          class-direct-subclasses class-direct-slots class-slots
          class-direct-default-initargs class-default-initargs class-prototype
          class-finalized-p finalize-inheritance
          compute-direct-slot-definition-initargs direct-slot-definition-class
          compute-class-precedence-list
          compute-slots compute-effective-slot-definition
          compute-effective-slot-definition-initargs
          effective-slot-definition-class
          compute-default-initargs
          validate-superclass add-direct-subclass remove-direct-subclass
          standard-accessor-method
          standard-reader-method standard-writer-method
          reader-method-class writer-method-class
          ensure-class ensure-class-using-class
          ;; MOP for specializers
          specializer eql-specializer
          specializer-direct-generic-functions specializer-direct-methods
          add-direct-method remove-direct-method
          eql-specializer-object intern-eql-specializer
          ;; MOP for methods
          method standard-method
          method-function method-generic-function method-lambda-list
          method-specializers method-qualifiers accessor-method-slot-definition
          extract-lambda-list extract-specializer-names
          ;; MOP for method combinations
          find-method-combination compute-effective-method
          ;; MOP for generic functions
          funcallable-standard-class funcallable-standard-object
          set-funcallable-instance-function
          generic-function-name generic-function-methods
          generic-function-method-class generic-function-lambda-list
          generic-function-method-combination
          generic-function-argument-precedence-order
          generic-function-declarations
          compute-discriminating-function
          compute-applicable-methods compute-applicable-methods-using-classes
          compute-effective-method-as-function
          ensure-generic-function ensure-generic-function-using-class
          ;; CLISP specific symbols
          generic-flet generic-labels no-primary-method
          method-call-error method-call-type-error
          method-call-error-generic-function
          method-call-error-method method-call-error-argument-list
          standard-stablehash structure-stablehash dynamically-modifiable
          clos-warning gf-already-called-warning gf-replacing-method-warning
          clos-novice-warning clos-style-warning class-obsolescence-warning
)        )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-package.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-method4.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP
;;;; Methods
;;;; Part n-1: Generic functions specified in the MOP.
;;;; Bruno Haible 2004-06-01

(in-package "CLOS")


;; Make creation of <standard-method> instances customizable.
(setf (fdefinition 'make-instance-<standard-method>) #'make-instance)

;; Make creation of <standard-reader-method>, <standard-writer-method>
;; instances customizable.
(setf (fdefinition 'make-instance-<standard-reader-method>) #'make-instance)
(setf (fdefinition 'make-instance-<standard-writer-method>) #'make-instance)

;; Make creation of method instances customizable.
(setf (fdefinition 'make-method-instance) #'make-instance) ; ABI
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-method4.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-method3.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP
;;;; Methods
;;;; Part n-2: make/initialize-instance methods, generic functions.
;;;; Bruno Haible 21.8.1993 - 2004
;;;; Sam Steingold 1998 - 2004, 2010, 2017
;;;; German comments translated into English: Stefan Kain 2002-04-08

(in-package "CLOS")


;;; Lift the initialization protocol.

(defmethod initialize-instance ((method method) &rest args
                                &key ((from-defgeneric from-defgeneric) nil)
                                     ((backpointer backpointer) nil)
                                &allow-other-keys)
  (declare (ignore from-defgeneric backpointer))
  (apply #'initialize-instance-<method> method args))

(defmethod initialize-instance ((method standard-method) &rest args
                                &key qualifiers
                                     lambda-list
                                     specializers
                                     function
                                     documentation
                                     ((fast-function fast-function) nil)
                                     ((wants-next-method-p wants-next-method-p) nil)
                                     ((signature signature) nil)
                                     ((gf gf) nil)
                                     ((from-defgeneric from-defgeneric) nil)
                                     ((backpointer backpointer) nil)
                                &allow-other-keys)
  (declare (ignore qualifiers lambda-list specializers function documentation
                   fast-function wants-next-method-p signature gf
                   from-defgeneric backpointer))
  (apply #'initialize-instance-<standard-method> method args))

(defmethod initialize-instance ((method standard-accessor-method) &rest args
                                &key slot-definition
                                &allow-other-keys)
  (declare (ignore slot-definition))
  (apply #'initialize-instance-<standard-accessor-method> method args))

(defmethod reinitialize-instance ((instance method) &rest initargs)
  (declare (ignore initargs))
  (error (TEXT "~S: The MOP does not allow reinitializing ~S")
         'reinitialize-instance instance))


;; MOP p. 82
(fmakunbound 'method-function)
(defgeneric method-function (method)
  (:method ((method standard-method))
    (std-method-function-or-substitute method)))
(initialize-extended-method-check #'method-function)

;; MOP p. 82
(let ((*allow-making-generic* t))
  (defgeneric method-qualifiers (method)
    (declare (dynamically-modifiable))
    (:method ((method standard-method))
      (std-method-qualifiers method))))
(setq |#'method-qualifiers| #'method-qualifiers)
; No extended method check because this GF is specified in ANSI CL.
;(initialize-extended-method-check #'method-qualifiers)

;; MOP p. 82
(fmakunbound 'method-lambda-list)
(defgeneric method-lambda-list (method)
  (:method ((method standard-method))
    (std-method-lambda-list method)))
(initialize-extended-method-check #'method-lambda-list)

;; Not in MOP.
(let ((*allow-making-generic* t))
  (defgeneric method-signature (method)
    (:method ((method method))
      (let ((lambda-list (method-lambda-list method)))
        (method-lambda-list-to-signature lambda-list
          #'(lambda (form detail errorstring &rest arguments)
              (sys::lambda-list-error form detail
                (TEXT "Invalid ~S result for ~S: ~:S: ~?")
                'method-lambda-list method lambda-list
                errorstring arguments)))))
    (:method ((method standard-method))
      (std-method-signature method))))

;; MOP p. 82
(let ((*allow-making-generic* t))
  (defgeneric method-specializers (method)
    (:method ((method standard-method))
      (std-method-specializers method))))
(setq |#'method-specializers| #'method-specializers)
(initialize-extended-method-check #'method-specializers)

;; MOP p. 82
(let ((*allow-making-generic* t))
  (defgeneric method-generic-function (method)
    (declare (dynamically-modifiable))
    (:method ((method standard-method))
      (std-method-generic-function method))))
(initialize-extended-method-check #'method-generic-function)
;; Not in MOP.
(let ((*allow-making-generic* t))
  (defgeneric (setf method-generic-function) (new-gf method)
    (declare (dynamically-modifiable))
    (:method (new-gf (method standard-method))
      (setf (std-method-generic-function method) new-gf))))

(defgeneric function-keywords (method)
  (declare (dynamically-modifiable))
  (:method ((method standard-method))
    (let ((sig (method-signature method)))
      (values (sig-keywords sig) (sig-allow-p sig)))))

;; MOP p. 82-83
(defgeneric accessor-method-slot-definition (method)
  (:method ((method standard-accessor-method))
    (%accessor-method-slot-definition method)))
(initialize-extended-method-check #'accessor-method-slot-definition)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-method3.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-method2.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP: Methods
;;;; Bruno Haible 21.8.1993 - 2004
;;;; Sam Steingold 1998 - 2004, 2008, 2010, 2017
;;;; German comments translated into English: Stefan Kain 2002-04-08

(in-package "CLOS")

;; ANSI CL 3.4.3. Specialized Lambda Lists
;; Decompose a specialized lambda list into
;; 1. an ordinary lambda list,
;; 2. a list of specializers for the required arguments,
;; 3. a list of ignorable required parameters.
(defun decompose-specialized-lambda-list (specialized-lambda-list errfunc)
  (let ((remaining-lambda-list specialized-lambda-list)
        (req-vars '())
        (ignorable-req-vars '())
        (spec-list '()))
    (do ()
        ((or (atom remaining-lambda-list)
             (memq (car remaining-lambda-list) lambda-list-keywords)))
      (let ((item (pop remaining-lambda-list)))
        ;; item can be a variable or of the form (variable specializer-name).
        ;; ANSI CL 3.4.3. also allows the syntax (variable), but the DEFMETHOD
        ;; description forbids it, and the DEFGENERIC description refers to it.
        (if (atom item)
          (progn
            (push item req-vars)
            (push 't spec-list))
          (if (and (consp (cdr item)) (null (cddr item)))
            (progn
              (push (first item) req-vars)
              (push (first item) ignorable-req-vars) ; CLtL2 p. 840 top
              (push (second item) spec-list))
            (funcall errfunc specialized-lambda-list item
              (TEXT "Invalid specialized parameter in method lambda list ~S: ~S")
              specialized-lambda-list item)))))
    (let ((lambda-list (nreconc req-vars remaining-lambda-list)))
      (analyze-lambdalist lambda-list errfunc)
      (values lambda-list (nreverse spec-list) (nreverse ignorable-req-vars)))))

;; helper
(defmacro program-error-reporter (caller)
  `(lambda (form detail errorstring &rest arguments)
     (sys::lambda-list-error form detail "~S: ~?" ,caller errorstring arguments)))

;; MOP p. 52
(defun extract-lambda-list (specialized-lambda-list)
  (nth-value 0
    (decompose-specialized-lambda-list
      specialized-lambda-list
      (program-error-reporter 'extract-lambda-list))))

;; MOP p. 53
(defun extract-specializer-names (specialized-lambda-list)
  (nth-value 1
    (decompose-specialized-lambda-list
      specialized-lambda-list
      (program-error-reporter 'extract-specializer-names))))

;;; For DEFMETHOD, DEFGENERIC, GENERIC-FUNCTION, GENERIC-FLET,
;;;     GENERIC-LABELS, WITH-ADDED-METHODS
;; caller: symbol
;; whole-form: whole source form
;; funname: function name, symbol or (SETF symbol)
;; description: (qualifier* spec-lambda-list {declaration|docstring}* form*)
;; ==>
;; 1. a function lambda, to be applied to a backpointer cons (that will later
;;    point back to the method object), that returns a cons h with
;;    (car h) = fast-function,
;;    (cadr h) = true if the compiler could optimize away the ",cont" variable.
;; 2. method-initargs-forms,
;; 3. signature
(defun analyze-method-description (caller whole-form funname description)
  ;; Collect the qualifiers:
  (let ((qualifiers nil))
    (loop
      (when (atom description)
        (error-of-type 'ext:source-program-error
          :form whole-form
          :detail description
          (TEXT "~S ~S: missing lambda list")
          caller funname))
      (when (listp (car description)) (return))
      (push (pop description) qualifiers))
    (setq qualifiers (nreverse qualifiers))
    ;; Build lambdalist, extract parameter-specializers and signature:
    (let ((specialized-lambda-list (car description))
          (body (cdr description)))
      (multiple-value-bind (lambda-list spec-list ignorable-req-vars)
          (decompose-specialized-lambda-list specialized-lambda-list
            #'(lambda (form detail errorstring &rest arguments)
                (declare (ignore form)) ; FORM is lambda-list, use WHOLE-FORM
                (sys::lambda-list-error whole-form detail
                  "~S ~S: ~?" caller funname errorstring arguments)))
        (let ((req-specializer-forms
                (mapcar #'(lambda (specializer-name)
                            (cond ((defined-class-p specializer-name)
                                   `',specializer-name)
                                  ((symbolp specializer-name)
                                   `(FIND-CLASS ',specializer-name))
                                  ((and (consp specializer-name)
                                        (eq (car specializer-name) 'EQL)
                                        (consp (cdr specializer-name))
                                        (null (cddr specializer-name)))
                                   `(INTERN-EQL-SPECIALIZER ,(second specializer-name)))
                                  (t (error-of-type 'ext:source-program-error
                                       :form whole-form
                                       :detail specializer-name
                                       (TEXT "~S ~S: Invalid specializer ~S in lambda list ~S")
                                       caller funname specializer-name specialized-lambda-list))))
                        spec-list)))
          (check-method-redefinition funname qualifiers spec-list caller)
          (multiple-value-bind (reqvars optvars optinits optsvars rest
                                keyp keywords keyvars keyinits keysvars
                                allowp auxvars auxinits)
              (analyze-lambdalist lambda-list
                #'(lambda (lalist detail errorstring &rest arguments)
                    (declare (ignore lalist)) ; use WHOLE-FORM instead
                    (sys::lambda-list-error whole-form detail
                      "~S ~S: ~?" caller funname errorstring arguments)))
            (declare (ignore optinits optsvars keyvars keyinits keysvars
                             auxvars auxinits))
            (let ((reqnum (length reqvars))
                  (optnum (length optvars))
                  (restp (or keyp (not (eql rest 0))))
                  (weakened-lambda-list lambda-list))
              ;; Methods have an implicit &allow-other-keys (CLtL2 28.1.6.4., ANSI CL 7.6.4.):
              (when (and keyp (not allowp))
                (let ((index (+ (position '&KEY lambda-list :test #'eq) 1 (length keywords))))
                  (setq weakened-lambda-list
                    `(,@(subseq lambda-list 0 index) &ALLOW-OTHER-KEYS
                      ,@(subseq lambda-list index)))))
              (let* ((backpointer (gensym))
                     (compile-decl nil)
                     (documentation nil)
                     (lambdabody
                       (multiple-value-bind (body-rest declarations docstring compile-name)
                           (sys::parse-body body t)
                         (setq compile-decl
                               (case compile-name
                                 (0 '()) (1 '((DECLARE (COMPILE))))
                                 (t `((DECLARE (COMPILE ,compile-name))))))
                         (setq documentation docstring)
                         (when ignorable-req-vars
                           (push `(IGNORABLE ,@ignorable-req-vars) declarations))
                         (let ((lambdabody-part1
                                `(,weakened-lambda-list
                                  ,@(if declarations `((DECLARE ,@declarations)))))
                               (lambdabody-part2
                                 (if (eq caller 'generic-function)
                                   body-rest
                                   ;; implicit block
                                   `((BLOCK ,(function-block-name funname)
                                       ,@body-rest)))))
                           (let ((cont (gensym)) ; variable for the continuation
                                 (req-dummies (gensym-list reqnum))
                                 (rest-dummy (if (or restp (> optnum 0)) (gensym)))
                                 (lambda-expr `(LAMBDA ,@lambdabody-part1 ,@lambdabody-part2)))
                             `(; new lambda-list:
                               (,cont
                                ,@req-dummies
                                ,@(if rest-dummy `(&REST ,rest-dummy) '()))
                               ,(add-next-method-local-functions
                                  backpointer cont req-dummies rest-dummy
                                  ;; new body:
                                  (list
                                    (if rest-dummy
                                      `(APPLY (FUNCTION ,lambda-expr)
                                              ,@req-dummies ,rest-dummy)
                                      `(,lambda-expr ,@req-dummies)))))))))
                     (sig (make-signature :req-num reqnum :opt-num optnum
                                          :rest-p restp :keys-p keyp
                                          :keywords keywords :allow-p allowp)))
                (values
                  `(LAMBDA (,backpointer)
                     ,@compile-decl
                     (%OPTIMIZE-FUNCTION-LAMBDA (T) ,@lambdabody))
                  `(:QUALIFIERS ',qualifiers
                    :LAMBDA-LIST ',lambda-list
                    'SIGNATURE ,sig
                    :SPECIALIZERS (LIST ,@req-specializer-forms)
                    ,@(if documentation `(:DOCUMENTATION ',documentation))
                    ,@(if (eq caller 'DEFGENERIC) `('FROM-DEFGENERIC T)))
                  sig)))))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-method2.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-method1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP: Methods
;;;; Bruno Haible 21.8.1993 - 2004
;;;; Sam Steingold 1998 - 2004, 2007, 2010, 2017
;;;; German comments translated into English: Stefan Kain 2002-04-08

(in-package "CLOS")


;;; ---------------------------------------------------------------------------

(defparameter <method>
  (defclass method (standard-stablehash metaobject)
    (($from-defgeneric     ; flag, if this method comes from a DEFGENERIC
       :type boolean
       :accessor method-from-defgeneric))
    (:fixed-slot-locations t)
    (:generic-accessors nil)))

(defun initialize-instance-<method> (method &rest args
                                     &key ((from-defgeneric from-defgeneric) nil)
                                          ((backpointer backpointer) nil backpointer-p)
                                     &allow-other-keys)
  (if *classes-finished*
    (apply #'%initialize-instance method args) ; == (call-next-method)
    ; Bootstrapping: Simulate the effect of #'%initialize-instance.
    (apply #'shared-initialize-<standard-stablehash> method 't args))
  ; Fill the slots.
  (setf (method-from-defgeneric method) from-defgeneric)
  ; Fill the backpointer. This is needed for NO-NEXT-METHOD to work: When
  ; CALL-NEXT-METHOD is called from within the method function without a next
  ; method being available, the method function must call NO-NEXT-METHOD with
  ; the method object as argument. But since the method function is called
  ; with the argument list and the remaining methods list as arguments, it
  ; cannot know about the method object to which it belongs. We solve this
  ; paradox by constructing a backpointer cons that the method function
  ; has access to and that points back to the method object after it has been
  ; initialized.
  (when backpointer-p
    (setf (car backpointer) method))
  method)

;;; ---------------------------------------------------------------------------

(defparameter <standard-method> ; ABI
  (defclass standard-method (method)
    (($fast-function       ; the function with fast calling conventions, i.e.
                           ; argument list (&rest arguments) or
                           ; (next-methods-function &rest arguments), depending
                           ; on wants-next-method-p
       :type (or null function)
       :accessor std-method-fast-function)
     ($wants-next-method-p ; flag, if the NEXT-METHOD (as function with all
                           ; arguments) resp. NIL is to be passed as first
                           ; argument (= NIL for :BEFORE- and :AFTER-methods)
       :type boolean
       :accessor std-method-wants-next-method-p)
     ($function            ; the function with slow calling conventions, i.e.
                           ; argument list (arguments next-methods-list)
       :type (or null function)
       :accessor std-method-function)
     ($specializers        ; list of specializers, e.g. classes or
                           ; eql-specializers
       :type list
       :accessor std-method-specializers)
     ($qualifiers          ; list of non-NIL atoms, e.g. (:before)
       :type list
       :accessor std-method-qualifiers)
     ($lambda-list         ; lambda list without specializers
       :type list
       :accessor std-method-lambda-list)
     ($signature           ; signature struct (see functions.lisp)
       :type (simple-vector 6)
       :accessor std-method-signature)
     ($documentation       ; string or NIL
       :type (or string null)
       :accessor std-method-documentation)
     ($gf                  ; the generic function, which this method belongs to
                           ; (only for the purpose of CALL-NEXT-METHOD and
                           ; NO-NEXT-METHOD)
       :type (or null generic-function)
       :accessor std-method-generic-function))
    (:fixed-slot-locations t)
    (:generic-accessors nil)))

;; Note about the argument passing convention for methods:
;; 1) The MOP description of COMPUTE-EFFECTIVE-METHOD and MAKE-METHOD-LAMBDA
;;    says that a method function takes 2 arguments: the list of arguments (!)
;;    and the list of next methods. This is awfully inefficient, and useless
;;    (since MAKE-METHOD-LAMBDA is ill-designed anyway). Therefore here we
;;    pass to the function the arguments as-is, and the next methods as
;;    inserted first argument, if needed.
;; 2) Instead of the list of next methods, we pass an effective method that
;;    consists of these next methods. This is more efficient (saves a FUNCALL)
;;    for the simple case of a single applicable method, but is less
;;    efficient (a FUNCALL instead of just a CAR) for longer lists of methods.
;; 3) We don't explicitly pass the generic function to the method during the
;;    invocation. However, for CALL-NEXT-METHOD, NO-NEXT-METHOD and
;;    METHOD-GENERIC-FUNCTION the generic function must be known. So we have
;;    to store a generic function backpointer in the method.

(defun method-lambda-list-to-signature (lambda-list errfunc)
  (multiple-value-bind (reqvars optvars optinits optsvars rest
                        keyp keywords keyvars keyinits keysvars
                        allowp auxvars auxinits)
      (analyze-lambdalist lambda-list errfunc)
    (declare (ignore optinits optsvars keyvars keyinits keysvars
                     auxvars auxinits))
    (make-signature
      :req-num (length reqvars) :opt-num (length optvars)
      :rest-p (or keyp (not (eql rest 0))) :keys-p keyp
      :keywords keywords :allow-p allowp)))

(defun initialize-instance-<standard-method> (method &rest args
                                              &key (qualifiers '())
                                                   (lambda-list nil lambda-list-p)
                                                   (specializers nil specializers-p)
                                                   (function nil function-p)
                                                   (documentation nil)
                                                   ((fast-function fast-function) nil fast-function-p)
                                                   ((wants-next-method-p wants-next-method-p) nil)
                                                   ((signature signature) nil signature-p)
                                                   ((gf gf) nil)
                                                   ((from-defgeneric from-defgeneric) nil)
                                                   ((backpointer backpointer) nil)
                                              &allow-other-keys)
  (declare (ignore from-defgeneric backpointer))
  (apply #'initialize-instance-<method> method args) ; == (call-next-method)
  ; Check the qualifiers.
  (unless (proper-list-p qualifiers)
    (error (TEXT "(~S ~S): The ~S argument should be a proper list, not ~S")
           'initialize-instance 'standard-method ':qualifiers qualifiers))
  (unless (notany #'listp qualifiers)
    (error (TEXT "(~S ~S): The qualifiers list should consist of non-NIL atoms, not ~S")
           'initialize-instance 'standard-method qualifiers))
  ; Check the lambda-list and compute the signature from it.
  (unless lambda-list-p
    (error (TEXT "(~S ~S): Missing ~S argument.")
           'initialize-instance 'standard-method ':lambda-list))
  (let ((sig (method-lambda-list-to-signature lambda-list
               #'(lambda (form detail errorstring &rest arguments)
                   (sys::lambda-list-error form detail
                     (TEXT "(~S ~S): Invalid ~S argument: ~?")
                     'initialize-instance 'standard-method ':lambda-list
                     errorstring arguments)))))
    ; Check the signature argument. It is optional; specifying it only has
    ; the purpose of saving memory allocation (by sharing the same signature
    ; for all reader methods and the same signature for all writer methods).
    (if signature-p
      (unless (equalp sig signature)
        (error (TEXT "(~S ~S): Lambda-list ~S and signature ~S are inconsistent.")
               'initialize-instance 'standard-method lambda-list signature))
      (setq signature sig)))
  ; Check the specializers.
  (unless specializers-p
    (error (TEXT "(~S ~S): Missing ~S argument.")
           'initialize-instance 'standard-method ':specializers))
  (unless (proper-list-p specializers)
    (error (TEXT "(~S ~S): The ~S argument should be a proper list, not ~S")
           'initialize-instance 'standard-method ':specializers specializers))
  (dolist (x specializers)
    (unless (or (defined-class-p x) (eql-specializer-p x))
      (if (typep x 'specializer)
        (error (TEXT "(~S ~S): The element ~S of the ~S argument is not yet defined.")
               'initialize-instance 'standard-method x ':specializers)
        (error (TEXT "(~S ~S): The element ~S of the ~S argument is not of type ~S.")
               'initialize-instance 'standard-method x ':specializers 'specializer))))
  (unless (= (length specializers) (sig-req-num signature))
    (error (TEXT "(~S ~S): The lambda list ~S has ~S required arguments, but the specializers list ~S has length ~S.")
           'initialize-instance 'standard-method lambda-list (sig-req-num signature)
           specializers (length specializers)))
  ; Check the function, fast-function and wants-next-method-p.
  (unless (or function-p fast-function-p)
    (error (TEXT "(~S ~S): Missing ~S argument.")
           'initialize-instance 'standard-method ':function))
  (when function-p
    (unless (functionp function)
      (error (TEXT "(~S ~S): The ~S argument should be a function, not ~S")
             'initialize-instance 'standard-method ':function function)))
  (when fast-function-p
    (unless (functionp fast-function)
      (error (TEXT "(~S ~S): The ~S argument should be a function, not ~S")
             'initialize-instance 'standard-method 'fast-function fast-function)))
  (unless (typep wants-next-method-p 'boolean)
    (error (TEXT "(~S ~S): The ~S argument should be a NIL or T, not ~S")
           'initialize-instance 'standard-method 'wants-next-method-p  wants-next-method-p))
  (when function-p
    ;; :function overrides fast-function and wants-next-method-p, because it is
    ;; the standardized way (employed by user-defined method classes) to define
    ;; the behaviour of a method.
    (setq fast-function nil
          wants-next-method-p t))
  ; Check the documentation.
  (unless (or (null documentation) (stringp documentation))
    (error (TEXT "(~S ~S): The ~S argument should be a string or NIL, not ~S")
           'initialize-instance 'standard-method ':documentation documentation))
  ; Fill the slots.
  (setf (std-method-fast-function method) fast-function)
  (setf (std-method-wants-next-method-p method) wants-next-method-p)
  (setf (std-method-function method) function)
  (setf (std-method-specializers method) specializers)
  (setf (std-method-qualifiers method) qualifiers)
  (setf (std-method-lambda-list method) lambda-list)
  (setf (std-method-signature method) signature)
  (setf (std-method-documentation method) documentation)
  (setf (std-method-generic-function method) gf)
  method)

(defun make-instance-<standard-method> (class &rest args
                                        &key &allow-other-keys)
  ;; class = <standard-method>
  ;; Don't add functionality here! This is a preliminary definition that is
  ;; replaced with #'make-instance later.
  (declare (ignore class))
  (let ((method (%allocate-instance <standard-method>)))
    (apply #'initialize-instance-<standard-method> method args)))

(defun print-object-<standard-method> (method stream)
  (print-unreadable-object (method stream :type t)
    (if (and (not (eq (sys::%unbound) (std-method-qualifiers method)))
             (not (eq (sys::%unbound) (std-method-specializers method))))
      (progn
        (dolist (q (std-method-qualifiers method))
          (write q :stream stream)
          (write-char #\Space stream))
        (write (mapcar #'specializer-pretty (std-method-specializers method))
               :stream stream))
      (write :uninitialized :stream stream))))

;; Preliminary.
;; During bootstrapping, only <standard-method> instances are used.
(defun make-method-instance (class &rest args ; ABI
                             &key &allow-other-keys)
  (apply #'make-instance-<standard-method> class args))
(predefun method-function (method)
  (std-method-function-or-substitute method))
(predefun method-qualifiers (method)
  (std-method-qualifiers method))
(predefun method-lambda-list (method)
  (std-method-lambda-list method))
(predefun method-signature (method)
  (std-method-signature method))
(predefun method-specializers (method)
  (std-method-specializers method))
(predefun method-generic-function (method)
  (std-method-generic-function method))
(predefun (setf method-generic-function) (new-gf method)
  (setf (std-method-generic-function method) new-gf))

;;; ---------------------------------------------------------------------------

(defparameter <standard-accessor-method>
  (defclass standard-accessor-method (standard-method)
    (($slot-definition     ; direct slot definition responsible for this method
       :type direct-slot-definition
       :accessor %accessor-method-slot-definition))
    (:fixed-slot-locations t)
    (:generic-accessors nil)))

(defun initialize-instance-<standard-accessor-method> (method &rest args
                                                       &key (slot-definition nil slot-definition-p)
                                                       &allow-other-keys)
  (apply #'initialize-instance-<standard-method> method args) ; == (call-next-method)
  ; Check the slot-definition.
  (unless slot-definition-p
    (error (TEXT "(~S ~S): Missing ~S argument.")
           'initialize-instance 'standard-accessor-method ':slot-definition))
  (unless (typep slot-definition 'direct-slot-definition)
    (error (TEXT "(~S ~S): Argument ~S is not of type ~S.")
           'initialize-instance 'standard-accessor-method ':slot-definition
           'direct-slot-definition))
  ; Fill the slots.
  (setf (%accessor-method-slot-definition method) slot-definition)
  method)

;;; ---------------------------------------------------------------------------

(defparameter <standard-reader-method>
  (defclass standard-reader-method (standard-accessor-method)
    ()
    (:fixed-slot-locations t)))

(defun make-instance-<standard-reader-method> (class &rest args
                                               &key &allow-other-keys)
  ;; class = <standard-reader-method>
  ;; Don't add functionality here! This is a preliminary definition that is
  ;; replaced with #'make-instance later.
  (declare (ignore class))
  (let ((method (%allocate-instance <standard-reader-method>)))
    (apply #'initialize-instance-<standard-accessor-method> method args)))

;;; ---------------------------------------------------------------------------

(defparameter <standard-writer-method>
  (defclass standard-writer-method (standard-accessor-method)
    ()
    (:fixed-slot-locations t)))

(defun make-instance-<standard-writer-method> (class &rest args
                                               &key &allow-other-keys)
  ;; class = <standard-writer-method>
  ;; Don't add functionality here! This is a preliminary definition that is
  ;; replaced with #'make-instance later.
  (declare (ignore class))
  (let ((method (%allocate-instance <standard-writer-method>)))
    (apply #'initialize-instance-<standard-accessor-method> method args)))

;;; ---------------------------------------------------------------------------
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-method1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-methcomb4.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP
;;;; Method Combination
;;;; Part n-1: Generic functions specified in the MOP.
;;;; Bruno Haible 2004-06-10

(in-package "CLOS")


;; Make creation of <method-combination> instances customizable.
(setf (fdefinition 'make-instance-<method-combination>) #'make-instance)

;; MOP p. 54
(defgeneric find-method-combination (generic-function name options)
  (:method ((gf generic-function) (name symbol) options)
    (find-method-combination-<generic-function>-<symbol> gf name options)))
(initialize-extended-method-check #'find-method-combination)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-methcomb4.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-methcomb3.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP
;;;; Method Combination
;;;; Part n-2: make/initialize-instance methods.
;;;; Bruno Haible 2004-06-10

(in-package "CLOS")


;;; Lift the initialization protocol.

(defmethod initialize-instance ((combination method-combination) &rest args
                                 &key name
                                      documentation
                                      check-options
                                      expander
                                      check-method-qualifiers
                                      call-next-method-allowed
                                      declarations
                                      qualifiers
                                      operator
                                      identity-with-one-argument
                                      long-expander
                                      arguments-lambda-list
                                      options)
  (declare (ignore name documentation check-options expander
                   check-method-qualifiers call-next-method-allowed
                   declarations qualifiers operator identity-with-one-argument
                   long-expander arguments-lambda-list options))
  (apply #'initialize-instance-<method-combination> combination args))

(defmethod reinitialize-instance ((instance method-combination) &rest initargs)
  (declare (ignore initargs))
  (error (TEXT "~S: It is not allowed to reinitialize ~S")
         'reinitialize-instance instance))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-methcomb3.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-methcomb2.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP: Method Combination
;;;; Bruno Haible 21.8.1993 - 2006
;;;; Sam Steingold 1998 - 2005, 2007, 2010, 2017
;;;; German comments translated into English: Stefan Kain 2002-04-08
;;;; James Anderson 2003

(in-package "CLOS")


;;; ---------------------------- Method Selection ----------------------------

;; CLtL2 28.1.6.3., ANSI CL 7.6.3.
;; Agreement on Parameter Specializers and Qualifiers
(defun specializers-agree-p (specializers1 specializers2)
  (and (eql (length specializers1) (length specializers2))
       (every #'same-specializers-p specializers1 specializers2)))
(defun same-specializers-p (specializer1 specializer2)
  ;; Since EQL-specializers can be assumed to be interned, just comparing
  ;; with EQ is sufficient.
  (eq specializer1 specializer2))


;;; ----------------- Bridging different calling conventions -----------------

;; For most purposes, the fast-function is used. However, the MOP specifies
;; a slow calling convention for the method-function. There are two places
;; where this needs to be supported:
;;   - The user can funcall the method-function of a method defined through
;;     DEFMETHOD. For this case we need to convert the fast function into a
;;     slow one. Done by std-method-function-or-substitute.
;;   - The user can create methods through
;;       (MAKE-INSTANCE <METHOD> :FUNCTION #'(lambda (args next-methods) ...))
;;     and insert them in a generic-function. We have to call them with the
;;     proper conventions. This is handled by the CALL-METHOD macro.
;;     Note: We cannot provide the local macros/functions CALL-NEXT-METHOD and
;;     NEXT-METHOD-P for this case. The user is responsible for peeking at the
;;     next-methods list himself. Something like this:
;;       (lambda (args next-methods)
;;         (flet ((next-method-p () (not (null next-methods)))
;;                (call-next-method (&rest new-args)
;;                  (unless new-args (setq new-args args))
;;                  (if (null next-methods)
;;                    (apply #'no-next-method ... ... new-args)
;;                    (funcall (method-function (first next-methods))
;;                             new-args (rest next-methods)))))
;;           ...))

(defun method-list-to-continuation (methods-list)
  (if methods-list
    (let ((method (first methods-list))
          (next-methods-list (rest methods-list)))
      (if (and (typep-class method <standard-method>)
               (std-method-fast-function method))
        ; Fast method function calling conventions.
        (let ((fast-func (std-method-fast-function method)))
          (if (std-method-wants-next-method-p method)
            (let ((next-continuation (method-list-to-continuation next-methods-list)))
              #'(lambda (&rest args)
                  (apply fast-func next-continuation args)))
            ; Some methods are known a-priori to not use the next-method list.
            fast-func))
        ; Slow method function calling conventions.
        (let ((slow-func (method-function method)))
          #'(lambda (&rest args)
              (funcall slow-func args next-methods-list)))))
    nil))

(defun std-method-function-or-substitute (method)
  (or (std-method-function method)
      (setf (std-method-function method)
            #'(lambda (arguments next-methods-list)
                ; Fast method function calling conventions.
                (let ((fast-func (std-method-fast-function method)))
                  (if fast-func
                    (if (std-method-wants-next-method-p method)
                      (apply fast-func
                             (method-list-to-continuation next-methods-list)
                             arguments)
                      ; Some methods are known a-priori to not use the next-method list.
                      (apply fast-func arguments))
                    (error (TEXT "The method function of ~S cannot be called before the method has been added to a generic function.")
                           method)))))))

(defun method-function-substitute (h)
  (let ((fast-func (car h))
        (wants-next-method-p (null (cadr h))))
    (if wants-next-method-p
      #'(lambda (arguments next-methods-list)
          (apply fast-func
                 (method-list-to-continuation next-methods-list)
                 arguments))
      ; Some methods are known a-priori to not use the next-method list.
      #'(lambda (arguments next-methods-list)
          (declare (ignore next-methods-list))
          (apply fast-func arguments)))))

;; Computes the :function / fast-function initargs list for a freshly allocated
;; (but yet uninitialized) method.
;; h = (funcall fast-function-factory method)
;; Returns a freshly allocated list.
(defun method-function-initargs (method-class h) ; ABI
  (if (subclassp method-class <standard-method>)
    (list 'fast-function (car h)
          'wants-next-method-p (null (cadr h)))
    (list ':function (method-function-substitute h))))

;;; ------------- Error Messages for Long Form Method Combination -------------

;; Context about the method combination call, set during the execution of a
;; long-expander.
; The actual generic function call arguments (in compute-effective-method).
(defvar *method-combination-arguments* nil) ; ABI
; The generic function applied (in compute-effective-method).
(defvar *method-combination-generic-function* nil) ; ABI
; The generic function's method combination (in compute-effective-method).
(defvar *method-combination* nil) ; ABI

;; Error about a method whose qualifiers don't fit with a method-combination.
;; This is specified to be a function, not a condition type, because it is
;; meant to be called from a DEFINE-METHOD-COMBINATION's body.
(defun invalid-method-error (method format-string &rest args)
  (error
    (TEXT "For function ~S applied to argument list ~S:~%While computing the effective method through ~S:~%Invalid method: ~S~%~?")
    *method-combination-generic-function* *method-combination-arguments*
    *method-combination*
    method
    format-string args))

;; Other error during method combination, not tied to a particular method.
;; This is specified to be a function, not a condition type, because it is
;; meant to be called from a DEFINE-METHOD-COMBINATION's body.
;; The fact that MISSING-REQUIRED-METHOD and NO-PRIMARY-METHOD don't call this
;; function is not a problem, because the user is not supposed to redefine or
;; customize this function.
(defun method-combination-error (format-string &rest args)
  (error
    (TEXT "For function ~S applied to argument list ~S:~%While computing the effective method through ~S:~%Impossible to combine the methods:~%~?")
    *method-combination-generic-function* *method-combination-arguments*
    *method-combination*
    format-string args))

(defun invalid-method-sort-order-error (order-form order-value) ; ABI
  (method-combination-error
    (TEXT "The value of ~S is ~S, should be ~S or ~S.")
    order-form order-value ':MOST-SPECIFIC-FIRST ':MOST-SPECIFIC-LAST))

(defun call-method-duplicates-error (gf method+groupname)
  (let ((*method-combination-generic-function* gf)
        (*method-combination* (safe-gf-method-combination gf)))
    (method-combination-error
      (TEXT "Method ~S has the same specializers and different qualifiers than other methods in method group ~S, and is actually used in the effective method.")
            (car method+groupname) (cdr method+groupname))))

;;; ----------------------- General Method Combination -----------------------

(defun invalid-sort-order-error (order-form order-value) ; ABI
  (error-of-type 'program-error
    (TEXT "The value of ~S is ~S, should be ~S or ~S.")
    order-form order-value ':MOST-SPECIFIC-FIRST ':MOST-SPECIFIC-LAST))

(defun any-method-combination-check-options (gf-name combination options checker) ; ABI
  (locally (declare (compile))
    (sys::%handler-bind
     #'(lambda () (apply checker options))
     'program-error
     #'(lambda (err)
         (error-of-type 'program-error
           (TEXT "~S ~S: Invalid method-combination options ~S for ~S: ~A")
           'defgeneric gf-name options combination err)))))

; Check the effective-method option (:ARGUMENTS ...).
; Returns two values:
; 1. the arguments-lambda-list,
; 2. the list of variables contained therein.
(defun check-em-arguments-option (option caller whole-form name)
  (let ((arguments-lambda-list (cdr option)))
    (multiple-value-bind (whole reqvars optvars optinits optsvars rest
                          keyp keywords keyvars keyinits keysvars allowp
                          auxvars auxinits)
        (sys::analyze-method-combination-lambdalist arguments-lambda-list
          #'(lambda (lalist detail errorstring &rest arguments)
              (declare (ignore lalist)) ; use WHOLE-FORM instead
              (if (eq caller 'define-method-combination)
                (sys::lambda-list-error whole-form detail
                  #1=(TEXT "~S ~S: invalid ~S lambda-list: ~?")
                  caller name ':arguments errorstring arguments)
                (error-of-type 'program-error
                  #1# caller name ':arguments errorstring arguments))))
      (declare (ignore optinits keyp keywords keyinits allowp auxinits))
      (values
       arguments-lambda-list
       (remove 0 (append (list whole) reqvars optvars optsvars (list rest)
                         keyvars keysvars auxvars))))))

; Check the effective-method option (:GENERIC-FUNCTION ...).
; Returns the generic-function variable contained therein.
(defun check-em-generic-function-option (option caller whole-form name)
  (unless (and (consp (cdr option)) (symbolp (cadr option)) (null (cddr option)))
    (if (eq caller 'define-method-combination)
      (error-of-type 'ext:source-program-error :form whole-form :detail option
        #1=(TEXT "~S ~S: Invalid syntax for ~S option: ~S")
        caller name ':generic-function option)
      (error-of-type 'program-error #1# caller name ':generic-function option)))
  (cadr option))

; Check the effective-method option (:DUPLICATES ...).
; Returns an alist of methods and its method group names.
(defun check-em-duplicates-option (option caller name)
  (unless (and (proper-list-p (cdr option))
               (every #'(lambda (x)
                          (and (consp x)
                               (typep-class (car x) <method>)
                               (symbolp (cdr x))))
                      (cdr option)))
    (error-of-type 'program-error
      (TEXT "~S ~S: Invalid syntax for ~S option: ~S")
      caller name ':duplicates option))
  (cdr option))

;; Adds the function-macro definitions of CALL-NEXT-METHOD and NEXT-METHOD-P.
(defun add-next-method-local-functions (backpointer cont req-dummies rest-dummy body)
  `(SYSTEM::FUNCTION-MACRO-LET
     ((CALL-NEXT-METHOD
        ((&REST NEW-ARGS)
         (IF NEW-ARGS
           ;; argument checking in the interpreter only
           (IF (EVAL-WHEN (EVAL) T)
             (%CALL-NEXT-METHOD
               ,backpointer
               ,cont
               ,(if rest-dummy
                  `(LIST* ,@req-dummies ,rest-dummy)
                  `(LIST ,@req-dummies))
               NEW-ARGS)
             (IF ,cont
               (APPLY ,cont NEW-ARGS)
               (APPLY (FUNCTION %NO-NEXT-METHOD) ,backpointer NEW-ARGS)))
           ,(if rest-dummy
              `(IF ,cont
                 (APPLY ,cont ,@req-dummies ,rest-dummy)
                 (APPLY (FUNCTION %NO-NEXT-METHOD) ,backpointer
                        ,@req-dummies ,rest-dummy))
              `(IF ,cont
                 (FUNCALL ,cont ,@req-dummies)
                 (%NO-NEXT-METHOD ,backpointer ,@req-dummies)))))
        ,(system::make-funmacro-full-lambdabody
           `(CALL-NEXT-METHOD (&REST NEW-ARG-EXPRS)
             (IF NEW-ARG-EXPRS
               ;; argument checking in the interpreter only
               (LIST 'IF '(EVAL-WHEN (EVAL) T)
                 (LIST '%CALL-NEXT-METHOD
                   ',backpointer
                   ',cont
                   (LIST ',(if rest-dummy 'LIST* 'LIST)
                     ,@(mapcar #'(lambda (x) `',x) req-dummies)
                     ,@(if rest-dummy `(',rest-dummy) '()))
                   (CONS 'LIST NEW-ARG-EXPRS))
                 (LIST 'IF ',cont
                   (LIST* 'FUNCALL ',cont NEW-ARG-EXPRS)
                   (LIST* '%NO-NEXT-METHOD ',backpointer NEW-ARG-EXPRS)))
               ,(if rest-dummy
                  `(LIST 'IF ',cont
                     (LIST 'APPLY ',cont
                       ,@(mapcar #'(lambda (x) `',x) req-dummies)
                       ',rest-dummy)
                     (LIST 'APPLY '(FUNCTION %NO-NEXT-METHOD)
                       ',backpointer
                       ,@(mapcar #'(lambda (x) `',x) req-dummies)
                       ',rest-dummy))
                  `(LIST 'IF ',cont
                     (LIST 'FUNCALL ',cont
                       ,@(mapcar #'(lambda (x) `',x) req-dummies))
                     (LIST '%NO-NEXT-METHOD
                       ',backpointer
                       ,@(mapcar #'(lambda (x) `',x) req-dummies))))))))
      (NEXT-METHOD-P
        (() ,cont)
        ,(system::make-funmacro-full-lambdabody
           `(NEXT-METHOD-P () ',cont))))
     ,@body))

(defmacro call-method (&whole whole-form
                       method &optional next-methods-list)
  (declare (ignore method next-methods-list))
  (error-of-type 'ext:source-program-error
    :form whole-form
    :detail whole-form
    (TEXT "~S is possible only from within the context of an effective method function. See ~S.")
    'call-method 'define-method-combination))

(defmacro make-method (&whole whole-form
                       form)
  (declare (ignore form))
  (error-of-type 'ext:source-program-error
    :form whole-form
    :detail whole-form
    (TEXT "~S is possible only at particular places from within the context of an effective method function. See ~S.")
    'make-method 'define-method-combination))

(defun make-method-error (whole-form)
  (error-of-type 'ext:source-program-error
    :form whole-form
    :detail whole-form
    (TEXT "~S cannot be used here: ~S")
    'make-method whole-form))

(defun callable-method-form-p (form)
  (or (typep-class form <method>)
      (and (consp form) (eq (car form) 'MAKE-METHOD)
           (consp (cdr form)) (null (cddr form)))))

(defun call-method-arg1-error (whole-form)
  (error-of-type 'ext:source-program-error
    :form whole-form
    :detail whole-form
    (TEXT "~S: The first argument is neither a method nor a (MAKE-METHOD ...) form: ~S")
    'call-method whole-form))

(defun call-method-arg2-error (whole-form)
  (error-of-type 'ext:source-program-error
    :form whole-form
    :detail whole-form
    (TEXT "~S: The second argument is not a list: ~S")
    'call-method whole-form))

(defun call-method-arg2elements-error (whole-form)
  (error-of-type 'ext:source-program-error
    :form whole-form
    :detail whole-form
    (TEXT "~S: The second argument is not a list of methods or (MAKE-METHOD ...) forms: ~S")
    'call-method whole-form))

;; Returns pieces of code to be used in the expansion of the effective-method.
;; 1. the lambda-list of the effective-method.
;; 2. the part of the lambda-list responsible for keyword checking.
;; 3. a declarations/forms list to use right after the lambda-list.
;; 4. an application primitive to use with argument lists for the methods.
;; 5. a list of forms representing the arguments to pass to methods.
;; 6. a set of macro definitions that defines local macros.
(defun effective-method-code-bricks (gf methods duplicates)
  (let* ((signature (safe-gf-signature gf))
         (req-num (sig-req-num signature))
         (req-vars (gensym-list req-num))
         (restp (gf-sig-restp signature))
         (rest-var (if restp (gensym)))
         (apply-fun (if restp 'APPLY 'FUNCALL))
         (apply-args `(,@req-vars ,@(if restp `(,rest-var) '())))
         (lambdalist `(,@req-vars ,@(if restp `(&REST ,rest-var) '()))))
    (multiple-value-bind (opt-vars key-vars lambdalist-keypart)
        (gf-keyword-arguments restp signature methods)
      (values
        ;; 1. lambda-list
        (if (null opt-vars)
          (append lambdalist lambdalist-keypart)
          lambdalist)
        ;; 2. lambda-list &key part
        lambdalist-keypart
        ;; 3. declarations and first forms
        (if (null opt-vars)
          (if key-vars `((DECLARE (IGNORE ,@key-vars))) '())
          `((APPLY #'(LAMBDA (&OPTIONAL ,@opt-vars ,@lambdalist-keypart)
                       (DECLARE (IGNORE ,@opt-vars ,@key-vars)))
                   ,rest-var)))
        ;; 4. application primitive
        apply-fun
        ;; 5. list of forms representing the argument
        apply-args
        ;; 6. macro definitions
        `((MAKE-METHOD (&WHOLE WHOLE FORM)
            (DECLARE (IGNORE FORM))
            (MAKE-METHOD-ERROR WHOLE))
          (CALL-METHOD (&WHOLE WHOLE METHOD &OPTIONAL NEXT-METHODS-LIST)
            (UNLESS (CALLABLE-METHOD-FORM-P METHOD)
              (CALL-METHOD-ARG1-ERROR WHOLE))
            (UNLESS (LISTP NEXT-METHODS-LIST)
              (CALL-METHOD-ARG2-ERROR WHOLE))
            ,@(when duplicates
                `((LET ((METHOD+GROUPNAME (ASSOC METHOD ',duplicates :TEST #'EQ)))
                    (WHEN METHOD+GROUPNAME
                      (CALL-METHOD-DUPLICATES-ERROR ',gf METHOD+GROUPNAME)))))
            (LET ((NEXT-METHODS-EM-FORM
                    (IF NEXT-METHODS-LIST
                      (LIST 'FUNCTION
                        (LIST 'LAMBDA ',lambdalist
                          (LIST 'CALL-METHOD (CAR NEXT-METHODS-LIST)
                            (CDR NEXT-METHODS-LIST))))
                      'NIL)))
              (IF (TYPEP-CLASS METHOD <METHOD>)
                (IF (AND (TYPEP-CLASS METHOD <STANDARD-METHOD>)
                         (STD-METHOD-FAST-FUNCTION METHOD))
                  ; Fast method function calling conventions.
                  (IF (STD-METHOD-WANTS-NEXT-METHOD-P METHOD)
                    (LIST* ',apply-fun (LIST 'QUOTE (STD-METHOD-FAST-FUNCTION METHOD))
                           NEXT-METHODS-EM-FORM ',apply-args)
                    ; Some methods are known a-priori to not use the next-method list.
                    (LIST* ',apply-fun (LIST 'QUOTE (STD-METHOD-FAST-FUNCTION METHOD))
                           ',apply-args))
                  ; Slow method function calling conventions.
                  (PROGN
                    (UNLESS (EVERY #'CALLABLE-METHOD-FORM-P NEXT-METHODS-LIST)
                      (CALL-METHOD-ARG2ELEMENTS-ERROR WHOLE))
                    (LIST 'FUNCALL (LIST 'QUOTE (METHOD-FUNCTION METHOD))
                      ',(cons (ecase apply-fun (APPLY 'LIST*) (FUNCALL 'LIST))
                              apply-args)
                      (LIST* 'LIST
                        (MAPCAR #'(LAMBDA (NEXT-METHOD)
                                    (IF (TYPEP-CLASS NEXT-METHOD <METHOD>)
                                      NEXT-METHOD ; no need to quote, since self-evaluating
                                      (LIST 'LET
                                        (LIST (LIST 'METHOD-CLASS
                                                    '',(safe-gf-default-method-class gf))
                                              '(BACKPOINTER (LIST NIL)))
                                        (LIST 'APPLY
                                              '#'MAKE-METHOD-INSTANCE
                                              'METHOD-CLASS
                                              ':LAMBDA-LIST '',lambdalist
                                              ''SIGNATURE ,signature
                                              ':SPECIALIZERS '',(make-list req-num :initial-element <t>)
                                              ''BACKPOINTER 'BACKPOINTER
                                              (LIST 'METHOD-FUNCTION-INITARGS
                                                    'METHOD-CLASS
                                                    (LIST 'CONS
                                                          (LET ((CONT (GENSYM)))
                                                            (LIST 'FUNCTION
                                                              (LIST 'LAMBDA (CONS CONT ',lambdalist)
                                                                (LIST 'DECLARE (LIST 'IGNORABLE CONT))
                                                                (ADD-NEXT-METHOD-LOCAL-FUNCTIONS 'NIL CONT ',req-vars ',rest-var
                                                                  (CDR NEXT-METHOD)))))
                                                          (LIST 'QUOTE '(NIL))))))))
                                NEXT-METHODS-LIST)))))
                (LET ((CONT (GENSYM)))
                  (LIST 'LET (LIST (LIST CONT NEXT-METHODS-EM-FORM))
                    (LIST 'DECLARE (LIST 'IGNORABLE CONT))
                    (ADD-NEXT-METHOD-LOCAL-FUNCTIONS 'NIL CONT ',req-vars ',rest-var
                      (CDR METHOD))))))))))))

;; Given the generic function, its combination, and the effective method form
;; and the arguments-lambda-list specifying variables for it, constructs the
;; function form for the effective method, including correct arguments and with
;; the next-method support.
(defun build-effective-method-function-form (generic-function combination methods
                                             effective-method-form
                                             combination-arguments-lambda-list
                                             generic-function-variable
                                             duplicates)
  (multiple-value-bind (lambdalist lambdalist-keypart firstforms apply-fun apply-args macrodefs)
      (effective-method-code-bricks generic-function methods duplicates)
    (let* ((declarations (method-combination-declarations combination))
           (ef-fun
             (if (and ;; Optimize the special but frequent case of
                      ;; effective-method-form = `(CALL-METHOD ,method ...)
                      ;; where CALL-METHOD would expand to a single call
                      ;; without needing a next-methods argument and the outer
                      ;; LAMBDA does not need to do keyword argument checking.
                      (consp effective-method-form)
                      (eq (first effective-method-form) 'CALL-METHOD)
                      (consp (cdr effective-method-form))
                      (typep-class (second effective-method-form) <standard-method>)
                      (let ((method (second effective-method-form)))
                        (and (std-method-fast-function method)
                             (not (std-method-wants-next-method-p method))
                             (null (assoc method duplicates :test #'eq))))
                      (null lambdalist-keypart))
               (std-method-fast-function (second effective-method-form))
               (let ((wrapped-ef-form
                       `(MACROLET ,macrodefs
                          ,effective-method-form)))
                 (when combination-arguments-lambda-list
                   ;; Use an inline lambda to assign values to the variables
                   ;; of the combination-arguments-lambda-list.
                   (multiple-value-bind (whole reqvars optvars optinits optsvars rest
                                         keyp keywords keyvars keyinits keysvars
                                         allowp auxvars auxinits)
                       (sys::analyze-method-combination-lambdalist combination-arguments-lambda-list
                         #'(lambda (lalist detail errorstring &rest arguments)
                             (sys::lambda-list-error lalist detail
                               (TEXT "In ~S ~S lambda list: ~?")
                               combination ':arguments errorstring arguments)))
                     (declare (ignore optinits optsvars
                                      keywords keyvars keyinits keysvars
                                      allowp auxvars auxinits))
                     (let ((whole-var nil)
                           (whole-form nil))
                       (unless (eql whole 0)
                         (setq whole-var whole)
                         (setq whole-form (list* (ecase apply-fun
                                                   (APPLY 'LIST*)
                                                   (FUNCALL 'LIST))
                                                 apply-args))
                         (setq combination-arguments-lambda-list
                               (cddr combination-arguments-lambda-list)))
                       ;; The combination-arguments-lambda-list has an implicit
                       ;; &ALLOW-OTHER-KEYS.
                       (when (and (memq '&KEY combination-arguments-lambda-list)
                                  (not (memq '&ALLOW-OTHER-KEYS combination-arguments-lambda-list)))
                         (let ((i (or (position '&AUX combination-arguments-lambda-list)
                                      (length combination-arguments-lambda-list))))
                           (setq combination-arguments-lambda-list
                                 (append (subseq combination-arguments-lambda-list 0 i)
                                         '(&ALLOW-OTHER-KEYS)
                                         (subseq combination-arguments-lambda-list i)))))
                       (let* ((ll-req-num (length reqvars))
                              (ll-opt-num (length optvars))
                              (signature (safe-gf-signature generic-function))
                              (gf-req-num (sig-req-num signature))
                              (gf-opt-num (sig-opt-num signature)))
                         ;; "If the section of the :arguments lambda-list is
                         ;;  shorter, extra arguments are ignored."
                         (when (< ll-req-num gf-req-num)
                           (setq apply-args (append (subseq apply-args 0 ll-req-num)
                                                    (subseq apply-args gf-req-num))))
                         ;; "If the section of the :arguments lambda-list is
                         ;;  longer, excess required parameters are bound to
                         ;;  forms that evaluate to nil and excess optional
                         ;;  parameters are bound to their initforms."
                         (when (> ll-req-num gf-req-num)
                           (setq apply-args (append (subseq apply-args 0 gf-req-num)
                                                    (make-list (- ll-req-num gf-req-num)
                                                               :initial-element 'NIL)
                                                    (subseq apply-args gf-req-num))))
                         ;; Now the required parameters section of apply-args
                         ;; has length ll-req-num.
                         ;; Likewise for the &optional section.
                         (when (< ll-opt-num gf-opt-num)
                           (let* ((has-&optional (eq (nth ll-req-num combination-arguments-lambda-list) '&OPTIONAL))
                                  (i (+ ll-req-num (if has-&optional 1 0) ll-opt-num)))
                             (setq combination-arguments-lambda-list
                                   (append (subseq combination-arguments-lambda-list 0 i)
                                           (if has-&optional '() '(&OPTIONAL))
                                           (gensym-list (- gf-opt-num ll-opt-num))
                                           (subseq combination-arguments-lambda-list i)))))
                         (when (> ll-opt-num gf-opt-num)
                           ;; In this case we have to split the one lambda into
                           ;; two or three ones.
                           ;; Outermost lambda: the required and present optional
                           ;;                   variables.
                           ;; Inner lambda: The missing optional variables.
                           ;; Innermost lambda: The &rest/&key variables.
                           (let ((combination-arguments-rest
                                   (subseq combination-arguments-lambda-list (+ ll-req-num 1 ll-opt-num)))
                                 (apply-args-rest (subseq apply-args ll-req-num)))
                             (when (memq (first combination-arguments-rest) '(&REST &KEY))
                               (setq wrapped-ef-form
                                     `(,apply-fun #'(LAMBDA ,(append (if (> gf-opt-num 0) '(&OPTIONAL) '())
                                                                     (gensym-list gf-opt-num)
                                                                     combination-arguments-rest)
                                                      ,@declarations
                                                      ,wrapped-ef-form)
                                                  ,@apply-args-rest))
                               (setq combination-arguments-lambda-list
                                     (subseq combination-arguments-lambda-list 0 (+ ll-req-num 1 ll-opt-num))))
                             (setq wrapped-ef-form
                                   `(FUNCALL #'(LAMBDA (&OPTIONAL ,@(subseq combination-arguments-lambda-list (+ ll-req-num 1 gf-opt-num)))
                                                 ,@declarations
                                                 ,wrapped-ef-form)))
                             (setq combination-arguments-lambda-list
                                   (subseq combination-arguments-lambda-list 0 (+ ll-req-num 1 gf-opt-num)))
                             (when (memq (first combination-arguments-rest) '(&REST &KEY))
                               (setq combination-arguments-lambda-list
                                     (append combination-arguments-lambda-list `(&REST ,(gensym)))))))
                         ;; When lambdalist has &rest or &key but combination-arguments-lambda-list
                         ;; doesn't, add a dummy &rest variable to it.
                         (when (and (eq apply-fun 'APPLY)
                                    (not (or (not (eql rest 0)) keyp)))
                           (let ((i (or (position '&AUX combination-arguments-lambda-list)
                                        (length combination-arguments-lambda-list))))
                             (setq combination-arguments-lambda-list
                                   (append (subseq combination-arguments-lambda-list 0 i)
                                           `(&REST ,(gensym))
                                           (subseq combination-arguments-lambda-list i)))))
                         ;; "&whole var can be placed first in the :arguments lambda-list."
                         (when whole-form
                           (setq combination-arguments-lambda-list
                                 (cons whole-var combination-arguments-lambda-list))
                           (setq apply-args (cons whole-form apply-args)))
                         (setq wrapped-ef-form
                               `(,apply-fun #'(LAMBDA ,combination-arguments-lambda-list
                                                ,@declarations
                                                ,wrapped-ef-form)
                                            ,@apply-args))))))
                 (when generic-function-variable
                   (setq wrapped-ef-form
                         `(LET ((,generic-function-variable ',generic-function))
                            ,@declarations
                            ,wrapped-ef-form)))
                 `#'(LAMBDA ,lambdalist
                      ,@declarations
                      ,@firstforms
                      ,wrapped-ef-form)))))
      ef-fun)))

(defun compute-effective-method-<generic-function> (gf combination methods)
  ;; Apply method combination:
  (funcall (method-combination-expander combination)
           gf combination (method-combination-options combination) methods))

;; Preliminary.
(predefun compute-effective-method (gf combination methods)
  (compute-effective-method-<generic-function> gf combination methods))

(defun compute-effective-method-as-function-form (gf combination methods *method-combination-arguments*)
  ;; Call the customizable compute-effective-method from the MOP. (No need to
  ;; verify that it produces exactly two values: Many user-defined methods
  ;; probably return just the first value, letting the second value default
  ;; to empty.)
  (multiple-value-bind (effective-method-form effective-method-options)
      (funcall (cond ((or (eq gf |#'compute-discriminating-function|)  ; for bootstrapping
                          (eq gf |#'compute-effective-method|)
                          (eq gf |#'compute-applicable-methods-using-classes|))
                      #'compute-effective-method-<generic-function>)
                     (t #'compute-effective-method))
               gf combination methods)
    ;; Build a function form around the inner form:
    (build-effective-method-function-form gf combination methods
      effective-method-form
      (let ((option (assoc ':ARGUMENTS effective-method-options)))
        (if option
          (check-em-arguments-option option 'compute-discriminating-function nil gf)
          '()))
      ;; Supporting the :GENERIC-FUNCTION effective-method option here is
      ;; is useless, since COMPUTE-EFFECTIVE-METHOD has been passed the
      ;; generic function as argument, and COMPUTE-EFFECTIVE-METHOD could just
      ;; use this generic function object (quoted or not, doesn't matter, since
      ;; it's self-evaluating) instead of introducing a variable. But the MOP
      ;; p. 42 talks about it, and it increases consistency with the
      ;; DEFINE-METHOD-COMBINATION macro, so let's support it.
      (let ((option (assoc ':GENERIC-FUNCTION effective-method-options)))
        (if option
          (check-em-generic-function-option option 'compute-discriminating-function nil gf)
          nil))
      (let ((option (assoc ':DUPLICATES effective-method-options)))
        (if option
          (check-em-duplicates-option option 'compute-discriminating-function gf)
          '())))))

;;; ----------------------- Standard Method Combination -----------------------

(defun standard-method-combination-check-options (gf-name combination options)
  (declare (ignore combination))
  (unless (null options)
    (error-of-type 'program-error
      (TEXT "~S ~S: The ~S method combination permits no options: ~S")
      'defgeneric gf-name 'standard options)))

;; partition the methods according to qualifiers
(defun partition-method-list (methods gf)
  (let ((primary-methods '())
        (before-methods '())
        (after-methods '())
        (around-methods '()))
    (dolist (method methods)
      (let ((quals (safe-method-qualifiers method gf)))
        (cond ((equal quals '())        (push method primary-methods))
              ((equal quals '(:before)) (push method before-methods))
              ((equal quals '(:after))  (push method after-methods))
              ((equal quals '(:around)) (push method around-methods)))))
    (values
      (nreverse primary-methods)
      (nreverse before-methods)
      (nreverse after-methods)
      (nreverse around-methods))))

(defun standard-method-combination-expander (gf combination options methods)
  (declare (ignore combination))
  (declare (ignore options)) ; already checked in check-options
  ;; Split up into individual method types.
  (multiple-value-bind (primary-methods before-methods after-methods around-methods)
      (partition-method-list methods gf)
    (when (null primary-methods)
      (return-from standard-method-combination-expander
        (let ((rest-variable (gensym)))
          (values `(APPLY #'NO-PRIMARY-METHOD ',gf ,rest-variable)
                  `((:ARGUMENTS &WHOLE ,rest-variable))))))
    ;; Combine methods into an "effective method":
    (labels ((ef-1 (primary-methods before-methods after-methods
                    around-methods)
               (if (null around-methods)
                 (ef-2 primary-methods before-methods after-methods)
                 (let ((next-ef
                         (ef-1 primary-methods before-methods
                               after-methods (rest around-methods))))
                   `(CALL-METHOD ,(first around-methods)
                      ,(list `(MAKE-METHOD ,next-ef))))))
             (forms-for-invoking-sequentially (methods)
               (mapcar #'(lambda (method)
                           `(CALL-METHOD ,method))
                       methods))
             (ef-2 (primary-methods before-methods after-methods)
               (let ((next-ef (ef-3 primary-methods after-methods)))
                 (if (null before-methods)
                   next-ef
                   `(PROGN
                      ; most-specific-first:
                      ,@(forms-for-invoking-sequentially before-methods)
                      ,next-ef))))
             (ef-3 (primary-methods after-methods)
               (let ((next-ef (ef-4 primary-methods)))
                 (if (null after-methods)
                   next-ef
                   `(MULTIPLE-VALUE-PROG1
                      ,next-ef
                      ; most-specific-last:
                      ,@(forms-for-invoking-sequentially (reverse after-methods))))))
             (ef-4 (primary-methods)
               `(CALL-METHOD ,(first primary-methods) ,(rest primary-methods))))
      (values
        (ef-1 primary-methods before-methods after-methods around-methods)
        '()))))

(defun standard-method-combination-check-method-qualifiers (gf method-combo method)
  ;; CLtL2 28.1.7.2., 28.1.7.4., ANSI CL 7.6.6.2., 7.6.6.4. Method qualifiers
  (let ((qualifiers (method-qualifiers method)))
    (when qualifiers
      (let ((allowed-qualifiers (method-combination-qualifiers method-combo)))
        (if allowed-qualifiers
          (dolist (q qualifiers)
            (unless (member q allowed-qualifiers)
              (error-of-type 'program-error
                (TEXT "~S method combination, used by ~S, allows no method qualifiers except ~S: ~S")
                (method-combination-name method-combo) gf allowed-qualifiers method)))
          (error-of-type 'program-error
            (TEXT "~S method combination, used by ~S, does not allow method qualifiers: ~S")
            (method-combination-name method-combo) gf method))
        (when (> (length qualifiers) 1)
          (error-of-type 'program-error
            (TEXT "~S method combination, used by ~S, does not allow more than one method qualifier on a method: ~S")
            (method-combination-name method-combo) gf method))))))

(defun standard-method-combination-call-next-method-allowed (gf method-combo method)
  (declare (ignore gf method-combo))
  (let ((qualifiers (method-qualifiers method)))
    (or (equal qualifiers '()) (equal qualifiers '(:around)))))

(setf (get-method-combination 'standard)
      (make-instance-<method-combination> <method-combination>
        :name 'standard
        :documentation "the STANDARD METHOD-COMBINATION object"
        :qualifiers '(:before :after :around)
        :check-options #'standard-method-combination-check-options
        :expander #'standard-method-combination-expander
        :check-method-qualifiers #'standard-method-combination-check-method-qualifiers
        :call-next-method-allowed #'standard-method-combination-call-next-method-allowed))

;;; ---------------------- Short-Form Method Combination ----------------------

(defun short-form-method-combination-check-options (gf-name combination options) ; ABI
  (any-method-combination-check-options gf-name combination options
    (function method-combination-option-checker
      (lambda (&optional (order ':most-specific-first))
        (unless (memq order '(:most-specific-first :most-specific-last))
          (invalid-sort-order-error 'order order))))))

(defun short-form-method-combination-expander (gf combination options methods) ; ABI
  (sys::simple-destructuring-bind (&optional (order ':most-specific-first)) options
    (let ((operator (method-combination-operator combination)))
      (multiple-value-bind (primary around)
           (let ((primary-methods '())
                 (around-methods '()))
             (dolist (method methods)
               (let ((quals (method-qualifiers method)))
                 (if (equal quals '(:around))
                   (push method around-methods)
                   (push method primary-methods))))
             (when (null primary-methods)
               (return-from short-form-method-combination-expander
                 (let ((rest-variable (gensym)))
                   (values `(APPLY #'NO-PRIMARY-METHOD ',gf ,rest-variable)
                           `((:ARGUMENTS &WHOLE ,rest-variable))))))
             (values
               (ecase order
                 (:most-specific-first (nreverse primary-methods))
                 (:most-specific-last primary-methods))
               (nreverse around-methods)))
        (let ((form
                (if (and (null (rest primary))
                         (method-combination-identity-with-one-argument combination))
                  `(CALL-METHOD ,(first primary))
                  `(,operator ,@(mapcar #'(lambda (method) `(CALL-METHOD ,method)) primary)))))
          (when around
            (setq form `(CALL-METHOD ,(first around)
                                     (,@(rest around) (make-method ,form)))))
          (values form '()))))))

(defun short-form-method-combination-check-method-qualifiers
    (gf method-combo method) ; ABI
  (standard-method-combination-check-method-qualifiers gf method-combo method)
  (let ((qualifiers (method-qualifiers method)))
    (when (null qualifiers)
      (error-of-type 'program-error
        (TEXT "~S method combination, used by ~S, does not allow less than one method qualifier on a method: ~S")
        (method-combination-name method-combo) gf method))))

(defun short-form-method-combination-call-next-method-allowed
    (gf method-combo method) ; ABI
  (declare (ignore gf method-combo))
  (let ((qualifiers (method-qualifiers method)))
    (equal qualifiers '(:around))))

;;; Predefined method combinations.
(dolist (name '(+ and append list max min nconc or progn))
  (setf (get-method-combination name)
        (make-instance-<method-combination> <method-combination>
          :name name :operator name
          :qualifiers (list name ':around)
          :identity-with-one-argument (not (eq name 'list))
          :documentation (format nil "the ~A ~A object"
                                 name 'method-combination)
          :check-options #'short-form-method-combination-check-options
          :expander #'short-form-method-combination-expander
          :check-method-qualifiers #'short-form-method-combination-check-method-qualifiers
          :call-next-method-allowed #'short-form-method-combination-call-next-method-allowed)))

;;; ---------------------- Long-Form Method Combination ----------------------

(defun long-form-method-combination-expander
    (*method-combination-generic-function* *method-combination* options methods) ; ABI
  (multiple-value-bind (effective-method-form duplicates)
      (apply (method-combination-long-expander *method-combination*)
             *method-combination-generic-function* methods options)
    (values
      effective-method-form
      `((:ARGUMENTS ,@(method-combination-arguments-lambda-list *method-combination*))
        (:DUPLICATES ,@duplicates)))))

(defun long-form-method-combination-call-next-method-allowed (gf method-combo method) ; ABI
  (declare (ignore gf method-combo method))
  t)

;; ANSI CL says that when "two methods [with identical specializers, but with
;; different qualifiers,] play the same role and their order matters, an error
;; is signaled".
;; The way we implement this is that after partitioning the sorted list of
;; applicable methods into method groups, we scan the (still sorted!) lists
;; of each method group for duplicates. We don't signal an error on them
;; immediately, because they could be ignored, but instead let CALL-METHOD
;; signal an error on them.
(defun long-form-method-combination-collect-duplicates (methods groupname) ; ABI
  (let ((duplicates '())
        (last-was-duplicate nil))
    (do ((l methods (cdr l)))
        ((endp (cdr l)))
      (let ((method1 (first l))
            (method2 (second l)))
        (if (specializers-agree-p (method-specializers method1)
                                  (method-specializers method2))
          ;; The specializers agree, so we know the qualifiers must differ.
          (progn
            (unless last-was-duplicate (push (cons method1 groupname) duplicates))
            (push (cons method2 groupname) duplicates)
            (setq last-was-duplicate t))
          (setq last-was-duplicate nil))))
    duplicates))

;;; ------------------------ DEFINE-METHOD-COMBINATION ------------------------

(defun parse-method-groups (whole-form name method-groups)
  (labels ((group-error (group detail message &rest message-args)
             (error-of-type 'ext:source-program-error
               :form whole-form
               :detail detail
               (TEXT "~S ~S: invalid method group specifier ~S: ~?")
               'define-method-combination name group message message-args))
           ;; Performs the syntax check of a method-group-specifier and
           ;; returns a simple-vector
           ;;   #(name patterns/predicate orderform required-p description)
           ;; The second element can be a non-empty list of patterns, or a
           ;; non-null symbol naming a predicate.
           (normalize-group (group)
             (unless (and (consp group) (consp (cdr group)))
               (group-error group group
                            (TEXT "Not a list of length at least 2")))
             (let ((variable (car group))
                   (groupr (cdr group))
                   (patterns '())
                   (predicate nil)
                   (orderforms '())
                   (requireds '())
                   (description nil))
               (unless (symbolp variable)
                 (group-error group variable (TEXT "Not a variable name: ~S")
                              variable))
               ; Parse the {qualifier-pattern+ | predicate} part:
               (do ()
                   ((atom groupr))
                 (let ((qp (car groupr)))
                   (cond ((or (eq qp '*)
                              (and (listp qp)
                                   (memq (cdr (last qp)) '(nil *))))
                          ; A qualifier pattern.
                          (when predicate
                            (group-error group predicate (TEXT "In method group ~S: Cannot specify both qualifier patterns and a predicate.") variable))
                          (push qp patterns))
                         ((memq qp '(:DESCRIPTION :ORDER :REQUIRED))
                          ; End of the {qualifier-pattern+ | predicate} part.
                          (return))
                         ((symbolp qp)
                          ; A predicate.
                          (when predicate
                            (group-error group predicate (TEXT "In method group ~S: Cannot specify more than one predicate.") variable))
                          (when patterns
                            (group-error group patterns (TEXT "In method group ~S: Cannot specify both qualifier patterns and a predicate.") variable))
                          (setq predicate qp))
                         (t
                           (group-error group qp (TEXT "In method group ~S: Neither a qualifier pattern nor a predicate: ~S") variable qp))))
                 (setq groupr (cdr groupr)))
               (do ()
                   ((atom groupr))
                 (when (atom (cdr groupr))
                   (group-error group groupr (TEXT "In method group ~S: options must come in pairs") variable))
                 (let ((optionkey (first groupr))
                       (argument (second groupr)))
                   (case optionkey
                     (:ORDER
                      (when orderforms
                        (group-error group orderforms (TEXT "In method group ~S: option ~S may only be given once") variable ':order))
                      (setq orderforms (list argument)))
                     (:REQUIRED
                      (when requireds
                        (group-error group requireds (TEXT "In method group ~S: option ~S may only be given once") variable ':required))
                      (setq requireds (list (not (null argument)))))
                     (:DESCRIPTION
                      (when description
                        (group-error group description (TEXT "In method group ~S: option ~S may only be given once") variable ':description))
                      (unless (stringp argument)
                        (group-error group argument (TEXT "In method group ~S: ~S is not a string") variable argument))
                      (setq description argument))
                     (t
                      (group-error group optionkey (TEXT "In method group ~S: Invalid option ~S") variable optionkey))))
                 (setq groupr (cddr groupr)))
               (unless (or patterns predicate)
                 (group-error group group (TEXT "In method group ~S: Missing pattern or predicate.") variable))
               (vector variable
                       (or predicate (nreverse patterns))
                       (if orderforms (first orderforms) '':MOST-SPECIFIC-FIRST)
                       (if requireds (first requireds) 'NIL)
                       (or description
                           (concatenate 'string
                             (sys::format-quote (format nil "~A" variable))
                             "~@{ ~S~}"))))))
    (mapcar #'normalize-group method-groups)))

;; Given the normalized method group specifiers, computes
;; 1. a function without arguments, that checks the options,
;; 2. a function to be applied to a list of methods to produce the effective
;;    method function's body and the list of duplicate methods. The group
;;    variables are bound in the body.
;; 3. a function to be applied to a single method to produce a qualifiers check.
(defun compute-method-partition-lambdas (method-groups body)
  (let ((order-bindings nil))
    (labels (;; Returns a form that tests whether a list of qualifiers, assumed
             ;; to be present in the variable QUALIFIERS, matches the given pattern.
             (compute-match-predicate-1 (pattern)
               ; Already checked above.
               (assert (or (eq pattern '*)
                           (and (listp pattern)
                                (memq (cdr (last pattern)) '(nil *)))))
               (cond ((null pattern) `(NULL QUALIFIERS))
                     ((eq pattern '*) `T)
                     ((null (cdr (last pattern))) `(EQUAL QUALIFIERS ',pattern))
                     (t (let* ((required-part (ldiff pattern '*))
                               (n (length required-part)))
                          `(AND (SYS::CONSES-P ,n QUALIFIERS)
                                (EQUAL (LDIFF QUALIFIERS (NTHCDR ,n QUALIFIERS))
                                       ',required-part))))))
             ;; Returns a form that tests whether a list of qualifiers, assumed
             ;; to be present in the variable QUALIFIERS, satisfies the test
             ;; for the given normalized method group description.
             (compute-match-predicate (ngroup)
               (let ((patterns (svref ngroup 1)))
                 ; Already checked above.
                 (assert (and (or (listp patterns) (symbolp patterns))
                              (not (null patterns))))
                 (if (listp patterns)
                   `(OR ,@(mapcar #'compute-match-predicate-1 patterns))
                   `(,patterns QUALIFIERS))))
             ;; Tests whether there is only a single list of qualifiers that
             ;; matches the patterns.
             (match-is-equality-p (ngroup)
               (let ((patterns (svref ngroup 1)))
                 ; Already checked above.
                 (assert (and (or (listp patterns) (symbolp patterns))
                              (not (null patterns))))
                 (if (listp patterns)
                   (and (= (length (remove-duplicates patterns :test #'equal)) 1)
                        (let ((pattern (first patterns)))
                          (and (listp pattern) (null (cdr (last pattern))))))
                   nil)))
             ;; Returns the variable binding for the given normalized method
             ;; group description.
             (compute-variable-binding (ngroup)
               (let ((variable (svref ngroup 0)))
                 `(,variable NIL)))
             ;; Returns a form that computes the duplicates among the contents
             ;; of the variable for the given normalized method group description.
             (compute-duplicates-form (ngroup)
               (unless (match-is-equality-p ngroup)
                 (let ((variable (svref ngroup 0)))
                   `(LONG-FORM-METHOD-COMBINATION-COLLECT-DUPLICATES ,variable ',variable))))
             ;; Returns a form that performs the :required check for the given
             ;; normalized method group description.
             (compute-required-form (ngroup)
               (let ((variable (svref ngroup 0))
                     (required-p (svref ngroup 3)))
                 (when required-p
                   `(UNLESS ,variable
                      (APPLY #'MISSING-REQUIRED-METHOD
                        *METHOD-COMBINATION-GENERIC-FUNCTION*
                        *METHOD-COMBINATION*
                        ',variable
                        #'(LAMBDA (METH)
                            (LET ((QUALIFIERS (METHOD-QUALIFIERS METH)))
                              (DECLARE (IGNORABLE QUALIFIERS))
                              ,(compute-match-predicate ngroup)))
                        *METHOD-COMBINATION-ARGUMENTS*)))))
             ;; Returns a form that reorders the list of methods in the method
             ;; group that originates from the given normalized method group
             ;; description.
             (compute-reorder-form (ngroup)
               ;; If an order spec is present, make a binding for the
               ;; shared value and use that to decide whether to reverse.
               ;; If the order is :most-positive-first, we have to reverse,
               ;; to undo the reversal done by the previous PUSH operations.
               (let ((variable (svref ngroup 0))
                     (order-form (svref ngroup 2)))
                 (if (or (equal order-form '':MOST-SPECIFIC-FIRST)
                         (equal order-form ':MOST-SPECIFIC-FIRST))
                   `(SETQ ,variable (NREVERSE ,variable))
                   (let ((order-variable
                           (first (find order-form order-bindings :key #'second))))
                     (unless order-variable
                       (setq order-variable (gensym "ORDER-"))
                       (push `(,order-variable ,order-form) order-bindings))
                     `(COND ((EQ ,order-variable ':MOST-SPECIFIC-FIRST)
                             (SETQ ,variable (NREVERSE ,variable)))
                            ((EQ ,order-variable ':MOST-SPECIFIC-LAST))
                            (T (INVALID-METHOD-SORT-ORDER-ERROR ',order-form ,order-variable))))))))
      (let ((match-clauses '())
            (check-forms '()))
        (dolist (ngroup method-groups)
          (let ((variable (svref ngroup 0))
                (qualifier-test-form (compute-match-predicate ngroup)))
            (push `(,qualifier-test-form (PUSH METHD ,variable))
                  match-clauses)
            (push qualifier-test-form check-forms)))
        (setq match-clauses (nreverse match-clauses))
        (setq check-forms (nreverse check-forms))
        (let ((duplicates-forms
                (delete nil (mapcar #'compute-duplicates-form method-groups)))
              (order-forms
                (delete nil (mapcar #'compute-reorder-form method-groups))))
          (values
            `(LAMBDA ()
               (LET (,@order-bindings)
                 ,@(mapcar #'(lambda (order-binding)
                               (let ((order-variable (first order-binding))
                                     (order-form (second order-binding)))
                                 `(UNLESS (MEMQ ,order-variable '(:MOST-SPECIFIC-FIRST :MOST-SPECIFIC-LAST))
                                    (INVALID-SORT-ORDER-ERROR ',order-form ,order-variable))))
                           order-bindings)))
            `(LAMBDA (METHODS)
               (LET (,@(mapcar #'compute-variable-binding method-groups)
                     ,@order-bindings)
                 (DOLIST (METHD METHODS)
                   (LET ((QUALIFIERS (METHOD-QUALIFIERS METHD)))
                     (DECLARE (IGNORABLE QUALIFIERS))
                     (COND ,@match-clauses
                           (T (INVALID-METHOD-QUALIFIERS-ERROR *METHOD-COMBINATION-GENERIC-FUNCTION* METHD)))))
                 (LET ,(if duplicates-forms `((DUPLICATES (NCONC ,@duplicates-forms))) '())
                   ,@order-forms
                   ,@(delete nil (mapcar #'compute-required-form method-groups))
                   (VALUES
                     (PROGN ,@body)
                     ,(if duplicates-forms 'DUPLICATES 'NIL)))))
            `(LAMBDA (GF METHD)
               (LET ((QUALIFIERS (METHOD-QUALIFIERS METHD)))
                 (DECLARE (IGNORABLE QUALIFIERS))
                 (OR ,@check-forms
                     (INVALID-METHOD-QUALIFIERS-ERROR GF METHD))))))))))

(defmacro define-method-combination (&whole whole-form
                                     name &rest options)
  "The macro define-method-combination defines a new method combination.
Short-form options are :documentation, :identity-with-one-argument,
 and :operator.
Long-form options are a list of method-group specifiers,
 each of which comprises a sequence of qualifier patterns
 followed by respective :description, :order, :required options,
 and optional :generic-function, and :arguments options preceeding
 the definition body."
  (unless (symbolp name)
    (error-of-type 'ext:source-program-error
      :form whole-form
      :detail name
      (TEXT "~S: method combination name ~S should be a symbol")
      'define-method-combination name))
  (sys::check-redefinition
    name 'define-method-combination
    (and (get-method-combination name nil)
         (TEXT "method combination")))
  (cond ;; "The short form syntax ... is recognized when the second subform is
        ;;  a non-nil symbol or is not present."
        ((or (null options)
             (and (consp options)
                  (typep (first options) '(and symbol (not null)))))
         ;; Short form.
         (when (oddp (length options))
           (error-of-type 'ext:source-program-error
             :form whole-form
             :detail options
             (TEXT "~S ~S: options must come in pairs")
             'define-method-combination name))
         (let ((documentation nil)
               (identities '())
               (operators '()))
           (do ((optionsr options (cddr optionsr)))
               ((atom optionsr))
             (when (atom (cdr optionsr))
               (error-of-type 'ext:source-program-error
                 :form whole-form
                 :detail options
                 (TEXT "~S ~S: options must come in pairs")
                 'define-method-combination name))
             (let ((optionkey (first optionsr))
                   (argument (second optionsr)))
               (case optionkey
                 (:DOCUMENTATION
                  (when documentation
                    (error-of-type 'ext:source-program-error
                      :form whole-form
                      :detail options
                      (TEXT "~S ~S: option ~S may only be given once")
                      'define-method-combination name ':documentation))
                  (unless (stringp argument)
                    (error-of-type 'ext:source-program-error
                      :form whole-form
                      :detail argument
                      (TEXT "~S ~S: ~S is not a string")
                      'define-method-combination name argument))
                  (setq documentation argument))
                 (:IDENTITY-WITH-ONE-ARGUMENT
                  (when identities
                    (error-of-type 'ext:source-program-error
                      :form whole-form
                      :detail options
                      (TEXT "~S ~S: option ~S may only be given once")
                      'define-method-combination name ':identity-with-one-argument))
                  (setq identities (list (not (null argument)))))
                 (:OPERATOR
                  (when operators
                    (error-of-type 'ext:source-program-error
                      :form whole-form
                      :detail options
                      (TEXT "~S ~S: option ~S may only be given once")
                      'define-method-combination name ':operator))
                  (unless (symbolp argument)
                    (error-of-type 'ext:source-program-error
                      :form whole-form
                      :detail argument
                      (TEXT "~S ~S, option ~S: ~S is not a symbol")
                      'define-method-combination name ':operator argument))
                  (setq operators (list argument)))
                 (t
                   (error-of-type 'ext:source-program-error
                     :form whole-form
                     :detail optionkey
                     (TEXT "~S ~S: ~S is not a valid short-form option")
                     'define-method-combination name optionkey)))))
           `(DO-DEFINE-METHOD-COMBINATION
              ',name
              ,@(when documentation
                  `(:DOCUMENTATION ',documentation))
              ,@(when identities
                  `(:IDENTITY-WITH-ONE-ARGUMENT ',(first identities)))
              :OPERATOR ',(if operators (first operators) name)
              :QUALIFIERS ',(list name ':around)
              :CHECK-OPTIONS #'SHORT-FORM-METHOD-COMBINATION-CHECK-OPTIONS
              :EXPANDER #'SHORT-FORM-METHOD-COMBINATION-EXPANDER
              :CHECK-METHOD-QUALIFIERS #'SHORT-FORM-METHOD-COMBINATION-CHECK-METHOD-QUALIFIERS
              :CALL-NEXT-METHOD-ALLOWED #'SHORT-FORM-METHOD-COMBINATION-CALL-NEXT-METHOD-ALLOWED)))
        ;; "The long form syntax ... is recognized when the second subform is a
        ;;  list."
        ((and (consp options) (listp (first options)))
         ;; Long form.
         (unless (and (>= (length options) 2) (listp (second options)))
           (error-of-type 'ext:source-program-error
             :form whole-form
             :detail options
             (TEXT "~S ~S: invalid syntax for long form: ~S")
             'define-method-combination name whole-form))
         (let ((lambda-list (first options))
               (method-group-specifiers (second options))
               (body (cddr options)))
           ; Check the lambda-list.
           (analyze-lambdalist lambda-list
             #'(lambda (lalist detail errorstring &rest arguments)
                 (declare (ignore lalist)) ; use WHOLE-FORM instead
                 (sys::lambda-list-error whole-form detail
                   (TEXT "~S ~S: invalid lambda-list: ~?")
                   'define-method-combination name errorstring arguments)))
           ; Check the method-group-specifiers, then the rest.
           (let ((method-groups
                   (parse-method-groups whole-form name method-group-specifiers))
                 (arguments-lambda-list nil)
                 (arguments-variables '())
                 (user-gf-variable nil)
                 (gf-name-variable (gensym "GF-NAME-"))
                 (gf-variable (gensym "GF-"))
                 (combination-variable (gensym "COMBINATION-"))
                 (options-variable (gensym "OPTIONS-"))
                 (methods-variable (gensym "METHODS-"))
                 (method-variable (gensym "METHOD-")))
             (when (and (consp body) (consp (car body))
                        (eq (caar body) ':ARGUMENTS))
               (multiple-value-setq (arguments-lambda-list arguments-variables)
                   (check-em-arguments-option (car body) 'define-method-combination whole-form name))
               (setq body (cdr body)))
             (when (and (consp body) (consp (car body))
                        (eq (caar body) ':GENERIC-FUNCTION))
               (setq user-gf-variable
                     (check-em-generic-function-option (car body) 'define-method-combination whole-form name))
               (setq body (cdr body)))
             (multiple-value-bind (body-rest declarations documentation)
                 (sys::parse-body body t)
               (when arguments-variables
                 ;; Add bindings so that the effective method function can
                 ;; access the arguments that were passed to generic function.
                 (setq body-rest
                       `((LET ,(mapcan
                                 #'(lambda (variable)
                                     (list `(,variable ',variable)))
                                 arguments-variables)
                           ,@body-rest))))
               (multiple-value-bind (check-options-lambda partition-lambda check-lambda)
                   (compute-method-partition-lambdas method-groups body-rest)
                 `(DO-DEFINE-METHOD-COMBINATION
                    ',name
                    ,@(when documentation
                        `(:DOCUMENTATION ',documentation))
                    ,@(when declarations
                        `(:DECLARATIONS '((DECLARE ,@declarations))))
                    ,@(when arguments-lambda-list
                        `(:ARGUMENTS-LAMBDA-LIST ',arguments-lambda-list))
                    :CHECK-OPTIONS
                      #'(LAMBDA (,gf-name-variable ,combination-variable
                                 ,options-variable)
                          (ANY-METHOD-COMBINATION-CHECK-OPTIONS
                            ,gf-name-variable ,combination-variable
                            ,options-variable
                            (FUNCTION METHOD-COMBINATION-OPTION-CHECKER
                              (LAMBDA (,@lambda-list)
                                (,check-options-lambda)))))
                    :EXPANDER #'LONG-FORM-METHOD-COMBINATION-EXPANDER
                    :LONG-EXPANDER
                      #'(LAMBDA (,gf-variable ,methods-variable ,@lambda-list)
                          (LET (,@(when user-gf-variable `(,user-gf-variable ,gf-variable)))
                            (,partition-lambda ,methods-variable)))
                    :CHECK-METHOD-QUALIFIERS
                      #'(LAMBDA (,gf-variable ,combination-variable ,method-variable)
                          (DECLARE (IGNORE ,combination-variable))
                          (,check-lambda ,gf-variable ,method-variable))
                    :CALL-NEXT-METHOD-ALLOWED
                      #'LONG-FORM-METHOD-COMBINATION-CALL-NEXT-METHOD-ALLOWED))))))
        (t (error-of-type 'ext:source-program-error
             :form whole-form
             :detail whole-form
             (TEXT "~S ~S: invalid syntax, neither short form nor long form syntax: ~S")
             'define-method-combination name whole-form))))

;; DEFINE-METHOD-COMBINATION execution.
;; Performs the instantiation and registration and returns the name.
(defun do-define-method-combination (name &rest initargs) ; ABI
  (let ((method-combination
          (apply #'make-instance-<method-combination> <method-combination>
                 :name name initargs)))
    (setf (get-method-combination name) method-combination)
    name))

;;; ---------------------------------- Misc ----------------------------------

(defun method-combination-with-options (gf-name combination options) ; ABI
  (funcall (method-combination-check-options combination)
           gf-name combination options)
  (when options
    (setq combination (copy-method-combination combination))
    (setf (method-combination-options combination) (copy-list options)))
  combination)

(defun find-method-combination-<generic-function>-<symbol> (gf name options)
  (let ((combination (get-method-combination name 'defgeneric)))
    (method-combination-with-options (sys::closure-name gf) combination options)))

;; Preliminary.
(predefun find-method-combination (gf name options)
  (find-method-combination-<generic-function>-<symbol> gf name options))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-methcomb2.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-methcomb1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP: Method Combination
;;;; Bruno Haible 21.8.1993 - 2004
;;;; Sam Steingold 1998 - 2004
;;;; German comments translated into English: Stefan Kain 2002-04-08
;;;; James Anderson 2003

(in-package "CLOS")

;;; ===========================================================================

;;; Global management of method-combinations and their names:

;; Mapping from name, a symbol, to method-combination instance.
;; If the caller is non-nil, an error is signalled if the method-combination
;; does not exist. Otherwise nil is returned.
;; All method-combination objects used here have an empty options list;
;; method-combination objects with options are stored in generic functions.
(defun get-method-combination (name caller)
  (or (get name '%method-combination)
      (and caller
           (error (TEXT "~S: The method combination ~S is not defined.")
                  caller name))))
(defun (setf get-method-combination) (new-value name)
  (setf (get name '%method-combination) new-value))

;;; ===========================================================================

;;; The method-combination class definition.
;; A method-combination is used 1) without options when defined and attached
;; to a symbol, 2) with options when applied to a particular generic function.
;; Strange design... but ANSI CL specifies it this way.
;; A structure definition is to be preferred, otherwise the compiled
;; load fails on type tests as the class can't be defined early enough
;; in the file.
(defparameter <method-combination>
  (defclass method-combination (metaobject)
    ((name                      ; a symbol naming the method combination
       :type symbol
       :accessor method-combination-name)
     (documentation             ; an optional documentation string
       :type (or null string)
       :accessor method-combination-documentation)
     (check-options             ; A function of 3 arguments
                                ; (function-name method-combination options)
                                ; that checks the syntax of arguments to the
                                ; method combination
       :type function
       :accessor method-combination-check-options)
     (expander                  ; A function of 4 arguments
                                ; (function method-combination options methods)
                                ; which computes two values: 1. the inner body
                                ; of the effective method, as a form containing
                                ; (CALL-METHOD ...) forms, 2. a list of
                                ; options describing the wrapper, such as
                                ; (:ARGUMENTS ...) or (:GENERIC-FUNCTION ...).
       :type function
       :accessor method-combination-expander)
     (check-method-qualifiers   ; A function of 3 arguments
                                ; (function method-combination method)
                                ; that checks whether the method's qualifiers
                                ; are compatible with the method-combination.
       :type function
       :accessor method-combination-check-method-qualifiers)
     (call-next-method-allowed  ; A function of 3 arguments
                                ; (function method-combination method)
                                ; telling whether call-next-method is allowed
                                ; in the particular method.
       :type function
       :accessor method-combination-call-next-method-allowed)
     (declarations              ; list to be prepended to the effective method
                                ; body
       :type list
       :accessor method-combination-declarations)

     ;; The following slots apply only to standard and short form
     ;; method-combination.
     (qualifiers                ; the allowed list of qualifiers
       :type list
       :accessor method-combination-qualifiers)

     ;; The following slots apply only to short form method-combination.
     (operator                  ; a symbol
       :type symbol
       :accessor method-combination-operator)
     (identity-with-one-argument ; true if `(operator ,x) should be replaced
                                ; with x
       :type boolean
       :accessor method-combination-identity-with-one-argument)

     ;; The following slots apply only to long form method-combination.
     (long-expander             ; A function of 2+n variables
                                ; (function methods . options)
                                ; which computes the inner body of the effective
                                ; method, as a form containing (CALL-METHOD ...)
                                ; forms
       :type function
       :accessor method-combination-long-expander)
     (arguments-lambda-list     ; The :arguments option of the defined method
                                ; combination for inclusion in the effective
                                ; method function.
       :type list
       :accessor method-combination-arguments-lambda-list)

     ;; The following slots depend on the particular generic function.
     (options                   ; arguments for the method combination
       :type list
       :accessor method-combination-options))

    (:fixed-slot-locations t)
    (:generic-accessors nil)))

(defun initialize-instance-<method-combination> (combination &rest args
                                                 &key name
                                                      (documentation nil)
                                                      check-options
                                                      expander
                                                      check-method-qualifiers
                                                      call-next-method-allowed
                                                      (declarations '())
                                                      qualifiers
                                                      operator
                                                      (identity-with-one-argument nil)
                                                      long-expander
                                                      arguments-lambda-list
                                                      (options '()))
  (when *classes-finished*
    (apply #'%initialize-instance combination args)) ; == (call-next-method)
  (setf (method-combination-name combination) name)
  (setf (method-combination-documentation combination) documentation)
  (setf (method-combination-check-options combination) check-options)
  (setf (method-combination-expander combination) expander)
  (setf (method-combination-check-method-qualifiers combination) check-method-qualifiers)
  (setf (method-combination-call-next-method-allowed combination) call-next-method-allowed)
  (setf (method-combination-declarations combination) declarations)
  (setf (method-combination-qualifiers combination) qualifiers)
  (setf (method-combination-operator combination) operator)
  (setf (method-combination-identity-with-one-argument combination) identity-with-one-argument)
  (setf (method-combination-long-expander combination) long-expander)
  (setf (method-combination-arguments-lambda-list combination) arguments-lambda-list)
  (setf (method-combination-options combination) options)
  combination)

(defun make-instance-<method-combination> (class &rest args
                                           &key &allow-other-keys)
  ;; class = <method-combination>
  ;; Don't add functionality here! This is a preliminary definition that is
  ;; replaced with #'make-instance later.
  (declare (ignore class))
  (let ((combination (%allocate-instance <method-combination>)))
    (apply #'initialize-instance-<method-combination> combination args)))

(defun copy-method-combination (combination)
  (make-instance-<method-combination> <method-combination>
    :name (method-combination-name combination)
    :documentation (method-combination-documentation combination)
    :check-options (method-combination-check-options combination)
    :expander (method-combination-expander combination)
    :check-method-qualifiers (method-combination-check-method-qualifiers combination)
    :call-next-method-allowed (method-combination-call-next-method-allowed combination)
    :declarations (method-combination-declarations combination)
    :qualifiers (method-combination-qualifiers combination)
    :operator (method-combination-operator combination)
    :identity-with-one-argument (method-combination-identity-with-one-argument combination)
    :long-expander (method-combination-long-expander combination)
    :arguments-lambda-list (method-combination-arguments-lambda-list combination)
    :options (method-combination-options combination)))

(defun print-object-<method-combination> (object stream)
  (print-unreadable-object (object stream :identity t :type t)
    (write (method-combination-name object) :stream stream)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-methcomb1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-metaobject1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP
;;;; Generic metaobjects
;;;; Bruno Haible 2004-05-29

(in-package "CLOS")

;;; The metaobject abstract class.

(defvar <metaobject> 'metaobject)
(defvar *<metaobject>-defclass*
  '(defclass metaobject ()
     ()))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-metaobject1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-macros.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP
;;;; Internal Macros
;;;; Bruno Haible 2004

(in-package "CLOS")

;;; ===========================================================================

;;; Support for weak sets that are stored as either
;;; - NIL or a weak-list (for saving memory when there are few subclasses), or
;;; - a weak-hash-table (for speed when there are many subclasses).

;;; (def-weak-set-accessors ACCESSOR ELEMENT-TYPE
;;;   ADDER REMOVER LISTER)
;;; defines three functions
;;;   (defun ADDER (holder element) ...) ; adds element to the set
;;;   (defun REMOVER (holder element) ...) ; removes element from the set
;;;   (defun LISTER (holder) ...) ; returns the set as a freshly consed list

(defmacro def-weak-set-accessors (accessor element-type adder remover lister)
  `(PROGN
     (DEFUN ,adder (HOLDER ELEMENT)
       (ADD-TO-WEAK-SET HOLDER (,accessor HOLDER) ELEMENT
                        #'(SETF ,accessor) ',element-type))
     (DEFUN ,remover (HOLDER ELEMENT)
       (REMOVE-FROM-WEAK-SET HOLDER (,accessor HOLDER) ELEMENT))
     (DEFUN ,lister (HOLDER)
       (LIST-WEAK-SET (,accessor HOLDER)))))

;; Auxiliary functions for def-weak-set-accessors.

(defun add-to-weak-set (holder set element setter element-type)
  (cond ((null set)
         (let ((new-set (ext:make-weak-list (list element))))
           (funcall setter new-set holder)))
        ((ext:weak-list-p set)
         (let ((list (ext:weak-list-list set)))
           (unless (member element list :test #'eq)
             (push element list)
             (if (<= (length list) 10)
               (setf (ext:weak-list-list set) list)
               (let ((new-set
                       (let ((ht (make-hash-table :key-type element-type :value-type '(eql t)
                                                  :test 'ext:stablehash-eq :warn-if-needs-rehash-after-gc t
                                                  :weak :key)))
                         (dolist (x list) (setf (gethash x ht) t))
                         ht)))
                 (funcall setter new-set holder))))))
        (t (setf (gethash element set) t))))

(defun remove-from-weak-set (holder set element)
  (declare (ignore holder))
  (cond ((null set))
        ((ext:weak-list-p set)
         (let ((list (ext:weak-list-list set)))
           (when (member element list :test #'eq)
             (setf (ext:weak-list-list set) (remove element list :test #'eq)))))
        (t (remhash element set))))

(defun list-weak-set (set)
  (cond ((null set) '())
        ((ext:weak-list-p set)
         (ext:weak-list-list set))
        (t (let ((l '()))
             (maphash #'(lambda (x y) (declare (ignore y)) (push x l)) set)
             l))))

;;; ===========================================================================

;; Typecheck in accessor functions that are not generic functions.
;; (accessor-typecheck object class caller)
;; > object: a form producing any object.
;; > class: a form producing a class or a class name.
;; > caller: a form producing the accessor's name, usually a quoted symbol.
(defmacro accessor-typecheck (object class caller)
  `(UNLESS (TYPEP ,object ,class)
     (ERROR-ACCESSOR-TYPECHECK ,caller ,object ,class)))

;; Auxiliary function for non-generic accessors.
(defun error-accessor-typecheck (caller object class) ; ABI
  (error-of-type 'type-error
    :datum object :expected-type class
    "~S: The argument is not of type ~S: ~S"
    caller
    (if (and (defined-class-p class) (eq (find-class (class-name class) nil) class))
      (class-name class)
      class)
    object))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-macros.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP
;;;; Bruno Haible 21.8.1993 - 2004
;;;; Sam Steingold 1998 - 2004, 2007
;;;; German comments translated into English: Stefan Kain 2002-04-08
;;;; method combinations: James Anderson 2003

(in-package "CLOS")

;;; preliminary remarks:

;; abbreviations:
;; std = standard
;; gf = generic function
;; <...> = (class ...), mostly = (find-class '...)
;; em = effective method

; Now DEFCLASS works (except for accessor methods).
(load "clos-slots1")
(load "clos-method1")
(load "clos-methcomb1")
(load "clos-genfun1")
(load "clos-genfun2a")
(load "clos-methcomb2")
(load "clos-genfun2b")
(load "clos-method2")
(load "clos-genfun3")
; Now DEFGENERIC, DEFMETHOD work. DEFCLASS works fully.
(load "clos-dependent")
(load "clos-genfun4")
(load "clos-method3")
(load "clos-methcomb3")
(load "clos-slots2")
(load "clos-slotdef2")
(load "clos-stablehash2")
(load "clos-specializer2")
(load "clos-class4")
(load "clos-class5")
; Now instance creation works. Instances can be passed to generic functions.
(setq *classes-finished* t)
(setq *allow-making-generic* t)
(load "clos-slotdef3")
(load "clos-specializer3")
(load "clos-class6")
(load "clos-method4")
(load "clos-methcomb4")
(load "clos-genfun5")
(load "clos-print")
(load "clos-custom")
(setq *allow-making-generic* nil)
(load "documentation")
(setq *enable-clos-warnings* t)


;; Bootstrapping techniques

; Due to the extreme self-circularity of CLOS - classes are CLOS instances
; and therefore described by CLOS classes, generic functions are customizable
; through generic functions, CLOS instances are constructed through
; make-instance which is a generic function, etc. - several techniques need
; to be used for bootstrapping.

; 1) class-version
; Since each CLOS instance points to its class, and CLOS classes are
; themselves CLOS instances - how can the first CLOS class be created?
; In particular, the class STANDARD-CLASS is a direct instance of itself.
; But it also inherits from the classes CLASS, STANDARD-OBJECT and T, which
; are themselves also instances of CLASS.
; The solution is to realize that each instance points to a CLASS-VERSION
; which itself points to the CLASS. These CLASS-VERSION objects are ideal
; points for breaking the circularity, because they are just plain
; simple-vectors and because they are small in number: just one per concrete
; class.
; So for a concrete class <foo> we pre-allocate a class-version:
;
;   (defvar *<foo>-class-version* (make-class-version))
;
; and use it during bootstrapping:
;
;   (defun make-instance-<foo> (class &rest args &key &allow-other-keys)
;     (declare (ignore class))
;     (let ((instance (allocate-metaobject-instance *<foo>-class-version* n)))
;       (apply #'initialize-instance-<foo> instance args)))
;
; Later, immediately after the class is really defined (which creates a new
; class-version for this class) we only need to connect the old class-version
; with the new class:
;
;   (defparameter <foo> (defclass foo ...))
;   (replace-class-version <foo> *<foo>-class-version*)
;
; No need to update already created <foo> instances!

; 2) fixed-slot-locations
; Each local slot value of a standard-object instance is stored at an index
; called "slot location". Each slot value access has, to determine it, to
; look it up in the class' slot-location-table (or similar). But how can it
; know where to find the slot-location-table? In the presence of multiple
; inheritance - which is explicitly allowed for subclasses of CLASS - the
; slot-location-table's index could depend on the class, thus again requiring
; a slot-location-table access in the metaclass, etc. ad infinitum.
; There are two ways to resolve this:
; a) Note that every chain x -> (CLASS-OF x) -> (CLASS-OF (CLASS-OF x)) -> ...
;    must eventually end at the STANDARD-CLASS class. This is because user
;    defined classes must have a metaclass that was defined before them, and
;    among the predefined classes, the STANDARD-CLASS class is the only object
;    for which (EQ x (CLASS-OF x)).
; b) The MOP has a restriction that does not allow programs to create classes
;    that inherit from two categories of metaobjects (classes, slot-definitions,
;    generic functions, methods, method-combinations) simultaneously. See
;    MOP p. 3: "A metaobject class is a subclass of exactly one of these
;    classes. The results are undefined if an attempt is made to define a
;    class that is a subclass of more than one basic metaobject class."
;    This allows the Lisp implementation to fix the index of every slot of the
;    built-in metaobject classes.
; We use approach b), since it obviously leads to more efficient operations.
; (In particular, it allows the operations in record.d to use fixed indices
; for the slot-location-table.)
; To this effect, DEFCLASS with metaclass STANDARD-CLASS supports an option
; (:FIXED-SLOT-LOCATIONS T) that specifies that all local slots listed in this
; class will be accessible under the same slot locations in _all_ subclasses.
; Effectively this disallows some kinds of multiple inheritance; an error
; is signalled during the computation of the slot locations of subclasses if
; the constraints cannot be fulfilled.
; If a class has (:FIXED-SLOT-LOCATIONS T), it makes sense to mark all its
; superclasses that have slots as (:FIXED-SLOT-LOCATIONS T) as well.
; So, after
;
;   (defclass foo ()
;     (slot1 slot2 ... slotN)
;     (:fixed-slot-locations t))
;
; we know that slot1 will be at index 1, slot2 at index 2, etc. in all
; subclasses.

; 3) initialize-instance and make-instance methods
; make-instance and initialize-instance are generic functions used for the
; construction of instances. But they are themselves built from methods,
; which are CLOS instances, and whose specializers are CLOS classes, therefore
; also CLOS instances. How can the first CLOS instances be created then?
; The solution is to use plain non-generic functions for creating and
; initializing all CLOS instances, until the CLOS is sufficiently complete
; for executing generic functions like make-instance and initialize-instance.
; But we want 1. to avoid code duplication, 2. to avoid differences in
; behaviour between the incomplete CLOS and the complete CLOS.
; The way to achieve this is to define the bulk of the built-in methods of
; user-extensible generic functions in plain functions, which then get called
; or replaced by method definitions.
;
; Idiom 1, that can be used for any normal or user-extensible generic function:
;   (defclass foo ...)
;   (defun something-<foo> (a b c) ...)
;   (defun something (a b c) (something-<foo> a b c))
;   (defun other-code ... (something ...))
;   ; and then after CLOS is complete:
;   (fmakunbound 'something)
;   (defgeneric something (a b c)
;     (:method ((a foo) b c)
;       (something-<foo> a b c)))
;
; Idiom 2, that can be used for methods with only the standard behaviour:
;   (defclass foo ...)
;
;   (defun initialize-instance-<foo> (instance &rest args &key &allow-other-keys)
;     (apply #'shared-initialize instance 't args))
;   (defun other-code ... (initialize-instance-<foo> ...))
;   ; and then after CLOS is complete:
;   (setf (fdefinition 'initialize-instance-<foo>) #'initialize-instance)
;
;   (defun make-instance-<foo> (class &rest args &key &allow-other-keys)
;     (declare (ignore class))
;     (let ((instance (allocate-metaobject-instance *<foo>-class-version* n)))
;       (apply #'initialize-instance-<foo> instance args)))
;   (defun other-code ... (make-instance-<foo> ...))
;   ; and then after CLOS is complete:
;   (setf (fdefinition 'make-instance-<foo>) #'make-instance)

; 4) *classes-finished* and %initialize-instance
; When the user creates a subclass of a metaobject class, instances of his
; class should be initialized correctly:
;   (defclass my-method (method)
;     ((slot1 :initform (slot1-init) ...) ...))
; It is the last-priority applicable method of initialize-instance, called
; clos::%initialize-instance, that calls
;   (setf (slot-value new-instance 'slot1) (slot1-init))
; So we have to call clos::%initialize-instance at the beginning of
; initialize-instance-<method>. But we cannot do this while the CLOS is not
; complete - because clos::%initialize-instance does a CLASS-OF of the instance
; and then traverses the slot-location-table of the class. Both of these (the
; pointer from the class-version to the class, and the slot-location-table
; in the class) don't exist at this moment. The fact that CLOS is complete or
; not is indicated by the variable *classes-finished*. So what we do is
;
;   (defun initialize-instance-<method> (instance &rest args &key &allow-other-keys)
;     (when *classes-finished*
;       (apply #'%initialize-instance instance args)) ; == (call-next-method)
;     ...)
;
; But to avoid behaviour differences between *classes-finished* = nil and = t,
; we have simulate the task of %initialize-instance during bootstrapping. In
; the initialize-instance-<xyz> function of each subclass we have to fill the
; slots with the initforms. Example:
;
;   (defun initialize-instance-<foo-method> (instance &rest args &key &allow-other-keys)
;     (apply #'initialize-instance-<method> instance args) ; == (call-next-method)
;     (unless *classes-finished*
;       ; Bootstrapping: Simulate the effect of #'%initialize-instance.
;       (setf (foo-method-slot1) (foo-method-slot1-initform))
;       ...)
;     ...)
;
; For subclasses of <class>, the same holds for shared-initialize instead of
; initialize-instance.

; 5) generic-accessors
; Once CLASS and SLOT-DEFINITION and its subclasses are defined, we can already
; use DEFCLASS to define classes like METHOD or METHOD-COMBINATION. The use of
; (:FIXED-SLOT-LOCATIONS T) guarantees fast accessors if we write them by hand,
; one by one. As a shorthand, to automate the creation of accessors at a moment
; when generic functions don't yet work, the DEFCLASS option
; (:GENERIC-ACCESSORS NIL) allows to create the accessors as plain functions.
; This is like DEFSTRUCT does for STRUCTURE-CLASS/STRUCTURE-OBJECT instance
; accessors, except that it also works for STANDARD-CLASS/STANDARD-OBJECT
; accessors. Thus,
;
;   (defclass foo ()
;     ((slot1 :accessor foo-slot1) ...)
;     (:generic-accessors nil))
;
; is equivalent to
;
;   (defclass foo ()
;     ((slot1) ...)
;   (defun foo-slot1 (instance)
;     (accessor-typecheck instance 'foo 'foo-slot1)
;     (slot-value instance 'slot1))
;   (defun (setf foo-slot1) (new-value instance)
;     (accessor-typecheck instance 'foo '(setf foo-slot1))
;     (setf (slot-value instance 'slot1) new-value))
;
; This can be combined with (:FIXED-SLOT-LOCATIONS T):
;
;   (defclass foo ()
;     ((slot1 :accessor foo-slot1) ...)
;     (:fixed-slot-locations t)
;     (:generic-accessors nil))
;
; is equivalent to
;
;   (defclass foo ()
;     ((slot1) ...)
;   (defun foo-slot1 (instance)
;     (accessor-typecheck instance 'foo 'foo-slot1)
;     (sys::%record-ref instance 1))
;   (defun (setf foo-slot1) (new-value instance)
;     (accessor-typecheck instance 'foo '(setf foo-slot1))
;     (setf (sys::%record-ref instance 1) new-value))


;; Debugging Techniques

; Some generic functions, like compute-effective-method or method-specializers,
; are used to implement the behaviour of generic functions. We have a boot-
; strapping problem here.
; Since we try to call the generic function whenever possible, and the non-
; generic particular method only if absolutely necessary, the technique is to
; write generic code and break the metacircularity at selected points.
; In practice this means you get a "*** - Lisp stack overflow. RESET" message
; and have to break the endless recursion. How to detect the metacircularity
; that causes the endless recursion?
; 1. Start "./lisp.run -i init.lisp | tee log". You get "Lisp stack overflow".
; 2. Find the source form which causes the endless recursion. If you are
;    unsure, add a ":echo t" to the LOAD form loading the particular form in
;    init.lisp or clos.lisp and go back to step 1.
; 3. At the prompt, type  (in-package "CLOS")  and the problematic source form.
; 4. While it is executing, eating more and more stack, interrupt it through a
;    "kill -2 <pid>" from a nearby shell window, where <pid> is the lisp.run's
;    process id. (Just pressing Ctrl-C would kill the lisp.run and tee
;    processes.)
; 5. Type  (ext:show-stack).
; 6. Analyze the resulting log file. To find the loop in the stack trace,
;    concentrate on the middle. You have to skip the first 500 or 1000 lines
;    of stack trace. To get a quick overview, look at only the lines
;    starting with "APPLY frame".
; 7. Think about the ideal point for breaking the loop.


;; Extension Protocols

; The MOP specifies the following individual protocols.
; The "checks" column tells whether the CLISP code contains verifications
; that the user added code is fulfilling the required constraints.
; The "testsuite" column tells whether the mop.tst contains interesting
; testcases.
;                                                     checks  testsuite
; add-dependent remove-dependent map-dependents         --      OK
; add-direct-method remove-direct-method \
;   specializer-direct-generic-functions \
;   specializer-direct-methods                          --      OK
; add-direct-subclass remove-direct-subclass \
;   class-direct-subclasses                             OK      OK
; compute-applicable-methods \
;   compute-applicable-methods-using-classes            OK      OK
; compute-class-precedence-list                         OK      OK
; compute-default-initargs                              OK      OK
; compute-direct-slot-definition-initargs               OK      OK
; compute-discriminating-function                       OK      OK
; compute-effective-method                              --      OK
; compute-effective-slot-definition                     OK      OK
; compute-effective-slot-definition-initargs            OK      OK
; compute-slots                                         OK      OK
; direct-slot-definition-class                          OK      OK
; effective-slot-definition-class                       OK      OK
; ensure-class-using-class                              OK      OK
; ensure-generic-function-using-class                   OK      OK
; make-method-lambda
; reader-method-class                                   OK      OK
; slot-value-using-class \
;   (setf slot-value-using-class) \
;   slot-boundp-using-class \
;   slot-makunbound-using-class                         --      OK
; validate-superclass                                   OK      OK
; writer-method-class                                   OK      OK
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-genfun5.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP
;;;; Generic Functions
;;;; Part n-1: Generic functions specified in the MOP.
;;;; Bruno Haible 2004-06-13
;;;; Sam Steingold 2017

(in-package "CLOS")


;; Make creation of <standard-generic-function> instances customizable.
(setf (fdefinition 'make-instance-<standard-generic-function>) #'make-instance)

;; Make creation of generic-function instances customizable.
(setf (fdefinition 'allocate-generic-function-instance) #'allocate-instance) ; ABI
(setf (fdefinition 'make-generic-function-instance) #'make-instance) ; ABI

;;; ===========================================================================

;;; Generic function definition customization

;; MOP p. 50
(defgeneric ensure-generic-function-using-class (gf funname
                                                 &key generic-function-class
                                                      lambda-list
                                                      argument-precedence-order
                                                      method-class
                                                      method-combination
                                                      documentation
                                                      declarations
                                                      declare
                                                      environment
                                                   &allow-other-keys)
  (declare (dynamically-modifiable))
  (:method ((gf generic-function) funname &rest args)
    (apply #'ensure-generic-function-using-class-<t> gf funname args))
  (:method ((gf null) funname &rest args)
    (apply #'ensure-generic-function-using-class-<t> gf funname args)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-genfun5.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-genfun4.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP
;;;; Generic Functions
;;;; Part n-2: make/initialize-instance methods, generic functions.
;;;; Bruno Haible 21.8.1993 - 2004
;;;; Sam Steingold 1998 - 2005, 2008, 2010, 2017
;;;; German comments translated into English: Stefan Kain 2002-04-08

(in-package "CLOS")


;; ----------------------------------------------------------------------------

;;; Lift the initialization protocol.

(defmethod shared-initialize ((gf generic-function) situation &rest args
                              &key name)
  (declare (ignore name))
  (apply #'shared-initialize-<generic-function> gf situation args))

(defmethod shared-initialize ((gf standard-generic-function) situation &rest args
                              &key name
                                   lambda-list
                                   argument-precedence-order
                                   method-class
                                   method-combination
                                   documentation
                                   declarations
                                   declare)
  (declare (ignore name lambda-list argument-precedence-order method-class
                   method-combination documentation declarations declare))
  (apply #'shared-initialize-<standard-generic-function> gf situation args))

(defmethod initialize-instance ((gf generic-function) &rest args
                                &key name
                                     lambda-list
                                     argument-precedence-order
                                     method-class
                                     method-combination
                                     documentation
                                     declarations
                                     declare
                                     ((methods methods) nil)) ; from DEFGENERIC
  (declare (ignore name lambda-list argument-precedence-order method-class
                   method-combination documentation declarations declare
                   methods))
  (apply #'initialize-instance-<generic-function> gf args))

(defmethod reinitialize-instance ((gf generic-function) &rest args
                                  &key name
                                       lambda-list
                                       argument-precedence-order
                                       method-class
                                       method-combination
                                       documentation
                                       declarations
                                       declare
                                       ((methods methods) nil) ; from DEFGENERIC
                                  &allow-other-keys)
  (declare (ignore name lambda-list argument-precedence-order method-class
                   method-combination documentation declarations declare
                   methods))
  (apply #'reinitialize-instance-<generic-function> gf args))

;; ----------------------------------------------------------------------------

;; An argument is called "dispatching" if not all the corresponding parameter
;; specializers are <t>.
(defun dispatching-arg-p (index methods)
  (notevery #'(lambda (method)
                (eq (nth index (method-specializers method)) <t>))
            methods))
(defun single-dispatching-arg (reqanz methods)
  (let ((first-dispatching-arg
         (dotimes (i reqanz nil)
           (when (dispatching-arg-p i methods) (return i)))))
    (and first-dispatching-arg
         (do ((i (1+ first-dispatching-arg) (1+ i)))
             ((>= i reqanz) first-dispatching-arg)
           (when (dispatching-arg-p i methods) (return nil))))))
(defun dispatching-arg-type (index methods)
  `(OR ,@(remove-duplicates
           (mapcar #'(lambda (method)
                       (nth index (method-specializers method)))
                   methods)
           :test #'same-specializers-p)))

(defgeneric no-applicable-method (gf &rest args)
  (declare (dynamically-modifiable))
  (:method ((gf t) &rest args)
    (let* ((methods (safe-gf-methods gf))
           (dispatching-arg
             (if (safe-gf-undeterminedp gf)
               nil
               (let ((reqnum (sig-req-num (safe-gf-signature gf))))
                 (single-dispatching-arg reqnum methods)))))
      (sys::retry-function-call
        (if dispatching-arg
          (make-condition 'method-call-type-error
            :datum (nth dispatching-arg args)
            :expected-type (dispatching-arg-type dispatching-arg methods)
            :generic-function gf :argument-list args
            :format-control (TEXT "~S: When calling ~S with arguments ~S, no method is applicable.")
            :format-arguments (list 'no-applicable-method gf args))
          (make-condition 'method-call-error
            :generic-function gf :argument-list args
            :format-control (TEXT "~S: When calling ~S with arguments ~S, no method is applicable.")
            :format-arguments (list 'no-applicable-method gf args)))
        gf args))))

(defgeneric missing-required-method (gf combination group-name group-filter &rest args) ; ABI
  (:method ((gf t) (combination method-combination) (group-name symbol) (group-filter function) &rest args)
    (let* ((methods (remove-if-not group-filter (safe-gf-methods gf)))
           (dispatching-arg
             (if (safe-gf-undeterminedp gf)
               nil
               (let ((reqnum (sig-req-num (safe-gf-signature gf))))
                 (single-dispatching-arg reqnum methods)))))
      (if dispatching-arg
        (error-of-type 'method-call-type-error
          :datum (nth dispatching-arg args)
          :expected-type (dispatching-arg-type dispatching-arg methods)
          :generic-function gf :argument-list args
          (TEXT "~S: When calling ~S with arguments ~S, no method of group ~S (from ~S) is applicable.")
          'missing-required-method gf args group-name combination)
        (error-of-type 'method-call-error
          :generic-function gf :argument-list args
          (TEXT "~S: When calling ~S with arguments ~S, no method of group ~S (from ~S) is applicable.")
          'missing-required-method gf args group-name combination)))))

;; Special case of missing-required-method for STANDARD method combination
;; and the PRIMARY method group.
(defgeneric no-primary-method (gf &rest args)
  (declare (dynamically-modifiable))
  (:method ((gf t) &rest args)
    (let* ((methods (remove-if-not #'null (safe-gf-methods gf)
                                   :key #'method-qualifiers))
           (dispatching-arg
             (if (safe-gf-undeterminedp gf)
               nil
               (let ((reqnum (sig-req-num (safe-gf-signature gf))))
                 (single-dispatching-arg reqnum methods)))))
      (sys::retry-function-call
        (if dispatching-arg
          (make-condition 'method-call-type-error
            :datum (nth dispatching-arg args)
            :expected-type (dispatching-arg-type dispatching-arg methods)
            :generic-function gf :argument-list args
            :format-control (TEXT "~S: When calling ~S with arguments ~S, no primary method is applicable.")
            :format-arguments (list 'no-primary-method gf args))
          (make-condition 'method-call-error
            :generic-function gf :argument-list args
            :format-control (TEXT "~S: When calling ~S with arguments ~S, no primary method is applicable.")
            :format-arguments (list 'no-primary-method gf args)))
        gf args))))

(defun %no-next-method (backpointer &rest args) ; ABI
  (let ((method (car backpointer)))
    (apply #'no-next-method (method-generic-function method) method args)))
(defgeneric no-next-method (gf method &rest args)
  (declare (dynamically-modifiable))
  (:method ((gf standard-generic-function) (method method) &rest args
            &aux (cont-mesg (format nil (TEXT "ignore ~S") 'CALL-NEXT-METHOD)))
    (if (let ((method-combo (safe-gf-method-combination gf)))
          (funcall (method-combination-call-next-method-allowed method-combo)
                   gf method-combo method))
      (cerror cont-mesg 'method-call-error
        :generic-function gf :method method :argument-list args
        :format-control (TEXT "~S: When calling ~S with arguments ~S, there is no next method after ~S, and ~S was called.")
        :format-arguments (list 'no-next-method gf args method
                                '(call-next-method)))
      (let ((qualifiers (method-qualifiers method)))
        (if qualifiers
          (cerror cont-mesg 'sys::simple-program-error
            :format-control (TEXT "~S: ~S is invalid within ~{~S~^ ~} methods")
            :format-arguments (list gf 'CALL-NEXT-METHOD qualifiers))
          (cerror cont-mesg 'sys::simple-program-error
            :format-control (TEXT "~S: ~S is invalid within primary methods")
            :format-arguments (list gf 'CALL-NEXT-METHOD)))))))

;; ----------------------------------------------------------------------------

(defgeneric find-method (gf qualifiers specializers &optional errorp)
  (declare (dynamically-modifiable))
  (:method ((gf standard-generic-function) qualifiers specializers &optional (errorp t))
    (std-find-method gf qualifiers specializers errorp)))

;; MOP p. 33
(let ((*allow-making-generic* t))
  (defgeneric add-method (gf method)
    (declare (dynamically-modifiable))
    (:method ((gf standard-generic-function) (method method))
      (std-add-method gf method))))
; No extended method check because this GF is specified in ANSI CL.
;(initialize-extended-method-check #'add-method)

;; MOP p. 91
(fmakunbound 'remove-method)
(defgeneric remove-method (gf method)
  (declare (dynamically-modifiable))
  (:method ((gf standard-generic-function) (method method))
    (std-remove-method gf method)))
; No extended method check because this GF is specified in ANSI CL.
;(initialize-extended-method-check #'remove-method)

;; MOP p. 40
(fmakunbound 'compute-discriminating-function)
(defgeneric compute-discriminating-function (gf)
  (declare (dynamically-modifiable))
  (:method ((gf generic-function))
    (compute-discriminating-function-<generic-function> gf)))
(setq |#'compute-discriminating-function| #'compute-discriminating-function)

;; MOP p. 35
(fmakunbound 'compute-applicable-methods)
(defgeneric compute-applicable-methods (gf args)
  (declare (dynamically-modifiable))
  (:method ((gf generic-function) args)
    (compute-applicable-methods-<generic-function> gf args)))
(setq |#'compute-applicable-methods| #'compute-applicable-methods)

;; MOP p. 36
(fmakunbound 'compute-applicable-methods-using-classes)
(defgeneric compute-applicable-methods-using-classes (gf req-arg-classes)
  (declare (dynamically-modifiable))
  (:method ((gf generic-function) req-arg-classes)
    (compute-applicable-methods-using-classes-<generic-function> gf req-arg-classes)))
(setq |#'compute-applicable-methods-using-classes| #'compute-applicable-methods-using-classes)

;; MOP p. 41
(fmakunbound 'compute-effective-method)
(defgeneric compute-effective-method (gf combination methods)
  (declare (dynamically-modifiable))
  (:method ((gf generic-function) combination methods)
    (compute-effective-method-<generic-function> gf combination methods)))
(setq |#'compute-effective-method| #'compute-effective-method)

;; ----------------------------------------------------------------------------

;; MOP p. 10
;;
;; "Portable programs may define methods that override specified methods
;;  only when the description of the specified method explicitly allows this."
;; (Note: "override" means a method that does not (call-next-method).)
;;
;; "Portable programs may define methods that extend specified methods
;;  unless the description of the specified method explicitly prohibits this.
;;  Unless there is a specific statement to the contrary, these extending
;;  methods must return whatever value was returned by the call to
;;  call-next-method."
;; (Note: "extend" means a method that does (call-next-method).)
;; There are no explicit prohibitions. So this rule is applicable to all
;; MOP generic functions that are not part of a protocol.

;; Signal an error if the first MOP-standardized method was not called, or
;; if the returned values are different ones.
(defun extended-method-check (called original-values extended-values name)
  (unless called
    (error (TEXT "~S: Overriding a standardized method is not allowed. You need to call ~S.")
           name 'call-next-method))
  (unless (and (eql (length original-values) (length extended-values))
               (every #'eql original-values extended-values))
    (error (if (and (eql (length original-values) 1) (eql (length extended-values) 1))
             (TEXT "~S: Extending a standardized method is only allowed if it returns the same values as the next method.~%Original value: ~{~S~^, ~}~%Value returned by the extending method: ~{~S~^, ~}")
             (TEXT "~S: Extending a standardized method is only allowed if it returns the same values as the next method.~%Original values: ~{~S~^, ~}~%Values returned by the extending method: ~{~S~^, ~}"))
           name original-values extended-values))
  (values-list extended-values))

;; The list of packages whose classes are considered MOP-standardized.
(defvar *mop-standardized-packages*
        (list (find-package "COMMON-LISP") (find-package "CLOS")))

;; Tests whether a method is considered MOP-standardized.
(defun mop-standardized-p (method)
  ;; Careful! Don't use the generic function method-specializers here,
  ;; otherwise we get an infinite recursion.
  (and (typep method 'standard-method)
       (every #'(lambda (specializer)
                  (and (defined-class-p specializer)
                       (let ((name (class-name specializer)))
                         (and (symbolp name)
                              (memq (symbol-package name)
                                    *mop-standardized-packages*)))))
              (std-method-specializers method))))

;; Rewrite an effective-method, adding a check that
;; 1. the first MOP-standardized method in the list is really called,
;; 2. the returned values are identical to the values of this call.
(defun add-extended-method-check (efm gf)
  (let ((name (generic-function-name gf)))
    (flet ((add-outer-wrapper (form)
             `(LET ((STANDARDIZED-METHOD-CALLED NIL)
                    (STANDARDIZED-METHOD-VALUES NIL))
                (LET ((EXTENDED-VALUES (MULTIPLE-VALUE-LIST ,form)))
                  (EXTENDED-METHOD-CHECK STANDARDIZED-METHOD-CALLED
                                         STANDARDIZED-METHOD-VALUES
                                         EXTENDED-VALUES
                                         ',name))))
           (add-method-call-wrapper (form)
             `(PROGN
                (SETQ STANDARDIZED-METHOD-VALUES (MULTIPLE-VALUE-LIST ,form))
                (SETQ STANDARDIZED-METHOD-CALLED T)
                (VALUES-LIST STANDARDIZED-METHOD-VALUES))))
      (labels ((convert-effective-method (efm)
                 (if (consp efm)
                   (if (eq (car efm) 'CALL-METHOD)
                     (let ((method-list (third efm)))
                       (if (or (typep (first method-list) 'method) (rest method-list))
                         ; Reduce the case of multiple methods to a single one.
                         ; Make the call to the next-method explicit.
                         (convert-effective-method
                           `(CALL-METHOD ,(second efm)
                              ((MAKE-METHOD
                                 (CALL-METHOD ,(first method-list) ,(rest method-list))))))
                         ; Now the case of at most one method.
                         (if (and (typep (second efm) 'method)
                                  (member (method-qualifiers (second efm)) '((:before) (:after))
                                          :test #'equal))
                           ; Don't recurse into :before/:after methods since they
                           ; cannot call CALL-NEXT-METHOD and their values are ignored.
                           efm
                           (if (and (typep (second efm) 'method)
                                    (mop-standardized-p (second efm)))
                             ; Wrap the method call. Don't need to recurse into efm
                             ; because we are only interested in the outermost call
                             ; to a MOP-standardized method.
                             (add-method-call-wrapper efm)
                             ; Normal recursive processing.
                             (cons (convert-effective-method (car efm))
                                   (convert-effective-method (cdr efm)))))))
                     (cons (convert-effective-method (car efm))
                           (convert-effective-method (cdr efm))))
                   efm)))
        (add-outer-wrapper (convert-effective-method efm))))))

(defparameter *extended-method-check-method*
  ;; This method is added for each MOP-standardized generic function.
  (defmethod compute-effective-method ((gf (eql nil)) method-combination methods)
    (declare (ignore method-combination))
    (if (or (every #'mop-standardized-p methods)
            (notany #'mop-standardized-p methods))
      (call-next-method)
      (add-extended-method-check (call-next-method) gf))))

(defun initialize-extended-method-check (gf)
  (add-method |#'compute-effective-method|
    (make-instance-<standard-method> <standard-method>
      :qualifiers          (std-method-qualifiers *extended-method-check-method*)
      :lambda-list         (std-method-lambda-list *extended-method-check-method*)
      :specializers        (list (intern-eql-specializer gf) <t> <t>)
      :documentation       (std-method-documentation *extended-method-check-method*)
      'fast-function       (std-method-fast-function *extended-method-check-method*)
      'wants-next-method-p (std-method-wants-next-method-p *extended-method-check-method*)
      'signature           (std-method-signature *extended-method-check-method*))))

;; ----------------------------------------------------------------------------

(defun check-generic-function-initialized (gf)
  (unless (std-gf-initialized gf)
    (error (TEXT "The generic function ~S has not yet been initialized.")
           gf)))

;; MOP p. 80
(defgeneric generic-function-name (generic-function)
  (:method ((gf standard-generic-function))
    (check-generic-function-initialized gf)
    (funcallable-name gf)))
(initialize-extended-method-check #'generic-function-name)
;; MOP p. 92
(defgeneric (setf generic-function-name) (new-value generic-function)
  (:method (new-value (gf standard-generic-function))
    (unless (sys::function-name-p new-value)
      (error-of-type 'type-error
        :datum new-value :expected-type '(or symbol (cons (eql setf) (cons symbol null)))
        (TEXT "~S: The name of a generic function must be a function name, not ~S")
        '(setf generic-function-name) new-value))
    (reinitialize-instance gf :name new-value)
    new-value))
(initialize-extended-method-check #'(setf generic-function-name))

;; MOP p. 80
(let ((*allow-making-generic* t))
  (defgeneric generic-function-methods (generic-function)
    (:method ((gf standard-generic-function))
      (check-generic-function-initialized gf)
      (std-gf-methods gf))))
(setq |#'generic-function-methods| #'generic-function-methods)
(initialize-extended-method-check #'generic-function-methods)

;; MOP p. 80
(let ((*allow-making-generic* t))
  (defgeneric generic-function-method-class (generic-function)
    (:method ((gf standard-generic-function))
      (check-generic-function-initialized gf)
      (std-gf-default-method-class gf))))
(setq |#'generic-function-method-class| #'generic-function-method-class)
(initialize-extended-method-check #'generic-function-method-class)

(defun check-gf-lambda-list (gf caller)
  (when (std-gf-undeterminedp gf)
    (error (TEXT "~S: the lambda-list of ~S is not yet known") caller gf)))

;; MOP p. 79
(defgeneric generic-function-lambda-list (generic-function)
  (:method ((gf standard-generic-function))
    (check-generic-function-initialized gf)
    (check-gf-lambda-list gf 'generic-function-lambda-list)
    (std-gf-lambda-list gf)))
(initialize-extended-method-check #'generic-function-lambda-list)

;; Not in MOP.
(let ((*allow-making-generic* t))
  (defgeneric generic-function-signature (generic-function)
    (:method ((gf generic-function))
      (let ((lambdalist (generic-function-lambda-list gf)))
        (generic-function-lambda-list-to-signature lambdalist
          #'(lambda (lalist detail errorstring &rest arguments)
              (sys::lambda-list-error lalist detail
                 (TEXT "Invalid ~S result ~S: ~?")
                 'generic-function-lambda-list lambdalist
                 errorstring arguments)))))
    (:method ((gf standard-generic-function))
      (check-generic-function-initialized gf)
      (check-gf-lambda-list gf 'generic-function-signature)
      (std-gf-signature gf))))
(setq |#'generic-function-signature| #'generic-function-signature)

;; Not in MOP.
(let ((*allow-making-generic* t))
  (defgeneric generic-function-undeterminedp (generic-function)
    (:method ((gf generic-function))
      ;; It's a pity that this is not a MOP function. So we have to catch errors
      ;; in order to peek into the state of a generic function.
      (block nil
        (sys::%handler-bind
         #'(lambda () (generic-function-lambda-list gf) nil) 'ERROR
         #'(lambda (condition) (declare (ignore condition)) (return t)))))
    (:method ((gf standard-generic-function))
      (check-generic-function-initialized gf)
      (std-gf-undeterminedp gf))))
(setq |#'generic-function-undeterminedp| #'generic-function-undeterminedp)

;; MOP p. 80
(let ((*allow-making-generic* t))
  (defgeneric generic-function-method-combination (generic-function)
    (:method ((gf standard-generic-function))
      (check-generic-function-initialized gf)
      (std-gf-method-combination gf))))
(setq |#'generic-function-method-combination| #'generic-function-method-combination)
(initialize-extended-method-check #'generic-function-method-combination)

;; MOP p. 79
(defgeneric generic-function-argument-precedence-order (generic-function)
  (:method ((gf standard-generic-function))
    (check-generic-function-initialized gf)
    (check-gf-lambda-list gf 'generic-function-argument-precedence-order)
    (let ((argorder (std-gf-argorder gf))
          (lambdalist (std-gf-lambda-list gf)))
      (mapcar #'(lambda (i) (nth i lambdalist)) argorder))))
(initialize-extended-method-check #'generic-function-argument-precedence-order)

;; Not in MOP.
(fmakunbound 'generic-function-argorder)
(defgeneric generic-function-argorder (generic-function)
  (:method ((gf generic-function))
    (let* ((lambdalist (generic-function-lambda-list gf))
           (signature (generic-function-signature gf))
           (reqnum (sig-req-num signature))
           (reqvars (subseq lambdalist 0 reqnum))
           (argument-precedence-order (generic-function-argument-precedence-order gf)))
      (generic-function-argument-precedence-order-to-argorder
        argument-precedence-order reqnum reqvars
        #'(lambda (detail errorstring &rest arguments)
            (declare (ignore detail))
            (error (TEXT "Invalid ~S result ~S: ~?")
                   'generic-function-argument-precedence-order
                   argument-precedence-order errorstring arguments)))))
  (:method ((gf standard-generic-function))
    (check-generic-function-initialized gf)
    (check-gf-lambda-list gf 'generic-function-argorder)
    (std-gf-argorder gf)))
(setq |#'generic-function-argorder| #'generic-function-argorder)

;; MOP p. 79
(fmakunbound 'generic-function-declarations)
(defgeneric generic-function-declarations (generic-function)
  (:method ((gf standard-generic-function))
    (check-generic-function-initialized gf)
    (std-gf-declspecs gf)))
(setq |#'generic-function-declarations| #'generic-function-declarations)
(initialize-extended-method-check #'generic-function-declarations)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-genfun4.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-genfun3.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP: Generic Functions
;;;; Bruno Haible 21.8.1993 - 2004
;;;; Sam Steingold 1998-2004, 2007-2010, 2016-2017
;;;; German comments translated into English: Stefan Kain 2002-04-08

(in-package "CLOS")


;; ============================= Runtime support =============================

;; Runtime support for CALL-NEXT-METHOD.
(defun %call-next-method (backpointer next-methods original-args new-args) ; ABI
  (let* ((method (car backpointer))
         (gf (method-generic-function method)))
    (when (gf-never-called-p gf)
      ;; Oops, gf still contains a prototype dispatch which only calls
      ;; initial-funcall-gf. This can really happen, because make-instance
      ;; can call initial-make-instance, which calls initialize-instance's
      ;; effective method without going through initialize-instance itself.
      ;; Similarly for initial-initialize-instance and
      ;; initial-reinitialize-instance, which call shared-initialize's
      ;; effective method without going through shared-initialize's dispatch.
      ;; Similarly for slot-value, which call slot-value-using-class's
      ;; effective method without going through slot-value-using-class.
      ;; Remedy by calling the prototype dispatch once.
      (apply (sys::generic-function-effective-method-function gf) original-args))
    ;; Now we can assume that the real dispatch is installed.
    (let* ((emf (sys::generic-function-effective-method-function gf))
           (original-em (apply emf original-args))
           (new-em (apply emf new-args)))
      ;; Protect against the case that emf is a prototype dispatch which only
      ;; calls initial-funcall-gf.
      (when (or (eq original-em gf) (eq new-em gf))
        (error-of-type 'error
          (TEXT "~S in ~S: bug in determination of effective methods")
          'call-next-method gf))
      (if (eq original-em new-em)
        (if next-methods
          (apply next-methods new-args)
          (apply #'%no-next-method backpointer new-args))
        (error-of-type 'error
          (TEXT "~S in ~S: the new arguments ~S have a different effective method than the old arguments ~S")
          'call-next-method gf new-args original-args)))))


;; =================== Initialization and Reinitialization ===================

(defun make-generic-function (generic-function-class caller whole-form funname lambda-list argument-precedence-order method-combination method-combination-p method-class method-class-p declspecs declspecs-p documentation documentation-p user-defined-args ; ABI
                              &rest methods)
  (when user-defined-args
    ;; Provide good error messages. The error message from
    ;; MAKE-INSTANCE later is unintelligible.
    (let ((valid-keywords (class-valid-initialization-keywords generic-function-class)))
      (unless (eq valid-keywords 'T)
        (dolist (option user-defined-args)
          (unless (member (first option) valid-keywords)
            (error-of-type 'ext:source-program-error
              :form whole-form
              :detail option
              (TEXT "~S ~S: invalid ~S option ~S")
              caller funname 'defgeneric option))))))
  (let ((gf (apply #'make-generic-function-instance generic-function-class
              :name funname
              :lambda-list lambda-list
              :argument-precedence-order argument-precedence-order
              (append
                (if method-class-p (list :method-class method-class))
                (if method-combination-p (list :method-combination method-combination))
                (if declspecs-p (list :declarations declspecs))
                (if documentation-p (list :documentation documentation))
                (mapcan #'(lambda (option) (list (first option) (rest option)))
                        user-defined-args)
                (unless method-class-p (list :method-class method-class))
                (unless method-combination-p (list :method-combination method-combination))
                (unless declspecs-p (list :declarations declspecs))
                (unless documentation-p (list :documentation documentation))))))
    (dolist (method methods) (add-method gf method))
    gf))

;; When this is true, it is possible to replace a non-generic function with
;; a generic function through DEFGENERIC or ENSURE-GENERIC-FUNCTION.
(defparameter *allow-making-generic* nil)

(defun ensure-generic-function-using-class-<t> (gf funname &rest all-keys
                                                &key (generic-function-class <standard-generic-function>)
                                                     lambda-list
                                                     argument-precedence-order
                                                     (method-class nil method-class-p)
                                                     method-combination
                                                     documentation
                                                     declarations
                                                     declare
                                                     environment
                                                     ((methods methods) nil) ; from DEFGENERIC
                                                &allow-other-keys)
  (declare (ignore lambda-list argument-precedence-order method-combination
                   documentation declarations declare environment methods))
  ;; Argument checks.
  (unless (function-name-p funname)
    (error-of-type 'program-error
      (TEXT "~S: the name of a function must be a symbol, not ~S")
      'ensure-generic-function-using-class funname))
  (unless (defined-class-p generic-function-class)
    (if (symbolp generic-function-class)
      (setq generic-function-class (find-class generic-function-class))
      (error (TEXT "~S for generic-function ~S: ~S ~S is neither a class or a symbol")
             'ensure-generic-function-using-class funname
             ':generic-function-class generic-function-class)))
  (unless (subclassp generic-function-class <generic-function>)
    (error (TEXT "~S for generic-function ~S: ~S ~S is not a subclass of ~S")
           'ensure-generic-function-using-class funname
           ':generic-function-class generic-function-class 'GENERIC-FUNCTION))
  ;; Preparation of initialization arguments.
  (setq all-keys (copy-list all-keys))
  (remf all-keys ':generic-function-class)
  (when method-class-p
    (unless (defined-class-p method-class)
      (if (symbolp method-class)
        (setq method-class (find-class method-class))
        (error (TEXT "~S for generic-function ~S: ~S ~S is neither a class or a symbol")
               'ensure-generic-function-using-class funname
               ':method-class method-class)))
    (setf (getf all-keys ':method-class) method-class))
  (if gf
    ;; Redefinition of a generic function.
    (progn
      ;; Take into account the new generic-function-class.
      (unless (eq (class-of gf) generic-function-class)
        ;; MOP p. 51 says that an error should be signalled in this case,
        ;; but ANSI CL says that CHANGE-CLASS is used to modify the GF.
        (change-class gf generic-function-class))
      (when (need-gf-already-called-warning-p gf)
        ;; maybe somehow check that this is not a simple file reloading?
        (clos-warn 'simple-gf-already-called-warning
          (TEXT "Redefining an already called generic function ~S") gf))
      (apply #'reinitialize-instance gf all-keys)
      gf)
    ;; First definition of a generic function.
    (setf (fdefinition funname)
          (apply #'make-generic-function-instance
                 generic-function-class
                 :name funname
                 all-keys))))

;; Preliminary.
(predefun ensure-generic-function-using-class (gf funname &rest args
                                               &key generic-function-class
                                                    lambda-list
                                                    argument-precedence-order
                                                    method-class
                                                    method-combination
                                                    documentation
                                                    declarations
                                                    declare
                                                    environment
                                               &allow-other-keys)
  (declare (ignore generic-function-class lambda-list argument-precedence-order
                   method-class method-combination documentation declarations
                   declare environment))
  (apply #'ensure-generic-function-using-class-<t> gf funname args))

;; MOP p. 49
(defun ensure-generic-function (funname &rest args
                                &key generic-function-class
                                     lambda-list
                                     argument-precedence-order
                                     method-class
                                     method-combination
                                     documentation
                                     declarations
                                     declare
                                     environment
                                &allow-other-keys)
  (declare (ignore generic-function-class lambda-list argument-precedence-order
                   method-class method-combination documentation declarations
                   declare environment))
  (unless (function-name-p funname)
    (error-of-type 'program-error
      (TEXT "~S: the name of a function must be a symbol, not ~S")
      'ensure-generic-function funname))
  (let ((result
          (apply #'ensure-generic-function-using-class
                 (if (fboundp funname)
                   (let ((gf (fdefinition funname)))
                     (if (typep-class gf <generic-function>)
                       gf
                       (if (not *allow-making-generic*)
                         (error-of-type 'program-error
                           (TEXT "~S: ~S does not name a generic function")
                           'ensure-generic-function funname)
                         nil)))
                   nil)
                 funname
                 args)))
    ; A check, to verify that user-defined methods on
    ; ensure-generic-function-using-class work as they should.
    (unless (typep-class result <generic-function>)
      (error (TEXT "Wrong ~S result for ~S: not a generic-function: ~S")
             'ensure-generic-function-using-class funname result))
    result))

#||
;; For GENERIC-FLET, GENERIC-LABELS
;; like make-generic-function, only that the dispatch-code is
;; installed immediately.
(defun make-generic-function-now (generic-function-class caller whole-form funname lambda-list argument-precedence-order method-combination method-class method-class-p declspecs declspecs-p documentation documentation-p user-defined-args
                                  &rest methods)
  (let ((gf (apply #'make-generic-function generic-function-class caller whole-form funname lambda-list argument-precedence-order method-combination method-class method-class-p declspecs declspecs-p documentation documentation-p user-defined-args methods)))
    (install-dispatch gf)
    gf))
||#


;; ================================ DEFMETHOD ================================

(defmacro defmethod (&whole whole-form
                     funname &rest method-description)
  (setq funname (sys::check-function-name funname 'defmethod))
  (multiple-value-bind (fast-function-factory-lambda method-initargs-forms signature)
      (analyze-method-description 'defmethod whole-form funname method-description)
    `(LET ()
       (SYS::EVAL-WHEN-COMPILE
         (SYS::C-DEFUN ',funname ,signature nil 'DEFMETHOD))
       (WHEN (GET ',(SYS::GET-FUNNAME-SYMBOL funname) 'SYS::TRACED-DEFINITION)
         (SYS::UNTRACE1 ',funname))
       (DO-DEFMETHOD ',funname (FUNCTION ,fast-function-factory-lambda)
                     (LIST ,@method-initargs-forms)))))

;; Installs a method. Can be called in two ways:
;; (do-defmethod funname method)
;; (do-defmethod funname fast-function-factory method-initargs)
(defun do-defmethod (funname arg1 &optional (arg2 nil must-build-method)) ; ABI
  (let* ((gf
           (if (fboundp funname)
             (let ((gf (fdefinition funname)))
               (if (typep-class gf <generic-function>)
                 gf
                 (error-of-type 'error
                   (TEXT "~S: ~S does not name a generic function")
                   'defmethod funname)))
             (setf (fdefinition funname)
                   ;; Create a GF compatible with the given method signature.
                   (multiple-value-bind (m-lambdalist m-signature)
                       (if must-build-method
                         (values (getf arg2 ':lambda-list)
                                 (getf arg2 'signature))
                         (values (method-lambda-list arg1)
                                 (method-signature arg1)))
                     (let ((gf-lambdalist
                             (gf-lambdalist-from-first-method m-lambdalist m-signature)))
                       (make-generic-function-instance <standard-generic-function>
                         :name funname
                         :lambda-list gf-lambdalist
                         :method-class <standard-method>))))))
         (method
           (if must-build-method
             (let ((method-class (safe-gf-default-method-class gf))
                   (backpointer (list nil)))
               (apply #'make-method-instance method-class
                      'backpointer backpointer
                      (nconc (method-function-initargs method-class
                                                       (funcall arg1 backpointer))
                             arg2)))
             arg1)))
    (add-method gf method)
    method))

;;; (DECLAIM-METHOD function-name qualifier* spec-lambda-list)
;; does the compile-time side effects of
;; (DEFMETHOD function-name qualifier* spec-lambda-list ...)

(defmacro declaim-method (&whole whole-form
                          funname &rest method-description)
  (setq funname (sys::check-function-name funname 'declaim-method))
  (multiple-value-bind (fast-function-factory-lambda method-initargs-forms signature)
      (analyze-method-description 'defmethod whole-form funname method-description)
    (declare (ignore fast-function-factory-lambda method-initargs-forms))
    `(SYS::EVAL-WHEN-COMPILE
       (SYS::C-DEFUN ',funname ,signature nil 'DEFMETHOD))))


;; ====================== DEFGENERIC and similar Macros ======================

;;; For DEFGENERIC, GENERIC-FUNCTION, GENERIC-FLET, GENERIC-LABELS,
;;;     WITH-ADDED-METHODS
;; caller: symbol
;; whole-form: whole source form
;; funname: function name, symbol or (SETF symbol)
;; lambdalist: lambdalist of the generic function
;; options: (option*)
;; Returns 8 values:
;; 1. generic-function-class-form,
;; 2. signature,
;; 3. argument-precedence-order,
;; 4. method-combination-lambda, to be applied to the generic-function-class,
;; 5. method-combination-p,
;; 6. method-class-form,
;; 7. method-class-p,
;; 8. declspecs,
;; 9. declspecs-p,
;; 10. docstring,
;; 11. docstring-p,
;; 12. user-defined-args,
;; 13. method-forms.
(defun analyze-defgeneric (caller whole-form funname lambdalist options)
  (setq funname (sys::check-function-name funname caller))
  ;; Parse the lambdalist:
  (analyze-defgeneric-lambdalist caller whole-form funname lambdalist)
  ;; Process the options:
  (let ((generic-function-classes nil)
        (method-forms '())
        (method-combinations nil)
        (method-classes nil)
        (argorders nil)
        (declares nil)
        (docstrings nil)
        (user-defined-args))
    (dolist (option options)
      (unless (listp option)
        (error-of-type 'ext:source-program-error
          :form whole-form
          :detail option
          (TEXT "~S ~S: not a ~S option: ~S")
          caller funname 'defgeneric option))
      (case (first option)
        (DECLARE
         ;; The DEFGENERIC description in ANSI CL is inconsistent. According to
         ;; the BNF syntax, multiple DECLARE options cannot be passed in a
         ;; single DEFGENERIC forms. However, it also says explicitly "The
         ;; declare option may be specified more than once..."
         #|
         (when declares
           (error-of-type 'ext:source-program-error
             :form whole-form
             :detail options
             (TEXT "~S ~S: ~S may only be specified once.")
             caller funname 'declare))
         |#
         (let ((new-delarations
                (check-gf-declspecs (rest option) 'declare
                  (lambda (reporter errorstring &rest arguments)
                    (funcall reporter "~S ~S: ~?" caller funname
                             errorstring arguments)))))
           (when new-delarations
             (setq declares `(DECLARE ,@(rest declares) ,@new-delarations)))))
        (:ARGUMENT-PRECEDENCE-ORDER
         (when argorders
           (error-of-type 'ext:source-program-error
             :form whole-form
             :detail options
             (TEXT "~S ~S: ~S may only be specified once.")
             caller funname ':argument-precedence-order))
         (setq argorders option))
        (:DOCUMENTATION
         (unless (and (eql (length option) 2) (stringp (second option)))
           (error-of-type 'ext:source-program-error
             :form whole-form
             :detail option
             (TEXT "~S ~S: A string must be specified after ~S : ~S")
             caller funname ':documentation option))
         (when docstrings
           (error-of-type 'ext:source-program-error
             :form whole-form
             :detail options
             (TEXT "~S ~S: Only one ~S string is allowed.")
             caller funname ':documentation))
         (setq docstrings (rest option)))
        (:METHOD-COMBINATION
         (when method-combinations
           (error-of-type 'ext:source-program-error
             :form whole-form
             :detail options
             (TEXT "~S ~S: ~S may only be specified once.")
             caller funname ':method-combination))
         ;; The syntax for this option is
         ;;   (method-combination-name method-combination-argument*)
         ;; CLHS writes "method-combination" here instead of
         ;; "method-combination-name" but this is most probably a typo.
         ;; To be liberal, we also allow a method-combination instead of a
         ;; method-combination-name.
         (unless (>= (length option) 2)
           (error-of-type 'ext:source-program-error
             :form whole-form
             :detail option
             (TEXT "~S ~S: A method combination type name must be specified after ~S : ~S")
             caller funname ':method-combination option))
         (let ((method-combination-name (second option)))
           (unless (or (symbolp method-combination-name)
                       (typep-class method-combination-name <method-combination>))
             (error-of-type 'ext:source-program-error
               :form whole-form
               :detail method-combination-name
               (TEXT "~S ~S: Invalid method combination specification: ~S")
               caller funname option))
           (setq method-combinations (rest option))))
        (:GENERIC-FUNCTION-CLASS
         (unless (and (eql (length option) 2) (symbolp (second option)))
           (error-of-type 'ext:source-program-error
             :form whole-form
             :detail option
             (TEXT "~S ~S: A class name must be specified after ~S : ~S")
             caller funname ':generic-function-class option))
         (when generic-function-classes
           (error-of-type 'ext:source-program-error
             :form whole-form
             :detail options
             (TEXT "~S ~S: Only one ~S option is allowed.")
             caller funname ':generic-function-class))
         (setq generic-function-classes (rest option)))
        (:METHOD-CLASS
         (unless (and (eql (length option) 2) (symbolp (second option)))
           (error-of-type 'ext:source-program-error
             :form whole-form
             :detail option
             (TEXT "~S ~S: A class name must be specified after ~S : ~S")
             caller funname ':method-class option))
         (when method-classes
           (error-of-type 'ext:source-program-error
             :form whole-form
             :detail options
             (TEXT "~S ~S: Only one ~S option is allowed.")
             caller funname ':method-class))
         (setq method-classes (rest option)))
        (:METHOD
         (multiple-value-bind (fast-function-factory-lambda method-initargs-forms)
             (analyze-method-description caller whole-form funname (rest option))
           (push (cons fast-function-factory-lambda method-initargs-forms)
                 method-forms)))
        ((:LAMBDA-LIST :DECLARATIONS)
         (error-of-type 'ext:source-program-error
           :form whole-form
           :detail option
           (TEXT "~S ~S: invalid ~S option ~S")
           caller funname 'defgeneric option))
        (t
         (let ((optionkey (first option)))
           (if (symbolp optionkey)
             (if (assoc optionkey user-defined-args)
               (error-of-type 'ext:source-program-error
                 :form whole-form
                 :detail options
                 (TEXT "~S ~S: Only one ~S option is allowed.")
                 caller funname optionkey)
               (push option user-defined-args))
             (error-of-type 'ext:source-program-error
               :form whole-form
               :detail option
               (TEXT "~S ~S: invalid syntax in ~S option: ~S")
               caller funname 'defgeneric option))))))
    ;; Check :argument-precedence-order :
    (multiple-value-bind (signature argument-precedence-order argorder)
        (check-gf-lambdalist+argorder lambdalist (rest argorders) argorders
          #'(lambda (detail errorstring &rest arguments)
              (error-of-type 'ext:source-program-error
                :form whole-form
                :detail detail
                "~S ~S: ~?" caller funname errorstring arguments)))
      (declare (ignore argorder))
      (let ((method-combinations-defaulted
              ;; Default :method-combination is STANDARD:
              (or method-combinations '(STANDARD)))
            (generic-function-class-form
              (if generic-function-classes
                `(FIND-CLASS ',(first generic-function-classes))
                '<STANDARD-GENERIC-FUNCTION>))
            (method-class-form
              (if method-classes
                `(FIND-CLASS ',(first method-classes))
                '<STANDARD-METHOD>)))
        (values generic-function-class-form
                signature
                argument-precedence-order
                (let ((method-combination-name (car method-combinations-defaulted))
                      (options (cdr method-combinations-defaulted)))
                  `(LAMBDA (GF-CLASS)
                     ,(if (symbolp method-combination-name)
                        ;; We need a preliminary generic function because the
                        ;; method combination must be passed to
                        ;; ensure-generic-function, and the GF has not yet been
                        ;; created and initialized at this moment.
                        `(FIND-METHOD-COMBINATION
                           (MAKE-GENERIC-FUNCTION-PROTOTYPE GF-CLASS :NAME ',funname)
                           ',method-combination-name ',options)
                        `(METHOD-COMBINATION-WITH-OPTIONS ',funname ',method-combination-name ',options))))
                (not (null method-combinations))
                method-class-form
                (not (null method-classes))
                ;; list of declspecs
                (cdr declares)
                (not (null declares))
                ;; docstring or nil
                (car docstrings)
                (not (null docstrings))
                (nreverse user-defined-args)
                ;; list of the method-forms
                (mapcar #'(lambda (method-cons)
                            (let ((fast-function-factory-lambda (car method-cons))
                                  (method-initargs-forms (cdr method-cons)))
                              `(LET ((METHOD-CLASS ,method-class-form)
                                     (BACKPOINTER (LIST NIL)))
                                 (APPLY #'MAKE-METHOD-INSTANCE METHOD-CLASS
                                   ,@method-initargs-forms
                                   'BACKPOINTER BACKPOINTER
                                   (METHOD-FUNCTION-INITARGS METHOD-CLASS
                                                             (,fast-function-factory-lambda BACKPOINTER))))))
                  (nreverse method-forms)))))))

;; Parse a DEFGENERIC lambdalist:
;; lambdalist --> reqnum, req-vars, optnum, restp, keyp, keywords, allowp
(defun analyze-defgeneric-lambdalist (caller whole-form funname lambdalist)
  (multiple-value-bind (reqvars optvars rest keyp keywords keyvars allowp)
      (sys::analyze-generic-function-lambdalist lambdalist
        #'(lambda (lalist detail errorstring &rest arguments)
            (declare (ignore lalist)) ; use WHOLE-FORM instead
            (sys::lambda-list-error whole-form detail
              (TEXT "~S ~S: invalid generic function lambda-list: ~?")
              caller funname errorstring arguments)))
    (declare (ignore keyvars))
    (values (length reqvars) reqvars (length optvars)
            (or (not (eql rest 0)) keyp) ; &key implies &rest
            keyp keywords allowp)))


;;; DEFGENERIC

(defmacro defgeneric (&whole whole-form
                      funname lambda-list &rest options)
  (multiple-value-bind (generic-function-class-form signature argument-precedence-order method-combination-lambda method-combination-p method-class-form method-class-p declspecs declspecs-p docstring docstring-p user-defined-args method-forms)
      (analyze-defgeneric 'defgeneric whole-form funname lambda-list options)
    (let* ((generic-function-class-var (gensym))
           (generic-function-class-keywords-var (gensym))
           (funname-symbol (sys::get-funname-symbol funname))
           (method-combination-form `(,method-combination-lambda ,generic-function-class-var)))
      `(LET ()
         (DECLARE (SYS::IN-DEFUN ,funname))
         (SYS::EVAL-WHEN-COMPILE
           (SYS::C-DEFUN ',funname ',signature nil 'DEFGENERIC))
         (WHEN (GET ',funname-symbol 'SYS::TRACED-DEFINITION)
           (SYS::UNTRACE1 ',funname))
         ;; NB: no (SYSTEM::REMOVE-OLD-DEFINITIONS ',funname)
         (sys::check-redefinition ',funname 'defgeneric
                                  (sys::fbound-string ',funname-symbol))
         (LET* ((,generic-function-class-var ,generic-function-class-form)
                ,@(if user-defined-args
                    `((,generic-function-class-keywords-var
                        (CLASS-VALID-INITIALIZATION-KEYWORDS ,generic-function-class-var)))))
           ;; Provide good error messages. The error message from
           ;; ENSURE-GENERIC-FUNCTION (actually MAKE-INSTANCE) later is unintelligible.
           ,@(if user-defined-args
               `((UNLESS (EQ ,generic-function-class-keywords-var 'T)
                   ,@(mapcar #'(lambda (option)
                                 `(UNLESS (MEMBER ',(first option) ,generic-function-class-keywords-var)
                                    (ERROR-OF-TYPE 'EXT:SOURCE-PROGRAM-ERROR
                                      :FORM ',whole-form
                                      :DETAIL ',option
                                      (TEXT "~S ~S: invalid option ~S")
                                      'DEFGENERIC ',funname ',option)))
                             user-defined-args))))
           (APPLY #'ENSURE-GENERIC-FUNCTION ',funname
             ;; Here we pass a default for :GENERIC-FUNCTION-CLASS because
             ;; defaulting it in the context of ENSURE-GENERIC-FUNCTION is
             ;; less straightforward than defaulting it here.
             :GENERIC-FUNCTION-CLASS ,generic-function-class-var
             :LAMBDA-LIST ',lambda-list
             ;; Here we pass a default for :ARGUMENT-PRECEDENCE-ORDER because
             ;; it's error-prone to pass :LAMBDA-LIST without
             ;; :ARGUMENT-PRECEDENCE-ORDER.
             :ARGUMENT-PRECEDENCE-ORDER ',argument-precedence-order
             ,@(if method-class-p `(:METHOD-CLASS ,method-class-form))
             ;; We have to pass a :METHOD-COMBINATION always. Here we pass it
             ;; only if explicitly specified; it will override user-defined
             ;; and default initargs. Otherwise we pass it further down the
             ;; argument list, where user-defined and default initargs can
             ;; override it. The MOP doesn't mandate this, but it allows users
             ;; to specify a default method-combination for a generic-function
             ;; class; see https://sourceforge.net/p/clisp/bugs/316/
             ,@(if method-combination-p `(:METHOD-COMBINATION ,method-combination-form))
             ,@(if docstring-p `(:DOCUMENTATION ',docstring))
             ,@(if declspecs-p `(:DECLARATIONS ',declspecs))
             'METHODS (LIST ,@method-forms)
             ;; Pass user-defined initargs of the generic-function-class.
             ,@(mapcan #'(lambda (option)
                           (list `',(first option) `',(rest option)))
                       user-defined-args)
             (APPEND
               ;; Pass the default initargs of the generic-function class, in
               ;; order to erase leftovers from the previous definition.
               (MAPCAN #'(LAMBDA (X) (LIST (FIRST X) (FUNCALL (THIRD X))))
                       (CLASS-DEFAULT-INITARGS ,generic-function-class-var))
               (LIST
                 ;; Here we pass defaults for :METHOD-CLASS, :DOCUMENTATION,
                 ;; :DECLARATIONS if the corresponding option wasn't specified
                 ;; in the DEFGENERIC form, because when a generic function is
                 ;; being redefined, passing :DOCUMENTATION NIL to
                 ;; ENSURE-GENERIC-FUNCTION means to erase the documentation
                 ;; string, while nothing means to keep it! See MOP p. 61.
                 ,@(unless method-class-p '(:METHOD-CLASS <STANDARD-METHOD>))
                 ,@(unless method-combination-p `(:METHOD-COMBINATION ,method-combination-form))
                 ,@(unless docstring-p '(:DOCUMENTATION NIL))
                 ,@(unless declspecs-p '(:DECLARATIONS NIL))))))))))

;; ============================================================================

;; For GENERIC-FUNCTION, GENERIC-FLET, GENERIC-LABELS

;; Transform lambdalist into calling convention for the compiler:
(defun defgeneric-lambdalist-callinfo (caller whole-form funname lambdalist)
  (multiple-value-bind (reqnum req-vars optnum restp keyp keywords allowp)
      (analyze-defgeneric-lambdalist caller whole-form funname lambdalist)
    (declare (ignore req-vars keyp))
    (callinfo reqnum optnum restp keywords allowp)))

(defun make-generic-function-form (caller whole-form funname lambda-list options)
  (multiple-value-bind (generic-function-class-form signature argument-precedence-order method-combination-lambda method-combination-p method-class-form method-class-p declspecs declspecs-p docstring docstring-p user-defined-args method-forms)
      (analyze-defgeneric caller whole-form funname lambda-list options)
    (declare (ignore signature))
    (let ((generic-function-class-var (gensym)))
      `(LET ((,generic-function-class-var ,generic-function-class-form))
         (MAKE-GENERIC-FUNCTION ,generic-function-class-var ',caller ',whole-form ',funname ',lambda-list ',argument-precedence-order (,method-combination-lambda ,generic-function-class-var) ,method-combination-p ,method-class-form ,method-class-p ',declspecs ,declspecs-p ',docstring ,docstring-p ',user-defined-args
                                ,@method-forms)))))

#| GENERIC-FUNCTION is a TYPE (and a COMMON-LISP symbol) in ANSI CL,
 but not a macro, so this definition violates the standard
(defmacro generic-function (&whole whole-form
                            lambda-list &rest options)
  (make-generic-function-form 'generic-function whole-form 'LAMBDA
                              lambda-list options))
|#

;; For GENERIC-FLET, GENERIC-LABELS
(defun analyze-generic-fundefs (caller whole-form fundefs)
  (let ((names '())
        (funforms '()))
    (dolist (fundef fundefs)
      (unless (and (consp fundef) (consp (cdr fundef)))
        (error-of-type 'ext:source-program-error
          :form whole-form
          :detail fundef
          (TEXT "~S: ~S is not a generic function specification")
          caller fundef))
      (push (first fundef) names)
      (push (make-generic-function-form
             caller whole-form (first fundef) (second fundef) (cddr fundef))
            funforms))
    (values (nreverse names) (nreverse funforms))))


;;; GENERIC-FLET

(defmacro generic-flet (&whole whole-form
                        fundefs &body body)
  (multiple-value-bind (funnames funforms)
      (analyze-generic-fundefs 'generic-flet whole-form fundefs)
    (let ((varnames (gensym-list funnames)))
      `(LET ,(mapcar #'list varnames funforms)
         (FLET ,(mapcar #'(lambda (varname funname)
                            `(,funname (&rest args) (apply ,varname args)))
                        varnames funnames)
           ,@body)))))

;;; GENERIC-LABELS

(defmacro generic-labels (&whole whole-form
                          fundefs &body body)
  (multiple-value-bind (funnames funforms)
      (analyze-generic-fundefs 'generic-labels whole-form fundefs)
    (let ((varnames (gensym-list funnames)))
      `(LET ,varnames
         (FLET ,(mapcar #'(lambda (varname funname)
                            `(,funname (&rest args) (apply ,varname args)))
                        varnames funnames)
           ,@(mapcar #'(lambda (varname funform) `(SETQ ,varname ,funform))
                     varnames funforms)
           ,@body)))))

;;; WITH-ADDED-METHODS
;; is screwed up and therefore will not be implemented.

;; ============================================================================
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-genfun3.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-genfun2b.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP
;;;; Generic Functions
;;;; Part 2: Generic function dispatch and execution
;;;; Bruno Haible 21.8.1993 - 2004, 2012
;;;; Sam Steingold 1998-2004, 2007-2008, 2010, 2017
;;;; German comments translated into English: Stefan Kain 2002-04-08

(in-package "CLOS")


;; ================ Combination of Applicable Methods, Part 3 ================

;;; Calculate the effective method for the given arguments.
;;; It is actually the effective method for all arguments,
;;; for the same EQL and class restrictions as the given arguments,
;;; therefore compute dispatch is already taken care of.
(defun compute-applicable-methods-effective-method (gf &rest args)
  (when (safe-gf-undeterminedp gf)
    ;; gf has uninitialized lambda-list, hence no methods.
    (return-from compute-applicable-methods-effective-method
      (no-method-caller 'no-applicable-method gf)))
  (let ((req-num (sig-req-num (safe-gf-signature gf))))
    (if (>= (length args) req-num)
      (let ((req-args (subseq args 0 req-num)))
        (multiple-value-bind (methods originator)
            ;; compute-applicable-methods would be sufficient, but the MOP p. 40
            ;; specifies a two-step process.
            (multiple-value-bind (methods certain)
                (funcall (cond ((eq gf |#'compute-applicable-methods-using-classes|)
                                #'compute-applicable-methods-using-classes-<generic-function>)
                               (t #'compute-applicable-methods-using-classes))
                         gf (mapcar #'class-of req-args))
              (if certain
                (values methods 'compute-applicable-methods-using-classes)
                (values
                  (funcall (cond ((or (eq gf |#'compute-applicable-methods|)
                                      (eq gf |#'compute-effective-method|))
                                  #'compute-applicable-methods-<generic-function>)
                                 (t #'compute-applicable-methods))
                           gf args)
                  'compute-applicable-methods)))
          ; Some checks, to guarantee that user-defined methods on
          ; compute-applicable-methods or compute-applicable-methods-using-classes
          ; don't break our CLOS.
          (unless (proper-list-p methods)
            (error (TEXT "Wrong ~S result for generic function ~S: not a proper list: ~S")
                   originator gf methods))
          (dolist (m methods)
            (unless (typep-class m <method>)
              (error (TEXT "Wrong ~S result for generic function ~S: list element is not a method: ~S")
                     originator gf m)))
          ;; Combine the methods to an effective method:
          (or (cdr (assoc methods (std-gf-effective-method-cache gf) :test #'equal))
              (let ((effective-method
                      (compute-effective-method-as-function gf methods args)))
                (push (cons methods effective-method) (std-gf-effective-method-cache gf))
                effective-method))))
      (error (TEXT "~S: ~S has ~S required argument~:P, but only ~S arguments were passed to ~S: ~S")
             'compute-applicable-methods-effective-method gf req-num (length args)
             'compute-applicable-methods-effective-method args))))

;; compute-applicable-methods-effective-method-for-set
;; is a generalization of compute-applicable-methods-effective-method.
;; For each argument position you can specify a set of possible required
;; arguments through one of:
;;   (TYPEP class)          [covers direct and indirect instances of class],
;;   (INSTANCE-OF-P class)  [covers only direct instances of class],
;;   (EQL object)           [covers the given object only].
;; Returns either the best possible effective-method, the gf itself otherwise.
(defun compute-applicable-methods-effective-method-for-set (gf req-arg-specs tentative-args)
  (when (safe-gf-undeterminedp gf)
    ;; gf has uninitialized lambda-list, hence no methods.
    (return-from compute-applicable-methods-effective-method-for-set
      (no-method-caller 'no-applicable-method gf)))
  (let ((req-num (sig-req-num (safe-gf-signature gf))))
    (if (and (= (length req-arg-specs) req-num)
             (>= (length tentative-args) req-num))
      (multiple-value-bind (methods certain)
          (compute-applicable-methods-for-set gf req-arg-specs)
        (unless certain
          (return-from compute-applicable-methods-effective-method-for-set gf))
        ;; Combine the methods to an effective method:
        (or (cdr (assoc methods (std-gf-effective-method-cache gf) :test #'equal))
            (let ((effective-method
                    (compute-effective-method-as-function gf methods tentative-args)))
              (push (cons methods effective-method) (std-gf-effective-method-cache gf))
              effective-method)))
      (error (TEXT "~S: ~S has ~S required argument~:P")
             'compute-applicable-methods-effective-method-for-set gf req-num))))

(defun effective-method-function-name (gf methods)
  (sys::symbol-suffix
   (sys::closure-name gf)
   (ext:string-concat "<EMF-" (princ-to-string (length methods)) ">")))

(defun compute-effective-method-as-function (gf methods args)
  (when (null methods)
    (return-from compute-effective-method-as-function
      (no-method-caller 'no-applicable-method gf)))
  ;; Apply method combination:
  (let ((ef-fun (compute-effective-method-as-function-form
                 gf (safe-gf-method-combination gf) methods args)))
    ;; Evaluate or compile the resulting form:
    (if (constantp ef-fun) ; constant or self-evaluating form?
      ;; No need to invoke the compiler for a constant form.
      ef-fun
      ;; For a general form:
      ;; (eval ef-fun)                                 ; interpreted
      ;; (eval `(LOCALLY (DECLARE (COMPILE)) ,ef-fun)) ; compiled
      (eval `(LET ()
               (DECLARE (COMPILE ,(effective-method-function-name gf methods))
                        (INLINE FUNCALL APPLY))
               ,ef-fun)))))

(defun no-method-caller (no-method-name gf)
  #'(lambda (&rest args) (apply no-method-name gf args)))


;; ======================= Computing the Dispatch Code =======================

;; The dispatch-code for generic functions is formed with
;; `(%GENERIC-FUNCTION-LAMBDA ,@lambdabody)
;; - similar to `(FUNCTION (LAMBDA ,@lambdabody)) -.
;; The following must not occur therein:
;; - access to dynamic variables, binding of dynamic variables,
;; - nontrivial BLOCK, RETURN-FROM, TAGBODY, GO constructions,
;; - invocation of global functions, that are not inline,
;; - formation of non-autonomous functions (closures).
;; So the following is necessary:
;;   (declare (inline case eql eq typep
;;                    arrayp bit-vector-p characterp complexp consp floatp
;;                    functionp hash-table-p integerp listp null numberp
;;                    packagep pathnamep sys::logical-pathname-p random-state-p
;;                    rationalp readtablep realp sys::sequencep
;;                    clos::std-instance-p streamp sys::file-stream-p
;;                    sys::synonym-stream-p sys::broadcast-stream-p
;;                    sys::concatenated-stream-p sys::two-way-stream-p
;;                    sys::echo-stream-p sys::string-stream-p stringp
;;                    clos::structure-object-p symbolp vectorp
;;                    class-of cons gethash funcall apply ...
;;   )        )

;; Preliminary.
(predefun compute-discriminating-function (gf)
  (compute-discriminating-function-<generic-function> gf))

(defun compile-no-jitc (name &optional suffix)
  (cons `(COMPILE ,(if suffix (sys::symbol-suffix name suffix) name))
        '((OPTIMIZE (SPEED 0) (SPACE 3)))))

(defun compute-discriminating-function-<generic-function> (gf)
  (multiple-value-bind (bindings lambdabody) (compute-dispatch gf)
    (let ((preliminary
            (eval `(LET ,bindings
                     (DECLARE ,@(safe-gf-declspecs gf)
                              ,@(compile-no-jitc (sys::closure-name gf)
                                                 'preliminary))
                     (%GENERIC-FUNCTION-LAMBDA ,@lambdabody)))))
      (assert (<= (sys::%record-length preliminary) 3))
      preliminary)))

;; Calculates the dispatch-code of a generic function.
;; It looks as follows:
;; (LAMBDA (variables) ; the required vars separately, everything else with &rest
;;   (DECLARE (INLINE ...)) ; everything inline because of %GENERIC-FUNCTION-LAMBDA
;;   If-cascades, where EQL-parameter-specializers and most of the
;;   builtin-classes are queried online via TYPEP.
;;   CLASS-OF is called for the other required-parameters, the results
;;   are gathered and inserted into a hash table as index. There, the effective
;;   method is located:
;;   (LET ((EM (GETHASH (CONS (CLASS-OF ...) ...) ht1)))
;;     (WHEN EM (RETURN-FROM block (APPLY EM Arguments))))
;;   If that failed:
;;   (APPLY 'COMPUTE-AND-ADD-EFFECTIVE-METHOD gf Arguments)
;; )
;; One does not need to write (APPLY ... Arguments),
;; it is done by %GENERIC-FUNCTION-LAMBDA automatically.
(defun compute-dispatch (gf)
  (when (safe-gf-undeterminedp gf)
    ;; gf has uninitialized lambda-list, hence no methods.
    (return-from compute-dispatch
      (values
        '()
        `((&REST ,(gensym))
          (DECLARE (INLINE FUNCALL))
          (FUNCALL 'NO-METHOD-CALLER 'NO-APPLICABLE-METHOD ',gf)))))
  (let* ((signature (safe-gf-signature gf))
         (req-vars (gensym-list (sig-req-num signature)))
         (restp (gf-sig-restp signature))
         (rest-var (if restp (gensym)))
         (apply-fun (if restp 'APPLY 'FUNCALL))
         (apply-args `(,@req-vars ,@(if restp `(,rest-var) '())))
         (arg-order (safe-gf-argorder gf))
         (methods (safe-gf-methods gf))
         (block-name (gensym))
         (maybe-no-applicable nil)
         (ht-vars '())) ; list of hashtable variables and their inits
    ;; We do a recursion over the arguments.
    (labels
       ((recursion (remaining-args ; an nthcdr of arg-order
                    remaining-methods ; sublist of methods
                    class-of-exprs) ; list of CLASS-OF expressions
          (if (null remaining-methods)
            (progn
              (setq maybe-no-applicable t)
              'NIL) ; nothing to do, call NO-APPLICABLE-METHOD later
            (if (null remaining-args)
              ;; All arguments processed.
              #|| ; use GETHASH :
              (let ((ht-var (gensym))
                    (n (length class-of-exprs)) ; index with n-tuples
                    ht-init ; expression for initialization of ht-var
                    ht-key-binding ; binding of a variable to an n-tuple
                    em-expr ; expression for looking up the EM
                    setf-em-expr) ; expression-part for setting the EM
                (if (eql n 0)
                  (setq ht-init 'NIL
                        ht-key-binding '()
                        em-expr ht-var
                        setf-em-expr `(SETQ ,ht-var))
                  (let ((tuple-var (gensym)))
                    (setq ht-init
                          `(MAKE-HASH-TABLE
                             ; :KEY-TYPE '(CONS ... CLASS ...) :VALUE-TYPE 'FUNCTION
                             :TEST ',(if (eql n 1) 'EXT:STABLEHASH-EQ 'EXT:STABLEHASH-EQUAL)
                             :WARN-IF-NEEDS-REHASH-AFTER-GC 'T)
                          ht-key-binding
                          `((,tuple-var
                             ,(let ((tuple-fun (hash-tuple-function n)))
                                (if (member '&rest (second tuple-fun))
                                  `(,tuple-fun ,@(reverse class-of-exprs))
                                  ;; no &rest -> can optimize
                                  ;; (the compiler is not yet too good at that)
                                  (sublis (mapcar #'cons (second tuple-fun) (reverse class-of-exprs))
                                          (third tuple-fun))))))
                          em-expr
                          `(GETHASH ,tuple-var ,ht-var)
                          setf-em-expr
                          ;; `(SETF (GETHASH ,tuple-var ,ht-var)) would also work;
                          ;; but the following spares two temporary variables:
                          `(SYSTEM::PUTHASH ,tuple-var ,ht-var))))
                (push (list ht-var ht-init) ht-vars)
                `(LET ,ht-key-binding
                   (RETURN-FROM ,block-name
                     (OR ,em-expr
                         (,@setf-em-expr
                               (,apply-fun 'COMPUTE-APPLICABLE-METHODS-EFFECTIVE-METHOD
                                           ',gf ,@apply-args))))))
              |# ; use CLASS-GETHASH and CLASS-TUPLE-GETHASH :
              (let ((ht-var (gensym))
                    (n (length class-of-exprs)) ; index with n-tuples
                    ht-init ; expression for initialization of ht-var
                    em-expr ; expression for looking up the EM
                    setf-em-expr) ; expression-part for setting the EM
                (if (eql n 0)
                  (setq ht-init 'NIL
                        em-expr ht-var
                        setf-em-expr `(SETQ ,ht-var))
                  (setq class-of-exprs
                        (reverse class-of-exprs)
                        ht-init
                        `(MAKE-HASH-TABLE
                           ; :KEY-TYPE '(CONS ... CLASS ...) :VALUE-TYPE 'FUNCTION
                           :TEST ',(if (eql n 1) 'EXT:STABLEHASH-EQ 'EXT:STABLEHASH-EQUAL)
                           :WARN-IF-NEEDS-REHASH-AFTER-GC 'T)
                        em-expr
                        (if (eql n 1) ; whatever is faster
                          ;; `(GETHASH ,@class-of-exprs ,ht-var) ==
                          `(CLASS-GETHASH ,ht-var ,(second (first class-of-exprs)))
                          `(CLASS-TUPLE-GETHASH ,ht-var ,@(mapcar #'second class-of-exprs)))
                        setf-em-expr
                        `(SYSTEM::PUTHASH
                          ,(let ((tuple-fun (hash-tuple-function n)))
                             (if (memq '&rest (second tuple-fun))
                               `(,tuple-fun ,@class-of-exprs)
                               ;; no &rest -> can optimize
                               ;; (the compiler is not yet too good at that)
                               (sublis (mapcar #'cons (second tuple-fun) class-of-exprs)
                                       (third tuple-fun))))
                          ,ht-var)))
                (push (list ht-var ht-init) ht-vars)
                `(RETURN-FROM ,block-name
                   (OR ,em-expr
                       (,@setf-em-expr
                             (,apply-fun 'COMPUTE-APPLICABLE-METHODS-EFFECTIVE-METHOD
                                         ',gf ,@apply-args)))))
              ;; Process next argument:
              (let* ((arg-index (first remaining-args))
                     (arg-var (nth arg-index req-vars))
                     (eql-cases ; all EQL-specializers for this argument
                       (remove-duplicates
                         (mapcar #'eql-specializer-object
                           (remove-if-not #'eql-specializer-p
                             (mapcar #'(lambda (m)
                                         (nth arg-index
                                           (safe-method-specializers m gf)))
                               remaining-methods)))
                         :test #'eql))
                     (eql-caselist ; case-list for CASE
                       (mapcar
                         #'(lambda (object)
                             `((,object)
                               ,(recursion
                                  (cdr remaining-args)
                                  (remove-if-not
                                    #'(lambda (m)
                                        (typep object
                                          (nth arg-index
                                            (safe-method-specializers m gf))))
                                    (the list remaining-methods))
                                  class-of-exprs)))
                         eql-cases)))
                ;; Until further notice we do not need to consider the
                ;; EQL-specialized methods anymore.
                (setq remaining-methods
                      (remove-if
                        #'(lambda (m)
                            (eql-specializer-p
                              (nth arg-index (safe-method-specializers m gf))))
                        (the list remaining-methods)))
                ((lambda (other-cases)
                   (if eql-caselist
                     `(CASE ,arg-var ,@eql-caselist (T ,other-cases))
                     other-cases))
                 (let ((classes
                         (delete <t>
                           (delete-duplicates
                             (mapcar #'(lambda (m)
                                         (nth arg-index
                                           (safe-method-specializers m gf)))
                                     remaining-methods)))))
                   ;; If all classes that are to be tested for are
                   ;; built-in-classes, then we will inline the type-dispatch,
                   ;; because in the hierarchy of the built-in-classes
                   ;; (that does not know multiple inheritance except for NULL
                   ;; and VECTOR) all CPLs are consistent.
                   ;; Hence, we can work with
                   ;; (subclassp (class-of obj) class) == (typep obj class)
                   ;; In the other case a hash-table-access is necessary
                   ;; anyway. Then we spare the test for the built-in-
                   ;; classes and include it into the hash-table.
                   (if (and (every #'bc-p classes)
                            (<= (length classes) 5)) ; too many cases -> hash
                     (labels
                        ((built-in-subtree (class remaining-classes remaining-methods)
                           ;; treats the cases, when the argument belongs to
                           ;; the Class class and affiliation to one of the
                           ;; remaining-classes has to be tested.
                           ;; (One can presume that (bc-and class x) /= nil
                           ;; for all x from remaining-classes.)
                           (if (null remaining-classes)
                             ;; case differentiation is no longer necessary
                             (recursion
                               (cdr remaining-args)
                               (remove-if-not
                                 #'(lambda (m)
                                     (bc-and class
                                       (nth arg-index
                                         (safe-method-specializers m gf))))
                                 (the list remaining-methods))
                               class-of-exprs)
                             ;; case differentiation via TYPEP
                             (let ((test-class (first remaining-classes)))
                               ;; better choose test-class maximal:
                               (loop
                                 (let ((other-class
                                         (find-if
                                           #'(lambda (x)
                                               (and (subclassp test-class x)
                                                    (not (eq test-class x))))
                                           (the list remaining-classes))))
                                   (unless other-class (return))
                                   (setq test-class other-class)))
                               (if (null (bc-and-not class test-class))
                                 ;; class is a subclass of test-class,
                                 ;; therefore the TYPEP test is redundant
                                 (built-in-subtree
                                   (bc-and class test-class) ; /= nil !
                                   (remove 'nil
                                     (mapcar
                                       #'(lambda (x) (bc-and x test-class))
                                       (remove test-class remaining-classes)))
                                   (remove-if-not
                                     #'(lambda (m)
                                         (bc-and
                                           (nth arg-index
                                             (safe-method-specializers m gf))
                                           test-class))
                                     (the list remaining-methods)))
                                 ;; general case
                                 `(IF (TYPEP ,arg-var ',(class-classname test-class))
                                    ,(built-in-subtree
                                       (bc-and class test-class) ; /= nil !
                                       (remove 'nil
                                         (mapcar
                                           #'(lambda (x) (bc-and x test-class))
                                           (remove test-class remaining-classes)))
                                       (remove-if-not
                                         #'(lambda (m)
                                             (bc-and
                                               (nth arg-index
                                                 (safe-method-specializers m gf))
                                               test-class))
                                         (the list remaining-methods)))
                                    ,(built-in-subtree
                                       (bc-and-not class test-class) ; /= nil !
                                       (remove 'nil
                                         (mapcar
                                           #'(lambda (x) (bc-and-not x test-class))
                                           remaining-classes))
                                       (remove-if-not
                                         #'(lambda (m)
                                             (bc-and-not
                                               (nth arg-index
                                                 (safe-method-specializers m gf))
                                               test-class))
                                         (the list remaining-methods)))))))))
                       (built-in-subtree <t> classes remaining-methods))
                     (recursion
                       (cdr remaining-args)
                       remaining-methods
                       (cons `(CLASS-OF ,arg-var) class-of-exprs))))))))))
      (let ((form (recursion arg-order methods '())))
        (values
          ;; bindings
          (nreverse ht-vars)
          ;; lambdabody
          `((,@req-vars ,@(if restp `(&REST ,rest-var) '()))
            (DECLARE
              (INLINE
               ;; for the case differentiations:
               CASE EQL EQ TYPEP
               ;; at the inline-expansion of TYPEP on built-in-classes:
               ARRAYP BIT-VECTOR-P CHARACTERP COMPLEXP CONSP FLOATP
               FUNCTIONP HASH-TABLE-P INTEGERP LISTP NULL NUMBERP
               PACKAGEP PATHNAMEP SYS::LOGICAL-PATHNAME-P RANDOM-STATE-P
               RATIONALP READTABLEP REALP SYS::SEQUENCEP
               CLOS::STD-INSTANCE-P STREAMP SYS::FILE-STREAM-P
               SYS::SYNONYM-STREAM-P SYS::BROADCAST-STREAM-P
               SYS::CONCATENATED-STREAM-P SYS::TWO-WAY-STREAM-P
               SYS::ECHO-STREAM-P SYS::STRING-STREAM-P STRINGP
               CLOS::STRUCTURE-OBJECT-P SYMBOLP VECTORP
               ;; looking up and calling of the effective method:
               CLASS-OF CONS GETHASH CLASS-GETHASH CLASS-TUPLE-GETHASH
               SYS::PUTHASH FUNCALL APPLY))
            (BLOCK ,block-name
              ,form
              ,@(if maybe-no-applicable
                  `((FUNCALL 'NO-METHOD-CALLER 'NO-APPLICABLE-METHOD
                             ',gf))))))))))

;; Our EQUAL hash-function looks into cons-trees only upto depth 4.
;; A tuple of at most 16 elements can be turned into such a tree.
(defun hash-tuple-function (n) ; n>0
  (case n
    (1 '(lambda (t1) t1))
    (2 '(lambda (t1 t2) (cons t1 t2)))
    (3 '(lambda (t1 t2 t3) (cons t1 (cons t2 t3))))
    (4 '(lambda (t1 t2 t3 t4) (cons (cons t1 t2) (cons t3 t4))))
    (5 '(lambda (t1 t2 t3 t4 t5) (cons (cons t1 t2) (cons t3 (cons t4 t5)))))
    (6 '(lambda (t1 t2 t3 t4 t5 t6)
         (cons (cons t1 t2) (cons (cons t3 t4) (cons t5 t6)))))
    (7 '(lambda (t1 t2 t3 t4 t5 t6 t7)
         (cons (cons t1 (cons t2 t3)) (cons (cons t4 t5) (cons t6 t7)))))
    (8 '(lambda (t1 t2 t3 t4 t5 t6 t7 t8)
         (cons (cons (cons t1 t2) (cons t3 t4))
          (cons (cons t5 t6) (cons t7 t8))) ))
    (9 '(lambda (t1 t2 t3 t4 t5 t6 t7 t8 t9)
         (cons (cons (cons t1 t2) (cons t3 t4))
          (cons (cons t5 t6) (cons t7 (cons t8 t9))))))
    (10 '(lambda (t1 t2 t3 t4 t5 t6 t7 t8 t9 t10)
          (cons (cons (cons t1 t2) (cons t3 t4))
           (cons (cons t5 t6) (cons (cons t7 t8) (cons t9 t10))))))
    (11 '(lambda (t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11)
           (cons (cons (cons t1 t2) (cons t3 t4))
            (cons (cons t5 (cons t6 t7))
             (cons (cons t8 t9) (cons t10 t11))))))
    (12 '(lambda (t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12)
           (cons (cons (cons t1 t2) (cons t3 t4))
            (cons (cons (cons t5 t6) (cons t7 t8))
             (cons (cons t9 t10) (cons t11 t12))))))
    (13 '(lambda (t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13)
           (cons (cons (cons t1 t2) (cons t3 (cons t4 t5)))
            (cons (cons (cons t6 t7) (cons t8 t9))
             (cons (cons t10 t11) (cons t12 t13))))))
    (14 '(lambda (t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14)
           (cons (cons (cons t1 t2) (cons (cons t3 t4) (cons t5 t6)))
            (cons (cons (cons t7 t8) (cons t9 t10))
             (cons (cons t11 t12) (cons t13 t14))))))
    (15 '(lambda (t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15)
           (cons (cons (cons t1 (cons t2 t3)) (cons (cons t4 t5) (cons t6 t7)))
            (cons (cons (cons t8 t9) (cons t10 t11))
             (cons (cons t12 t13) (cons t14 t15))))))
    (16 '(lambda (t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 t15 t16)
           (cons (cons (cons (cons t1 t2) (cons t3 t4))
                  (cons (cons t5 t6) (cons t7 t8)))
            (cons (cons (cons t9 t10) (cons t11 t12))
             (cons (cons t13 t14) (cons t15 t16))))))
    (t '(lambda (t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 t13 t14 &rest more-t)
          (cons (cons (cons (cons t1 t2) (cons t3 t4))
                 (cons (cons t5 t6) (cons t7 t8)))
           (cons (cons (cons t9 t10) (cons t11 t12))
            (cons (cons t13 t14) more-t)))))))


;; ===================== Generic Function Initialization =====================

;; Checks a generic-function lambda-list and converts it to a signature.
;; Reports errors through errfunc (a function taking a detail object, an
;; error format string and format string arguments).
(defun generic-function-lambda-list-to-signature (lambdalist errfunc)
  (multiple-value-bind (reqvars optvars rest keyp keywords keyvars allowp)
      (sys::analyze-generic-function-lambdalist lambdalist errfunc)
    (declare (ignore keyvars))
    (let ((reqnum (length reqvars))
          (optnum (length optvars))
          (restp (or (not (eql rest 0)) keyp))) ; &key implies &rest
      (make-signature :req-num reqnum :opt-num optnum
                      :rest-p restp :keys-p keyp
                      :keywords keywords :allow-p allowp))))

; n --> list (0 ... n-1)
(defun countup (n)
  (do* ((count n (1- count))
        (l '() (cons count l)))
       ((eql count 0) l)))

;; Checks an argument-precedence-order list and converts it to a list of
;; indices. reqvars is the required-variables portion of the lambda-list.
;; Reports errors through errfunc (a function taking a detail object, an
;; error format string and format string arguments).
(defun generic-function-argument-precedence-order-to-argorder (argument-precedence-order reqnum reqvars errfunc)
  (let ((indices
          (mapcar #'(lambda (x)
                      (or (position x reqvars)
                          (funcall errfunc x
                                   (TEXT "~S is not one of the required parameters: ~S")
                                   x argument-precedence-order)))
                  argument-precedence-order)))
    ;; Is argument-precedence-order a permutation of reqvars?
    ;; In other words: Is the mapping
    ;;         argument-precedence-order --> reqvars
    ;; resp.   indices                   --> {0, ..., reqnum-1}
    ;; bijective?
    (unless (or (<= (length indices) 1) (apply #'/= indices)) ; injective?
      (funcall errfunc argument-precedence-order
               (TEXT "Some variable occurs twice in ~S")
               argument-precedence-order))
    (unless (eql (length indices) reqnum) ; surjective?
      (let ((missing (set-difference reqvars argument-precedence-order)))
        (funcall errfunc missing
                 (TEXT "The variables ~S are missing in ~S")
                 missing argument-precedence-order)))
    indices))

;; Checks a generic-function lambda-list and argument-precedence-order.
;; Returns three values:
;; 1. the lambda-list's signature,
;; 2. the argument-precedence-order, as a list of variables,
;; 3. the argument-precedence-order, as a list of numbers from 0 to reqnum-1.
;; Reports errors through errfunc (a function taking a detail object, an
;; error format string and format string arguments).
(defun check-gf-lambdalist+argorder (lambdalist argument-precedence-order argument-precedence-order-p errfunc)
  ;; Check the lambda-list.
  (let* ((signature
           (generic-function-lambda-list-to-signature lambdalist
             #'(lambda (lalist detail errorstring &rest arguments)
                 (funcall errfunc lalist detail
                          (TEXT "Invalid generic function lambda-list: ~?")
                          errorstring arguments))))
         (reqnum (sig-req-num signature))
         (reqvars (subseq lambdalist 0 reqnum)))
    (if argument-precedence-order-p
      ;; Check the argument-precedence-order.
      (progn
        (unless (proper-list-p argument-precedence-order)
          (funcall errfunc argument-precedence-order
                   (TEXT "The ~S argument should be a proper list, not ~S")
                   ':argument-precedence-order argument-precedence-order))
        (let ((indices
                (generic-function-argument-precedence-order-to-argorder
                  argument-precedence-order reqnum reqvars
                  #'(lambda (detail errorstring &rest arguments)
                      (funcall errfunc detail
                               (TEXT "Incorrect ~S argument: ~?")
                               ':argument-precedence-order
                               errorstring arguments)))))
          (values signature argument-precedence-order indices)))
      (values signature reqvars (countup reqnum)))))

;; Checks a generic-function declspecs list.
(defun sys::top-level-declarations ()
  (assoc 'declaration sys::*toplevel-denv* :test #'eq))
(defun check-gf-declspecs (declspecs keyword errfunc)
  (unless (proper-list-p declspecs)
    (funcall errfunc #'error (TEXT "The ~S argument should be a proper list, not ~S")
             keyword declspecs))
  (remove-if-not
   (lambda (declspec)
     (if (and (consp declspec)
              (let ((d (first declspec)))
                (or (sys::memq d (cdr (sys::top-level-declarations)))
                    (sys::memq d sys::*user-declaration-types*))))
         declspec
         (funcall errfunc #'warn
                  (TEXT "In the ~S argument, ~S declaration is not permitted")
                  keyword declspec)))
   declspecs))

;; CLtL2 28.1.6.4., ANSI CL 7.6.4. Congruent Lambda-lists
(defun check-signature-congruence (gf method
                                   &optional (gf-sign (safe-gf-signature gf))
                                             (m-sign (method-signature method)))
  (unless (= (sig-req-num m-sign) (sig-req-num gf-sign))
    (error-of-type 'error
      (TEXT "~S has ~D, but ~S has ~D required parameter~:P")
      method (sig-req-num m-sign) gf (sig-req-num gf-sign)))
  (unless (= (sig-opt-num m-sign) (sig-opt-num gf-sign))
    (error-of-type 'error
      (TEXT "~S has ~D, but ~S has ~D optional parameter~:P")
      method (sig-opt-num m-sign) gf (sig-opt-num gf-sign)))
  (when (and (sig-rest-p m-sign) (not (sig-rest-p gf-sign)))
    (error-of-type 'error
      (TEXT "~S accepts &REST or &KEY, but ~S does not.")
      method gf))
  (when (and (sig-rest-p gf-sign) (not (sig-rest-p m-sign)))
    (error-of-type 'error
      (TEXT "~S accepts &REST or &KEY, but ~S does not.")
      gf method))
  (when (sig-keys-p gf-sign)    ; gf has keywords?
    ;; yes ==> method must accept it
    (unless (if (sig-keys-p m-sign)
              (or (sig-allow-p m-sign) ; keywords match
                  (subsetp (sig-keywords gf-sign) (sig-keywords m-sign)))
              (sig-rest-p m-sign)) ; method must have &rest!
      (error-of-type 'error
        (TEXT "~S does not accept the keywords ~S of ~S")
        method (sig-keywords gf-sign) gf))))

;; CLtL2 28.1.7.2., 28.1.7.4., ANSI CL 7.6.6.2., 7.6.6.4. Method qualifiers
(defun check-method-qualifiers (gf method
                                &optional (method-combination (safe-gf-method-combination gf)))
  (funcall (method-combination-check-method-qualifiers method-combination)
           gf method-combination method))
(defun invalid-method-qualifiers-error (gf method) ; ABI
  (error-of-type 'program-error
    (TEXT "~S method combination, used by ~S, does not allow the method qualifiers ~:S: ~S")
    (method-combination-name (safe-gf-method-combination gf)) gf
    (method-qualifiers method) method))

;; Initialization of a <standard-generic-function> instance.
(defun shared-initialize-<standard-generic-function> (gf situation &rest args
                                                      &key (name nil name-p)
                                                           (lambda-list nil lambda-list-p)
                                                           (argument-precedence-order nil argument-precedence-order-p)
                                                           (method-class nil method-class-p)
                                                           (method-combination nil method-combination-p)
                                                           (documentation nil documentation-p)
                                                           (declarations nil declarations-p)
                                                           (declare nil declare-p)
                                                      &allow-other-keys
                                                      &aux signature argorder)
  (declare (ignore name name-p))
  (apply #'shared-initialize-<generic-function> gf situation args)
  (when (eq situation 't)
    (setf (std-gf-initialized gf) nil))
  (when (and argument-precedence-order-p (not lambda-list-p))
    (error (TEXT "(~S ~S) for generic function ~S: ~S argument specified without a ~S argument.")
           (if (eq situation 't) 'initialize-instance 'shared-initialize)
           'standard-generic-function (funcallable-name gf)
           ':argument-precedence-order ':lambda-list))
  (when lambda-list-p
    ; Check the lambda-list and argument-precedence-order.
    (multiple-value-setq (signature argument-precedence-order argorder)
        (check-gf-lambdalist+argorder lambda-list
          argument-precedence-order argument-precedence-order-p
          #'(lambda (detail errorstring &rest arguments)
              (declare (ignore detail))
              (error (TEXT "(~S ~S) for generic function ~S: ~?")
                     (if (eq situation 't) 'initialize-instance 'shared-initialize)
                     'standard-generic-function (funcallable-name gf)
                     errorstring arguments))))
    (unless (eq situation 't)
      ;; ANSI CL description of ENSURE-GENERIC-FUNCTION says "If ... the new
      ;; value [for the :lambda-list argument] is congruent with the lambda
      ;; lists of all existing methods or there are no methods, the value is
      ;; changed; otherwise an error is signaled.
      (unless (or (safe-gf-undeterminedp gf)
                  (equalp signature (safe-gf-signature gf)))
        (dolist (method (safe-gf-methods gf))
          (check-signature-congruence gf method signature)))))
  (when (or (eq situation 't) method-class-p)
    ; Check the method-class.
    (unless method-class-p
      (setq method-class <standard-method>))
    (unless (defined-class-p method-class)
      (error (TEXT "(~S ~S) for generic function ~S: The ~S argument should be a class, not ~S")
             (if (eq situation 't) 'initialize-instance 'shared-initialize)
             'standard-generic-function (funcallable-name gf)
             ':method-class method-class))
    (unless (subclassp method-class <method>)
      (error (TEXT "(~S ~S) for generic function ~S: The ~S argument should be a subclass of ~S, not ~S")
             (if (eq situation 't) 'initialize-instance 'shared-initialize)
             'standard-generic-function (funcallable-name gf)
             ':method-class 'method method-class)))
  (when (or (eq situation 't) method-combination-p)
    ; Check the method-combination.
    #| ; Not sure whether giving an error here is appropriate.
    (unless method-combination-p
      (error (TEXT "(~S ~S) for generic function ~S: Missing ~S argument.")
             (if (eq situation 't) 'initialize-instance 'shared-initialize)
             'standard-generic-function (funcallable-name gf)
             ':method-combination))
    |#
    (unless method-combination-p
      (setq method-combination
            (get-method-combination 'STANDARD '(initialize-instance standard-generic-function))))
    (unless (typep-class method-combination <method-combination>)
      (error (TEXT "(~S ~S) for generic function ~S: The ~S argument should be a ~S object, not ~S")
             (if (eq situation 't) 'initialize-instance 'shared-initialize)
             'standard-generic-function (funcallable-name gf)
             ':method-combination 'method-combination method-combination))
    (unless (eq situation 't)
      (unless (eq method-combination (safe-gf-method-combination gf))
        (dolist (method (safe-gf-methods gf))
          (check-method-qualifiers gf method method-combination)))))
  (when (or (eq situation 't) documentation-p)
    ; Check the documentation.
    (unless (or (null documentation) (stringp documentation))
      (error (TEXT "(~S ~S) for generic function ~S: The ~S argument should be a string or NIL, not ~S")
             (if (eq situation 't) 'initialize-instance 'shared-initialize)
             'standard-generic-function (funcallable-name gf) ':documentation documentation)))
  (when (or (eq situation 't) declarations-p declare-p)
    ; Check the declarations.
    ; ANSI CL specifies the keyword :DECLARE for ensure-generic-function, but the
    ; MOP p. 50 specifies the keyword :DECLARATIONS for ensure-generic-function-using-class.
    (when (and declarations-p declare-p)
      (error (TEXT "(~S ~S) for generic function ~S: The ~S and ~S arguments cannot be specified together.")
             (if (eq situation 't) 'initialize-instance 'shared-initialize)
             'standard-generic-function (funcallable-name gf)
             ':declarations ':declare))
    (setq declarations
      (check-gf-declspecs
       (if declare-p declare declarations)
       (if declare-p ':declare ':declarations)
       (lambda (reporter errorstring &rest arguments)
         (funcall reporter (TEXT "(~S ~S) for generic function ~S: ~?")
                   (if (eq situation 't) 'initialize-instance 'shared-initialize)
                   'standard-generic-function (funcallable-name gf)
                   errorstring arguments)))))
  ; Fill the slots.
  (when lambda-list-p
    (setf (std-gf-lambda-list gf) lambda-list)
    (setf (std-gf-signature gf) signature)
    (setf (std-gf-argorder gf) argorder))
  (when (or (eq situation 't) method-class-p)
    (setf (std-gf-default-method-class gf) method-class))
  (when (or (eq situation 't) method-combination-p)
    (setf (std-gf-method-combination gf) method-combination))
  (when (or (eq situation 't) documentation-p)
    (setf (std-gf-documentation gf) documentation))
  (when (or (eq situation 't) declarations-p declare-p)
    (setf (std-gf-declspecs gf) declarations))
  (when (eq situation 't)
    (setf (std-gf-methods gf) '()))
  (when (or (eq situation 't)
            ; When reinitializing a generic-function, we need to clear the
            ; caches (cf. MOP p. 40 compute-discriminating-function item (ii)).
            ; But we don't need to do it if we know that all that has changed
            ; are the name, method-class, documentation, declarations, declare
            ; initargs. But other, possibly user-defined, initargs can have an
            ; effect on the discriminating function.
            (do ((l args (cddr l)))
                ((endp l) nil)
              (unless (memq (car l) '(:name :method-class :documentation :declarations :declare))
                (return t))))
    (setf (std-gf-effective-method-cache gf) '()))
  ; Now allow the user to call the generic-function-xxx accessor functions.
  (setf (std-gf-initialized gf) t)
  ; And allow the user to call gf.
  (finalize-fast-gf gf)
  gf)

;; ======================== The Set of Methods of a GF ========================

;; Cruel hack (CLtL2 28.1.9.2., ANSI CL 7.1.2.):
;; - MAKE-INSTANCE must be informed about the methods of ALLOCATE-INSTANCE,
;;   INITIALIZE-INSTANCE and SHARED-INITIALIZE.
;; - INITIALIZE-INSTANCE must be informed about the methods of
;;   INITIALIZE-INSTANCE and SHARED-INITIALIZE.
;; - REINITIALIZE-INSTANCE must be informed about the methods of
;;   REINITIALIZE-INSTANCE and SHARED-INITIALIZE.
;; - UPDATE-INSTANCE-FOR-REDEFINED-CLASS must be informed about the methods of
;;   UPDATE-INSTANCE-FOR-REDEFINED-CLASS and SHARED-INITIALIZE.
;; - UPDATE-INSTANCE-FOR-DIFFERENT-CLASS must be informed about the methods of
;;   UPDATE-INSTANCE-FOR-DIFFERENT-CLASS and SHARED-INITIALIZE.
(defvar |#'allocate-instance| nil)
(defvar |#'initialize-instance| nil)
(defvar |#'reinitialize-instance| nil)
(defvar |#'update-instance-for-redefined-class| nil)
(defvar |#'update-instance-for-different-class| nil)
(defvar |#'shared-initialize| nil)

;; Optimization of SLOT-VALUE and its brothers.
(defvar |#'slot-value-using-class| nil)
(defvar |#'(setf slot-value-using-class)| nil)
(defvar |#'slot-boundp-using-class| nil)
(defvar |#'slot-makunbound-using-class| nil)

;; More general notification.
(defun map-dependents-<generic-function> (gf function)
  (dolist (dependent (gf-listeners gf))
    (funcall function dependent)))

;; CLtL2 28.1.6.3., ANSI CL 7.6.3.
;; Agreement on Parameter Specializers and Qualifiers
(defun methods-agree-p (method1 method2)
  (and (equal (method-qualifiers method1) (method-qualifiers method2))
       (specializers-agree-p (method-specializers method1)
                             (method-specializers method2))))

;; MOP p. 62 says that the lambda-list of a generic function may become
;; determined only at the moment when the first method is added.
(defun gf-lambdalist-from-first-method (m-lambdalist m-signature)
  (let* ((req-num (sig-req-num m-signature))
         (opt-num (sig-opt-num m-signature))
         (rest-p (sig-rest-p m-signature)))
    (values
      ;; The inferred lambda-list:
      (append (subseq m-lambdalist 0 req-num)
              (if (> opt-num 0)
                (cons '&OPTIONAL
                      (mapcar #'(lambda (item) (if (consp item) (first item) item))
                              (subseq m-lambdalist (+ req-num 1) (+ req-num 1 opt-num))))
                '())
              (if rest-p
                (list '&REST
                      (let ((i (position '&REST m-lambdalist)))
                        (if i (nth (+ i 1) m-lambdalist) (gensym))))
               '()))
      ;; Its corresponding signature:
      (make-signature :req-num req-num :opt-num opt-num :rest-p rest-p))))

;; Add a method to a generic function.
(defun std-add-method (gf method)
  (if (safe-gf-undeterminedp gf)
    ;; The first added method determines the generic-function's signature.
    (shared-initialize-<standard-generic-function> gf nil
      :lambda-list (gf-lambdalist-from-first-method (method-lambda-list method)
                                                    (method-signature method)))
    (check-signature-congruence gf method))
  (when (method-generic-function method)
    (error-of-type 'error
      "~S: ~S already belongs to ~S, cannot also add it to ~S"
      'std-add-method method (method-generic-function method) gf))
  (check-method-qualifiers gf method)
  ;; The method is checked. Now add it:
  (when (need-gf-already-called-warning-p gf)
    (clos-warn 'simple-gf-already-called-warning
      (TEXT "Adding method ~S to an already called generic function ~S")
      method gf))
  (let ((old-method (find method (safe-gf-methods gf) :test #'methods-agree-p)))
    (when old-method
      (clos-warn 'simple-gf-replacing-method-warning
        (TEXT "Replacing method ~S in ~S") old-method gf)
      ;; Call remove-method without warnings.
      (let ((old-dm (gf-dynamically-modifiable gf))) ; cf. macros3.lisp:letf
        (unwind-protect
             (progn (setf (gf-dynamically-modifiable gf) t)
                    (remove-method gf old-method))
          (setf (gf-dynamically-modifiable gf) old-dm)))
      ;; Ensure that remove-method really has removed the method.
      (when (memq method (safe-gf-methods gf))
        (error (TEXT "Wrong ~S behaviour: ~S has not been removed from ~S")
               'remove-method old-method gf))))
  (cond ((eq gf |#'allocate-instance|) (note-ai-change method))
        ((eq gf |#'initialize-instance|) (note-ii-change method))
        ((eq gf |#'reinitialize-instance|) (note-ri-change method))
        ((eq gf |#'update-instance-for-redefined-class|) (note-uirc-change method))
        ((eq gf |#'update-instance-for-different-class|) (note-uidc-change method))
        ((eq gf |#'shared-initialize|) (note-si-change method)))
  ;; Step 1: Add method to the set.
  (setf (std-gf-methods gf) (cons method (safe-gf-methods gf))
        (method-generic-function method) gf)
  ;; Step 2: Call add-direct-method for each specializer.
  (dolist (specializer (method-specializers method))
    (add-direct-method specializer method))
  ;; Step 3: Clear the effective method cache and the discriminating function.
  ;; (Cf. MOP p. 41 compute-discriminating-function item (iii).)
  (setf (std-gf-effective-method-cache gf) '())
  (finalize-fast-gf gf)
  ;; Step 4: Update the dependents.
  (cond ((eq gf |#'slot-value-using-class|) (note-svuc-change method))
        ((eq gf |#'(setf slot-value-using-class)|) (note-ssvuc-change method))
        ((eq gf |#'slot-boundp-using-class|) (note-sbuc-change method))
        ((eq gf |#'slot-makunbound-using-class|) (note-smuc-change method)))
  (funcall (if *classes-finished*
             #'map-dependents
             #'map-dependents-<generic-function>)
    gf
    #'(lambda (dependent)
        (update-dependent gf dependent 'add-method method)))
  ;; It's not worth updating the seclass of a generic function, since 1. in
  ;; most cases, it can signal a NO-APPLICABLE-METHOD error and thus has
  ;; *seclass-dirty*, 2. the compiler must assume that the seclass doesn't
  ;; change over time, which we cannot guarantee, since generic functions are
  ;; not sealed.
  gf)

;; Preliminary.
(predefun add-method (gf method)
  (std-add-method gf method))

;; Remove a method from a generic function.
(defun std-remove-method (gf method)
  (let ((old-method (find method (safe-gf-methods gf))))
    (when old-method
      (when (need-gf-already-called-warning-p gf)
        (clos-warn 'simple-gf-already-called-warning
          (TEXT "Removing method ~S from an already called generic function ~S")
          old-method gf))
      (cond ((eq gf |#'allocate-instance|) (note-ai-change method))
            ((eq gf |#'initialize-instance|) (note-ii-change method))
            ((eq gf |#'reinitialize-instance|) (note-ri-change method))
            ((eq gf |#'update-instance-for-redefined-class|) (note-uirc-change method))
            ((eq gf |#'update-instance-for-different-class|) (note-uidc-change method))
            ((eq gf |#'shared-initialize|) (note-si-change method)))
      ;; Step 1: Remove method from the set.
      (setf (std-gf-methods gf) (remove old-method (safe-gf-methods gf))
            (method-generic-function old-method) nil
            (method-from-defgeneric old-method) nil)
      ;; Step 2: Call remove-direct-method for each specializer.
      (dolist (specializer (method-specializers method))
        (remove-direct-method specializer method))
      ;; Step 3: Clear the effective method cache and the discriminating function.
      ;; (Cf. MOP p. 41 compute-discriminating-function item (iii).)
      (setf (std-gf-effective-method-cache gf) '())
      (finalize-fast-gf gf)
      ;; Step 4: Update the dependents.
      (cond ((eq gf |#'slot-value-using-class|) (note-svuc-change method))
            ((eq gf |#'(setf slot-value-using-class)|) (note-ssvuc-change method))
            ((eq gf |#'slot-boundp-using-class|) (note-sbuc-change method))
            ((eq gf |#'slot-makunbound-using-class|) (note-smuc-change method)))
      (funcall (if *classes-finished*
                 #'map-dependents
                 #'map-dependents-<generic-function>)
        gf
        #'(lambda (dependent)
            (update-dependent gf dependent 'remove-method method)))))
  gf)

;; Preliminary.
(predefun remove-method (gf method)
  (std-remove-method gf method))

;; Find a method in a generic function.
(defun std-find-method (gf qualifiers specializers &optional (errorp t))
  (unless (listp specializers)
    (error-of-type 'error
      (TEXT "~S: the specializers argument is not a list: ~S")
      'find-method specializers))
  (if (safe-gf-undeterminedp gf)
    ;; Signature not known yet, hence no methods installed.
    (assert (null (safe-gf-methods gf)))
    (progn
      (let ((n (sig-req-num (safe-gf-signature gf))))
        (unless (eql (length specializers) n)
          (error-of-type 'error
            (TEXT "~S: the specializers argument has length ~D, but ~S has ~D required parameter~:P")
            'find-method (length specializers) gf n))
        ; Convert (EQL object) -> #<EQL-SPECIALIZER object>:
        (setq specializers
              (mapcar #'(lambda (specializer)
                          (if (and (consp specializer) (eq (car specializer) 'EQL)
                                   (consp (cdr specializer)) (null (cddr specializer)))
                            (intern-eql-specializer (second specializer))
                            specializer))
                      specializers)))
      ;; Simulate
      ;;   (find hypothetical-method (safe-gf-methods gf) :test #'methods-agree-p)
      ;; cf. methods-agree-p
      (dolist (method (safe-gf-methods gf))
        (when (and (equal (method-qualifiers method) qualifiers)
                   (specializers-agree-p (method-specializers method)
                                         specializers))
          (return-from std-find-method method)))))
  (if errorp
    (error-of-type 'error
      (TEXT "~S has no method with qualifiers ~:S and specializers ~:S")
      gf qualifiers specializers)
    nil))

;; ===================== Generic Function Initialization =====================

(defun gf-set-dynamically-modifiable (gf declarations)
  (setf (gf-dynamically-modifiable gf)
        (and (assoc 'DYNAMICALLY-MODIFIABLE declarations) t)))

(defun initialize-instance-<generic-function> (gf &rest args
                                               &key name
                                                    lambda-list
                                                    argument-precedence-order
                                                    method-class
                                                    method-combination
                                                    documentation
                                                    declarations
                                                    declare
                                                    ((methods methods) nil methods-p) ; from DEFGENERIC
                                               &allow-other-keys)
  (declare (ignore name lambda-list argument-precedence-order method-class
                   method-combination documentation declare))
  (if *classes-finished*
    (apply #'%initialize-instance gf args) ; == (call-next-method)
    ;; During bootstrapping, only <standard-generic-function> instances are used.
    (apply #'shared-initialize-<standard-generic-function> gf 't args))
  (gf-set-dynamically-modifiable gf declarations)
  (when methods-p
    ;; When invoked from DEFGENERIC: Install the defgeneric-originated methods.
    (dolist (method methods) (add-method gf method)))
  gf)

(defun reinitialize-instance-<generic-function> (gf &rest args
                                                 &key name
                                                      lambda-list
                                                      argument-precedence-order
                                                      method-class
                                                      method-combination
                                                      documentation
                                                      declarations
                                                      declare
                                                      ((methods methods) nil methods-p) ; from DEFGENERIC
                                                 &allow-other-keys)
  (declare (ignore name lambda-list argument-precedence-order method-class
                   method-combination documentation declare))
  (when methods-p
    ;; When invoked from DEFGENERIC:
    ;; Remove the old defgeneric-originated methods. Instead of calling
    ;; std-remove-method on each such method, while inhibiting warnings,
    ;; we can just as well remove the methods directly.
    (setf (std-gf-methods gf)
          (remove-if #'(lambda (method)
                         (when (method-from-defgeneric method)
                           ;; Step 1: Remove method from the set.
                           (setf (method-generic-function method) nil)
                           (setf (method-from-defgeneric method) nil)
                           ;; Step 2: Call remove-direct-method for each specializer.
                           (dolist (specializer (method-specializers method))
                             (remove-direct-method specializer method))
                           t))
                     (safe-gf-methods gf))))
  (apply (cond ((eq (class-of gf) <standard-generic-function>)
                #'shared-initialize-<standard-generic-function>)
               (t #'shared-initialize))
         gf nil args)
  (gf-set-dynamically-modifiable gf declarations)
  (when methods-p
    ;; When invoked from DEFGENERIC: Install the defgeneric-originated
    ;; methods.
    (dolist (method methods) (add-method gf method)))
  ;; Notification of listeners:
  (map-dependents gf
    #'(lambda (dependent)
        (apply #'update-dependent gf dependent args)))
  gf)

(defun make-instance-<standard-generic-function> (class &rest args
                                                  &key name
                                                       lambda-list
                                                       argument-precedence-order
                                                       method-class
                                                       method-combination
                                                       documentation
                                                       declarations
                                                       declare
                                                  &allow-other-keys)
  ;; class = <standard-generic-function>
  ;; Don't add functionality here! This is a preliminary definition that is
  ;; replaced with #'make-instance later.
  (declare (ignore class name lambda-list argument-precedence-order method-class
                   method-combination documentation declarations declare))
  (let ((gf (%allocate-instance <standard-generic-function>)))
    (apply #'initialize-instance-<generic-function> gf args)))

(defun allocate-generic-function-instance (class &rest args
                                           &key &allow-other-keys)
  ;; During bootstrapping, only <standard-generic-function> instances are used.
  (declare (ignore class args))
  (%allocate-instance <standard-generic-function>))

(defun make-generic-function-instance (class &rest args ; ABI
                                       &key &allow-other-keys)
  ;; During bootstrapping, only <standard-generic-function> instances are used.
  (apply #'make-instance-<standard-generic-function> class args))

;; Returns an instance of the given generic-function class that is initialized
;; with just the name, without calling user-defined initialize-instance methods.
(defun make-generic-function-prototype (class &rest args &key name) ; ABI
  (declare (ignore name))
  (let ((instance (allocate-generic-function-instance class)))
    (apply #'shared-initialize-<generic-function> instance 't args)))

;; ======================= Installing the Dispatch Code =======================

#||
 (defun make-gf (generic-function-class name lambdabody lambda-list argument-precedence-order method-combination user-defined-args methods)
  (let ((final
          (apply #'make-generic-function-instance generic-function-class
            :name name
            :lambda-list lambda-list
            :argument-precedence-order argument-precedence-order
            :method-combination method-combination
            (mapcan #'(lambda (option) (list (first option) (rest option)))
                    user-defined-args)))
        (preliminary
         (eval `(LET ()
                  (DECLARE ,@(compile-no-jitc name))
                  (%GENERIC-FUNCTION-LAMBDA ,@lambdabody)))))
    (assert (<= (sys::%record-length preliminary) 3))
    (set-funcallable-instance-function final preliminary)
    (setf (std-gf-methods final) methods)
    final))
||#


#|| ;; Generic functions with primitive dispatch:

 (defun make-slow-gf (generic-function-class name lambda-list argument-precedence-order method-class declspecs documentation user-defined-args methods)
  (let* ((final
           (apply #'make-generic-function-instance generic-function-class
             :name name
             :lambda-list lambda-list
             :argument-precedence-order argument-precedence-order
             :method-class method-class
             :declarations declspecs
             :documentation documentation
             (mapcan #'(lambda (option) (list (first option) (rest option)))
                     user-defined-args)))
         (preliminary
           (eval `(LET ((GF ',final))
                    (DECLARE ,@(compile-no-jitc name))
                    (%GENERIC-FUNCTION-LAMBDA (&REST ARGS)
                      (DECLARE (INLINE APPLY))
                      (APPLY 'SLOW-FUNCALL-GF GF ARGS))))))
    (assert (<= (sys::%record-length preliminary) 3))
    (set-funcallable-instance-function final preliminary)
    (setf (std-gf-methods final) methods)
    final))

 (flet ((prototype-factory (gf)
           (declare ,@(compile-no-jitc (sys::closure-name gf)))
           (%generic-function-lambda (&rest args)
             (declare (inline apply))
             (apply 'slow-funcall-gf gf args))))
  (assert (<= (sys::%record-length (prototype-factory 'dummy)) 3))
  (let ((prototype-code (sys::closure-codevec (prototype-factory 'dummy))))
  (defun finalize-slow-gf (gf)
      (set-funcallable-instance-function gf (prototype-factory gf)))
    (defun gf-never-called-p (gf)
      (eq (sys::closure-codevec gf) prototype-code))))

;; Call of a generic function.
;; Without any caching: Compute the effective method at each call.
 (defun slow-funcall-gf (gf &rest args)
  (unless (>= (length args) (sig-req-num (safe-gf-signature gf)))
      (error-of-type 'program-error
        (TEXT "Too few arguments to ~S: ~S")
        gf args))
  ;; Determine the effective method.
  ;; Return the effective method. It will then be applied to the arguments.
  (apply #'compute-applicable-methods-effective-method gf args))

||#

(defun gf-sig-restp (sig)
  (or (sig-rest-p sig) (> (sig-opt-num sig) 0)))

;; Generic functions with optimized dispatch:

;; First optimization: When the generic function is called, the required
;; arguments are not consed up into an argument list, but rather passed on
;; the stack.

(let ((prototype-factory-table
        (make-hash-table :key-type '(cons fixnum boolean) :value-type '(cons function (simple-array (unsigned-byte 8) (*)))
                         :test 'ext:stablehash-equal :warn-if-needs-rehash-after-gc t))
      (uninitialized-prototype-factory
       (eval `#'(LAMBDA (GF)
                  (DECLARE ,@(compile-no-jitc 'uninitialized-prototype-factory))
                  (%GENERIC-FUNCTION-LAMBDA (&REST ARGS)
                    (DECLARE (INLINE FUNCALL) (IGNORE ARGS))
                    (FUNCALL 'NO-METHOD-CALLER 'NO-APPLICABLE-METHOD GF))))))
  (defun finalize-fast-gf (gf)
    (let ((prototype-factory
            (if (safe-gf-undeterminedp gf)
              ;; gf has uninitialized lambda-list, hence no methods.
              uninitialized-prototype-factory
              (let* ((signature (safe-gf-signature gf))
                     (reqnum (sig-req-num signature))
                     (restp (gf-sig-restp signature))
                     (hash-key (cons reqnum restp)))
                (car
                  (or (gethash hash-key prototype-factory-table)
                      (setf (gethash hash-key prototype-factory-table)
                            (let* ((reqvars (gensym-list reqnum))
                                   (prototype-factory
                                    (eval `#'(LAMBDA (GF)
                                               (DECLARE ,@(compile-no-jitc (sys::closure-name gf) 'prototype-factory))
                                               (%GENERIC-FUNCTION-LAMBDA
                                                (,@reqvars ,@(if restp '(&REST ARGS) '()))
                                                (DECLARE (INLINE FUNCALL) (IGNORABLE ,@reqvars ,@(if restp '(ARGS) '())))
                                                (FUNCALL 'INITIAL-FUNCALL-GF GF)))))
                                   (dummy-f (funcall prototype-factory 'dummy)))
                              (assert (<= (sys::%record-length dummy-f) 3))
                              (cons prototype-factory
                                    (sys::closure-codevec dummy-f))))))))))
      (set-funcallable-instance-function gf (funcall prototype-factory gf))))
  (defun gf-never-called-p (gf)
    (or (safe-gf-undeterminedp gf)
        (let* ((signature (safe-gf-signature gf))
               (reqnum (sig-req-num signature))
               (restp (gf-sig-restp signature))
               (hash-key (cons reqnum restp))
               (prototype-factory+codevec (gethash hash-key prototype-factory-table)))
          (assert prototype-factory+codevec)
          (eq (sys::closure-codevec gf) (cdr prototype-factory+codevec)))))
  (defun need-gf-already-called-warning-p (gf)
    (and (not (gf-never-called-p gf))
         (not (gf-dynamically-modifiable gf))))
) ; let


;; Second optimization: The actual dispatch-code is calculated at the first
;; call of the function, in order to make successive method definitions not
;; too expensive.

;; First call of a generic function:
(defun initial-funcall-gf (gf)
  (install-dispatch gf)
  gf)

;; Installs the final dispatch-code into a generic function.
(defun install-dispatch (gf)
  (let ((dispatch
          (funcall (cond ((or (eq gf |#'compute-discriminating-function|) ; for bootstrapping
                              (eq gf |#'compute-applicable-methods-using-classes|))
                          #'compute-discriminating-function-<generic-function>)
                         (t #'compute-discriminating-function))
                   gf)))
    ; Some checks, to guarantee that user-defined methods on
    ; compute-discriminating-function don't break our CLOS.
    (unless (functionp dispatch)
      (error (TEXT "Wrong ~S result for generic-function ~S: not a function: ~S")
             'compute-discriminating-function gf dispatch))
    ; Now install it.
    (set-funcallable-instance-function gf dispatch)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-genfun2b.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-genfun2a.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP
;;;; Generic Functions
;;;; Part 2: Generic function dispatch and execution
;;;; Bruno Haible 21.8.1993 - 2004
;;;; Sam Steingold 1998 - 2004, 2007
;;;; German comments translated into English: Stefan Kain 2002-04-08

(in-package "CLOS")


;; ======================== Avoiding endless recursion ========================

;; Generic functions which are used in implementing the generic function
;; dispatch and execution.
(defvar |#'compute-discriminating-function| nil)
(defvar |#'compute-applicable-methods| nil)
(defvar |#'compute-applicable-methods-using-classes| nil)
(defvar |#'compute-effective-method| nil)
(defvar |#'generic-function-methods| nil)
(defvar |#'generic-function-method-class| nil)
(defvar |#'generic-function-signature| nil)
(defvar |#'generic-function-undeterminedp| nil)
(defvar |#'generic-function-method-combination| nil)
(defvar |#'generic-function-argorder| nil)
(defvar |#'generic-function-declarations| nil)
(defvar |#'method-qualifiers| nil)
(defvar |#'method-specializers| nil)

(defun safe-gf-methods (gf)
  (if (or (eq gf #'generic-function-methods) ; for bootstrapping
          (eq gf |#'generic-function-methods|)
          (eq gf |#'compute-effective-method|)
          (eq gf |#'compute-discriminating-function|)
          (eq gf |#'compute-applicable-methods-using-classes|))
    (std-gf-methods gf)
    (generic-function-methods gf)))

(defun safe-gf-default-method-class (gf)
  (if (or (eq gf |#'generic-function-method-class|)
          (eq gf |#'compute-effective-method|))
    (std-gf-default-method-class gf)
    (generic-function-method-class gf)))

(defun safe-gf-signature (gf)
  (if (or (eq gf #'generic-function-signature) ; for bootstrapping
          (eq gf |#'generic-function-signature|)
          (eq gf |#'generic-function-method-class|)
          (eq gf |#'compute-effective-method|))
    (std-gf-signature gf)
    (generic-function-signature gf)))

(defun safe-gf-undeterminedp (gf)
  (if (or (eq gf #'generic-function-undeterminedp) ; for bootstrapping
          (eq gf |#'generic-function-undeterminedp|))
    (std-gf-undeterminedp gf)
    (generic-function-undeterminedp gf)))

(defun safe-gf-method-combination (gf)
  (if (or (eq gf #'generic-function-method-combination) ; for bootstrapping
          (eq gf |#'generic-function-method-combination|)
          (eq gf |#'compute-effective-method|))
    (std-gf-method-combination gf)
    (generic-function-method-combination gf)))

(defun safe-gf-argorder (gf)
  (if (or (eq gf |#'generic-function-argorder|)
          (eq gf |#'method-qualifiers|)
          (eq gf |#'compute-effective-method|))
    (std-gf-argorder gf)
    (generic-function-argorder gf)))

(defun safe-gf-declspecs (gf)
  (if (or (eq gf |#'generic-function-declarations|)
          (eq gf |#'generic-function-argorder|)
          (eq gf |#'method-qualifiers|)
          (eq gf |#'compute-effective-method|))
    (std-gf-declspecs gf)
    (generic-function-declarations gf)))

(defun safe-method-qualifiers (method gf)
  (if (or (eq gf #'method-qualifiers) ; for bootstrapping
          (eq gf |#'method-qualifiers|)
          (eq gf |#'compute-effective-method|))
    (std-method-qualifiers method)
    (method-qualifiers method)))

(defun safe-method-specializers (method gf)
  (if (or (eq gf #'method-specializers) ; for bootstrapping
          (eq gf |#'method-specializers|)
          (eq gf |#'compute-effective-method|))
    (std-method-specializers method)
    (method-specializers method)))

;; ============================= Method Selection =============================

;; CLtL2 28.1.6.2., ANSI CL 7.6.2. Applicable methods
(defun method-applicable-p (method required-arguments gf)
  (every #'typep required-arguments (safe-method-specializers method gf)))

;; CLtL2 28.1.7.1., ANSI CL 7.6.6.1.2.
;; Sorting the applicable methods by precedence order
;; > methods: A list of methods from the same generic function that are
;;            already known to be applicable for the given required-arguments.
;; > required-argument-classes: the list of classes the required arguments are
;;                              direct instances of.
;; > argument-order: A list of indices in the range 0..req-num-1 that
;;                   determines the argument order.
(defun sort-applicable-methods (methods required-argument-classes argument-order gf)
  (sort (copy-list methods)
        #'(lambda (method1 method2) ; method1 < method2 ?
            (let ((specializers1 (safe-method-specializers method1 gf))
                  (specializers2 (safe-method-specializers method2 gf)))
              (dolist (arg-index argument-order nil)
                (let ((arg-class (nth arg-index required-argument-classes))
                      (psp1 (nth arg-index specializers1))
                      (psp2 (nth arg-index specializers2)))
                  (if (eql-specializer-p psp1)
                    (if (eql-specializer-p psp2)
                      nil         ; (EQL x) = (EQL x)
                      (return t)) ; (EQL x) < <class>  ==>  method1 < method2
                    (if (eql-specializer-p psp2)
                      (return nil) ; <class> > (EQL x)   ==>  method1 > method2
                      ;; two classes: compare the position in the CPL of arg-class:
                      (let* ((cpl (class-precedence-list arg-class))
                             (pos1 (position psp1 cpl))
                             (pos2 (position psp2 cpl)))
                        (cond ((< pos1 pos2) (return t)) ; method1 < method2
                              ((> pos1 pos2) (return nil)) ; method1 > method2
                              ))))))))))

;; Preliminary.
(predefun compute-applicable-methods (gf args)
  (compute-applicable-methods-<generic-function> gf args))

(defun compute-applicable-methods-<generic-function> (gf args)
  (if (safe-gf-undeterminedp gf)
    ;; gf has uninitialized lambda-list, hence no methods.
    '()
    (let ((req-num (sig-req-num (safe-gf-signature gf))))
      (if (>= (length args) req-num)
        ;; 0. Check the method specializers:
        (let ((methods (safe-gf-methods gf)))
          (dolist (method methods)
            (check-method-only-standard-specializers gf method
              'compute-applicable-methods))
          ;; 1. Select the applicable methods:
          (let ((req-args (subseq args 0 req-num)))
            (setq methods
                  (remove-if-not #'(lambda (method)
                                     (method-applicable-p method req-args gf))
                                 (the list methods)))
            ;; 2. Sort the applicable methods by precedence order:
            (sort-applicable-methods methods (mapcar #'class-of req-args) (safe-gf-argorder gf) gf)))
        (error (TEXT "~S: ~S has ~S required argument~:P, but only ~S arguments were passed to ~S: ~S")
               'compute-applicable-methods gf req-num (length args)
               'compute-applicable-methods args)))))

;; ----------------------------------------------------------------------------

;; compute-applicable-methods-using-classes is just plain redundant, and must
;; be a historical relic of the time before CLOS had EQL specializers (or a
;; brain fart of the PCL authors). But the MOP wants it, so we implement it.

;; Preliminary.
(predefun compute-applicable-methods-using-classes (gf req-arg-classes)
  (compute-applicable-methods-using-classes-<generic-function> gf req-arg-classes))

(defun compute-applicable-methods-using-classes-<generic-function> (gf req-arg-classes)
  (unless (and (proper-list-p req-arg-classes) (every #'defined-class-p req-arg-classes))
    (error (TEXT "~S: argument should be a proper list of classes, not ~S")
           'compute-applicable-methods-using-classes req-arg-classes))
  (if (safe-gf-undeterminedp gf)
    ;; gf has uninitialized lambda-list, hence no methods.
    '()
    (let ((req-num (sig-req-num (safe-gf-signature gf))))
      (if (= (length req-arg-classes) req-num)
        ;; 0. Check the method specializers:
        (let ((methods (safe-gf-methods gf)))
          (dolist (method methods)
            (check-method-only-standard-specializers gf method
              'compute-applicable-methods-using-classes))
          ;; 1. Select the applicable methods. Note that the arguments are
          ;; assumed to be _direct_ instances of the given classes, i.e.
          ;; classes = (mapcar #'class-of required-arguments).
          (setq methods
                (remove-if-not #'(lambda (method)
                                   (let ((specializers (safe-method-specializers method gf))
                                         (applicable t) (unknown nil))
                                     (mapc #'(lambda (arg-class specializer)
                                               (if (defined-class-p specializer)
                                                 ;; For class specializers,
                                                 ;; (typep arg specializer) is equivalent to
                                                 ;; (subtypep (class-of arg) specializer).
                                                 (unless (subclassp arg-class specializer)
                                                   (setq applicable nil))
                                                 ;; For EQL specializers,
                                                 ;; (typep arg specializer) is certainly false
                                                 ;; if (class-of arg) and (class-of (eql-specializer-object specializer))
                                                 ;; differ. Otherwise unknown.
                                                 (if (eq arg-class (class-of (eql-specializer-object specializer)))
                                                   (setq unknown t)
                                                   (setq applicable nil))))
                                           req-arg-classes specializers)
                                     (when (and applicable unknown)
                                       (return-from compute-applicable-methods-using-classes-<generic-function>
                                         (values nil nil)))
                                     applicable))
                               (the list methods)))
          ;; 2. Sort the applicable methods by precedence order:
          (values (sort-applicable-methods methods req-arg-classes (safe-gf-argorder gf) gf) t))
        (error (TEXT "~S: ~S has ~S required argument~:P, but ~S classes were passed to ~S: ~S")
               'compute-applicable-methods-using-classes gf req-num (length req-arg-classes)
               'compute-applicable-methods-using-classes req-arg-classes)))))

;; ----------------------------------------------------------------------------

;; compute-applicable-methods-for-set
;; is a generalization of compute-applicable-methods[-using-classes].
;; For each argument position you can specify a set of possible required
;; arguments through one of:
;;   (TYPEP class)          [covers direct and indirect instances of class],
;;   (INSTANCE-OF-P class)  [covers only direct instances of class],
;;   (EQL object)           [covers the given object only].
;; Returns 1. the list of applicable methods and 2. a certainty value.
(defun compute-applicable-methods-for-set (gf req-arg-specs)
  (unless (and (proper-list-p req-arg-specs)
               (every #'(lambda (x) (and (consp x) (memq (car x) '(TYPEP INSTANCE-OF-P EQL))))
                      req-arg-specs))
    (error (TEXT "~S: argument should be a proper list of specifiers, not ~S")
           'compute-applicable-methods-for-set req-arg-specs))
  (if (safe-gf-undeterminedp gf)
    ;; gf has uninitialized lambda-list, hence no methods.
    '()
    (let ((req-num (sig-req-num (safe-gf-signature gf))))
      (if (= (length req-arg-specs) req-num)
        ;; 0. Check the method specializers:
        (let ((methods (safe-gf-methods gf)))
          (dolist (method methods)
            (check-method-only-standard-specializers gf method
              'compute-applicable-methods-for-set))
          ;; 1. Select the applicable methods:
          (setq methods
                (remove-if-not #'(lambda (method)
                                   (let ((specializers (safe-method-specializers method gf))
                                         (applicable t) (unknown nil))
                                     (mapc #'(lambda (arg-spec specializer)
                                               (ecase (first arg-spec)
                                                 (TYPEP
                                                   (if (defined-class-p specializer)
                                                     ;; For class specializers,
                                                     ;; (typep arg specializer) is certainly true
                                                     ;; if the known class of arg is a subclass of
                                                     ;; the specializer. Otherwise unknown.
                                                     (unless (subclassp (second arg-spec) specializer)
                                                       (setq unknown t))
                                                     ;; For EQL specializers,
                                                     ;; (typep arg specializer) is certainly false
                                                     ;; if (eql-specializer-object specializer)
                                                     ;; doesn't belong to the known class of arg.
                                                     ;; Otherwise unknown.
                                                     (if (typep (eql-specializer-object specializer) (second arg-spec))
                                                       (setq unknown t)
                                                       (setq applicable nil))))
                                                 (INSTANCE-OF-P ; see ...-using-classes
                                                   (if (defined-class-p specializer)
                                                     ;; For class specializers,
                                                     ;; (typep arg specializer) is equivalent to
                                                     ;; (subtypep (class-of arg) specializer).
                                                     (unless (subclassp (second arg-spec) specializer)
                                                       (setq applicable nil))
                                                     ;; For EQL specializers,
                                                     ;; (typep arg specializer) is certainly false
                                                     ;; if (class-of arg) and (class-of (eql-specializer-object specializer))
                                                     ;; differ. Otherwise unknown.
                                                     (if (eq (second arg-spec) (class-of (eql-specializer-object specializer)))
                                                       (setq unknown t)
                                                       (setq applicable nil))))
                                                 (EQL ; see method-applicable-p
                                                   (unless (typep (second arg-spec) specializer)
                                                     (setq applicable nil)))))
                                           req-arg-specs specializers)
                                     (when (and applicable unknown)
                                       (return-from compute-applicable-methods-for-set
                                         (values nil nil)))
                                     applicable))
                               (the list methods)))
          ;; 2. Sort the applicable methods by precedence order:
          (let ((argument-order (safe-gf-argorder gf)))
            (values
              (sort (copy-list methods)
                    #'(lambda (method1 method2) ; method1 < method2 ?
                        (let ((specializers1 (safe-method-specializers method1 gf))
                              (specializers2 (safe-method-specializers method2 gf)))
                          (dolist (arg-index argument-order nil)
                            (let ((arg-spec (nth arg-index req-arg-specs))
                                  (psp1 (nth arg-index specializers1))
                                  (psp2 (nth arg-index specializers2)))
                              (if (eql-specializer-p psp1)
                                (if (eql-specializer-p psp2)
                                  nil         ; (EQL x) = (EQL x)
                                  (return t)) ; (EQL x) < <class>  ==>  method1 < method2
                                (if (eql-specializer-p psp2)
                                  (return nil) ; <class> > (EQL x)   ==>  method1 > method2
                                  ;; two classes: compare the position in the CPL of
                                  ;; the arg's class, if known:
                                  (unless (eq psp1 psp2)
                                    (cond ((eq psp2 <t>) (return t)) ; method1 < method2
                                          ((eq psp1 <t>) (return nil)) ; method1 > method2
                                          (t (let* ((arg-class
                                                      (ecase (first arg-spec)
                                                        (TYPEP
                                                          ; The precise arg-class is unknown.
                                                          (return-from compute-applicable-methods-for-set
                                                            (values nil nil)))
                                                        (INSTANCE-OF-P (second arg-spec))
                                                        (EQL (class-of (second arg-spec)))))
                                                    (cpl (class-precedence-list arg-class))
                                                    (pos1 (position psp1 cpl))
                                                    (pos2 (position psp2 cpl)))
                                               (cond ((< pos1 pos2) (return t)) ; method1 < method2
                                                     ((> pos1 pos2) (return nil)) ; method1 > method2
                                                     ))))))))))))
              t)))
        (error (TEXT "~S: ~S has ~S required argument~:P")
               'compute-applicable-methods-for-set gf req-num)))))

;; ----------------------------------------------------------------------------

;; There's no real reason for checking the method specializers in
;; compute-applicable-methods, rather than in
;; compute-effective-method-as-function, but that's how the MOP specifies it.
(defun check-method-only-standard-specializers (gf method caller)
  (dolist (spec (safe-method-specializers method gf))
    (unless (or (defined-class-p spec) (typep-class spec <eql-specializer>))
      (error (TEXT "~S: Invalid method specializer ~S on ~S in ~S")
        caller spec method gf))))

;; ================ Combination of Applicable Methods, Part 1 ================

(defun gf-keyword-arguments (restp signature methods)
  ;; CLtL2 28.1.6.4., 28.1.6.5., ANSI CL 7.6.4., 7.6.5.
  ;; Keyword Arguments in Generic Functions
  (when restp
    ;; The generic function has &REST or &KEY, thus try all methods.
    ;; "If the lambda-list of ... the generic function definition
    ;;  contains &allow-other-keys, all keyword arguments are accepted."
    (unless (sig-allow-p signature)
      ;; "The specific set of keyword arguments accepted ...
      ;;  varies according to the applicable methods."
      (let ((signatures (mapcar #'method-signature methods)))
        ;; "A method that has &rest but not &key does not affect the
        ;;   set of acceptable keyword arguments."
        (setq signatures (delete-if-not #'sig-keys-p signatures))
        ;; No &key in the generic function, and no method with &key ==>
        ;; no restriction on the arguments.
        (when (or (sig-keys-p signature) signatures)
          ;; "If the lambda-list of any applicable method ... contains
          ;;  &allow-other-keys, all keyword arguments are accepted."
          (unless (some #'sig-allow-p signatures)
            ;; "The set of keyword arguments accepted for a
            ;;  particular call is the union of the keyword
            ;;  arguments accepted by all applicable methods and
            ;;  the keyword arguments mentioned after &key in the
            ;;  generic function definition."
            (let* ((keywords
                    (remove-duplicates
                     (append (sig-keywords signature)
                             (mapcap #'sig-keywords signatures))
                     :from-end t))
                   (opt-vars (gensym-list (sig-opt-num signature)))
                   (key-vars (gensym-list keywords))
                   (lambdalist-keypart
                     `(&KEY    ; lambdalist-keypart
                       ,@(mapcar #'(lambda (kw var) `((,kw ,var)))
                                 keywords key-vars))))
              (values opt-vars key-vars lambdalist-keypart))))))))

;; ================ Combination of Applicable Methods, Part 2 ================

;; is in the file clos-methcomb2.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-genfun2a.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-genfun1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP: Generic Functions
;;;; Bruno Haible 21.8.1993 - 2004
;;;; Sam Steingold 1998 - 2004, 2007, 2017
;;;; German comments translated into English: Stefan Kain 2002-04-08

(in-package "CLOS")


;; ============================================================================

(defparameter <funcallable-standard-class>
  (defclass funcallable-standard-class (semi-standard-class)
    ()
    (:fixed-slot-locations t)))
(defparameter *<funcallable-standard-class>-class-version*
  (class-current-version <funcallable-standard-class>))

(defconstant *<funcallable-standard-class>-instance-size* 28)

;; For DEFCLASS macro expansions.
(defconstant *<funcallable-standard-class>-valid-initialization-keywords* ; ABI
             *<standard-class>-valid-initialization-keywords*)

(defun make-instance-<funcallable-standard-class> (metaclass &rest args
                                                   &key name
                                                        (direct-superclasses '())
                                                        (direct-slots '())
                                                        (direct-default-initargs '())
                                                   &allow-other-keys)
  ;; metaclass = <funcallable-standard-class>
  ;; Don't add functionality here! This is a preliminary definition that is
  ;; replaced with #'make-instance later.
  (declare (ignore metaclass name direct-superclasses direct-slots
                   direct-default-initargs))
  (let ((class (allocate-metaobject-instance *<funcallable-standard-class>-class-version*
                                             *<funcallable-standard-class>-instance-size*)))
    (apply #'initialize-instance-<funcallable-standard-class> class args)))

(defun initialize-instance-<funcallable-standard-class> (class &rest args
                                                         &key &allow-other-keys)
  ;; Don't add functionality here! This is a preliminary definition that is
  ;; replaced with #'initialize-instance later.
  (apply #'shared-initialize-<funcallable-standard-class> class 't args)
  (install-class-direct-accessors class)
  class)

(defun shared-initialize-<funcallable-standard-class> (class situation &rest args
                                                       &key (direct-superclasses '() direct-superclasses-p)
                                                            ((:direct-slots direct-slots-as-lists) '() direct-slots-as-lists-p)
                                                            ((direct-slots direct-slots-as-metaobjects) '() direct-slots-as-metaobjects-p)
                                                            (direct-default-initargs '() direct-default-initargs-p)
                                                            (documentation nil documentation-p)
                                                            (generic-accessors t generic-accessors-p)
                                                            (fixed-slot-locations nil fixed-slot-locations-p)
                                                       &allow-other-keys)
  (declare (ignore direct-superclasses direct-superclasses-p
                   direct-slots-as-lists direct-slots-as-lists-p
                   direct-slots-as-metaobjects direct-slots-as-metaobjects-p
                   direct-default-initargs direct-default-initargs-p
                   documentation documentation-p generic-accessors
                   generic-accessors-p fixed-slot-locations
                   fixed-slot-locations-p))
  (apply #'shared-initialize-<semi-standard-class> class situation args)
  class)

;; ----------------------------------------------------------------------------

;; Low-level representation of funcallable instances:
;; Funcallable instances are Closures with a certain bit set in the
;; closure_flags. They always the following shape:
;; - recdata[0] = clos_name_or_class_version is a semi-class-version,
;;   like for instances,
;; - recdata[1] = clos_codevec is a simple-8bit-vector, like for compiled
;;   functions,
;; - recdata[2] = clos_venv is reserved,
;; - recdata[3] is the first slot, the name,
;; - then come additional slots, as described by the class.

(defparameter <funcallable-standard-object>
  (ext:compiler-let ((*allow-mixing-metaclasses* t))
    (let ((*allow-mixing-metaclasses* t))
      (defclass funcallable-standard-object (function standard-object)
        ;; The MOP p. 7 specifies a superclass list (standard-object function),
        ;; but then generic-function and standard-generic-function would have a
        ;; class-precedence-list that contains standard-object before function,
        ;; which contradicts the last sentence of ANSI CL 4.2.2. Possible
        ;; workarounds are: 1. reversed order (function standard-object),
        ;; 2. use a twin superclass or subclass of standard-object instead of
        ;; standard-object itself, 3. override compute-class-precedence-list
        ;; for this class. We choose solution 1 because it is the one a user
        ;; will most easily understand.
        (($name ; The function name is present as first CLOS slot. The macro
                ; Closure_name in lispbibl.d refers to it. Therefore this slot
                ; must not be changed after initialization, since this could
                ; interfere with the forwarded-instance mechanism.
           :accessor funcallable-name))
        (:metaclass funcallable-standard-class)
        (:fixed-slot-locations t)
        (:generic-accessors nil)))))

(defun print-object-<funcallable-standard-object> (object stream)
  (print-unreadable-object (object stream :type t)
    (write (funcallable-name object) :stream stream)))

;; Preliminary.
;; Now we can at least print classes and generic-functions.
(predefun print-object (object stream)
  (cond ((potential-class-p object) (format stream "#<CLASS ~S>" (class-classname object)))
        ((funcallable-instance-p object) (print-object-<funcallable-standard-object> object stream))
        (t (write-string "#<UNKNOWN>" stream))))

;; ============================================================================

;; low-level-representation:
;; Compiled functions (Cclosures), for which a certain bit is set in
;; the flag-byte of the code-vector.

;; The compiler uses (at GENERIC-FLET, GENERIC-LABELS) and the evaluator
;; presupposes likewise, that a generic function does not change its
;; calling convention.
;; A generic function with signature (reqnum optnum restp keywords allowp)
;; is from the very beginning (!) a compiled function with
;;         reqnum  required parameters
;;         0       optional parameters
;;         &rest if and only if (or (> optnum 0) restp),
;;         without &key.
(defun callinfo (reqnum optnum restp keywords allowp)
  (declare (ignore keywords allowp))
  (list reqnum 0 (or (> optnum 0) restp) nil nil nil))

;; ----------------------------------------------------------------------------

(defparameter <generic-function>
  (defclass generic-function (metaobject funcallable-standard-object)
    (($listeners          ; list of objects to be notified upon a change
       :type list
       :accessor gf-listeners)
     ($dynamically-modifiable   ; signal gf-already-called-warning?
      :type boolean
      :accessor gf-dynamically-modifiable))
    (:metaclass funcallable-standard-class)
    (:fixed-slot-locations t)
    (:generic-accessors nil)))

;; Initialization of a <generic-function> instance.
(defun shared-initialize-<generic-function> (gf situation &rest args
                                             &key (name nil name-p)
                                             &allow-other-keys)
  (when *classes-finished*
    (apply #'%shared-initialize gf situation args)) ; == (call-next-method)
  (when (or (eq situation 't) name-p)
    (setf (funcallable-name gf) name))
  (when (eq situation 't)
    (setf (gf-listeners gf) nil))
  gf)

;; ----------------------------------------------------------------------------

(defparameter <standard-generic-function>
  (defclass standard-generic-function (generic-function)
    (($signature           ; a signature struct
       :type (simple-vector 6)
       :accessor std-gf-signature)
     ($argorder            ; the argument-precedence-order, as a list of
                           ; numbers from 0 to reqnum-1,
       :type list
       :accessor std-gf-argorder)
     ($methods             ; the list of all methods
       :type list
       :accessor std-gf-methods)
     ($method-combination  ; a method-combination object
       :type method-combination
       :accessor std-gf-method-combination)
     ($default-method-class ; default class for newly added methods
       :type class
       :accessor std-gf-default-method-class)
     ($lambda-list         ; a redundant non-canonical encoding of the
                           ; signature
       :type list
       :accessor std-gf-lambda-list)
     ($documentation
       :type (or null string)
       :accessor std-gf-documentation)
     ($declspecs           ; a list of declaration-specifiers
       :type list
       :accessor std-gf-declspecs)
     ($effective-method-cache ; an alist mapping a list of methods to the
                           ; effective method as function
       :type list
       :accessor std-gf-effective-method-cache)
     ($initialized         ; true if an instance has already been created
       :type boolean
       :accessor std-gf-initialized))
    (:metaclass funcallable-standard-class)
    (:fixed-slot-locations t)
    (:generic-accessors nil)))

(defun std-gf-undeterminedp (gf) (eq (sys::%unbound) (std-gf-signature gf)))

;; Preliminary.
;; During bootstrapping, only <standard-generic-function> instances are used.
(predefun generic-function-methods (gf)
  (std-gf-methods gf))
(predefun generic-function-method-class (gf)
  (std-gf-default-method-class gf))
(predefun generic-function-signature (gf)
  (std-gf-signature gf))
(predefun generic-function-undeterminedp (gf)
  (std-gf-undeterminedp gf))
(predefun generic-function-method-combination (gf)
  (std-gf-method-combination gf))
(predefun generic-function-argorder (gf)
  (std-gf-argorder gf))
(predefun generic-function-declarations (gf)
  (std-gf-declspecs gf))

;; ============================================================================
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-genfun1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-dependent.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP
;;;; Dependent Protocol
;;;; Bruno Haible 2004-07-29
;;;; Sam Steingold 2017

(in-package "CLOS")

;; ----------------------------------------------------------------------------

;; MOP p. 30
(defgeneric add-dependent (metaobject dependent)
  (declare (dynamically-modifiable))
  (:method ((metaobject defined-class) dependent)
    (pushnew dependent (class-listeners metaobject) :test #'eq))
  (:method ((metaobject generic-function) dependent)
    (pushnew dependent (gf-listeners metaobject) :test #'eq)))

;; MOP p. 87
(defgeneric remove-dependent (metaobject dependent)
  (declare (dynamically-modifiable))
  (:method ((metaobject defined-class) dependent)
    (setf (class-listeners metaobject)
          (delete dependent (the list (class-listeners metaobject)) :test #'eq)))
  (:method ((metaobject generic-function) dependent)
    (setf (gf-listeners metaobject)
          (delete dependent (the list (gf-listeners metaobject)) :test #'eq))))

;; MOP p. 73
(defgeneric map-dependents (metaobject function)
  (declare (dynamically-modifiable))
  (:method ((metaobject defined-class) function)
    (map-dependents-<defined-class> metaobject function))
  (:method ((metaobject generic-function) function)
    (map-dependents-<generic-function> metaobject function)))

;; MOP p. 101
(defgeneric update-dependent (metaobject dependent &rest initargs))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-dependent.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-custom.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP: Customizable variables
;;;; Bruno Haible 2004

(in-package "EXT")

(progn
  (export #1='(custom::*strict-mop*
               custom::*forward-referenced-class-misdesign*)
              "CUSTOM")
  (export #1# "EXT"))

(in-package "CLOS")

;; ============================================================================

(define-symbol-macro custom:*forward-referenced-class-misdesign*
                     (<forward-referenced-class>-under-<class>))

(defvar *<forward-referenced-class>-under-<class>* nil)

(defun <forward-referenced-class>-under-<class> ()
  *<forward-referenced-class>-under-<class>*)

(defun (setf <forward-referenced-class>-under-<class>) (val)
  (when val (setq val 't))
  (if val
    (unless (eq (find-class 'class) <potential-class>)
      (set-<class>-<potential-class>)
      (set-<forward-referenced-class>-<misdesigned-forward-referenced-class>))
    (unless (eq (find-class 'class) <defined-class>)
      (set-<class>-<defined-class>)
      (set-<forward-referenced-class>-<forward-reference-to-class>)))
  (setq *<forward-referenced-class>-under-<class>* val)
  val)

(defun set-<class>-<potential-class> ()
  (ext:without-package-lock ("CLOS")
    (setf (class-classname <defined-class>) 'defined-class)
    (setf (class-classname <potential-class>) 'class)
    (setf (find-class 'class) <potential-class>)
    (setf (get 'class 'sys::type-symbol) (get 'potential-class 'sys::type-symbol))))

(defun set-<class>-<defined-class> ()
  (ext:without-package-lock ("CLOS")
    (setf (class-classname <potential-class>) 'potential-class)
    (setf (class-classname <defined-class>) 'class)
    (setf (find-class 'class) <defined-class>)
    (setf (get 'class 'sys::type-symbol) (get 'defined-class 'sys::type-symbol))))

(defun set-<forward-referenced-class>-<misdesigned-forward-referenced-class> ()
  (ext:without-package-lock ("CLOS")
    (setf (class-classname <forward-reference-to-class>) 'forward-reference-to-class)
    (setf (class-classname <misdesigned-forward-referenced-class>) 'forward-referenced-class)
    (setf (find-class 'forward-referenced-class) <misdesigned-forward-referenced-class>)))

(defun set-<forward-referenced-class>-<forward-reference-to-class> ()
  (ext:without-package-lock ("CLOS")
    (setf (class-classname <misdesigned-forward-referenced-class>) 'misdesigned-forward-referenced-class)
    (setf (class-classname <forward-reference-to-class>) 'forward-referenced-class)
    (setf (find-class 'forward-referenced-class) <forward-reference-to-class>)))

; Initial setting:
(set-<class>-<defined-class>)
(set-<forward-referenced-class>-<forward-reference-to-class>)

;; ============================================================================

(define-symbol-macro custom:*strict-mop* (strict-mop))

(defvar *strict-mop* nil)

(defun strict-mop ()
  *strict-mop*)

(defun (setf strict-mop) (val)
  (when val (setq val 't))
  (setf custom:*forward-referenced-class-misdesign* val)
  (setq *strict-mop* val)
  val)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-custom.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-class6.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP
;;;; Class metaobjects
;;;; Part n-1: Generic functions specified in the MOP.
;;;; Bruno Haible 2004-05-25
;;;; Sam Steingold 2005-2008, 2017

(in-package "CLOS")

;;; ===========================================================================

;; Make creation of <defined-class> instances customizable.

;; Installing the accessor methods can only be done after a class has been
;; initialized, but must be done in a _primary_ initialize-instance method,
;; so that it doesn't interfere with :after/:around methods that a user could
;; install. See MOP p. 60.
(defmethod initialize-instance ((class defined-class) &rest args)
  (declare (ignore args))
  (call-next-method) ; == (apply #'shared-initialize class 't args)
  (install-class-direct-accessors class)
  class)

(defmethod initialize-instance ((class structure-class) &rest args
                                &key ((defclass-form defclass-form))
                                &allow-other-keys)
  (if (eq defclass-form 'defstruct) ; called from DEFINE-STRUCTURE-CLASS
      ;; we do not (CALL-NEXT-METHOD) because the
      ;; INITIALIZE-INSTANCE@DEFINED-CLASS method calls
      ;; INSTALL-CLASS-DIRECT-ACCESSORS which installs slot accessors
      ;; immediately overwritten by the accessors defined by DEFSTRUCT
      (apply #'shared-initialize class 't args)
      (call-next-method))       ; initialize-instance@defined-class
  class)

(setf (fdefinition 'initialize-instance-<built-in-class>) #'initialize-instance)
(setf (fdefinition 'make-instance-<built-in-class>) #'make-instance)
(setf (fdefinition 'initialize-instance-<structure-class>) #'initialize-instance)
(setf (fdefinition 'make-instance-<structure-class>) #'make-instance)
(setf (fdefinition 'initialize-instance-<standard-class>) #'initialize-instance)
(setf (fdefinition 'make-instance-<standard-class>) #'make-instance)
(setf (fdefinition 'initialize-instance-<funcallable-standard-class>) #'initialize-instance)
(setf (fdefinition 'make-instance-<funcallable-standard-class>) #'make-instance)

;;; ===========================================================================

;;; Optimized class-xxx accessors.
;;; These are possible thanks to the :fixed-slot-locations class option.

(defun check-class-initialized (class level)
  (unless (>= (class-initialized class) level)
    (error (TEXT "The class ~S has not yet been initialized.")
           class)))

(defun check-class-finalized (class level)
  (check-class-initialized class 2)
  (unless (>= (class-initialized class) level)
    (error (TEXT "The class ~S has not yet been finalized.")
           class)))

;; Not in MOP.
(defun class-classname (class)
  (accessor-typecheck class 'potential-class 'class-classname)
  (sys::%record-ref class *<potential-class>-classname-location*))
(defun (setf class-classname) (new-value class)
  (accessor-typecheck class 'potential-class '(setf class-classname))
  (setf (sys::%record-ref class *<potential-class>-classname-location*) new-value))
;; MOP p. 76
(defgeneric class-name (class)
  (declare (dynamically-modifiable))
  (:method ((class defined-class))
    (check-class-initialized class 1)
    (class-classname class))
  (:method ((class forward-reference-to-class))
    (slot-value class '$classname)))
; No extended method check because this GF is specified in ANSI CL.
;(initialize-extended-method-check #'class-name)
;; MOP p. 92
(defgeneric (setf class-name) (new-value class)
  (declare (dynamically-modifiable))
  (:method (new-value (class potential-class))
    (unless (symbolp new-value)
      (error-of-type 'type-error
        :datum new-value :expected-type 'symbol
        (TEXT "~S: The name of a class must be a symbol, not ~S")
        '(setf class-name) new-value))
    (when (built-in-class-p class)
      (error-of-type 'error
        (TEXT "~S: The name of the built-in class ~S cannot be modified")
        '(setf class-name) class))
    (reinitialize-instance class :name new-value)
    new-value))
(initialize-extended-method-check #'(setf class-name))

;; Not in MOP.
(defun class-direct-subclasses-table (class)
  (accessor-typecheck class 'super-class 'class-direct-subclasses-table)
  (if (potential-class-p class)
    (sys::%record-ref class *<potential-class>-direct-subclasses-location*)
    (slot-value class '$direct-subclasses)))
(defun (setf class-direct-subclasses-table) (new-value class)
  (accessor-typecheck class 'super-class '(setf class-direct-subclasses-table))
  (if (potential-class-p class)
    (setf (sys::%record-ref class *<potential-class>-direct-subclasses-location*) new-value)
    (setf (slot-value class '$direct-subclasses) new-value)))
;; MOP p. 76
(defgeneric class-direct-subclasses (class)
  (declare (dynamically-modifiable))
  (:method ((class defined-class))
    (check-class-initialized class 2)
    (list-direct-subclasses class))
  (:method ((class forward-reference-to-class))
    (list-direct-subclasses class)))

(defun class-not-yet-defined (method class)
  (clos-warning (TEXT "~S being called on ~S, but class ~S is not yet defined.")
    method class (class-name class)))

;; MOP p. 76
(defgeneric class-direct-superclasses (class)
  (declare (dynamically-modifiable))
  (:method ((class defined-class))
    (check-class-initialized class 2)
    (sys::%record-ref class *<defined-class>-direct-superclasses-location*))
  (:method ((class forward-reference-to-class))
    ;; Broken MOP. Any use of this method is a bug.
    (class-not-yet-defined 'class-direct-superclasses class)
    '()))
(initialize-extended-method-check #'class-direct-superclasses)
;; Not in MOP.
(defun (setf class-direct-superclasses) (new-value class)
  (accessor-typecheck class 'defined-class '(setf class-direct-superclasses))
  (setf (sys::%record-ref class *<defined-class>-direct-superclasses-location*) new-value))

;; Not in MOP.
(defun class-all-superclasses (class)
  (accessor-typecheck class 'defined-class 'class-all-superclasses)
  (sys::%record-ref class *<defined-class>-all-superclasses-location*))
(defun (setf class-all-superclasses) (new-value class)
  (accessor-typecheck class 'defined-class '(setf class-all-superclasses))
  (setf (sys::%record-ref class *<defined-class>-all-superclasses-location*) new-value))

;; MOP p. 76
(defgeneric class-precedence-list (class)
  (:method ((class defined-class))
    (check-class-finalized class 3)
    (sys::%record-ref class *<defined-class>-precedence-list-location*)))
(initialize-extended-method-check #'class-precedence-list)
;; Not in MOP.
(defun (setf class-precedence-list) (new-value class)
  (accessor-typecheck class 'defined-class '(setf class-precedence-list))
  (setf (sys::%record-ref class *<defined-class>-precedence-list-location*) new-value))

;; MOP p. 75
(defgeneric class-direct-slots (class)
  (:method ((class defined-class))
    (check-class-initialized class 2)
    (sys::%record-ref class *<defined-class>-direct-slots-location*))
  (:method ((class forward-reference-to-class))
    ;; Broken MOP. Any use of this method is a bug.
    (class-not-yet-defined 'class-direct-slots class)
    '()))
(initialize-extended-method-check #'class-direct-slots)
;; Not in MOP.
(defun (setf class-direct-slots) (new-value class)
  (accessor-typecheck class 'defined-class '(setf class-direct-slots))
  (setf (sys::%record-ref class *<defined-class>-direct-slots-location*) new-value))

;; MOP p. 77
(defgeneric class-slots (class)
  (:method ((class defined-class))
    (check-class-finalized class 5)
    (sys::%record-ref class *<defined-class>-slots-location*)))
(initialize-extended-method-check #'class-slots)
;; Not in MOP.
(defun (setf class-slots) (new-value class)
  (accessor-typecheck class 'defined-class '(setf class-slots))
  (setf (sys::%record-ref class *<defined-class>-slots-location*) new-value))

;; Not in MOP.
(defun class-slot-location-table (class)
  (accessor-typecheck class 'defined-class 'class-slot-location-table)
  (sys::%record-ref class *<defined-class>-slot-location-table-location*))
(defun (setf class-slot-location-table) (new-value class)
  (accessor-typecheck class 'defined-class '(setf class-slot-location-table))
  (setf (sys::%record-ref class *<defined-class>-slot-location-table-location*) new-value))

;; MOP p. 75
(defgeneric class-direct-default-initargs (class)
  (:method ((class defined-class))
    (check-class-initialized class 2)
    (sys::%record-ref class *<defined-class>-direct-default-initargs-location*))
  (:method ((class forward-reference-to-class))
    ;; Broken MOP. Any use of this method is a bug.
    (class-not-yet-defined 'class-direct-default-initargs class)
    '()))
(initialize-extended-method-check #'class-direct-default-initargs)
;; Not in MOP.
(defun (setf class-direct-default-initargs) (new-value class)
  (accessor-typecheck class 'defined-class '(setf class-direct-default-initargs))
  (setf (sys::%record-ref class *<defined-class>-direct-default-initargs-location*) new-value))

;; MOP p. 75
(defgeneric class-default-initargs (class)
  (:method ((class defined-class))
    (check-class-finalized class 6)
    (sys::%record-ref class *<defined-class>-default-initargs-location*)))
(initialize-extended-method-check #'class-default-initargs)
;; Not in MOP.
(defun (setf class-default-initargs) (new-value class)
  (accessor-typecheck class 'defined-class '(setf class-default-initargs))
  (setf (sys::%record-ref class *<defined-class>-default-initargs-location*) new-value))

;; Not in MOP.
(defun class-documentation (class)
  (accessor-typecheck class 'defined-class 'class-documentation)
  (sys::%record-ref class *<defined-class>-documentation-location*))
(defun (setf class-documentation) (new-value class)
  (accessor-typecheck class 'defined-class '(setf class-documentation))
  (setf (sys::%record-ref class *<defined-class>-documentation-location*) new-value))

;; Not in MOP.
(defun class-listeners (class)
  (accessor-typecheck class 'defined-class 'class-listeners)
  (sys::%record-ref class *<defined-class>-listeners-location*))
(defun (setf class-listeners) (new-value class)
  (accessor-typecheck class 'defined-class '(setf class-listeners))
  (setf (sys::%record-ref class *<defined-class>-listeners-location*) new-value))

;; Not in MOP.
(defun class-initialized (class)
  (accessor-typecheck class 'defined-class 'class-initialized)
  (sys::%record-ref class *<defined-class>-initialized-location*))
(defun (setf class-initialized) (new-value class)
  (accessor-typecheck class 'defined-class '(setf class-initialized))
  (setf (sys::%record-ref class *<defined-class>-initialized-location*) new-value))

;; Not in MOP.
(defun class-subclass-of-stablehash-p (class)
  (accessor-typecheck class 'slotted-class 'class-subclass-of-stablehash-p)
  (sys::%record-ref class *<slotted-class>-subclass-of-stablehash-p-location*))
(defun (setf class-subclass-of-stablehash-p) (new-value class)
  (accessor-typecheck class 'slotted-class '(setf class-subclass-of-stablehash-p))
  (setf (sys::%record-ref class *<slotted-class>-subclass-of-stablehash-p-location*) new-value))

;; Not in MOP.
(defun class-generic-accessors (class)
  (accessor-typecheck class 'slotted-class 'class-generic-accessors)
  (sys::%record-ref class *<slotted-class>-generic-accessors-location*))
(defun (setf class-generic-accessors) (new-value class)
  (accessor-typecheck class 'slotted-class '(setf class-generic-accessors))
  (setf (sys::%record-ref class *<slotted-class>-generic-accessors-location*) new-value))

;; Not in MOP.
(defun class-direct-accessors (class)
  (accessor-typecheck class 'slotted-class 'class-direct-accessors)
  (sys::%record-ref class *<slotted-class>-direct-accessors-location*))
(defun (setf class-direct-accessors) (new-value class)
  (accessor-typecheck class 'slotted-class '(setf class-direct-accessors))
  (setf (sys::%record-ref class *<slotted-class>-direct-accessors-location*) new-value))

;; Not in MOP.
(defun class-valid-initargs-from-slots (class)
  (accessor-typecheck class 'slotted-class 'class-valid-initargs-from-slots)
  (sys::%record-ref class *<slotted-class>-valid-initargs-from-slots-location*))
(defun (setf class-valid-initargs-from-slots) (new-value class)
  (accessor-typecheck class 'slotted-class '(setf class-valid-initargs-from-slots))
  ;; When the valid-initargs-from-slots change, the result of
  ;; (valid-initarg-keywords class ...) changes, therefore we need to invalidate
  ;; all the caches that use valid-initarg-keywords:
  (when (or (eq (sys::%unbound) (sys::%record-ref class *<slotted-class>-valid-initargs-from-slots-location*))
            (set-exclusive-or (sys::%record-ref class *<slotted-class>-valid-initargs-from-slots-location*) new-value))
    (remhash class *make-instance-table*)
    (remhash class *reinitialize-instance-table*)
    (remhash class *update-instance-for-redefined-class-table*)
    (remhash class *update-instance-for-different-class-table*))
  (setf (sys::%record-ref class *<slotted-class>-valid-initargs-from-slots-location*) new-value))

;; Not in MOP.
(defun class-instance-size (class)
  (accessor-typecheck class 'slotted-class 'class-instance-size)
  (sys::%record-ref class *<slotted-class>-instance-size-location*))
(defun (setf class-instance-size) (new-value class)
  (accessor-typecheck class 'slotted-class '(setf class-instance-size))
  (setf (sys::%record-ref class *<slotted-class>-instance-size-location*) new-value))

;; Not in MOP.
(defun class-names (class)
  (accessor-typecheck class 'structure-class 'class-names)
  (sys::%record-ref class *<structure-class>-names-location*))
(defun (setf class-names) (new-value class)
  (accessor-typecheck class 'structure-class '(setf class-names))
  (setf (sys::%record-ref class *<structure-class>-names-location*) new-value))

;; Not in MOP.
(defun class-kconstructor (class)
  (accessor-typecheck class 'structure-class 'class-kconstructor)
  (sys::%record-ref class *<structure-class>-kconstructor-location*))
(defun (setf class-kconstructor) (new-value class)
  (accessor-typecheck class 'structure-class '(setf class-kconstructor))
  (setf (sys::%record-ref class *<structure-class>-kconstructor-location*) new-value))

;; Not in MOP.
(defun class-boa-constructors (class)
  (accessor-typecheck class 'structure-class 'class-boa-constructors)
  (sys::%record-ref class *<structure-class>-boa-constructors-location*))
(defun (setf class-boa-constructors) (new-value class)
  (accessor-typecheck class 'structure-class '(setf class-boa-constructors))
  (setf (sys::%record-ref class *<structure-class>-boa-constructors-location*) new-value))

;; Not in MOP.
(defun class-copier (class)
  (accessor-typecheck class 'structure-class 'class-copier)
  (sys::%record-ref class *<structure-class>-copier-location*))
(defun (setf class-copier) (new-value class)
  (accessor-typecheck class 'structure-class '(setf class-copier))
  (setf (sys::%record-ref class *<structure-class>-copier-location*) new-value))

;; Not in MOP.
(defun class-predicate (class)
  (accessor-typecheck class 'structure-class 'class-predicate)
  (sys::%record-ref class *<structure-class>-predicate-location*))
(defun (setf class-predicate) (new-value class)
  (accessor-typecheck class 'structure-class '(setf class-predicate))
  (setf (sys::%record-ref class *<structure-class>-predicate-location*) new-value))

;; Not in MOP.
(defun class-current-version (class)
  (accessor-typecheck class 'semi-standard-class 'class-current-version)
  (sys::%record-ref class *<semi-standard-class>-current-version-location*))
(defun (setf class-current-version) (new-value class)
  (accessor-typecheck class 'semi-standard-class '(setf class-current-version))
  (setf (sys::%record-ref class *<semi-standard-class>-current-version-location*) new-value))

;; Not in MOP.
(defun class-funcallablep (class)
  (accessor-typecheck class 'semi-standard-class 'class-funcallablep)
  (sys::%record-ref class *<semi-standard-class>-funcallablep-location*))
(defun (setf class-funcallablep) (new-value class)
  (accessor-typecheck class 'semi-standard-class '(setf class-funcallablep))
  (setf (sys::%record-ref class *<semi-standard-class>-funcallablep-location*) new-value))

;; Not in MOP.
(defun class-fixed-slot-locations (class)
  (accessor-typecheck class 'semi-standard-class 'class-fixed-slot-locations)
  (sys::%record-ref class *<semi-standard-class>-fixed-slot-locations-location*))
(defun (setf class-fixed-slot-locations) (new-value class)
  (accessor-typecheck class 'semi-standard-class '(setf class-fixed-slot-locations))
  (setf (sys::%record-ref class *<semi-standard-class>-fixed-slot-locations-location*) new-value))

;; Not in MOP.
(defun class-instantiated (class)
  (accessor-typecheck class 'semi-standard-class 'class-instantiated)
  (sys::%record-ref class *<semi-standard-class>-instantiated-location*))
(defun (setf class-instantiated) (new-value class)
  (accessor-typecheck class 'semi-standard-class '(setf class-instantiated))
  (setf (sys::%record-ref class *<semi-standard-class>-instantiated-location*) new-value))

;; Not in MOP.
(defun class-direct-instance-specializers-table (class)
  (accessor-typecheck class 'semi-standard-class 'class-direct-instance-specializers-table)
  (sys::%record-ref class *<semi-standard-class>-direct-instance-specializers-location*))
(defun (setf class-direct-instance-specializers-table) (new-value class)
  (accessor-typecheck class 'semi-standard-class '(setf class-direct-instance-specializers-table))
  (setf (sys::%record-ref class *<semi-standard-class>-direct-instance-specializers-location*) new-value))

;; Not in MOP.
(defun class-finalized-direct-subclasses-table (class)
  (accessor-typecheck class 'semi-standard-class 'class-finalized-direct-subclasses-table)
  (sys::%record-ref class *<semi-standard-class>-finalized-direct-subclasses-location*))
(defun (setf class-finalized-direct-subclasses-table) (new-value class)
  (accessor-typecheck class 'semi-standard-class '(setf class-finalized-direct-subclasses-table))
  (setf (sys::%record-ref class *<semi-standard-class>-finalized-direct-subclasses-location*) new-value))

;; MOP p. 77
(defgeneric class-prototype (class)
  (:method ((class semi-standard-class))
    (check-class-finalized class 6)
    (or (sys::%record-ref class *<semi-standard-class>-prototype-location*)
        (setf (sys::%record-ref class *<semi-standard-class>-prototype-location*)
              (let ((old-instantiated (class-instantiated class)))
                (prog1
                  (clos::%allocate-instance class)
                  ;; The allocation of the prototype doesn't need to flag the
                  ;; class as being instantiated, because 1. the prototype is
                  ;; thrown away when the class is redefined, 2. we don't want
                  ;; a redefinition with nonexistent or non-finalized
                  ;; superclasses to succeed despite of the prototype.
                  (setf (class-instantiated class) old-instantiated))))))
  (:method ((class built-in-class))
    (let ((prototype (sys::%record-ref class *<built-in-class>-prototype-location*)))
      (if (eq (sys::%unbound) prototype)
        (error (TEXT "~S: ~S is an abstract class and therefore does not have a direct instance")
               'class-prototype class)
        prototype)))
  ;; CLISP extension:
  (:method ((class structure-class))
    (or (sys::%record-ref class *<structure-class>-prototype-location*)
        (setf (sys::%record-ref class *<structure-class>-prototype-location*)
              (clos::%allocate-instance class)))))
(initialize-extended-method-check #'class-prototype)
;; Not in MOP.
(defun (setf class-prototype) (new-value class)
  (accessor-typecheck class 'semi-standard-class '(setf class-prototype))
  (setf (sys::%record-ref class *<semi-standard-class>-prototype-location*) new-value))

;;; ===========================================================================

;;; Class Specification Protocol

;; Not in MOP.
(defgeneric compute-direct-slot-definition-initargs (class &rest slot-spec)
  (declare (dynamically-modifiable))
  (:method ((class defined-class) &rest slot-spec)
    slot-spec))

;;; ===========================================================================

;;; Class Finalization Protocol

;; MOP p. 76
(defgeneric class-finalized-p (class)
  (:method ((class defined-class))
    (= (class-initialized class) 6))
  (:method ((class forward-reference-to-class))
    nil)
  ;; CLISP extension: Convenience method on symbols.
  (:method ((name symbol))
    (class-finalized-p (find-class name))))
(initialize-extended-method-check #'class-finalized-p)

;; MOP p. 54
(defgeneric finalize-inheritance (class)
  (:method ((class semi-standard-class))
    (finalize-inheritance-<semi-standard-class> class))
  ;; CLISP extension: No-op method on other classes.
  (:method ((class defined-class))
    class)
  ;; CLISP extension: Convenience method on symbols.
  (:method ((name symbol))
    (finalize-inheritance (find-class name))))
(initialize-extended-method-check #'finalize-inheritance)

;; MOP p. 38
(defgeneric compute-class-precedence-list (class)
  (declare (dynamically-modifiable))
  (:method ((class defined-class))
    (compute-class-precedence-list-<defined-class> class)))

;; Not in MOP.
(defgeneric compute-effective-slot-definition-initargs (class direct-slot-definitions)
  (declare (dynamically-modifiable))
  (:method ((class defined-class) direct-slot-definitions)
    (compute-effective-slot-definition-initargs-<defined-class> class direct-slot-definitions)))

;; MOP p. 42
(defgeneric compute-effective-slot-definition (class slotname direct-slot-definitions)
  (declare (dynamically-modifiable))
  (:method ((class defined-class) slotname direct-slot-definitions)
    (compute-effective-slot-definition-<defined-class> class slotname direct-slot-definitions)))

;; MOP p. 43
(defgeneric compute-slots (class)
  (declare (dynamically-modifiable))
  (:method ((class semi-standard-class))
    (compute-slots-<defined-class>-primary class))
  (:method :around ((class semi-standard-class))
    (compute-slots-<slotted-class>-around class
      #'(lambda (c) (call-next-method c)))))

;; MOP p. 39
(defgeneric compute-default-initargs (class)
  (declare (dynamically-modifiable))
  (:method ((class defined-class))
    (compute-default-initargs-<defined-class> class)))

;;; ===========================================================================

;;; Class definition customization

;; MOP p. 47
(defgeneric ensure-class-using-class (class name
                                      &key metaclass
                                           direct-superclasses
                                           direct-slots
                                           direct-default-initargs
                                           documentation
                                           ; CLISP specific extension:
                                           fixed-slot-locations
                                      &allow-other-keys)
  (declare (dynamically-modifiable))
  (:method ((class potential-class) name &rest args)
    (apply #'ensure-class-using-class-<t> class name args))
  (:method ((class null) name &rest args)
    (apply #'ensure-class-using-class-<t> class name args)))

;; MOP p. 102
(defgeneric validate-superclass (class superclass)
  (declare (dynamically-modifiable))
  (:method ((class potential-class) (superclass potential-class))
    (or (eq superclass <t>)
        (eq (class-of class) (class-of superclass))
        (and (eq (class-of class) <funcallable-standard-class>)
             (eq (class-of superclass) <standard-class>))
        ;; This makes no sense: If the superclass is a
        ;; funcallable-standard-class, it is a subclass of FUNCTION,
        ;; therefore class will become a subclass of FUNCTION too, but there
        ;; is no way to FUNCALL or APPLY it. Where did the MOP authors have
        ;; their brain here?
        (and (eq (class-of class) <standard-class>)
             (eq (class-of superclass) <funcallable-standard-class>))
        ;; Needed for clos-genfun1.lisp:
        (and (eq superclass <function>)
             (eq (class-classname class) 'funcallable-standard-object))
        ;; CLISP specific extension:
        (subclassp (class-of class) (class-of superclass)))))

;;; ===========================================================================

;;; Subclass relationship change notification

;; MOP p. 32
(defgeneric add-direct-subclass (class subclass)
  (declare (dynamically-modifiable))
  (:method ((class super-class) (subclass potential-class))
    (add-direct-subclass-internal class subclass)))

;; MOP p. 90
(defgeneric remove-direct-subclass (class subclass)
  (declare (dynamically-modifiable))
  (:method ((class super-class) (subclass potential-class))
    (remove-direct-subclass-internal class subclass)))

;;; ===========================================================================

;;; Accessor definition customization

;; MOP p. 86
(defgeneric reader-method-class (class direct-slot &rest initargs)
  (declare (dynamically-modifiable))
  (:method ((class defined-class) direct-slot &rest initargs)
    (declare (ignore direct-slot initargs))
    <standard-reader-method>))

;; MOP p. 103
(defgeneric writer-method-class (class direct-slot &rest initargs)
  (declare (dynamically-modifiable))
  (:method ((class defined-class) direct-slot &rest initargs)
    (declare (ignore direct-slot initargs))
    <standard-writer-method>))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-class6.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-class5.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP: Classes
;;;; Bruno Haible 21.8.1993 - 2004
;;;; Sam Steingold 1998 - 2004, 2009, 2017
;;;; German comments translated into English: Stefan Kain 2002-04-08

(in-package "CLOS")


;;; CLtL2 28.1.9., ANSI CL 7.1. Object Creation and Initialization

;; Cruel hack (CLtL2 28.1.9.2., ANSI CL 7.1.2.):
;; - MAKE-INSTANCE must be informed about the methods of ALLOCATE-INSTANCE,
;;   INITIALIZE-INSTANCE and SHARED-INITIALIZE.
;; - INITIALIZE-INSTANCE must be informed about the methods of
;;   INITIALIZE-INSTANCE and SHARED-INITIALIZE.
;; - REINITIALIZE-INSTANCE must be informed about the methods of
;;   REINITIALIZE-INSTANCE and SHARED-INITIALIZE.
;; - UPDATE-INSTANCE-FOR-REDEFINED-CLASS must be informed about the methods of
;;   UPDATE-INSTANCE-FOR-REDEFINED-CLASS and SHARED-INITIALIZE.
;; - UPDATE-INSTANCE-FOR-DIFFERENT-CLASS must be informed about the methods of
;;   UPDATE-INSTANCE-FOR-DIFFERENT-CLASS and SHARED-INITIALIZE.

(defparameter *make-instance-table*
  (make-hash-table :key-type 'defined-class :value-type '(simple-vector 4)
                   :test 'ext:stablehash-eq :warn-if-needs-rehash-after-gc t))
  ;; Hash table, mapping a class to a simple-vector containing
  ;; - a list of valid keyword arguments,
  ;; - the effective method of allocate-instance,
  ;; - the effective method of initialize-instance,
  ;; - the effective method of shared-initialize.

(defparameter *reinitialize-instance-table*
  (make-hash-table :key-type 'defined-class :value-type 'cons
                   :test 'ext:stablehash-eq :warn-if-needs-rehash-after-gc t))
  ;; Hash table, mapping a class to a cons containing
  ;; - a list of valid keyword arguments,
  ;; - the effective method of shared-initialize.

(defparameter *update-instance-for-redefined-class-table*
  (make-hash-table :key-type 'defined-class :value-type 'list
                   :test 'ext:stablehash-eq :warn-if-needs-rehash-after-gc t))
  ;; Hash table, mapping a class to
  ;; - a list of valid keyword arguments.

(defparameter *update-instance-for-different-class-table*
  (make-hash-table :key-type '(cons class class) :value-type 'list
                   :test 'ext:stablehash-equal :warn-if-needs-rehash-after-gc t))
  ;; Hash table, mapping a cons (old-class . new-class) to
  ;; - a list of valid keyword arguments.

;; FIXME: These tables must also be cleaned when a class is redefined
;; (because subclassp changes, and for *update-instance-for-redefined-class-table*
;; also because the class-slots change).

(defun note-i-change (specializer table)
  (maphash #'(lambda (class value) (declare (ignore value))
               (when (subclassp class specializer)
                 (remhash class table)))
           table))
(defun note-i-meta-change (meta-specializer table)
  (maphash #'(lambda (class value) (declare (ignore value))
               (when (typep-class class meta-specializer) ; <==> (typep class meta-specializer)
                 (remhash class table)))
           table))

(defun note-ai-change (method)
  (let ((specializer (first (method-specializers method))))
    (if (eql-specializer-p specializer)
      ;; EQL-method for ALLOCATE-INSTANCE:
      ;; object must be a class, else worthless.
      (let ((specialized-object (eql-specializer-object specializer)))
        (when (defined-class-p specialized-object)
          ;; Remove the entries from *make-instance-table* for which the
          ;; implied method might be applicable:
          (note-i-change specialized-object *make-instance-table*)))
      ;; remove the entries from *make-instance-table* for which the
      ;; implied method might be applicable:
      (note-i-meta-change specializer *make-instance-table*))))

(defun note-ii-change (method)
  (let ((specializer (first (method-specializers method))))
    ;; EQL-methods for INITIALIZE-INSTANCE are worthless in any case.
    (unless (eql-specializer-p specializer)
      ;; Remove the entries from *make-instance-table* for which the
      ;; implied method might be applicable:
      (note-i-change specializer *make-instance-table*))))

(defun note-ri-change (method)
  (let ((specializer (first (method-specializers method))))
    ;; EQL-methods for REINITIALIZE-INSTANCE are essentially worthless.
    (unless (eql-specializer-p specializer)
      ;; Remove the entries from *reinitialize-instance-table* for which the
      ;; implied method might be applicable:
      (note-i-change specializer *reinitialize-instance-table*))))

(defun note-uirc-change (method)
  (let ((specializer (first (method-specializers method))))
    ;; EQL-methods for UPDATE-INSTANCE-FOR-REDEFINED-CLASS are essentially
    ;; worthless.
    (unless (eql-specializer-p specializer)
      ;; Remove the entries from *update-instance-for-redefined-class-table*
      ;; for which the implied method might be applicable:
      (note-i-change specializer *update-instance-for-redefined-class-table*))))

(defun note-uidc-change (method)
  (let ((specializer1 (first (method-specializers method)))
        (specializer2 (second (method-specializers method))))
    ;; Methods for UPDATE-INSTANCE-FOR-DIFFERENT-CLASS with EQL specializer
    ;; in the first argument are essentially worthless.
    (unless (eql-specializer-p specializer1)
      ;; Methods for UPDATE-INSTANCE-FOR-DIFFERENT-CLASS with EQL specializer
      ;; in the second argument are worthless in any case.
      (unless (eql-specializer-p specializer2)
        ;; Remove the entries from *update-instance-for-different-class-table*
        ;; for which the implied method might be applicable:
        (let ((table *update-instance-for-different-class-table*))
          (maphash #'(lambda (classes value) (declare (ignore value))
                       (let ((class1 (car classes))
                             (class2 (cdr classes)))
                         (when (and (subclassp class1 specializer1)
                                    (subclassp class2 specializer2))
                           (remhash classes table))))
                   table))))))

(defun note-si-change (method)
  (let* ((specializers (method-specializers method))
         (specializer1 (first specializers))
         (specializer2 (second specializers)))
    ;; EQL-methods for SHARED-INITIALIZE are essentially worthless.
    (unless (eql-specializer-p specializer1)
      ;; As second argument, INITIALIZE-INSTANCE passes always T .
      (when (typep 'T specializer2)
        ;; Remove the entries from *make-instance-table* for which the
        ;; implied method might be applicable:
        (note-i-change specializer1 *make-instance-table*))
      ;; As second argument, REINITIALIZE-INSTANCE passes always NIL .
      (when (typep 'NIL specializer2)
        ;; Remove the entries from *reinitialize-instance-table* for which the
        ;; implied method might be applicable:
        (note-i-change specializer1 *reinitialize-instance-table*))
      ;; Remove the entries from *update-instance-for-redefined-class-table*
      ;; for which the implied method might be applicable:
      (note-i-change specializer1 *reinitialize-instance-table*)
      ;; Remove the entries from *update-instance-for-different-class-table*
      ;; for which the implied method might be applicable:
      (let ((table *update-instance-for-different-class-table*))
        (maphash #'(lambda (classes value) (declare (ignore value))
                     (let ((class2 (cdr classes)))
                       (when (subclassp class2 specializer1)
                         (remhash classes table))))
                 table)))))

;;; collect all keywords from a list of applicable methods
(defun valid-initarg-keywords (class methods)
  (let ((signatures (mapcar #'method-signature methods)))
    ;; "A method that has &rest but not &key does not affect the set of
    ;;  acceptable keyword srguments."
    (setq signatures (delete-if-not #'sig-keys-p signatures))
    ;; "The presence of &allow-other-keys in the lambda list of an applicable
    ;;  method disables validity checking of initialization arguments."
    ;; (ANSI CL section 7.1.2)
    (if (some #'sig-allow-p signatures)
      't
      ;; "The keyword name of each keyword parameter specified in the method's
      ;;  lambda-list becomes an initialization argument for all classes for
      ;;  which the method is applicable."
      (remove-duplicates
        (append (class-valid-initargs-from-slots class)
                (mapcap #'sig-keywords signatures))
        :from-end t))))

;; NB: On calculation of an effective method, the residual
;; arguments do not count.
;; At the first call of INITIALIZE-INSTANCE or MAKE-INSTANCE of each class
;; we memorize the needed information in *make-instance-table*.

;; For MAKE-INSTANCE the following is necessary as keys:
;; - the initargs that are used for the initialization of slots,
;; - the keywords of methods from SHARED-INITIALIZE,
;; - the keywords of methods from INITIALIZE-INSTANCE,
;; - the keywords of methods from ALLOCATE-INSTANCE.
(defun valid-make-instance-keywords (class)
  (valid-initarg-keywords
    class
    (append
     ;; list of all applicable methods from SHARED-INITIALIZE
     (remove-if-not
      #'(lambda (method)
          (let* ((specializers (method-specializers method))
                 (specializer1 (first specializers))
                 (specializer2 (second specializers)))
            (and (not (eql-specializer-p specializer1))
                 (subclassp class specializer1)
                 (typep 'T specializer2))))
      (the list (generic-function-methods |#'shared-initialize|)))
     ;; list of all applicable methods from INITIALIZE-INSTANCE
     (remove-if-not
      #'(lambda (method)
          (let ((specializer (first (method-specializers method))))
            (and (not (eql-specializer-p specializer))
                 (subclassp class specializer))))
      (the list (generic-function-methods |#'initialize-instance|)))
     ;; list of all applicable methods from ALLOCATE-INSTANCE
     (remove-if-not
      #'(lambda (method)
          (let ((specializer (first (method-specializers method))))
            (if (eql-specializer-p specializer)
              (eql class (eql-specializer-object specializer))
              (typep-class class specializer)))) ; <==> (typep class specializer)
      (the list (generic-function-methods |#'allocate-instance|))))))
(defun make-instance-table-entry1 (class)
  (values (valid-make-instance-keywords class)
          (compute-applicable-methods-effective-method |#'allocate-instance| class)))
(defun make-instance-table-entry2 (instance)
  (values (compute-applicable-methods-effective-method |#'initialize-instance| instance)
          (compute-applicable-methods-effective-method |#'shared-initialize| instance 'T)))

;; For REINITIALIZE-INSTANCE the following is necessary as keys:
;; - the initargs that are used for the initialization of slots,
;; - the keywords of methods from SHARED-INITIALIZE,
;; - the keywords of methods from REINITIALIZE-INSTANCE.
(defun valid-reinitialize-instance-keywords (class)
  (valid-initarg-keywords
    class
    (append
      ;; list of all applicable methods from SHARED-INITIALIZE
      (remove-if-not
        #'(lambda (method)
            (let* ((specializers (method-specializers method))
                   (specializer1 (first specializers))
                   (specializer2 (second specializers)))
              (and (not (eql-specializer-p specializer1))
                   (subclassp class specializer1)
                   (typep 'NIL specializer2))))
        (the list (generic-function-methods |#'shared-initialize|)))
      ;; list of all applicable methods from REINITIALIZE-INSTANCE
      (remove-if-not
        #'(lambda (method)
            (let ((specializer (first (method-specializers method))))
              (and (not (eql-specializer-p specializer))
                   (subclassp class specializer))))
        (the list (generic-function-methods |#'reinitialize-instance|))))))

;; For UPDATE-INSTANCE-FOR-REDEFINED-CLASS the following is necessary as keys:
;; - the initargs that are used for the initialization of slots,
;; - the keywords of methods from SHARED-INITIALIZE,
;; - the keywords of methods from UPDATE-INSTANCE-FOR-REDEFINED-CLASS.
;; Return a 2nd value that indicates whether the result is independent of
;; added-slots, discarded-slots, property-list.
(defun valid-update-instance-for-redefined-class-keywords (class added-slots discarded-slots property-list)
  (let ((independent t))
    (values
      (valid-initarg-keywords
        class
        (append
          ;; list of all applicable methods from SHARED-INITIALIZE
          (remove-if-not
            #'(lambda (method)
                (let* ((specializers (method-specializers method))
                       (specializer1 (first specializers))
                       (specializer2 (second specializers)))
                  (and (not (eql-specializer-p specializer1))
                       (subclassp class specializer1)
                       (progn
                         (when (or (eql-specializer-p specializer2)
                                   (eq specializer2 <null>))
                           (setq independent nil))
                         (typep added-slots specializer2)))))
            (the list (generic-function-methods |#'shared-initialize|)))
          ;; list of all applicable methods from UPDATE-INSTANCE-FOR-REDEFINED-CLASS
          (remove-if-not
            #'(lambda (method)
                (let* ((specializers (method-specializers method))
                       (specializer1 (first specializers))
                       (specializer2 (second specializers))
                       (specializer3 (third specializers))
                       (specializer4 (fourth specializers)))
                  (and (not (eql-specializer-p specializer1))
                       (subclassp class specializer1)
                       (progn
                         (when (or (eql-specializer-p specializer2)
                                   (eq specializer2 <null>))
                           (setq independent nil))
                         (when (or (eql-specializer-p specializer3)
                                   (eq specializer3 <null>))
                           (setq independent nil))
                         (when (or (eql-specializer-p specializer4)
                                   (eq specializer4 <null>))
                           (setq independent nil))
                         (and (typep added-slots specializer2)
                              (typep discarded-slots specializer3)
                              (typep property-list specializer4))))))
            (the list (generic-function-methods |#'update-instance-for-redefined-class|)))))
      independent)))

;; For UPDATE-INSTANCE-FOR-DIFFERENT-CLASS the following is necessary as keys:
;; - the initargs that are used for the initialization of slots,
;; - the keywords of methods from SHARED-INITIALIZE,
;; - the keywords of methods from UPDATE-INSTANCE-FOR-DIFFERENT-CLASS.
(defun valid-update-instance-for-different-class-keywords (old-class new-class added-slots)
  (valid-initarg-keywords
    new-class
    (append
      ;; list of all applicable methods from SHARED-INITIALIZE
      (remove-if-not
        #'(lambda (method)
            (let* ((specializers (method-specializers method))
                   (specializer1 (first specializers))
                   (specializer2 (second specializers)))
              (and (not (eql-specializer-p specializer1))
                   (subclassp new-class specializer1)
                   (typep added-slots specializer2))))
        (the list (generic-function-methods |#'shared-initialize|)))
      ;; list of all applicable methods from UPDATE-INSTANCE-FOR-DIFFERENT-CLASS
      (remove-if-not
        #'(lambda (method)
            (let* ((specializers (method-specializers method))
                   (specializer1 (first specializers))
                   (specializer2 (second specializers)))
              (and (not (eql-specializer-p specializer1))
                   (subclassp old-class specializer1)
                   (not (eql-specializer-p specializer2))
                   (subclassp new-class specializer2))))
        (the list (generic-function-methods |#'update-instance-for-different-class|))))))

;; Also in record.d.
(defun check-initialization-argument-list (initargs caller)
  (do ((l initargs (cddr l)))
      ((endp l))
    (unless (symbolp (car l))
      (error-of-type 'program-error ; ANSI CL 3.5.1.5. wants a PROGRAM-ERROR here.
        "~S: invalid initialization argument ~S"
        caller (car l)))
    (when (endp (cdr l))
      (error-of-type 'program-error ; ANSI CL 3.5.1.6. wants a PROGRAM-ERROR here.
        "~S: keyword arguments in ~S should occur pairwise"
        caller initargs))))

;; CLtL2 28.1.9.5., 28.1.9.4., ANSI CL 7.1.5., 7.1.4.
(defgeneric shared-initialize
    (instance slot-names &rest initargs &key &allow-other-keys)
  (declare (dynamically-modifiable)))
(setq |#'shared-initialize| #'shared-initialize)
#||
 (defmethod shared-initialize ((instance standard-object) slot-names
                               &rest initargs)
  (check-initialization-argument-list initargs 'shared-initialize)
  (dolist (slot (class-slots (class-of instance)))
    (let ((slotname (slot-definition-name slot)))
      (multiple-value-bind (init-key init-value foundp)
          (get-properties initargs (slot-definition-initargs slot))
        (declare (ignore init-key))
        (if foundp
          (setf (slot-value instance slotname) init-value)
          (unless (slot-boundp instance slotname)
            (let ((initfunction (slot-definition-initfunction slot)))
              (when init
                (when (or (eq slot-names 'T) (memq slotname slot-names))
                  (setf (slot-value instance slotname)
                        (funcall initfunction))))))))))
  instance)
||#
;; the main work is done by a SUBR:
(do-defmethod 'shared-initialize
  (make-instance-<standard-method> <standard-method>
    :specializers (list (find-class 'standard-object) (find-class 't))
    'fast-function #'clos::%shared-initialize
    'wants-next-method-p nil
    :qualifiers '()
    :lambda-list '(instance slot-names &rest initargs)
    'signature #s(system::signature :req-num 2 :rest-p t)))
(do-defmethod 'shared-initialize
  (make-instance-<standard-method> <standard-method>
    :specializers (list (find-class 'structure-object) (find-class 't))
    'fast-function #'clos::%shared-initialize
    'wants-next-method-p nil
    :qualifiers '()
    :lambda-list '(instance slot-names &rest initargs)
    'signature #s(system::signature :req-num 2 :rest-p t)))

;; CLtL2 28.1.12., ANSI CL 7.3.
(defgeneric reinitialize-instance
    (instance &rest initargs &key &allow-other-keys)
  (declare (dynamically-modifiable)))
(setq |#'reinitialize-instance| #'reinitialize-instance)
#||
 (defmethod reinitialize-instance ((instance standard-object) &rest initargs)
  (check-initialization-argument-list initargs 'reinitialize-instance)
  (apply #'shared-initialize instance 'NIL initargs))
||#
#|| ; optimized:
 (defmethod reinitialize-instance ((instance standard-object) &rest initargs)
  (check-initialization-argument-list initargs 'reinitialize-instance)
  (let ((h (gethash (class-of instance) *reinitialize-instance-table*)))
    (if h
      (progn
        ;; CLtL2 28.1.9.2., ANSI CL 7.1.2. Validity of initialization arguments
        (let ((valid-keywords (car h)))
          (unless (eq valid-keywords 't)
            (sys::keyword-test initargs valid-keywords)))
        (if (not (eq (cdr h) #'clos::%shared-initialize))
          ;; apply effective method from shared-initialize:
          (apply (cdr h) instance 'NIL initargs)
          ;; clos::%shared-initialize with slot-names=NIL can be simplified:
          (progn
            (dolist (slot (class-slots (class-of instance)))
              (let ((slotname (slot-definition-name slot)))
                (multiple-value-bind (init-key init-value foundp)
                    (get-properties initargs (slot-definition-initargs slot))
                  (declare (ignore init-key))
                  (if foundp
                    (setf (slot-value instance slotname) init-value)))))
            instance)))
      (apply #'initial-reinitialize-instance instance initargs))))
||#
;; the main work is done by a SUBR:
(do-defmethod 'reinitialize-instance
  (make-instance-<standard-method> <standard-method>
    :specializers (list (find-class 'standard-object))
    'fast-function #'clos::%reinitialize-instance
    'wants-next-method-p nil
    :qualifiers '()
    :lambda-list '(instance &rest initargs)
    'signature #s(system::signature :req-num 1 :rest-p t)))
(do-defmethod 'reinitialize-instance
  (make-instance-<standard-method> <standard-method>
    :specializers (list (find-class 'structure-object))
    'fast-function #'clos::%reinitialize-instance
    'wants-next-method-p nil
    :qualifiers '()
    :lambda-list '(instance &rest initargs)
    'signature #s(system::signature :req-num 1 :rest-p t)))
;; At the first call of REINITIALIZE-INSTANCE of each class
;; we memorize the needed information in *reinitialize-instance-table*.
(defun initial-reinitialize-instance (instance &rest initargs)
  (let* ((class (class-of instance))
         (valid-keywords (valid-reinitialize-instance-keywords class)))
    ;; CLtL2 28.1.9.2., ANSI CL 7.1.2. Validity of initialization arguments
    (unless (eq valid-keywords 't)
      (sys::keyword-test initargs valid-keywords))
    (let ((si-ef (compute-applicable-methods-effective-method |#'shared-initialize| instance 'NIL)))
      (setf (gethash class *reinitialize-instance-table*)
            (cons valid-keywords si-ef))
      (apply si-ef instance 'NIL initargs))))

;; CLtL2 28.1.9.6., ANSI CL 7.1.6.
(defgeneric initialize-instance (instance &rest initargs
                                 &key &allow-other-keys)
  (declare (dynamically-modifiable)))
(setq |#'initialize-instance| #'initialize-instance)
#||
 (defmethod initialize-instance ((instance standard-object) &rest initargs)
  (check-initialization-argument-list initargs 'initialize-instance)
  (apply #'shared-initialize instance 'T initargs))
||#
#|| ; optimized:
 (defmethod initialize-instance ((instance standard-object) &rest initargs)
  (check-initialization-argument-list initargs 'initialize-instance)
  (let ((h (gethash class *make-instance-table*)))
    (if h
      (if (not (eq (svref h 3) #'clos::%shared-initialize))
        ;; apply effective method from shared-initialize:
        (apply (svref h 3) instance 'T initargs)
        ;; clos::%shared-initialize with slot-names=T can be simplified:
        (progn
          (dolist (slot (class-slots (class-of instance)))
            (let ((slotname (slot-definition-name slot)))
              (multiple-value-bind (init-key init-value foundp)
                  (get-properties initargs (slot-definition-initargs slot))
                (declare (ignore init-key))
                (if foundp
                  (setf (slot-value instance slotname) init-value)
                  (unless (slot-boundp instance slotname)
                    (let ((initfunction (slot-definition-initfunction slot)))
                      (when initfunction
                        (setf (slot-value instance slotname)
                              (funcall initfunction)))))))))
          instance))
      (apply #'initial-initialize-instance instance initargs))))
||#
;; the main work is done by a SUBR:
(do-defmethod 'initialize-instance
  (make-instance-<standard-method> <standard-method>
    :specializers (list (find-class 'standard-object))
    'fast-function #'clos::%initialize-instance
    'wants-next-method-p nil
    :qualifiers '()
    :lambda-list '(instance &rest initargs)
    'signature #s(system::signature :req-num 1 :rest-p t)))
(do-defmethod 'initialize-instance
  (make-instance-<standard-method> <standard-method>
    :specializers (list (find-class 'structure-object))
    'fast-function #'clos::%initialize-instance
    'wants-next-method-p nil
    :qualifiers '()
    :lambda-list '(instance &rest initargs)
    'signature #s(system::signature :req-num 1 :rest-p t)))
;; At the first call of MAKE-INSTANCE or INITIALIZE-INSTANCE of each class
;; we memorize the needed information in *make-instance-table*.
(defun initial-initialize-instance (instance &rest initargs)
  (let ((class (class-of instance)))
    (multiple-value-bind (valid-keywords ai-ef)
        (make-instance-table-entry1 class)
      (multiple-value-bind (ii-ef si-ef) (make-instance-table-entry2 instance)
        (setf (gethash class *make-instance-table*)
              (vector valid-keywords ai-ef ii-ef si-ef))
        ;; apply effective method from SHARED-INITIALIZE:
        (apply si-ef instance 'T initargs)))))

;; User-defined methods on allocate-instance are now supported.
(defgeneric allocate-instance (instance &rest initargs &key &allow-other-keys)
  (declare (dynamically-modifiable)))
(setq |#'allocate-instance| #'allocate-instance)
#||
 (defgeneric allocate-instance (class)
  (:method ((class semi-standard-class))
    (unless (= (class-initialized class) 6) (finalize-inheritance class))
    (allocate-std-instance class (class-instance-size class)))
  (:method ((class structure-class))
    (sys::%make-structure (class-names class) (class-instance-size class)
                          :initial-element unbound)))
||#
#||
 (defun %allocate-instance (class &rest initargs)
  (check-initialization-argument-list initargs 'allocate-instance)
  ;; No need to check the validity of the initargs, because ANSI CL says
  ;; "The caller of allocate-instance is expected to have already checked
  ;;  the initialization arguments."
  ;; Quick and dirty dispatch among <semi-standard-class> and <structure-class>.
  ;; (class-current-version class) is an atom, (class-names class) a cons.
  (if (atom (class-current-version class))
    (progn
      (unless (= (class-initialized class) 6) (finalize-inheritance class))
      ;; Dispatch among <standard-class> and <funcallable-standard-class>.
      (if (not (class-funcallablep class))
        (allocate-std-instance class (class-instance-size class))
        (allocate-funcallable-instance class (class-instance-size class))))
    (sys::%make-structure (class-names class) (class-instance-size class)
                          :initial-element unbound)))
||#
; the main work is done by a SUBR:
(do-defmethod 'allocate-instance
  (make-instance-<standard-method> <standard-method>
    :specializers (list (find-class 'semi-standard-class))
    'fast-function #'clos::%allocate-instance
    'wants-next-method-p nil
    :qualifiers '()
    :lambda-list '(class &rest initargs)
    'signature #s(system::signature :req-num 1 :rest-p t)))
(do-defmethod 'allocate-instance
  (make-instance-<standard-method> <standard-method>
    :specializers (list (find-class 'structure-class))
    'fast-function #'clos::%allocate-instance
    'wants-next-method-p nil
    :qualifiers '()
    :lambda-list '(class &rest initargs)
    'signature #s(system::signature :req-num 1 :rest-p t)))
; No extended method check because this GF is specified in ANSI CL.
;(initialize-extended-method-check #'allocate-instance)

;; CLtL2 28.1.9.7., ANSI CL 7.1.7.
(defgeneric make-instance (class &rest initargs &key &allow-other-keys)
  (declare (dynamically-modifiable))
  (:method ((class symbol) &rest initargs)
    (apply #'make-instance (find-class class) initargs)))
#||
 (defmethod make-instance ((class semi-standard-class) &rest initargs)
  (check-initialization-argument-list initargs 'make-instance)
  ;; CLtL2 28.1.9.3., 28.1.9.4., ANSI CL 7.1.3., 7.1.4.: Take note of
  ;; default-initargs:
  (dolist (default-initarg (class-default-initargs class))
    (let ((nothing default-initarg))
      (when (eq (getf initargs (car default-initarg) nothing) nothing)
        (setq initargs
              (append initargs
                (list (car default-initarg)
                      (funcall (caddr default-initarg))))))))
  #||
  ;; CLtL2 28.1.9.2., ANSI CL 7.1.2. Validity of initialization arguments
  (sys::keyword-test initargs
      (union (class-valid-initargs-from-slots class)
             (applicable-keywords #'initialize-instance class))) ; ??
  (let ((instance (apply #'allocate-instance class initargs)))
    (apply #'initialize-instance instance initargs))
  ||#
  (let ((h (gethash class *make-instance-table*)))
    (if h
      (progn
        ;; CLtL2 28.1.9.2., ANSI CL 7.1.2. Validity of initialization arguments
        (let ((valid-keywords (svref h 0)))
          (unless (eq valid-keywords 't)
            (sys::keyword-test initargs valid-keywords)))
        (let ((instance (apply #'allocate-instance class initargs)))
          (if (not (eq (svref h 2) #'clos::%initialize-instance))
            ;; apply effective method from initialize-instance:
            (apply (svref h 2) instance initargs)
            ;; clos::%initialize-instance can be simplified (one does not need
            ;; to look into *make-instance-table* once again):
            (if (not (eq (svref h 3) #'clos::%shared-initialize))
              ;; apply effective method from shared-initialize:
              (apply (svref h 3) instance 'T initargs)
              ...
            ))))
      (apply #'initial-make-instance class initargs))))
||#
;; the main work is done by a SUBR:
(do-defmethod 'make-instance
  (make-instance-<standard-method> <standard-method>
    :specializers (list (find-class 'semi-standard-class))
    'fast-function #'clos::%make-instance
    'wants-next-method-p nil
    :qualifiers '()
    :lambda-list '(class &rest initargs)
    'signature #s(system::signature :req-num 1 :rest-p t)))
(do-defmethod 'make-instance
  (make-instance-<standard-method> <standard-method>
    :specializers (list (find-class 'structure-class))
    'fast-function #'clos::%make-instance
    'wants-next-method-p nil
    :qualifiers '()
    :lambda-list '(class &rest initargs)
    'signature #s(system::signature :req-num 1 :rest-p t)))
; No extended method check because this GF is specified in ANSI CL.
;(initialize-extended-method-check #'make-instance)
;; At the first call of MAKE-INSTANCE or INITIALIZE-INSTANCE of each class
;; we memorize the needed information in *make-instance-table*.
(defun initial-make-instance (class &rest initargs)
  (multiple-value-bind (valid-keywords ai-ef)
      (make-instance-table-entry1 class)
    ;; http://www.lisp.org/HyperSpec/Body/sec_7-1-2.html
    ;; 7.1.2 Declaring the Validity of Initialization Arguments
    (unless (eq valid-keywords 't)
      (sys::keyword-test initargs valid-keywords))
    ;; call the effective method of ALLOCATE-INSTANCE:
    (let ((instance (apply ai-ef class initargs)))
      (unless (eq (class-of instance) class)
        (error-of-type 'error
          (TEXT "~S method for ~S returned ~S")
          'allocate-instance class instance))
      (multiple-value-bind (ii-ef si-ef) (make-instance-table-entry2 instance)
        (setf (gethash class *make-instance-table*)
              (vector valid-keywords ai-ef ii-ef si-ef))
        ;; call the effective method of INITIALIZE-INSTANCE:
        (apply ii-ef instance initargs))
      ;; return the instance
      instance)))

;; Returns the valid initialization arguments of a class, or T if any symbol
;; is allowed.
(defun class-valid-initialization-keywords (class) ; ABI
  (let ((entry (gethash class *make-instance-table*)))
    (if entry
      ;; Get it from the cache.
      (svref entry 0)
      ;; Compute it. Don't need to cache it, since this function does not need
      ;; to be fast.
      (valid-make-instance-keywords class))))

;;; change-class

(defgeneric change-class (instance new-class &key &allow-other-keys)
  (declare (dynamically-modifiable))
  (:method ((instance standard-object) (new-class standard-class)
            &rest initargs)
    (apply #'do-change-class instance new-class initargs))
  (:method ((instance funcallable-standard-object) (new-class standard-class)
            &rest initargs)
    (declare (ignore initargs))
    (error (TEXT "~S cannot change a funcallable object to a non-funcallable object: ~S")
           'change-class instance))
  (:method ((instance funcallable-standard-object) (new-class funcallable-standard-class)
            &rest initargs)
    (apply #'do-change-class instance new-class initargs))
  (:method ((instance standard-object) (new-class funcallable-standard-class)
            &rest initargs)
    (declare (ignore initargs))
    (error (TEXT "~S cannot change a non-funcallable object to a funcallable object: ~S")
           'change-class instance))
  (:method ((instance t) (new-class symbol) &rest initargs)
    (apply #'change-class instance (find-class new-class) initargs)))

(defun do-change-class (instance new-class &rest initargs)
  ;; ANSI CL 7.2.1. Modifying the Structure of the Instance.
  (let ((previous (%change-class instance new-class)))
    ;; previous = a copy of instance
    ;; instance = mutated instance, with new class, slots unbound
    ;; When the instance was used in an EQL specializer, the instance
    ;; could be used as index in a generic function's dispatch table. Need
    ;; to invalidate all the affected generic functions' dispatch tables.
    (let ((specializer (existing-eql-specializer instance)))
      (when specializer
        (dolist (gf (specializer-direct-generic-functions specializer))
          (when (typep-class gf <standard-generic-function>)
            ;; Clear the discriminating function.
            ;; The effective method cache does not need to be invalidated.
            #|(setf (std-gf-effective-method-cache gf) '())|#
            (finalize-fast-gf gf)))
        ;; Also, the EQL specializer is recorded in its class. But now its
        ;; class has changed; we have to record it in the new class.
        (let ((old-class (class-of previous))
              (new-class (class-of instance)))
          (when (semi-standard-class-p old-class)
            (remove-direct-instance-specializer old-class specializer))
          (when (and (semi-standard-class-p new-class)
                     (specializer-direct-methods specializer))
            (add-direct-instance-specializer new-class specializer)))))
    ;; Copy identically named slots:
    (let ((old-slots (class-slots (class-of previous)))
          (new-slots (class-slots new-class)))
      (dolist (slot old-slots)
        (let ((name (slot-definition-name slot)))
          (when (slot-boundp previous name)
            ;; Retain the slot's value if it is a local slot in new-class.
            (let ((new-slot (find name new-slots :test #'eq
                                  :key #'slot-definition-name)))
              (when (and new-slot (atom (slot-definition-location new-slot)))
                (setf (slot-value instance name)
                      (slot-value previous name))))))))
    ;; ANSI CL 7.2.2. Initializing Newly Added Local Slots.
    (apply #'update-instance-for-different-class
           previous instance initargs)))

(defgeneric update-instance-for-different-class (previous current
                                                 &key &allow-other-keys)
  (declare (dynamically-modifiable))
  (:method ((previous standard-object) (current standard-object)
            &rest initargs)
    ;; ANSI CL 7.2.2. Initializing Newly Added Local Slots.
    (check-initialization-argument-list initargs 'update-instance-for-different-class)
    (let* ((old-class (class-of previous))
           (old-slots-table (class-slot-location-table old-class))
           (new-class (class-of current))
           (added-slots
             (mapcan #'(lambda (slot)
                         ; Only local slots.
                         (when (atom (slot-definition-location slot))
                           (let ((name (slot-definition-name slot)))
                             ; Only slots for which no slot of the same name
                             ; exists in the previous class.
                             (when (null (gethash name old-slots-table))
                               (list name)))))
                     (class-slots new-class))))
      ;; CLtL2 28.1.9.2., ANSI CL 7.1.2. Validity of initialization arguments
      (multiple-value-bind (valid-keywords found)
          (gethash (cons old-class new-class) *update-instance-for-different-class-table*)
        (unless found
          (setq valid-keywords
                (valid-update-instance-for-different-class-keywords
                  old-class new-class added-slots))
          (setf (gethash (cons old-class new-class) *update-instance-for-different-class-table*)
                valid-keywords))
        (unless (eq valid-keywords 't)
          (sys::keyword-test initargs valid-keywords)))
      (apply #'shared-initialize current added-slots initargs)))
  ;; MOP p. 57.
  (:method ((previous potential-class) (current standard-object) &rest initargs)
    (declare (ignore initargs))
    (update-metaobject-instance-for-different-class previous))
  ;; MOP p. 61.
  (:method ((previous generic-function) (current standard-object) &rest initargs)
    (declare (ignore initargs))
    #| ;; MOP p. 61.
    (update-metaobject-instance-for-different-class previous)
    |# ;; We support this anyway, as an extension.
    (let ((gf current))
      (when (typep-class gf <standard-generic-function>)
        ;; Clear the effective method cache and the discriminating function.
        (setf (std-gf-effective-method-cache gf) '())
        (finalize-fast-gf gf)))
    (call-next-method))
  ;; MOP p. 64.
  (:method ((previous method) (current standard-object) &rest initargs)
    (declare (ignore initargs))
    #| ;; MOP p. 64.
    (update-metaobject-instance-for-different-class previous)
    |# ;; We support this anyway, as an extension.
    (let ((gf (method-generic-function previous)))
      (when (and gf (typep-class gf <standard-generic-function>))
        ;; Clear the effective method cache and the discriminating function.
        (setf (std-gf-effective-method-cache gf) '())
        (finalize-fast-gf gf))
      (prog1
        (call-next-method)
        (setf (method-generic-function current) gf))))
  ;; MOP p. 67.
  (:method ((previous slot-definition) (current standard-object) &rest initargs)
    (declare (ignore initargs))
    (update-metaobject-instance-for-different-class previous)))
(setq |#'update-instance-for-different-class| #'update-instance-for-different-class)

(defun update-metaobject-instance-for-different-class (previous)
  (error (TEXT "~S: The MOP does not allow changing the class of metaobject ~S")
         'update-instance-for-different-class previous))

;; Users want to be able to create subclasses of <standard-class> and write
;; methods on MAKE-INSTANCES-OBSOLETE on them. So, we now go redefine
;; MAKE-INSTANCES-OBSOLETE as a generic function.
(fmakunbound 'make-instances-obsolete)
(defgeneric make-instances-obsolete (class)
  (declare (dynamically-modifiable))
  (:method ((class semi-standard-class))
    (make-instances-obsolete-<semi-standard-class> class)
    class)
  (:method ((class symbol))
    (make-instances-obsolete (find-class class))
    class))

(defgeneric update-instance-for-redefined-class
    (instance added-slots discarded-slots property-list &rest initargs
     &key &allow-other-keys)
  (declare (dynamically-modifiable))
  (:method ((instance standard-object) added-slots discarded-slots
            property-list &rest initargs)
    ;; Check initargs.
    (check-initialization-argument-list initargs 'update-instance-for-redefined-class)
    ;; CLtL2 28.1.9.2., ANSI CL 7.1.2. Validity of initialization arguments
    (let ((class (class-of instance)))
      (multiple-value-bind (valid-keywords found)
          (gethash class *update-instance-for-redefined-class-table*)
        (unless found
          (let (independent)
            (multiple-value-setq (valid-keywords independent)
                (valid-update-instance-for-redefined-class-keywords
                 class added-slots discarded-slots property-list))
            (when independent
              (setf (gethash class *update-instance-for-redefined-class-table*)
                    valid-keywords))))
        (unless (eq valid-keywords 't)
          (sys::keyword-test initargs valid-keywords))))
    (apply #'shared-initialize instance added-slots initargs))
  #| ;; MOP p. 57, 61, 64, 67.
     ;; This is not needed, because the tests for <metaobject> in
     ;; reinitialize-instance-<defined-class> and
     ;; make-instances-obsolete-<semi-standard-class>-nonrecursive
     ;; prevent metaobject instances from being updated.
  (:method ((instance metaobject) added-slots discarded-slots
            property-list &rest initargs)
    (declare (ignore added-slots discarded-slots property-list initargs))
    (error (TEXT "~S: The MOP does not allow changing the metaobject class ~S")
           'update-instance-for-redefined-class (class-of instance)))
  |#
)
(setq |#'update-instance-for-redefined-class| #'update-instance-for-redefined-class)

;;; Utility functions

;; Returns the slot names of an instance of a slotted-class
;; (i.e. of a structure-object or standard-object).
(defun slot-names (object)
  (mapcar #'slot-definition-name (class-slots (class-of object))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-class5.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-class4.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP
;;;; Class metaobjects
;;;; Part n-2: Final class definitions, make/initialize-instance methods.
;;;; Bruno Haible 2004-05-25
;;;; Sam Steingold 2005

(in-package "CLOS")

;;; ===========================================================================

;;; Lift the initialization protocol.

(defmethod shared-initialize ((class potential-class) situation &rest args
                              &key name)
  (declare (ignore name))
  (apply #'shared-initialize-<potential-class> class situation args))

;;; ===========================================================================

(defmethod shared-initialize ((class defined-class) situation &rest args
                              &key name direct-superclasses direct-slots
                                   direct-default-initargs documentation)
  (declare (ignore name direct-superclasses direct-slots
                   direct-default-initargs documentation))
  (apply #'shared-initialize-<defined-class> class situation args))

(defmethod reinitialize-instance ((class defined-class) &rest args
                                  &key &allow-other-keys)
  (apply #'reinitialize-instance-<defined-class> class args))

;;; ===========================================================================

(defmethod shared-initialize ((class built-in-class) situation &rest args
                              &key name direct-superclasses
                                   ((prototype prototype) nil))
  (declare (ignore name direct-superclasses prototype))
  (apply #'shared-initialize-<built-in-class> class situation args))

;;; ===========================================================================

(defmethod shared-initialize ((class structure-class) situation &rest args
                              &key name direct-superclasses direct-slots
                                   direct-default-initargs documentation
                                   (generic-accessors t)
                                   ((direct-slots direct-slots-as-metaobjects) '())
                                   ((names names) nil)
                                   ((kconstructor kconstructor) nil)
                                   ((boa-constructors boa-constructors) '())
                                   ((copier copier) nil)
                                   ((predicate predicate) nil)
                                   ((slots slots) '()) ((size size) 1))
  (declare (ignore name direct-superclasses direct-slots
                   direct-default-initargs documentation generic-accessors
                   direct-slots-as-metaobjects names kconstructor
                   boa-constructors copier predicate slots size))
  (apply #'shared-initialize-<structure-class> class situation args))

;;; ===========================================================================

(defmethod shared-initialize ((class standard-class) situation &rest args
                              &key name direct-superclasses direct-slots
                                   direct-default-initargs documentation
                                   (generic-accessors t)
                                   (fixed-slot-locations nil))
  (declare (ignore name direct-superclasses direct-slots
                   direct-default-initargs documentation generic-accessors
                   fixed-slot-locations))
  (apply #'shared-initialize-<standard-class> class situation args))

;;; ===========================================================================

(defmethod shared-initialize ((class funcallable-standard-class) situation &rest args
                              &key name direct-superclasses direct-slots
                                   direct-default-initargs documentation
                                   (generic-accessors t)
                                   (fixed-slot-locations nil))
  (declare (ignore name direct-superclasses direct-slots
                   direct-default-initargs documentation generic-accessors
                   fixed-slot-locations))
  (apply #'shared-initialize-<funcallable-standard-class> class situation args))

;;; ===========================================================================

;; Now that all the predefined subclasses of <defined-class> have been defined,
;; CLASS-OF can work on all existing <defined-class> instances. Therefore now,
;; not earlier, it's possible to pass these <defined-class> instances to
;; generic functions.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-class4.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-class3.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP
;;;; Class metaobjects
;;;; Part 3: Class definition and redefinition.
;;;; Bruno Haible 21.8.1993 - 2004
;;;; Sam Steingold 1998 - 2010
;;;; German comments translated into English: Stefan Kain 2002-04-08

(in-package "CLOS")


;; Wipe out all traces of an earlier loaded CLOS.
(eval-when (load eval)
  (do-all-symbols (s) (remprop s 'CLOSCLASS)))

;; CLtL2 28.1.4., ANSI CL 4.3.7. Integrating Types and Classes
(defun subclassp (class1 class2)
  (unless (>= (class-initialized class1) 4) (finalize-inheritance class1))
  (values
    (gethash class2 (class-all-superclasses class1)))) ; T or (default) NIL

;; Continue bootstrapping.
(%defclos
  ;; distinctive marks for CLASS-P
  *<standard-class>-class-version*
  *<structure-class>-class-version*
  *<built-in-class>-class-version*
  'defined-class
  'class
  ;; built-in-classes for CLASS-OF - order in sync with constobj.d
  (vector 'array 'bit-vector 'character 'complex 'cons 'float 'function
          'hash-table 'integer 'list 'null 'package 'pathname
          #+LOGICAL-PATHNAMES 'logical-pathname
          'random-state 'ratio 'readtable
          'stream 'file-stream 'synonym-stream 'broadcast-stream
          'concatenated-stream 'two-way-stream 'echo-stream 'string-stream
          'string 'symbol 't 'vector))

;; Bootstrapping support.
(defun replace-class-version (class class-version)
  (replace class-version (class-current-version class))
  (setf (class-current-version class) class-version))

;;; -------------------------------- DEFCLASS --------------------------------

(defmacro defclass (&whole whole-form
                    name superclass-specs slot-specs &rest options)
  (setq name (sys::check-not-declaration name 'defclass))
  (let* ((superclass-forms
           (progn
             (unless (listp superclass-specs)
               (error-of-type 'ext:source-program-error
                 :form whole-form
                 :detail superclass-specs
                 (TEXT "~S ~S: expecting list of superclasses instead of ~S")
                 'defclass name superclass-specs))
             (mapcar #'(lambda (superclass)
                         (unless (symbolp superclass)
                           (error-of-type 'ext:source-program-error
                             :form whole-form
                             :detail superclass
                             (TEXT "~S ~S: superclass name ~S should be a symbol")
                             'defclass name superclass))
                         `',superclass)
                       superclass-specs)))
         (accessor-method-decl-forms '())
         (accessor-function-decl-forms '())
         (generic-accessors nil) (generic-accessors-arg 'T)
         (slot-forms
           (let ((slot-names '()))
             (unless (listp slot-specs)
               (error-of-type 'ext:source-program-error
                 :form whole-form
                 :detail slot-specs
                 (TEXT "~S ~S: expecting list of slot specifications instead of ~S")
                 'defclass name slot-specs))
             (when (and (oddp (length slot-specs)) (cdr slot-specs)
                        (do ((l (cdr slot-specs) (cddr l)))
                            ((endp l) t)
                          (unless (keywordp (car l))
                            (return nil))))
               ;; Typical beginner error: Omission of the parentheses around the
               ;; slot-specs. Probably someone who knows DEFSTRUCT and uses
               ;; DEFCLASS for the first time.
               (clos-warn 'simple-clos-novice-warning (TEXT "~S ~S: Every second slot name is a keyword, and these slots have no options. If you want to define a slot with options, you need to enclose all slot specifications in parentheses: ~S, not ~S.")
                 'defclass name (list slot-specs) slot-specs))
             (mapcar #'(lambda (slot-spec)
                         (let ((slot-name slot-spec) (slot-options '()))
                           (when (consp slot-spec)
                             (setq slot-name (car slot-spec)
                                   slot-options (cdr slot-spec)))
                           (unless (symbolp slot-name)
                             (error-of-type 'ext:source-program-error
                               :form whole-form
                               :detail slot-name
                               (TEXT "~S ~S: slot name ~S should be a symbol")
                               'defclass name slot-name))
                           (if (memq slot-name slot-names)
                             (error-of-type 'ext:source-program-error
                               :form whole-form
                               :detail slot-names
                               (TEXT "~S ~S: There may be only one direct slot with the name ~S.")
                               'defclass name slot-name)
                             (push slot-name slot-names))
                           (let ((readers '())
                                 (writers '())
                                 (allocations '())
                                 (initargs '())
                                 (initform nil) (initfunction nil)
                                 (types '())
                                 (documentation nil)
                                 (user-defined-args nil))
                             (when (oddp (length slot-options))
                               (error-of-type 'ext:source-program-error
                                 :form whole-form
                                 :detail slot-options
                                 (TEXT "~S ~S: slot options for slot ~S must come in pairs")
                                 'defclass name slot-name))
                             (do ((optionsr slot-options (cddr optionsr)))
                                 ((atom optionsr))
                               (let ((optionkey (first optionsr))
                                     (argument (second optionsr)))
                                 (case optionkey
                                   (:READER
                                    (unless (and (symbolp argument) argument)
                                      (error-of-type 'ext:source-program-error
                                        :form whole-form
                                        :detail argument
                                        (TEXT "~S ~S, slot option for slot ~S: ~S is not a non-NIL symbol")
                                        'defclass name slot-name argument))
                                    (push argument readers))
                                   (:WRITER
                                    (unless (function-name-p argument)
                                      (error-of-type 'ext:source-program-error
                                        :form whole-form
                                        :detail argument
                                        (TEXT "~S ~S, slot option for slot ~S: ~S is not a function name")
                                        'defclass name slot-name argument))
                                    (push argument writers))
                                   (:ACCESSOR
                                    (unless (and (symbolp argument) argument)
                                      (error-of-type 'ext:source-program-error
                                        :form whole-form
                                        :detail argument
                                        (TEXT "~S ~S, slot option for slot ~S: ~S is not a non-NIL symbol")
                                        'defclass name slot-name argument))
                                    (push argument readers)
                                    (push `(SETF ,argument) writers))
                                   (:ALLOCATION
                                    (unless (symbolp argument)
                                      (error-of-type 'ext:source-program-error
                                        :form whole-form
                                        :detail argument
                                        (TEXT "~S ~S, slot option ~S for slot ~S: ~S is not a symbol")
                                        'defclass name ':allocation slot-name argument))
                                    (when allocations
                                      (error-of-type 'ext:source-program-error
                                        :form whole-form
                                        :detail slot-options
                                        (TEXT "~S ~S, slot option ~S for slot ~S may only be given once")
                                        'defclass name ':allocation slot-name))
                                    (setq allocations (list argument)))
                                   (:INITARG
                                    (unless (symbolp argument)
                                      (error-of-type 'ext:source-program-error
                                        :form whole-form
                                        :detail argument
                                        (TEXT "~S ~S, slot option for slot ~S: ~S is not a symbol")
                                        'defclass name slot-name argument))
                                    (push argument initargs))
                                   (:INITFORM
                                    (when initform
                                      (error-of-type 'ext:source-program-error
                                        :form whole-form
                                        :detail slot-options
                                        (TEXT "~S ~S, slot option ~S for slot ~S may only be given once")
                                        'defclass name ':initform slot-name))
                                    (setq initform `(QUOTE ,argument)
                                          initfunction (make-initfunction-form argument slot-name)))
                                   (:TYPE
                                    (when types
                                      (error-of-type 'ext:source-program-error
                                        :form whole-form
                                        :detail slot-options
                                        (TEXT "~S ~S, slot option ~S for slot ~S may only be given once")
                                        'defclass name ':type slot-name))
                                    (setq types (list argument)))
                                   (:DOCUMENTATION
                                    (when documentation
                                      (error-of-type 'ext:source-program-error
                                        :form whole-form
                                        :detail slot-options
                                        (TEXT "~S ~S, slot option ~S for slot ~S may only be given once")
                                        'defclass name ':documentation slot-name))
                                    (unless (stringp argument)
                                      (error-of-type 'ext:source-program-error
                                        :form whole-form
                                        :detail argument
                                        (TEXT "~S ~S, slot option for slot ~S: ~S is not a string")
                                        'defclass name slot-name argument))
                                    (setq documentation argument))
                                   ((:NAME :READERS :WRITERS :INITARGS :INITFUNCTION)
                                    ;; These are valid initialization keywords for
                                    ;; <direct-slot-definition>, but nevertheless
                                    ;; not valid DEFCLASS slot options.
                                    (error-of-type 'ext:source-program-error
                                      :form whole-form
                                      :detail optionkey
                                      (TEXT "~S ~S, slot option for slot ~S: ~S is not a valid slot option")
                                      'defclass name slot-name optionkey))
                                   (t
                                     (if (symbolp optionkey)
                                       (let ((acons (assoc optionkey user-defined-args)))
                                         (if acons
                                           (push argument (cdr acons))
                                           (push (list optionkey argument) user-defined-args)))
                                       (error-of-type 'ext:source-program-error
                                         :form whole-form
                                         :detail optionkey
                                         (TEXT "~S ~S, slot option for slot ~S: ~S is not a valid slot option")
                                         'defclass name slot-name optionkey))))))
                             (setq readers (nreverse readers))
                             (setq writers (nreverse writers))
                             (setq user-defined-args (nreverse user-defined-args))
                             (let ((type (if types (first types) 'T)))
                               (dolist (funname readers)
                                 (push `(DECLAIM-METHOD ,funname ((OBJECT ,name)))
                                       accessor-method-decl-forms)
                                 (push `(PROCLAIM '(FUNCTION ,funname (,name) ,type))
                                       accessor-function-decl-forms)
                                 (push `(SYSTEM::EVAL-WHEN-COMPILE (SYSTEM::C-DEFUN ',funname (SYSTEM::LAMBDA-LIST-TO-SIGNATURE '(OBJECT))))
                                       accessor-function-decl-forms))
                               (dolist (funname writers)
                                 (push `(DECLAIM-METHOD ,funname (NEW-VALUE (OBJECT ,name)))
                                       accessor-method-decl-forms)
                                 (push `(PROCLAIM '(FUNCTION ,funname (,type ,name) ,type))
                                       accessor-function-decl-forms)
                                 (push `(SYSTEM::EVAL-WHEN-COMPILE (SYSTEM::C-DEFUN ',funname (SYSTEM::LAMBDA-LIST-TO-SIGNATURE '(NEW-VALUE OBJECT))))
                                       accessor-function-decl-forms)))
                             `(LIST
                                :NAME ',slot-name
                                ,@(when readers `(:READERS ',readers))
                                ,@(when writers `(:WRITERS ',writers))
                                ,@(when allocations `(:ALLOCATION ',(first allocations)))
                                ,@(when initargs `(:INITARGS ',(nreverse initargs)))
                                ,@(when initform `(:INITFORM ,initform :INITFUNCTION ,initfunction))
                                ,@(when types `(:TYPE ',(first types)))
                                ,@(when documentation `(:DOCUMENTATION ',documentation))
                                ,@(when user-defined-args
                                    ;; For error-checking purposes:
                                    `('DEFCLASS-FORM ',whole-form))
                                ,@(mapcan #'(lambda (option)
                                              (list `',(car option)
                                                    ;; If there are multiple occurrences
                                                    ;; of the same option, the values are
                                                    ;; passed as a list. Otherwise a single
                                                    ;; value is passed (not a 1-element list)!
                                                    `',(if (cddr option)
                                                         (nreverse (cdr option))
                                                         (cadr option))))
                                          user-defined-args)))))
                     slot-specs)))
         (metaclass nil) (metaclass-arg nil)
         (direct-default-initargs nil)
         (documentation nil)
         (user-defined-args nil))
    (dolist (option options)
      (block nil
        (when (listp option)
          (let ((optionkey (first option)))
            (when (case optionkey
                    (:METACLASS metaclass)
                    (:DEFAULT-INITARGS direct-default-initargs)
                    (:DOCUMENTATION documentation))
              (error-of-type 'ext:source-program-error
                :form whole-form
                :detail options
                (TEXT "~S ~S: option ~S may only be given once")
                'defclass name optionkey))
            (case optionkey
              (:METACLASS
               (when (eql (length option) 2)
                 (let ((argument (second option)))
                   (unless (symbolp argument)
                     (error-of-type 'ext:source-program-error
                       :form whole-form
                       :detail argument
                       (TEXT "~S ~S, option ~S: ~S is not a symbol")
                       'defclass name option argument))
                   (setq metaclass-arg argument)
                   (setq metaclass `(FIND-CLASS ',argument)))
                 (return)))
              (:DEFAULT-INITARGS
               (let ((list (rest option)))
                 (when (oddp (length list))
                   (error-of-type 'ext:source-program-error
                     :form whole-form
                     :detail list
                     (TEXT "~S ~S, option ~S: arguments must come in pairs")
                     'defclass name option))
                 (setq direct-default-initargs
                       `(:DIRECT-DEFAULT-INITARGS
                         (LIST
                          ,@(let ((arglist nil) (formlist nil))
                              (do ((listr list (cddr listr)))
                                  ((atom listr))
                                (unless (symbolp (first listr))
                                  (error-of-type 'ext:source-program-error
                                    :form whole-form
                                    :detail (first listr)
                                    (TEXT "~S ~S, option ~S: ~S is not a symbol")
                                    'defclass name option (first listr)))
                                (when (member (first listr) arglist)
                                  (error-of-type 'ext:source-program-error
                                    :form whole-form
                                    :detail list
                                    (TEXT "~S ~S, option ~S: ~S may only be given once")
                                    'defclass name option (first listr)))
                                (push (first listr) arglist)
                                (push (second listr) formlist))
                              (mapcan #'(lambda (arg form)
                                          `((LIST ',arg ',form ,(make-initfunction-form form arg))))
                                      (nreverse arglist) (nreverse formlist)))))))
               (return))
              (:DOCUMENTATION
               (when (eql (length option) 2)
                 (let ((argument (second option)))
                   (unless (stringp argument)
                     (error-of-type 'ext:source-program-error
                       :form whole-form
                       :detail argument
                       (TEXT "~S ~S, option ~S: ~S is not a string")
                       'defclass name option argument))
                   (setq documentation
                         `(:DOCUMENTATION ',argument)))
                 (return)))
              ((:NAME :DIRECT-SUPERCLASSES :DIRECT-SLOTS :DIRECT-DEFAULT-INITARGS)
               ;; These are valid initialization keywords for <defined-class>,
               ;; but nevertheless not valid DEFCLASS options.
               (error-of-type 'ext:source-program-error
                 :form whole-form
                 :detail option
                 (TEXT "~S ~S: invalid option ~S")
                 'defclass name option))
              (:GENERIC-ACCESSORS
               (when (eql (length option) 2)
                 (let ((argument (second option)))
                   (setq generic-accessors-arg argument)
                   (setq generic-accessors `(:GENERIC-ACCESSORS ',argument))
                   (return))))
              (T
               (when (symbolp optionkey)
                 (when (assoc optionkey user-defined-args)
                   (error-of-type 'ext:source-program-error
                     :form whole-form
                     :detail options
                     (TEXT "~S ~S: option ~S may only be given once")
                     'defclass name optionkey))
                 (push option user-defined-args)
                 (return))))))
        (error-of-type 'ext:source-program-error
          :form whole-form
          :detail option
          (TEXT "~S ~S: invalid option ~S")
          'defclass name option)))
    (setq user-defined-args (nreverse user-defined-args))
    (let ((metaclass-var (gensym))
          (metaclass-keywords-var (gensym)))
      `(LET ()
         (EVAL-WHEN (COMPILE LOAD EVAL)
           (LET* ((,metaclass-var ,(or metaclass '<STANDARD-CLASS>))
                  ,@(if user-defined-args
                      `((,metaclass-keywords-var
                          ,(cond ((or (null metaclass) (eq metaclass-arg 'STANDARD-CLASS))
                                  '*<STANDARD-CLASS>-VALID-INITIALIZATION-KEYWORDS*)
                                 ((eq metaclass-arg 'FUNCALLABLE-STANDARD-CLASS)
                                  '*<FUNCALLABLE-STANDARD-CLASS>-VALID-INITIALIZATION-KEYWORDS*)
                                 (t `(CLASS-VALID-INITIALIZATION-KEYWORDS ,metaclass-var)))))))
             ;; Provide good error messages. The error message from
             ;; ENSURE-CLASS (actually MAKE-INSTANCE) later is unintelligible.
             ,@(if user-defined-args
                 `((UNLESS (EQ ,metaclass-keywords-var 'T)
                     ,@(mapcar #'(lambda (option)
                                   `(UNLESS (MEMBER ',(first option) ,metaclass-keywords-var)
                                      (ERROR-OF-TYPE 'EXT:SOURCE-PROGRAM-ERROR
                                        :FORM ',whole-form
                                        :DETAIL ',option
                                        (TEXT "~S ~S: invalid option ~S")
                                        'DEFCLASS ',name ',option)))
                               user-defined-args))))
             (APPLY #'ENSURE-CLASS
               ',name
               :DIRECT-SUPERCLASSES (LIST ,@superclass-forms)
               :DIRECT-SLOTS (LIST ,@slot-forms)
               :METACLASS ,metaclass-var
               ,@direct-default-initargs
               ,@documentation
               ,@generic-accessors
               ;; Pass user-defined initargs of the metaclass.
               ,@(mapcan #'(lambda (option)
                             (list `',(first option) `',(rest option)))
                         user-defined-args)
               (APPEND
                 ;; Pass the default initargs of the metaclass, in
                 ;; order to erase leftovers from the previous definition.
                 ,(if metaclass
                    `(MAPCAN #'(LAMBDA (X) (LIST (FIRST X) (FUNCALL (THIRD X))))
                             (CLASS-DEFAULT-INITARGS ,metaclass-var))
                    `',*<standard-class>-default-initargs*)
                 (LIST
                   ;; Here we use (unless ... '(... NIL)) because when a class
                   ;; is being redefined, passing :DOCUMENTATION NIL to
                   ;; ENSURE-CLASS means to erase the documentation string,
                   ;; while nothing means to keep it! See MOP p. 57.
                   ,@(unless direct-default-initargs '(:DIRECT-DEFAULT-INITARGS NIL))
                   ,@(unless documentation '(:DOCUMENTATION NIL))
                   ,@(unless generic-accessors '(:GENERIC-ACCESSORS 'T)))))))
         ,@(if generic-accessors-arg
             (nreverse accessor-method-decl-forms) ; the DECLAIM-METHODs
             (nreverse accessor-function-decl-forms)) ; the C-DEFUNs
         (FIND-CLASS ',name)))))

;; DEFCLASS execution:

;; The function responsible for a MAKE-INSTANCES-OBSOLETE call.
(defvar *make-instances-obsolete-caller* 'make-instances-obsolete)

(defun ensure-class-using-class-<t> (class name &rest all-keys
                                     &key (metaclass <standard-class>)
                                          (direct-superclasses '())
                                          (direct-slots '())
                                          (direct-default-initargs '())
                                          (documentation nil)
                                          (fixed-slot-locations nil)
                                     &allow-other-keys)
  (declare (ignore direct-slots direct-default-initargs documentation
                   fixed-slot-locations))
  ;; Argument checks.
  (unless (symbolp name)
    (error (TEXT "~S: class name ~S should be a symbol")
           'ensure-class-using-class name))
  (unless (defined-class-p metaclass)
    (if (symbolp metaclass)
      (setq metaclass
            (cond ((eq metaclass 'standard-class) <standard-class>) ; for bootstrapping
                  (t (find-class metaclass))))
      (error (TEXT "~S for class ~S: metaclass ~S is neither a class or a symbol")
             'ensure-class-using-class name metaclass)))
  (unless (or (eq metaclass <standard-class>) ; for bootstrapping
              (subclassp metaclass <defined-class>))
    (error (TEXT "~S for class ~S: metaclass ~S is not a subclass of CLASS")
           'ensure-class-using-class name metaclass))
  (unless (proper-list-p direct-superclasses)
    (error (TEXT "~S for class ~S: The ~S argument should be a proper list, not ~S")
           'ensure-class-using-class name ':direct-superclasses direct-superclasses))
  (unless (every #'(lambda (x)
                     (or (defined-class-p x)
                         (forward-reference-to-class-p x)
                         (symbolp x)))
                 direct-superclasses)
    (error (TEXT "~S for class ~S: The direct-superclasses list should consist of classes and symbols, not ~S")
           'ensure-class-using-class name direct-superclasses))
  ;; Ignore the old class if the given name is not its "proper name".
  ;; (This is an ANSI CL requirement; it's not clear whether it belongs
  ;; here or in ENSURE-CLASS.)
  (when (and class (not (eq (class-name class) name)))
    (return-from ensure-class-using-class-<t>
      (apply #'ensure-class-using-class nil name all-keys)))
  ;; Decide whether to modify the given class or ignore it.
  (let ((a-semi-standard-class-p (or (eq metaclass <standard-class>)
                                     (subclassp metaclass <semi-standard-class>))))
    (when class
      (cond ((not (eq metaclass (class-of class)))
             ;; This can occur when mixing DEFSTRUCT and DEFCLASS.
             ;; MOP p. 48 says "If the class of the class argument is not the
             ;; same as the class specified by the :metaclass argument, an
             ;; error is signalled." But we can do better: ignore the old
             ;; class, warn and proceed. The old instances will thus keep
             ;; pointing to the old class.
             (clos-warning (TEXT "Cannot redefine ~S with a different metaclass ~S")
               class metaclass)
             (setq class nil))
            ((not a-semi-standard-class-p)
             ;; This can occur when redefining a class defined through
             ;; (DEFCLASS ... (:METACLASS STRUCTURE-CLASS)), which is
             ;; equivalent to re-executed DEFSTRUCT.
             ;; Only <semi-standard-class> subclasses support making instances
             ;; obsolete. Ignore the old class and proceed. The old instances
             ;; will thus keep pointing to the old class.
             (setq class nil)))
      (unless class
        (return-from ensure-class-using-class-<t>
          (apply #'ensure-class-using-class nil name all-keys))))
    ;; Preparation of class initialization arguments.
    (setq all-keys (copy-list all-keys))
    (remf all-keys ':metaclass)
    ;; See which direct superclasses are already defined.
    (setq direct-superclasses
          (mapcar #'(lambda (c)
                      (if (defined-class-p c)
                        c
                        (let ((cn (if (forward-reference-to-class-p c) (class-name c) c)))
                          (assert (symbolp cn))
                          (if a-semi-standard-class-p
                            ;; Need a class. Allocate a forward-referenced-class
                            ;; if none is yet allocated.
                            (or (get cn 'CLOSCLASS)
                                (setf (get cn 'CLOSCLASS)
                                      (make-instance 'forward-referenced-class
                                        :name cn)))
                            ;; Need a defined-class.
                            (find-class cn)))))
                  direct-superclasses))
    (if class
      ;; Modify the class and return the modified class.
      (apply #'reinitialize-instance ; => #'reinitialize-instance-<defined-class>
             class
             :direct-superclasses direct-superclasses
             all-keys)
      (setf (find-class name)
            (setq class
              (apply (cond ((eq metaclass <standard-class>)
                            #'make-instance-<standard-class>)
                           ((eq metaclass <funcallable-standard-class>)
                            #'make-instance-<funcallable-standard-class>)
                           ((eq metaclass <built-in-class>)
                            #'make-instance-<built-in-class>)
                           ((eq metaclass <structure-class>)
                            #'make-instance-<structure-class>)
                           (t #'make-instance))
                     metaclass
                     :name name
                     :direct-superclasses direct-superclasses
                     all-keys))))
    class))

;; Preliminary.
(predefun ensure-class-using-class (class name &rest args
                                    &key (metaclass <standard-class>)
                                         (direct-superclasses '())
                                         (direct-slots '())
                                         (direct-default-initargs '())
                                         (documentation nil)
                                         (fixed-slot-locations nil)
                                    &allow-other-keys)
  (declare (ignore metaclass direct-superclasses direct-slots
                   direct-default-initargs documentation fixed-slot-locations))
  (apply #'ensure-class-using-class-<t> class name args))

;; MOP p. 46
(defun ensure-class (name &rest args
                     &key (metaclass <standard-class>)
                          (direct-superclasses '())
                          (direct-slots '())
                          (direct-default-initargs '())
                          (documentation nil)
                          (fixed-slot-locations nil)
                     &allow-other-keys)
  (declare (ignore metaclass direct-superclasses direct-slots
                   direct-default-initargs documentation fixed-slot-locations))
  (unless (symbolp name)
    (error (TEXT "~S: class name ~S should be a symbol")
           'ensure-class name))
  (let ((result
          (apply #'ensure-class-using-class (find-class name nil) name args)))
    ; A check, to verify that user-defined methods on ensure-class-using-class
    ; work as they should.
    (unless (defined-class-p result)
      (error (TEXT "Wrong ~S result for ~S: not a class: ~S")
             'ensure-class-using-class name result))
    result))

;; Preliminary.
(predefun reader-method-class (class direct-slot &rest initargs)
  (declare (ignore class direct-slot initargs))
  <standard-reader-method>)
(predefun writer-method-class (class direct-slot &rest initargs)
  (declare (ignore class direct-slot initargs))
  <standard-writer-method>)

;; ---------------------------- Class redefinition ----------------------------

;; When this is true, all safety checks about the metaclasses
;; of superclasses are omitted.
(defparameter *allow-mixing-metaclasses* nil)

(defun reinitialize-instance-<defined-class> (class &rest all-keys
                                              &key (name nil name-p)
                                                   (direct-superclasses '() direct-superclasses-p)
                                                   (direct-slots '() direct-slots-p)
                                                   (direct-default-initargs '() direct-default-initargs-p)
                                                   (documentation nil documentation-p)
                                                   (fixed-slot-locations nil fixed-slot-locations-p)
                                              &allow-other-keys
                                              &aux (metaclass (class-of class)))
  (if (and (>= (class-initialized class) 4) ; already finalized?
           (subclassp class <metaobject>))
    ;; Things would go awry when we try to redefine <class> and similar.
    (clos-warning (TEXT "Redefining metaobject class ~S has no effect.") class)
    (progn
      (when direct-superclasses-p
        ;; Normalize the (class-direct-superclasses class) in the same way as
        ;; the direct-superclasses argument, so that we can compare the two
        ;; lists using EQUAL.
        (when (and (subclassp metaclass <standard-class>)
                   (< (class-initialized class) 3))
          (do ((l (class-direct-superclasses class) (cdr l)))
              ((atom l))
            (let ((c (car l)))
              (unless (defined-class-p c)
                (let ((new-c
                        (let ((cn (if (forward-reference-to-class-p c) (class-name c) c)))
                          (assert (symbolp cn))
                          ;; Need a class. Allocate a forward-referenced-class
                          ;; if none is yet allocated.
                          (or (get cn 'CLOSCLASS)
                              (setf (get cn 'CLOSCLASS)
                                    (make-instance 'forward-referenced-class
                                      :name cn))))))
                  (unless (eq new-c c)
                    (when (defined-class-p new-c)
                      ; changed from forward-referenced-class to defined-class
                      (check-allowed-superclass class new-c))
                    (setf (car l) new-c)
                    (when (or (defined-class-p c) (forward-reference-to-class-p c))
                      (remove-direct-subclass c class))
                    (add-direct-subclass new-c class))))))))
      (when direct-slots-p
        ;; Convert the direct-slots to <direct-slot-definition> instances.
        (setq direct-slots (convert-direct-slots class direct-slots)))
      (when fixed-slot-locations-p
        ;; Convert from list to boolean.
        (when (consp fixed-slot-locations)
          (setq fixed-slot-locations (car fixed-slot-locations))))
      ;; Trivial changes (that can occur when loading the same code twice)
      ;; do not require updating the instances:
      ;; changed slot-options :initform, :documentation,
      ;; changed class-options :name, :default-initargs, :documentation.
      (if (or (and direct-superclasses-p
                   (not (equal (or direct-superclasses (default-direct-superclasses class))
                               (class-direct-superclasses class))))
              (and direct-slots-p
                   (not (equal-direct-slots direct-slots (class-direct-slots class))))
              (and direct-default-initargs-p
                   (not (equal-default-initargs direct-default-initargs
                                                (class-direct-default-initargs class))))
              (and fixed-slot-locations-p
                   (not (eq fixed-slot-locations (class-fixed-slot-locations class)))))
        ;; Instances have to be updated:
        (let* ((was-finalized (>= (class-initialized class) 6))
               (must-be-finalized
                 (and was-finalized
                      (some #'class-instantiated (list-all-finalized-subclasses class))))
               (old-direct-superclasses (class-direct-superclasses class))
               (old-direct-accessors (class-direct-accessors class))
               (old-class-precedence-list (and was-finalized (class-precedence-list class)))
               old-class)
          ;; ANSI CL 4.3.6. Remove accessor methods created by old DEFCLASS.
          (remove-accessor-methods old-direct-accessors)
          (setf (class-direct-accessors class) '())
          ;; Clear the cached prototype.
          (setf (class-prototype class) nil)
          ;; Declare all instances as obsolete, and backup the class object.
          (let ((old-version (class-current-version class))
                (*make-instances-obsolete-caller* 'defclass))
            (make-instances-obsolete class)
            (setq old-class (cv-class old-version)))
          (locally (declare (compile))
            (sys::%handler-bind
             #'(lambda ()
                 (apply #'shared-initialize
                                ; => #'shared-initialize-<built-in-class>
                                ;    #'shared-initialize-<standard-class>
                                ;    #'shared-initialize-<structure-class>
                        class nil
                        `(,@(if direct-slots-p
                                (list 'direct-slots direct-slots) '())
                          ,@all-keys))
                 ;; If the class could be finalized (although not a "must"),
                 ;; keep it finalized and don't unfinalize it.
                 (when (>= (class-initialized class) 6)
                   (setq must-be-finalized t))
                 (update-subclasses-for-redefined-class
                  class was-finalized must-be-finalized
                  old-direct-superclasses))
             ;; If an error occurs during the class redefinition,
             ;; switch back to the old definition, so that existing
             ;; instances can continue to be used.
             'ERROR #'(lambda (condition)
                        (declare (ignore condition))
                        (let ((tmp-direct-superclasses (class-direct-superclasses class)))
                          ;; Restore the class using the backup copy.
                          (let ((new-version (class-current-version class)))
                            (dotimes (i (sys::%record-length class))
                              (setf (sys::%record-ref class i) (sys::%record-ref old-class i)))
                            (setf (class-current-version class) new-version))
                          ;; Restore the direct-subclasses pointers.
                          (dolist (super tmp-direct-superclasses)
                            (remove-direct-subclass-internal super class))
                          (dolist (super old-direct-superclasses)
                            (add-direct-subclass-internal super class))
                          ;; Restore the finalized-direct-subclasses pointers.
                          (dolist (super tmp-direct-superclasses)
                            (when (semi-standard-class-p super)
                              (remove-finalized-direct-subclass super class)))
                          (when (>= (class-initialized class) 6)
                            (dolist (super old-direct-superclasses)
                              (when (semi-standard-class-p super)
                                (add-finalized-direct-subclass super class))))
                          ;; Restore the accessor methods.
                          (add-accessor-methods old-direct-accessors)
                          (setf (class-direct-accessors class) old-direct-accessors)))))
          (let ((new-class-precedence-list
                  (and (>= (class-initialized class) 6) (class-precedence-list class))))
            (unless (equal old-class-precedence-list new-class-precedence-list)
              (update-subclass-instance-specializer-generic-functions class)
              (update-subclass-cpl-specializer-generic-functions class
                old-class-precedence-list new-class-precedence-list)))
          (install-class-direct-accessors class))
        ;; Instances don't need to be updated:
        (progn
          (when name-p
            ;; Store new name:
            (setf (class-classname class) name))
          (when direct-slots-p
            ;; Store new slot-inits:
            (do ((l-old (class-direct-slots class) (cdr l-old))
                 (l-new direct-slots (cdr l-new)))
                ((null l-new))
              (let ((old (car l-old))
                    (new (car l-new)))
                (setf (slot-definition-initform old) (slot-definition-initform new))
                (setf (slot-definition-initfunction old) (slot-definition-initfunction new))
                (setf (slot-definition-documentation old) (slot-definition-documentation new)))))
          (when direct-default-initargs-p
            ;; Store new default-initargs:
            (do ((l-old (class-direct-default-initargs class) (cdr l-old))
                 (l-new direct-default-initargs (cdr l-new)))
                ((null l-new))
              (let ((old (cdar l-old))
                    (new (cdar l-new)))
                ;; Move initform and initfunction from new destructively into
                ;; the old one:
                (setf (car old) (car new))
                (setf (cadr old) (cadr new)))))
          (when documentation-p
            ;; Store new documentation:
            (setf (class-documentation class) documentation))
          ;; NB: These modifications are automatically inherited by the
          ;; subclasses of class! Due to <inheritable-slot-definition-initer>
          ;; and <inheritable-slot-definition-doc>.
          ;; No need to call (install-class-direct-accessors class) here.
      ) )
      ;; Try to finalize it (mop-cl-reinit-mo, https://sourceforge.net/p/clisp/bugs/353/)
      (unless *allow-mixing-metaclasses* ; for gray.lisp
        (when (finalizable-p class)
          (finalize-inheritance class)))
      ;; Notification of listeners:
      (map-dependents class
        #'(lambda (dependent)
            (apply #'update-dependent class dependent all-keys)))
  ) )
  class)

(defun equal-direct-slots (slots1 slots2)
  (or (and (null slots1) (null slots2))
      (and (consp slots1) (consp slots2)
           (equal-direct-slot (first slots1) (first slots2))
           (equal-direct-slots (rest slots1) (rest slots2)))))
(defun equal-default-initargs (initargs1 initargs2)
  (or (and (null initargs1) (null initargs2))
      (and (consp initargs1) (consp initargs2)
           (eq (car (first initargs1)) (car (first initargs2)))
           (equal-default-initargs (cdr initargs1) (cdr initargs2)))))

(defun map-dependents-<defined-class> (class function)
  (dolist (dependent (class-listeners class))
    (funcall function dependent)))

;; ------------------- General routines for <defined-class> -------------------

;; Preliminary.
(predefun class-name (class)
  (class-classname class))

;; Returns the list of implicit direct superclasses when none was specified.
(defun default-direct-superclasses (class)
  (cond ((typep class <standard-class>) (list <standard-object>))
        ((typep class <funcallable-standard-class>) (list <funcallable-standard-object>))
        ((typep class <structure-class>) (list <structure-object>))
        (t '())))

(defun check-metaclass-mix (name direct-superclasses metaclass-test metaclass)
  (unless *allow-mixing-metaclasses*
    (unless (every metaclass-test direct-superclasses)
      (error-of-type 'error
        (TEXT "(~S ~S): superclass ~S should be of class ~S")
        'DEFCLASS name (find-if-not metaclass-test direct-superclasses)
        metaclass))))

;; Preliminary.
(predefun validate-superclass (class superclass)
  (or ;; Green light if class and superclass belong to the same metaclass.
      (eq (sys::%record-ref class 0) (sys::%record-ref superclass 0))
      ;; Green light also if class is a funcallable-standard-class and
      ;; superclass is a standard-class.
      (and (eq (sys::%record-ref class 0) *<funcallable-standard-class>-class-version*)
           (eq (sys::%record-ref superclass 0) *<standard-class>-class-version*))
      ;; Other than that, only <standard-object> and <structure-object> can
      ;; inherit from <t> without belonging to the same metaclass.
      (and (eq superclass <t>)
           (memq (class-classname class) '(standard-object structure-object)))
      ;; And only <funcallable-standard-object> can inherit from <function>
      ;; without belonging to the same metaclass.
      (and (eq superclass <function>)
           (eq (class-classname class) 'funcallable-standard-object))))

(defun check-allowed-superclass (class superclass)
  (unless (validate-superclass class superclass)
    (error (TEXT "(~S ~S) for class ~S: ~S does not allow ~S to become a subclass of ~S. You may define a method on ~S to allow this.")
           'initialize-instance 'class (class-classname class) 'validate-superclass class superclass
           'validate-superclass)))

;;; The direct-subclasses slot can be either
;;; - NIL or a weak-list (for saving memory when there are few subclasses), or
;;; - a weak-hash-table (for speed when there are many subclasses).
#|
;; Adds a class to the list of direct subclasses.
(defun add-direct-subclass (class subclass) ...)
;; Removes a class from the list of direct subclasses.
(defun remove-direct-subclass (class subclass) ...)
;; Returns the currently existing direct subclasses, as a freshly consed list.
(defun list-direct-subclasses (class) ...)
|#
(def-weak-set-accessors class-direct-subclasses-table defined-class
  add-direct-subclass-internal
  remove-direct-subclass-internal
  list-direct-subclasses)

;; Preliminary.
(predefun add-direct-subclass (class subclass)
  (add-direct-subclass-internal class subclass))
(predefun remove-direct-subclass (class subclass)
  (remove-direct-subclass-internal class subclass))
(predefun class-direct-subclasses (class)
  (list-direct-subclasses class))

(defun checked-class-direct-subclasses (class)
  (let ((result (class-direct-subclasses class)))
    ; Some checks, to guarantee that user-defined methods on
    ; class-direct-subclasses don't break our CLOS.
    (unless (proper-list-p result)
      (error (TEXT "Wrong ~S result for class ~S: not a proper list: ~S")
             'class-direct-subclasses (class-name class) result))
    (dolist (c result)
      (unless (defined-class-p c)
        (error (TEXT "Wrong ~S result for class ~S: list element is not a class: ~S")
               'class-direct-subclasses (class-name class) c))
      (unless (memq class (class-direct-superclasses c))
        (error (TEXT "Wrong ~S result for class ~S: ~S is not a direct superclass of ~S")
               'class-direct-subclasses (class-name class) class c)))
    result))

(defun update-subclasses-sets (class old-direct-superclasses new-direct-superclasses)
  (unless (equal old-direct-superclasses new-direct-superclasses)
    (let ((removed-direct-superclasses
            (set-difference old-direct-superclasses new-direct-superclasses))
          (added-direct-superclasses
            (set-difference new-direct-superclasses old-direct-superclasses)))
      (dolist (super removed-direct-superclasses)
        (remove-direct-subclass super class))
      (dolist (super added-direct-superclasses)
        (add-direct-subclass super class)))))

;; ----------------------------------------------------------------------------
;; CLtL2 28.1.5., ANSI CL 4.3.5. Determining the Class Precedence List

;; The set of all classes forms a directed graph: Class C is located
;; below the direct superclasses of C. This graph is acyclic, because
;; at the moment of definition of the class C all direct superclasses must
;; already be present.

;; Hence, one can use Noether Induction (Induction from above to below in
;; the class graph) .

;; For a class C let DS(n) be the list of all direct superclasses of C.
;; The set of all superclasses (incl. C itself) is inductively defined as
;; S(C) := {C} union union_{D in DS(C)} S(D).

;; In other words:
;; S(C) = { C_n : C_n in DS(C_{n-1}), ..., C_1 in DS(C_0), C_0 = C }

;; Lemma 1: (a) C in S(C).
;;          (b) DS(C) subset S(C).
;;          (c) D in DS(C) ==> S(D) subset S(C).
;;          (d) D in S(C) ==> S(D) subset S(C).
;; proof:  (a) follows from the definition.
;;         (b) from (a) and from the definition.
;;         (c) from the definition.
;;         (d) from (c) with fixed D via induction over C.

;; The CPL of a class C is one order of set S(C).
;; If CPL(C) = (... D1 ... D2 ...), one writes D1 < D2.
;; The relation introduced by this is a total order upon S(C).
;; The following set of restrictions has to be taken into account:
;; R(C) := union_{D in S(C)} DR(D)  with
;; DR(C) := { C < C1, C1 < C2, ..., C{n-1} < C_n } if DS(C) = (C1, ..., Cn).
;; If R(C) contains a cycle, R(C) cannot be completed into a total order,
;; of course. Then, R(C) is called inconsistent.
;; CPL(C) is constructed as follows:
;;   L := (), R := R(C).
;;   L := (L | C), remove all (C < ..) from R.
;;   while R /= {}, deal with the set M of all minimal elements of R
;;     (those classes, that can be added to L without violating R(C) ).
;;     If M is empty, then there is a cycle in R(C) and
;;     the algorithm is finished. Else, choose that element among the
;;     elements E of M, which has a D being rightmost in L with
;;     E in DS(D) .
;;     L := (L | E), remove all (E < ..) from R.
;;   CPL(C) := L.
;; L is lengthened stepwise by one element, R is shortened stepwise,
;; and R always consists solely of relations between elements
;; of S(C)\L.

;; Lemma 2: (a) CPL(C) = (C ...).
;;          (b) If DS(C) = (C1, ..., Cn), then
;;              CPL(C) = (C ... C1 ... C2 ... ... Cn ...).
;; proof:  (a) obvious by construction.
;;         (b) If Ci is added to the CPL, then the restriction
;;             C{i-1} < Ci can no longer be in R, so C{i-1} must already be
;;             in the CPL.

;; The following statement is wrong:
;; (*) If D is in DS(C) and CPL(D) = (D1, ..., Dn), then
;;     CPL(C) = (C ... D1 ... D2 ... ... Dn ...).
;; Example:
;;     z
;;    /|\             CPL(z) = (z)
;;   / | \            CPL(x) = (x z)
;;  x  |  x           CPL(y) = (y z)
;;  |  |  |           CPL(d) = (d x z)
;;  d  y  e           CPL(e) = (e x z)
;;   \/ \/            CPL(b) = (b d x y z)
;;   b   c            CPL(c) = (c y e x z)
;;    \ /             CPL(a) = (a b d c y e x z)
;;     a
;;                    CPL(a) does not contain CPL(b) !

#||
 (defclass z () ())
 (defclass x (z) ())
 (defclass y (z) ())
 (defclass d (x z) ())
 (defclass e (x z) ())
 (defclass b (d y) ())
 (defclass c (y e) ())
 (defclass a (b c) ())
 (mapcar #'find-class '(z x y d e b c a))
||#

(defun std-compute-cpl (class direct-superclasses)
  (let* ((superclasses ; list of all superclasses in any order
          (remove-duplicates
           (mapcap #'class-precedence-list direct-superclasses)))
         (L '())
         (R1 (list (cons class direct-superclasses)))
         (R2 (mapcar #'(lambda (D) (cons D (class-direct-superclasses D)))
                     superclasses)))
    (loop
      ;; L is the reversed, so far constructed CPL.
      ;; R1 is the list of the so far relevant restrictions, in the form
      ;; R1 = (... (Dj ... Dn) ...) if from DR(D) = (D1 ... Dn) only
      ;; Dj,...,Dn is left over. The order in R1 corresponds to that in L.
      ;; R2 is the list of all so far irrelevant restrictions.
      (when (null R1)
        (return)) ; R1 = R2 = () -> finished
      (let ((M (remove-duplicates (mapcar #'first R1) :from-end t)))
        (setq M (remove-if #'(lambda (E)
                               (or (dolist (r R1 nil)
                                     (when (member E (cdr r)) (return t)))
                                   (dolist (r R2 nil)
                                     (when (member E (cdr r)) (return t)))))
                           (the list M)))
        (when (null M)
          (error-of-type 'error
            (TEXT "~S ~S: inconsistent precedence graph, cycle ~S")
            'defclass (class-classname class)
            ;; find cycle: advance to ever smaller elements
            ;; with aid of the restrictions.
            (let* ((R0 (append R1 R2))
                   (cycle (list (car (first R0)))))
              (loop
                (let* ((last (car cycle))
                       (next (dolist (r R0 nil)
                               (when (member last (cdr r))
                                 (return (nth (position last (cdr r)) r))))))
                  (when (null next)
                    ;; last is now apparently a minimal element, after all!
                    (return '??))
                  (when (member next cycle)
                    (setf (cdr (member next cycle)) nil)
                    (return cycle))
                  (push next cycle))))))
        (let ((E (first M)))
          (push E L)
          (push (assoc E R2) R1)
          (setq R2 (delete E R2 :key #'first))
          (mapl #'(lambda (r) (when (eq (first (car r)) E) (pop (car r)))) R1)
          (setq R1 (delete-if #'null R1)))))
    (setq L (nreverse L))
    ;; Test, if L is compatible with the CPL(D), D in direct-superclasses:
    (mapc #'(lambda (D)
              (unless ; Is (class-precedence-list D) sublist of L ?
                  (do ((CL L)
                       (DL (class-precedence-list D) (cdr DL)))
                      ((null DL) t)
                    (when (null (setq CL (member (car DL) CL))) (return nil)))
                (clos-warning (TEXT "(class-precedence-list ~S) and (class-precedence-list ~S) are inconsistent")
                  class D)))
          direct-superclasses)
    L))

(defun compute-class-precedence-list-<defined-class> (class)
  (std-compute-cpl class (class-direct-superclasses class)))

;; Preliminary.
(predefun compute-class-precedence-list (class)
  (compute-class-precedence-list-<defined-class> class))

(defun checked-compute-class-precedence-list (class)
  (let ((cpl (compute-class-precedence-list class))
        (name (class-name class)))
    ; Some checks, to guarantee that user-defined methods on
    ; compute-class-precedence-list don't break our CLOS.
    (unless (proper-list-p cpl)
      (error (TEXT "Wrong ~S result for class ~S: not a proper list: ~S")
             'compute-class-precedence-list name cpl))
    (dolist (c cpl)
      (unless (defined-class-p c)
        (error (TEXT "Wrong ~S result for class ~S: list element is not a class: ~S")
               'compute-class-precedence-list name c)))
    (unless (eq (first cpl) class)
      (error (TEXT "Wrong ~S result for class ~S: list doesn't start with the class itself: ~S")
             'compute-class-precedence-list name cpl))
    (unless (or (eq name 't) ; for bootstrapping
                (eq (car (last cpl)) <t>))
      (error (TEXT "Wrong ~S result for class ~S: list doesn't end with ~S: ~S")
             'compute-class-precedence-list name <t> cpl))
    (unless (= (length cpl) (length (remove-duplicates cpl :test #'eq)))
      (error (TEXT "Wrong ~S result for class ~S: list contains duplicates: ~S")
             'compute-class-precedence-list name cpl))
    (let ((superclasses (reduce #'union
                                (mapcar #'class-precedence-list
                                        (class-direct-superclasses class))
                                :initial-value '())))
      (let ((forgotten (set-difference superclasses cpl)))
        (when forgotten
          (error (TEXT "Wrong ~S result for class ~S: list doesn't contain the superclass~[~;~:;es~] ~{~S~^, ~}.")
                 'compute-class-precedence-list name (length forgotten) forgotten)))
      (let ((extraneous (set-difference (rest cpl) superclasses)))
        (when extraneous
          (error (TEXT "Wrong ~S result for class ~S: list contains elements that are not superclasses: ~{~S~^, ~}")
                 'compute-class-precedence-list name extraneous))))
    ; Now we've checked the CPL is OK.
    cpl))

;; Stuff all superclasses (from the precedence-list) into a hash-table.
(defun std-compute-superclasses (precedence-list)
  (let ((ht (make-hash-table :key-type 'defined-class :value-type '(eql t)
                             :test 'ext:stablehash-eq :warn-if-needs-rehash-after-gc t)))
    (mapc #'(lambda (superclass) (setf (gethash superclass ht) t))
          precedence-list)
    ht))

;; Determine whether a class inherits from <standard-stablehash> or
;; <structure-stablehash>.
(defun std-compute-subclass-of-stablehash-p (class)
  (dolist (superclass (class-precedence-list class) nil)
    (let ((superclassname (class-classname superclass)))
      (when (or (eq superclassname 'standard-stablehash)
                (eq superclassname 'structure-stablehash))
        (return t)))))

;; ----------------------------------------------------------------------------
;; CLtL2 28.1.3.2., ANSI CL 7.5.3. Inheritance of Slots and Slot Options

(defun compute-effective-slot-definition-initargs-<defined-class> (class directslotdefs)
  (declare (ignore class))
  (unless (and (proper-list-p directslotdefs) (consp directslotdefs))
    (error (TEXT "~S: argument should be a non-empty proper list, not ~S")
           'compute-effective-slot-definition-initargs directslotdefs))
  (dolist (slot directslotdefs)
    (unless (direct-slot-definition-p slot)
      (error (TEXT "~S: argument list element is not a ~S: ~S")
             'compute-effective-slot-definition-initargs 'direct-slot-definition
             slot)))
  (let ((name (slot-definition-name (first directslotdefs))))
    (dolist (slot (rest directslotdefs))
      (unless (eql name (slot-definition-name slot))
        (error (TEXT "~S: argument list elements should all have the same name, not ~S and ~S")
               'compute-effective-slot-definition-initargs name (slot-definition-name slot))))
    `(:name ,name
      ; "The allocation of a slot is controlled by the most
      ;  specific slot specifier."
      :allocation ,(slot-definition-allocation (first directslotdefs))
      ; "The set of initialization arguments that initialize a
      ;  given slot is the union of the initialization arguments
      ;  declared in the :initarg slot options in all the slot
      ;  specifiers.
      ,@(let ((initargs
                (remove-duplicates
                  (mapcap #'slot-definition-initargs directslotdefs)
                  :from-end t)))
          (if initargs `(:initargs ,initargs)))
      ; "The default initial value form for a slot is the value
      ;  of the :initform slot option in the most specific slot
      ;  specifier that contains one."
      ,@(dolist (slot directslotdefs '())
          (when (slot-definition-initfunction slot)
            (return `(:initform ,(slot-definition-initform slot)
                      :initfunction ,(slot-definition-initfunction slot)
                      inheritable-initer ,(slot-definition-inheritable-initer slot)))))
      ; "The contents of a slot will always be of type
      ;  (and T1 ... Tn) where T1 ...Tn are the values of the
      ;  :type slot options contained in all of the slot specifiers."
      ,@(let ((types '()))
          (dolist (slot directslotdefs)
            (push (slot-definition-type slot) types))
          `(:type ,(if types `(AND ,@(nreverse types)) 'T)))
      ; "The documentation string for a slot is the value of the
      ;  :documentation slot option in the most specific slot
      ;  specifier that contains one."
      ,@(dolist (slot directslotdefs '())
          (when (slot-definition-documentation slot)
            (return `(:documentation ,(slot-definition-documentation slot)
                      inheritable-doc ,(slot-definition-inheritable-doc slot)))))
      #|| ; Commented out because <effective-slot-definition>
          ; doesn't have readers and writers.
      ,@(let ((readers (mapcap #'slot-definition-readers directslotdefs)))
          (if readers `(:readers ,readers)))
      ,@(let ((writers (mapcap #'slot-definition-writers directslotdefs)))
          (if writers `(:writers ,writers)))
      ||#
     )))

;; Preliminary.
(predefun compute-effective-slot-definition-initargs (class direct-slot-definitions)
  (compute-effective-slot-definition-initargs-<defined-class> class direct-slot-definitions))

(defun compute-effective-slot-definition-<defined-class> (class name directslotdefs)
  (let ((args (compute-effective-slot-definition-initargs class directslotdefs)))
    ; Some checks, to guarantee that user-defined primary methods on
    ; compute-effective-slot-definition-initargs don't break our CLOS.
    (unless (and (proper-list-p args) (evenp (length args)))
      (error (TEXT "Wrong ~S result for ~S: not a list of keyword/value pairs: ~S")
             'compute-effective-slot-definition-initargs class args))
    (let* ((default '#:default)
           (returned-name (getf args ':name '#:default)))
      (unless (eql returned-name name)
        (if (eq returned-name default)
          (error (TEXT "Wrong ~S result for ~S: missing ~S")
                 'compute-effective-slot-definition-initargs class ':name)
          (error (TEXT "Wrong ~S result for ~S: invalid ~S value")
                 'compute-effective-slot-definition-initargs class ':name))))
    (let ((slot-definition-class
            (apply #'effective-slot-definition-class class args)))
      (cond ((semi-standard-class-p class)
             (unless (or ; for bootstrapping
                         (eq slot-definition-class 'standard-effective-slot-definition)
                         (and (defined-class-p slot-definition-class)
                              (subclassp slot-definition-class <standard-effective-slot-definition>)))
               (error (TEXT "Wrong ~S result for class ~S: not a subclass of ~S: ~S")
                      'effective-slot-definition-class (class-name class)
                      'standard-effective-slot-definition slot-definition-class)))
            ((structure-class-p class)
             (unless (and (defined-class-p slot-definition-class)
                          (subclassp slot-definition-class <structure-effective-slot-definition>))
               (error (TEXT "Wrong ~S result for class ~S: not a subclass of ~S: ~S")
                      'effective-slot-definition-class (class-name class)
                      'structure-effective-slot-definition slot-definition-class))))
      (apply (cond ((eq slot-definition-class 'standard-effective-slot-definition)
                    #'make-instance-<standard-effective-slot-definition>)
                   (t #'make-instance))
             slot-definition-class args))))

;; Preliminary.
(predefun compute-effective-slot-definition (class slotname direct-slot-definitions)
  (compute-effective-slot-definition-<defined-class> class slotname direct-slot-definitions))

(defun compute-slots-<defined-class>-primary (class)
  ;; Gather all slot-specifiers, ordered by precedence:
  (let ((all-slots
          (mapcan #'(lambda (c) (nreverse (copy-list (class-direct-slots c))))
                  (class-precedence-list class))))
    ;; Partition by slot-names:
    (setq all-slots
          (let ((ht (make-hash-table :key-type 'symbol :value-type 't
                                     :test 'ext:stablehash-eql :warn-if-needs-rehash-after-gc t)))
            (dolist (slot all-slots)
              (let ((slot-name (slot-definition-name slot)))
                (push slot (gethash slot-name ht nil))))
            (let ((L nil))
              (maphash #'(lambda (name slot-list)
                           (push (cons name (nreverse slot-list)) L))
                       ht)
              L))) ; not (nreverse L), because maphash reverses the order
    ;; Bring the slots into final order: Superclass before subclass, and
    ;; inside each class, keeping the same order as in the direct-slots.
    (setq all-slots (nreverse all-slots))
    ;; all-slots is now a list of lists of the form
    ;; (name most-specific-slot ... least-specific-slot).
    (mapcar
      #'(lambda (slotbag)
          (let ((name (car slotbag))
                (directslotdefs (cdr slotbag)))
            ;; Create the effective slot definition in a way that depends
            ;; only on the class, name, and direct-slot-definitions.
            (let ((eff-slot
                    (compute-effective-slot-definition class name directslotdefs)))
              ; Some checks, to guarantee that user-defined methods on
              ; compute-effective-slot-definition don't break our CLOS.
              (unless (effective-slot-definition-p eff-slot)
                (error (TEXT "Wrong ~S result for class ~S, slot ~S: not an ~S instance: ~S")
                       'compute-effective-slot-definition class name 'effective-slot-definition eff-slot))
              eff-slot)))
      all-slots)))

;; Allocation of local and shared slots.
;; Side effects done by this function: The slot-definition-location of the
;; slots is determined.
(defun compute-slots-<slotted-class>-around (class next-method)
  (let ((cpl (class-precedence-list class))
        (slots (funcall next-method class)))
    ; Some checks, to guarantee that user-defined primary methods on
    ; compute-slots don't break our CLOS.
    (unless (proper-list-p slots)
      (error (TEXT "Wrong ~S result for class ~S: not a proper list: ~S")
             'compute-slots (class-name class) slots))
    (cond ((semi-standard-class-p class)
           (dolist (slot slots)
             (unless (standard-effective-slot-definition-p slot)
               (error (TEXT "Wrong ~S result for class ~S: list element is not a ~S: ~S")
                      'compute-slots (class-name class)
                      'standard-effective-slot-definition slot))))
          ((structure-class-p class)
           (dolist (slot slots)
             (unless (typep-class slot <structure-effective-slot-definition>)
               (error (TEXT "Wrong ~S result for class ~S: list element is not a ~S: ~S")
                      'compute-slots (class-name class)
                      'structure-effective-slot-definition slot)))))
    (unless (= (length slots)
               (length (delete-duplicates (mapcar #'slot-definition-name slots))))
      (error (TEXT "Wrong ~S result for class ~S: list contains duplicate slot names: ~S")
             'compute-slots (class-name class) slots))
    ;; Implementation of fixed-slot-locations policy.
    (let ((superclasses-with-fixed-slot-locations
            (remove-if-not #'(lambda (c)
                               (and (semi-standard-class-p c)
                                    (class-fixed-slot-locations c)))
                           (cdr (class-precedence-list class)))))
      (when superclasses-with-fixed-slot-locations
        (dolist (slot slots)
          (let ((name (slot-definition-name slot))
                (location nil))
            (dolist (superclass superclasses-with-fixed-slot-locations)
              (let ((slot-in-superclass (find name (class-slots superclass)
                                              :key #'slot-definition-name)))
                (when slot-in-superclass
                  (when (eq (slot-definition-allocation slot-in-superclass) ':instance)
                    (let ((guaranteed-location
                            (slot-definition-location slot-in-superclass)))
                      (assert (integerp guaranteed-location))
                      (if location
                        (unless (equal location guaranteed-location)
                          (error (TEXT "In class ~S, the slot ~S is constrained by incompatible constraints inherited from the superclasses.")
                                 (class-name class) name))
                        (setq location guaranteed-location)))))))
            (when location
              (unless (eq (slot-definition-allocation slot) ':instance)
                (error (TEXT "In class ~S, non-local slot ~S is constrained to be a local slot at offset ~S.")
                       (class-name class) name location))
              (setf (slot-definition-location slot) location))))))
    (let ((constrained-indices
            (let ((constrained-slots (remove-if-not #'slot-definition-location slots)))
              (setq constrained-slots (copy-list constrained-slots))
              (setq constrained-slots (sort constrained-slots #'< :key #'slot-definition-location))
              (do ((l constrained-slots (cdr l)))
                  ((null (cdr l)))
                (when (= (slot-definition-location (car l)) (slot-definition-location (cadr l)))
                  (error (TEXT "In class ~S, the slots ~S and ~S are constrained from the superclasses to both be located at offset ~S.")
                         (class-name class)
                         (slot-definition-name (car l)) (slot-definition-name (cadr l))
                         (slot-definition-location (car l)))))
              (mapcar #'slot-definition-location constrained-slots)))
          (local-index (class-instance-size class))
          (shared-index 0))
      ;; Actually the constrained-indices must form a list of consecutive indices
      ;; (1 2 ... n), but we don't need to make use of this.
      ;; Now determine the location of each slot.
      (when (and constrained-indices (< (first constrained-indices) local-index))
        (error (TEXT "In class ~S, a slot constrained from a superclass wants to be located at offset ~S, which is impossible.")
               (class-name class) (first constrained-indices)))
      (flet ((skip-constrained-indices ()
               (loop
                 (if (and constrained-indices
                          (= (first constrained-indices) local-index))
                   (progn (incf local-index) (pop constrained-indices))
                   (return)))))
        (skip-constrained-indices)
        (dolist (slot slots)
          (let ((name (slot-definition-name slot))
                (allocation (slot-definition-allocation slot)))
            (setf (slot-definition-location slot)
                  (cond ((eq allocation ':instance)
                         ;; Local slot.
                         (or (slot-definition-location slot)
                             (prog1
                               local-index
                               (incf local-index)
                               (skip-constrained-indices))))
                        ((eq allocation ':class)
                         ;; Shared slot.
                         ;; This is a flaw in the compute-slots protocol: the
                         ;; primary compute-slots method returns a list of slots,
                         ;; without information about the class where the slot
                         ;; comes from. So we have to re-scan the direct slots
                         ;; lists.
                         (let ((origin
                                 (dolist (superclass cpl class)
                                   (when (find name (class-direct-slots superclass)
                                               :key #'slot-definition-name)
                                     (return superclass)))))
                           (if (eq origin class)
                             ;; New shared slot.
                             (prog1
                               (cons (class-current-version class) shared-index)
                               (incf shared-index))
                             ;; Inherited shared slot.
                             (let ((inh-descriptor
                                     (gethash name (class-slot-location-table origin))))
                               (if (effective-slot-definition-p inh-descriptor)
                                 (slot-definition-location inh-descriptor)
                                 inh-descriptor)))))
                        (t ;; Don't signal an error for user-defined allocation
                           ;; types. They can be handled by user-defined around
                           ;; methods.
                           nil))))))
      ;; Actually the constrained-indices must already have been emptied by
      ;; the first (skip-constrained-indices) call, but we don't need to make
      ;; use of this. Warn if :fixed-slot-locations would cause a waste of
      ;; space.
      (when constrained-indices
        (setq local-index (1+ (car (last constrained-indices))))
        (clos-warning (TEXT "In class ~S, constrained slot locations cause holes to appear.")
          (class-name class)))
      slots)))

;; Preliminary.
(predefun compute-slots (class)
  (compute-slots-<slotted-class>-around class #'compute-slots-<defined-class>-primary))

(defun checked-compute-slots (class)
  (let ((slots (compute-slots class)))
    ; Some checks, to guarantee that user-defined around methods on
    ; compute-slots don't break our CLOS.
    (unless (proper-list-p slots)
      (error (TEXT "Wrong ~S result for class ~S: not a proper list: ~S")
             'compute-slots (class-name class) slots))
    (dolist (slot slots)
      (unless (standard-effective-slot-definition-p slot)
        (error (TEXT "Wrong ~S result for class ~S: list element is not a ~S: ~S")
               'compute-slots (class-name class)
               'standard-effective-slot-definition slot)))
    (unless (= (length slots)
               (length (delete-duplicates (mapcar #'slot-definition-name slots))))
      (error (TEXT "Wrong ~S result for class ~S: list contains duplicate slot names: ~S")
             'compute-slots (class-name class) slots))
    (dolist (slot slots)
      (case (slot-definition-allocation slot)
        ((:INSTANCE :CLASS)
         (unless (slot-definition-location slot)
           (error (TEXT "Wrong ~S result for class ~S: no slot location has been assigned to ~S")
                  'compute-slots (class-name class) slot)))))
    slots))

;; The MOP lacks a way to customize the instance size as a function of the
;; slots. This becomes an issue when you have slots which occupy more than one
;; word, and such a slot is the last local slot.
(defun compute-instance-size (class)
  (let ((size (class-instance-size class))) ; initial size depends on the metaclass
    (dolist (slot (class-slots class))
      (when (eq (slot-definition-allocation slot) ':instance)
        (let ((location (slot-definition-location slot)))
          (assert (integerp location))
          (setq size (max size (+ location 1))))))
    size))

;; Similarly, the MOP lacks a way to customize the shared slot values vector's
;; size as a function of the slots.
(defun compute-shared-size (class)
  (let ((shared-size 0))
    (dolist (slot (class-slots class))
      (let ((location (slot-definition-location slot)))
        (when (and (consp location) (eq (cv-newest-class (car location)) class))
          (let ((shared-index (cdr location)))
            (setq shared-size (max shared-size (+ shared-index 1)))))))
    shared-size))

;; Creates the shared slot values vector for a class.
(defun create-shared-slots-vector (class shared-size old-slot-location-table)
  (let ((v (make-array shared-size :initial-element 'DEADBEEF)))
    (dolist (slot (class-slots class))
      (let ((location (slot-definition-location slot)))
        (when (and (consp location)
                   (eq (cv-newest-class (car location)) class))
          (let ((shared-index (cdr location)))
            (setf (svref v shared-index)
                  (let* ((old-slot-descriptor
                           (gethash (slot-definition-name slot) old-slot-location-table))
                         (old-slot-location
                           (if (effective-slot-definition-p old-slot-descriptor)
                             (slot-definition-location old-slot-descriptor)
                             old-slot-descriptor)))
                    (if (and (consp old-slot-location)
                             (eq (cv-newest-class (car old-slot-location)) class))
                      ;; The slot was already shared. Retain its value.
                      (svref (cv-shared-slots (car old-slot-location))
                             (cdr old-slot-location))
                      ;; A new shared slot.
                      (let ((initfunction (slot-definition-initfunction slot)))
                        (if initfunction
                          (funcall initfunction)
                          (sys::%unbound))))))))))
    v))

(defun compute-slot-location-table (class)
  (let ((slots (class-slots class)))
    (if slots
      (make-hash-table
        :key-type 'symbol :value-type 't
        :test 'ext:stablehash-eq :warn-if-needs-rehash-after-gc t
        :initial-contents
          (mapcar #'(lambda (slot)
                      (cons (slot-definition-name slot)
                            (compute-slot-location-table-entry class slot)))
                  slots))
      empty-ht)))

(defun compute-slot-location-table-entry (class slot)
  (let ((location (slot-definition-location slot))
        ;; Compute the effective methods of SLOT-VALUE-USING-CLASS etc.
        ;; Note that we cannot use (class-prototype class) yet.
        ;; Also, SLOT-VALUE-USING-CLASS etc. are not defined on STRUCTURE-CLASS.
        (efm-svuc
          (if (and (semi-standard-class-p class) *classes-finished*)
            (compute-applicable-methods-effective-method-for-set
              |#'slot-value-using-class|
              (list `(EQL ,class) `(INSTANCE-OF-P ,class) `(EQL ,slot))
              (list class '`(CLASS-PROTOTYPE ,class) slot))
            #'%slot-value-using-class))
        (efm-ssvuc
          (if (and (semi-standard-class-p class) *classes-finished*)
            (compute-applicable-methods-effective-method-for-set
              |#'(setf slot-value-using-class)|
              (list `(TYPEP ,<t>) `(EQL ,class) `(INSTANCE-OF-P ,class) `(EQL ,slot))
              (list 'ANY-VALUE class '`(CLASS-PROTOTYPE ,class) slot))
            #'%set-slot-value-using-class))
        (efm-sbuc
          (if (and (semi-standard-class-p class) *classes-finished*)
            (compute-applicable-methods-effective-method-for-set
              |#'slot-boundp-using-class|
              (list `(EQL ,class) `(INSTANCE-OF-P ,class) `(EQL ,slot))
              (list class '`(CLASS-PROTOTYPE ,class) slot))
            #'%slot-boundp-using-class))
        (efm-smuc
          (if (and (semi-standard-class-p class) *classes-finished*)
            (compute-applicable-methods-effective-method-for-set
              |#'slot-makunbound-using-class|
              (list `(EQL ,class) `(INSTANCE-OF-P ,class) `(EQL ,slot))
              (list class '`(CLASS-PROTOTYPE ,class) slot))
            #'%slot-makunbound-using-class)))
    (setf (slot-definition-efm-svuc slot) efm-svuc)
    (setf (slot-definition-efm-ssvuc slot) efm-ssvuc)
    (setf (slot-definition-efm-sbuc slot) efm-sbuc)
    (setf (slot-definition-efm-smuc slot) efm-smuc)
    (if (and (eq efm-svuc #'%slot-value-using-class)
             (eq efm-ssvuc #'%set-slot-value-using-class)
             (eq efm-sbuc #'%slot-boundp-using-class)
             (eq efm-smuc #'%slot-makunbound-using-class))
      location
      slot)))

;; ----------------------------------------------------------------------------
;; CLtL2 28.1.3.3., ANSI CL 4.3.4.2. Inheritance of Default-Initargs

(defun compute-default-initargs-<defined-class> (class)
  (remove-duplicates
    (mapcap #'class-direct-default-initargs (class-precedence-list class))
    :key #'car
    :from-end t))

;; Preliminary.
(predefun compute-default-initargs (class)
  (compute-default-initargs-<defined-class> class))

(defun checked-compute-default-initargs (class)
  (let ((default-initargs (compute-default-initargs class)))
    ; Some checks, to guarantee that user-defined methods on
    ; compute-default-initargs don't break our CLOS.
    (unless (proper-list-p default-initargs)
      (error (TEXT "Wrong ~S result for class ~S: not a proper list: ~S")
             'compute-default-initargs (class-name class) default-initargs))
    (dolist (di default-initargs)
      (unless (canonicalized-default-initarg-p di)
        (error (TEXT "Wrong ~S result for class ~S: list element is not a canonicalized default initarg: ~S")
               'compute-default-initargs (class-name class) di)))
    (unless (= (length default-initargs)
               (length (delete-duplicates (mapcar #'first default-initargs))))
      (error (TEXT "Wrong ~S result for class ~S: list contains duplicate initarg names: ~S")
             'compute-default-initargs (class-name class) default-initargs))
    default-initargs))

;; ----------------------------- Accessor Methods -----------------------------

;; Flag to avoid bootstrapping issues with the compiler.
(defvar *compile-accessor-functions* nil)

(defun check-method-redefinition (funname qualifiers spec-list caller)
  (sys::check-redefinition
   (list* funname qualifiers spec-list) caller
   ;; do not warn about redefinition when no method was defined
   (and (fboundp 'find-method) (fboundp funname)
        (typep-class (fdefinition funname) <generic-function>)
        (not (safe-gf-undeterminedp (fdefinition funname)))
        (eql (sig-req-num (safe-gf-signature (fdefinition funname)))
             (length spec-list))
        (find-method (fdefinition funname) qualifiers spec-list nil)
        (TEXT "method"))))

;; Install the accessor methods corresponding to the direct slots of a class.
(defun install-class-direct-accessors (class)
  (dolist (slot (class-direct-slots class))
    (let ((slot-name (slot-definition-name slot))
          (readers (slot-definition-readers slot))
          (writers (slot-definition-writers slot)))
      (when (or readers writers)
        (let ((generic-p (class-generic-accessors class))
              (access-place
                (let (effective-slot)
                  (if (and (semi-standard-class-p class)
                           (class-fixed-slot-locations class)
                           (setq effective-slot
                                 (find slot-name (class-slots class)
                                       :key #'slot-definition-name))
                           (eq (slot-definition-allocation effective-slot)
                               ':instance))
                    (progn
                      (assert (typep (slot-definition-location effective-slot) 'integer))
                      `(STANDARD-INSTANCE-ACCESS OBJECT ,(slot-definition-location effective-slot)))
                    (if (and (structure-class-p class)
                             (setq effective-slot
                                   (find slot-name (class-slots class)
                                         :key #'slot-definition-name))
                             (eq (slot-definition-allocation effective-slot)
                                 ':instance))
                      (progn
                        (assert (typep (slot-definition-location effective-slot) 'integer))
                        `(SYSTEM::%STRUCTURE-REF ',(class-name class) OBJECT ,(slot-definition-location effective-slot)))
                      `(SLOT-VALUE OBJECT ',slot-name))))))
          ;; Generic accessors are defined as methods and listed in the
          ;; direct-accessors list, so they can be removed upon class redefinition.
          ;; Non-generic accessors are defined as plain functions.
          ;; Call CHECK-REDEFINITION appropriately.
          (dolist (funname readers)
            (if generic-p
              (progn
                (check-method-redefinition funname nil (list class) 'defclass)
                (setf (class-direct-accessors class)
                      (list* funname
                             (do-defmethod funname
                               (let* ((args
                                       (list
                                        :specializers (list class)
                                        :qualifiers nil
                                        :lambda-list '(OBJECT)
                                        'signature (sys::memoized (make-signature :req-num 1))
                                        :slot-definition slot))
                                      (method-class
                                       (apply #'reader-method-class
                                              class slot args)))
                                 (unless (and (defined-class-p method-class)
                                              (subclassp method-class <standard-reader-method>))
                                   (error (TEXT "Wrong ~S result for class ~S: not a subclass of ~S: ~S")
                                          'reader-method-class (class-name class) 'standard-reader-method method-class))
                                 (apply #'make-instance method-class
                                        (nconc (method-function-initargs
                                                method-class
                                                (eval
                                                 `(LOCALLY (DECLARE (COMPILE
                                                                     ,funname))
                                                    (%OPTIMIZE-FUNCTION-LAMBDA
                                                     (T) (#:CONTINUATION OBJECT)
                                                     (DECLARE (COMPILE))
                                                     ,access-place))))
                                               args))))
                             (class-direct-accessors class))))
              (progn
                (sys::check-redefinition
                 funname 'defclass (sys::fbound-string funname))
                (setf (fdefinition funname)
                      (eval `(FUNCTION ,funname (LAMBDA (OBJECT)
                               ,@(if *compile-accessor-functions*
                                     `((DECLARE (COMPILE ,funname))))
                               (UNLESS (TYPEP OBJECT ',class)
                                 (ERROR-ACCESSOR-TYPECHECK ',funname OBJECT ',class))
                               ,access-place)))))))
          (dolist (funname writers)
            (if generic-p
              (progn
                (check-method-redefinition funname nil (list class) 'defclass)
                (setf (class-direct-accessors class)
                      (list* funname
                             (do-defmethod funname
                               (let* ((args
                                       (list
                                        :specializers (list <t> class)
                                        :qualifiers nil
                                        :lambda-list '(NEW-VALUE OBJECT)
                                        'signature (sys::memoized (make-signature :req-num 2))
                                        :slot-definition slot))
                                      (method-class
                                       (apply #'writer-method-class
                                              class slot args)))
                                 (unless (and (defined-class-p method-class)
                                              (subclassp method-class <standard-writer-method>))
                                   (error (TEXT "Wrong ~S result for class ~S: not a subclass of ~S: ~S")
                                          'writer-method-class
                                          (class-name class)
                                          'standard-writer-method method-class))
                                 (apply #'make-instance method-class
                                        (nconc (method-function-initargs
                                                method-class
                                                (eval
                                                 `(LOCALLY (DECLARE (COMPILE
                                                                     ,funname))
                                                    (%OPTIMIZE-FUNCTION-LAMBDA
                                                     (T) (#:CONTINUATION NEW-VALUE OBJECT)
                                                     (DECLARE (COMPILE))
                                                     (SETF ,access-place NEW-VALUE)))))
                                               args))))
                             (class-direct-accessors class))))
              (progn
                (sys::check-redefinition
                 funname 'defclass (sys::fbound-string
                                    (sys::get-funname-symbol funname)))
                (setf (fdefinition funname)
                      (eval `(FUNCTION ,funname (LAMBDA (NEW-VALUE OBJECT)
                               ,@(if *compile-accessor-functions*
                                     `((DECLARE (COMPILE ,funname))))
                               (UNLESS (TYPEP OBJECT ',class)
                                 (ERROR-ACCESSOR-TYPECHECK ',funname OBJECT ',class))
                               (SETF ,access-place NEW-VALUE)))))))))))))

;; Remove a set of accessor methods given as a plist.
(defun remove-accessor-methods (plist)
  (do ((l plist (cddr l)))
      ((endp l))
    (let ((funname (car l))
          (method (cadr l)))
      (remove-method (fdefinition funname) method))))

;; Add a set of accessor methods given as a plist.
(defun add-accessor-methods (plist)
  (do ((l plist (cddr l)))
      ((endp l))
    (let ((funname (car l))
          (method (cadr l)))
      (add-method (fdefinition funname) method))))

;; --------------- Creation of an instance of <built-in-class> ---------------

(defun make-instance-<built-in-class> (metaclass &rest args
                                       &key name (direct-superclasses '())
                                       &allow-other-keys)
  ;; metaclass = <built-in-class>
  ;; Don't add functionality here! This is a preliminary definition that is
  ;; replaced with #'make-instance later.
  (declare (ignore metaclass name direct-superclasses))
  (let ((class (allocate-metaobject-instance *<built-in-class>-class-version*
                                             *<built-in-class>-instance-size*)))
    (apply #'initialize-instance-<built-in-class> class args)))

(defun initialize-instance-<built-in-class> (class &rest args
                                             &key &allow-other-keys)
  ;; Don't add functionality here! This is a preliminary definition that is
  ;; replaced with #'initialize-instance later.
  (apply #'shared-initialize-<built-in-class> class 't args)
  (install-class-direct-accessors class)
  class)

(defun shared-initialize-<built-in-class> (class situation &rest args
                                           &key (name nil name-p)
                                                (direct-superclasses '() direct-superclasses-p)
                                                ((prototype prototype) nil prototype-p)
                                           &allow-other-keys)
  (when (or (eq situation 't) direct-superclasses-p)
    (check-metaclass-mix (if name-p name (class-classname class))
                         direct-superclasses
                         #'built-in-class-p 'built-in-class))
  (apply #'shared-initialize-<defined-class> class situation args)
  ; Initialize the remaining <defined-class> slots:
  (when (or (eq situation 't) direct-superclasses-p)
    (setf (class-precedence-list class)
          (checked-compute-class-precedence-list class))
    (when (eq situation 't)
      (setf (class-initialized class) 3))
    (setf (class-all-superclasses class)
          (std-compute-superclasses (class-precedence-list class)))
    (when (eq situation 't)
      (setf (class-initialized class) 4)))
  (when (eq situation 't)
    (setf (class-slots class) '())
    (setf (class-initialized class) 5)
    (setf (class-default-initargs class) '())
    (setf (class-initialized class) 6))
  (when (or (eq situation 't) prototype-p)
    (setf (sys::%record-ref class *<built-in-class>-prototype-location*) prototype))
  ; Done.
  class)

;; --------------- Creation of an instance of <structure-class> ---------------

(defun make-instance-<structure-class> (metaclass &rest args
                                        &key name (direct-superclasses '())
                                             ;; The following keys come from ENSURE-CLASS.
                                             ((:direct-slots direct-slots-as-lists) '())
                                             (direct-default-initargs '())
                                             ;; The following keys come from DEFINE-STRUCTURE-CLASS.
                                             ((names names) nil)
                                             ((kconstructor kconstructor) nil)
                                             ((boa-constructors boa-constructors) '())
                                             ((copier copier) nil)
                                             ((predicate predicate) nil)
                                             (documentation nil)
                                             ((direct-slots direct-slots-as-metaobjects) '())
                                             ((slots slots) '()) ((size size) 1)
                                        &allow-other-keys)
  ;; metaclass = <structure-class>
  ;; Don't add functionality here! This is a preliminary definition that is
  ;; replaced with #'make-instance later.
  (declare (ignore metaclass name direct-superclasses direct-slots-as-lists
                   direct-default-initargs documentation
                   names kconstructor boa-constructors copier predicate
                   direct-slots-as-metaobjects slots size))
  (let ((class (allocate-metaobject-instance *<structure-class>-class-version*
                                             *<structure-class>-instance-size*)))
    (apply #'initialize-instance-<structure-class> class args)))

(defun initialize-instance-<structure-class> (class &rest args
                                              &key &allow-other-keys)
  ;; Don't add functionality here! This is a preliminary definition that is
  ;; replaced with #'initialize-instance later.
  (apply #'shared-initialize-<structure-class> class 't args)
  ;; avoid slot accessor redefinition warning
  ;; (install-class-direct-accessors class)
  class)

(defun shared-initialize-<structure-class> (class situation &rest args
                                            &key (name nil name-p)
                                                 (direct-superclasses '() direct-superclasses-p)
                                                 (generic-accessors t generic-accessors-p)
                                                 ;; The following keys come from ENSURE-CLASS.
                                                 ((:direct-slots direct-slots-as-lists) '() direct-slots-as-lists-p)
                                                 (direct-default-initargs '() direct-default-initargs-p)
                                                 ;; The following keys come from DEFINE-STRUCTURE-CLASS.
                                                 (documentation nil documentation-p)
                                                 ((names names) nil names-p)
                                                 ((kconstructor kconstructor) nil kconstructor-p)
                                                 ((boa-constructors boa-constructors) '() boa-constructors-p)
                                                 ((copier copier) nil copier-p)
                                                 ((predicate predicate) nil predicate-p)
                                                 ((direct-slots direct-slots-as-metaobjects) '() direct-slots-as-metaobjects-p)
                                                 ((slots slots) '())
                                                 ((size size) 1)
                                            &allow-other-keys)
  ;; metaclass  <structure-class>
  (declare (ignore generic-accessors generic-accessors-p direct-slots-as-lists
                   direct-slots-as-metaobjects direct-default-initargs))
  (when (or (eq situation 't) direct-superclasses-p)
    (check-metaclass-mix (if name-p name (class-classname class))
                         direct-superclasses
                         #'structure-class-p 'STRUCTURE-CLASS))
  (apply #'shared-initialize-<slotted-class> class situation args)
  (setq direct-superclasses (class-direct-superclasses class)) ; augmented
  ; Initialize the remaining <defined-class> slots:
  (when (or (eq situation 't) direct-superclasses-p)
    (setf (class-precedence-list class)
          (checked-compute-class-precedence-list class))
    (when (eq situation 't)
      (setf (class-initialized class) 3))
    (setf (class-all-superclasses class)
          (std-compute-superclasses (class-precedence-list class)))
    (when (eq situation 't)
      (setf (class-initialized class) 4)))
  (when (or (eq situation 't) direct-superclasses-p
            direct-slots-as-lists-p direct-slots-as-metaobjects-p)
    (setf (class-slots class) slots)
    (when (eq situation 't)
      (setf (class-initialized class) 5))
    (setf (class-slot-location-table class) (compute-slot-location-table class))
    (setf (class-instance-size class) size)
    (unless names
      (setf (class-instance-size class) 1)
      (setf (class-slots class)
            (compute-slots-<slotted-class>-around class #'compute-slots-<defined-class>-primary))
      (setf (class-instance-size class) (max size (compute-instance-size class)))
      (when (class-slots class)
        (let ((ht (class-slot-location-table class)))
          (when (eq ht empty-ht) ; avoid clobbering empty-ht!
            (setq ht (setf (class-slot-location-table class)
                           (make-hash-table
                             :key-type 'symbol :value-type 't
                             :test 'ext:stablehash-eq :warn-if-needs-rehash-after-gc t))))
          (dolist (slot (class-slots class))
            (setf (gethash (slot-definition-name slot) ht)
                  (slot-definition-location slot)))))
      (when (plusp (compute-shared-size class))
        (error-of-type 'error
          (TEXT "(~S ~S): metaclass ~S does not support shared slots")
                'DEFCLASS name 'STRUCTURE-CLASS))))
  (when documentation-p
    (setf (class-documentation class) documentation))
  (when (or (eq situation 't) direct-superclasses-p direct-default-initargs-p)
    (setf (class-default-initargs class)
          (checked-compute-default-initargs class)))
  (when (eq situation 't)
    (setf (class-initialized class) 6))
  ; Initialize the remaining <slotted-class> slots:
  (when (or (eq situation 't) direct-superclasses-p)
    (setf (class-subclass-of-stablehash-p class)
          (std-compute-subclass-of-stablehash-p class)))
  (when (or (eq situation 't) direct-superclasses-p
            direct-slots-as-lists-p direct-slots-as-metaobjects-p)
    (setf (class-valid-initargs-from-slots class)
          (remove-duplicates (mapcap #'slot-definition-initargs (class-slots class)))))
  ; Initialize the remaining <structure-class> slots:
  (when (or (eq situation 't) direct-superclasses-p names-p)
    (unless names
      (setq names
            (cons name
                  (if direct-superclasses
                     (class-names (first direct-superclasses))
                     '()))))
    (setf (class-names class) names))
  (when (or (eq situation 't) kconstructor-p)
    (setf (class-kconstructor class) kconstructor))
  (when (or (eq situation 't) boa-constructors-p)
    (setf (class-boa-constructors class) boa-constructors))
  (when (or (eq situation 't) copier-p)
    (setf (class-copier class) copier))
  (when (or (eq situation 't) predicate-p)
    (setf (class-predicate class) predicate))
  (when (eq situation 't)
    (setf (sys::%record-ref class *<structure-class>-prototype-location*) nil))
  ; Done.
  (when (eq situation 't)
    (system::note-new-structure-class))
  class)

;; DEFSTRUCT-Hook
(defun define-structure-class (name names keyword-constructor boa-constructors copier predicate all-slots direct-slots documentation) ; ABI
  (setf (find-class name)
        (make-instance-<structure-class> <structure-class>
          :name name
          :direct-superclasses
            (if (cdr names) (list (find-class (second names))) '())
          'names names
          'kconstructor keyword-constructor
          'boa-constructors boa-constructors
          'copier copier
          'predicate predicate
          'direct-slots direct-slots
          'slots all-slots
          'size (if all-slots
                  (1+ (slot-definition-location (car (last all-slots))))
                  1)
          :generic-accessors nil
          :documentation documentation
          'clos::defclass-form 'defstruct)))
(defun undefine-structure-class (name) ; ABI
  (setf (find-class name) nil))

;; ------------- Creation of an instance of <semi-standard-class> -------------

(defun shared-initialize-<semi-standard-class> (class situation &rest args
                                                &key (direct-superclasses '() direct-superclasses-p)
                                                     ((:direct-slots direct-slots-as-lists) '() direct-slots-as-lists-p)
                                                     ((direct-slots direct-slots-as-metaobjects) '() direct-slots-as-metaobjects-p)
                                                     (direct-default-initargs '() direct-default-initargs-p)
                                                     (documentation nil documentation-p)
                                                     (generic-accessors t generic-accessors-p)
                                                     (fixed-slot-locations nil fixed-slot-locations-p)
                                                &allow-other-keys)
  (declare (ignore direct-superclasses direct-superclasses-p
                   direct-slots-as-lists direct-slots-as-lists-p
                   direct-slots-as-metaobjects direct-slots-as-metaobjects-p
                   direct-default-initargs direct-default-initargs-p
                   documentation documentation-p generic-accessors
                   generic-accessors-p))
  (apply #'shared-initialize-<slotted-class> class situation args)
  (when (eq situation 't)
    (setf (class-current-version class)
          (make-class-version :newest-class class
                              :class class
                              :serial 0))
    (unless *classes-finished*
      ; Bootstrapping: Simulate the effect of #'%shared-initialize.
      (setf (class-instantiated class) nil)
      (setf (class-direct-instance-specializers-table class) '())
      (setf (class-finalized-direct-subclasses-table class) '())))
  ; Initialize the remaining <defined-class> slots:
  (setf (class-initialized class) 2) ; mark as not yet finalized
  (setf (class-precedence-list class) nil) ; mark as not yet finalized
  (setf (class-all-superclasses class) nil) ; mark as not yet finalized
  ; Initialize the remaining <slotted-class> slots:
  ; Initialize the remaining <semi-standard-class> slots:
  (when (or (eq situation 't) fixed-slot-locations-p)
    ;; Convert from list to boolean.
    (when (consp fixed-slot-locations)
      (setq fixed-slot-locations (car fixed-slot-locations)))
    (setf (class-fixed-slot-locations class) fixed-slot-locations))
  (setf (class-prototype class) nil)
  ; Try to finalize it.
  (when (finalizable-p class)
    (finalize-inheritance class))
  ; Done.
  class)

;; ------------- Finalizing an instance of <semi-standard-class> -------------

;; Tests whether a class can be finalized, by recursing on the
;; direct-superclasses list. May call finalize-inheritance on some of the
;; superclasses.
;; Returns T if all the direct-superclasses could be finalized.
;; Returns NIL if this is not possible, and as second value a list from the
;; direct-superclass that couldn't be finalized up to the forward-reference
;; that is not yet defined.
(defun finalizable-p (class &optional (stack nil))
  (assert (defined-class-p class))
  (when (memq class stack)
    (error-of-type 'program-error
      (TEXT "~S: class definition circularity: ~S depends on itself")
      'defclass class))
  (let ((stack (cons class stack)))
    (do ((superclassesr (class-direct-superclasses class) (cdr superclassesr)))
        ((endp superclassesr))
      (let ((superclass (car superclassesr)))
        (unless (defined-class-p superclass)
          (unless (forward-reference-to-class-p superclass)
            (error (TEXT "~S has a direct-superclasses element ~S, which is invalid.")
                   class superclass))
          (let ((real-superclass
                  (or (find-class (class-name superclass) nil)
                      (return-from finalizable-p (values nil (list superclass))))))
            ;; Changed from forward-reference-to-class to defined-class.
            (check-allowed-superclass class real-superclass)
            (setf (car superclassesr) real-superclass)
            (remove-direct-subclass superclass class)
            (add-direct-subclass real-superclass class)
            (setq superclass real-superclass)))
        (assert (defined-class-p superclass))
        (unless (>= (class-initialized superclass) 6) ; not already finalized?
          ;; Here we get only for instances of STANDARD-CLASS, since instances
          ;; of BUILT-IN-CLASS and STRUCTURE-CLASS are already finalized when
          ;; they are constructed.
          (multiple-value-bind (done failure-cause) (finalizable-p superclass stack)
            (unless done
              ;; Finalization of a superclass was impossible.
              (return-from finalizable-p (values nil (cons superclass failure-cause)))))
          ;; Now finalize the superclass. (We could also do this later, from
          ;; inside finalize-inheritance, but then we would need some extra
          ;; bookkeeping to ensure that the running time for a class hierarchy
          ;; like this
          ;;                     A1
          ;;                    /  \
          ;;                   B1  C1
          ;;                    \  /
          ;;                     A2
          ;;                    /  \
          ;;                   B2  C2
          ;;                    \  /
          ;;                     A3
          ;;                    ....
          ;;                   A(n-1)
          ;;                    /  \
          ;;                B(n-1) C(n-1)
          ;;                    \  /
          ;;                     An
          ;; is linear, not exponential, in the number of classes.)
          (finalize-inheritance superclass)))))
  t)

;; Preliminary.
(predefun finalize-inheritance (class)
  (finalize-inheritance-<semi-standard-class> class))

(defun finalize-inheritance-<semi-standard-class> (class)
  (multiple-value-bind (done failure-cause) (finalizable-p class)
    (unless done
      (let ((pretty-cause (mapcar #'class-pretty (cons class failure-cause))))
        (error (TEXT "~S: Cannot finalize class ~S. ~:{Class ~S inherits from class ~S. ~}Class ~S is not yet defined.")
               'finalize-inheritance (first pretty-cause)
               (mapcar #'list pretty-cause (rest pretty-cause))
               (car (last pretty-cause))))))
  ;; Now we know that all direct superclasses are finalized.
  (when (boundp 'class-finalized-p)
    (assert (every #'class-finalized-p (class-direct-superclasses class))))
  ;; Now compute the class-precedence-list.
  (finalize-instance-semi-standard-class class)
  class)

(defun finalize-instance-semi-standard-class (class
       &aux (direct-superclasses (class-direct-superclasses class))
            (name (class-name class))
            (old-slot-location-table (class-slot-location-table class)))
  ;; metaclass  <semi-standard-class>
  (if (standard-class-p class)
    (check-metaclass-mix name direct-superclasses
                         #'standard-class-p 'STANDARD-CLASS)
    (check-metaclass-mix name direct-superclasses
                         #'semi-standard-class-p 'SEMI-STANDARD-CLASS))
  (setf (class-precedence-list class)
        (checked-compute-class-precedence-list class))
  (when (< (class-initialized class) 3)
    (setf (class-initialized class) 3))
  (setf (class-all-superclasses class)
        (std-compute-superclasses (class-precedence-list class)))
  (when (< (class-initialized class) 4)
    (setf (class-initialized class) 4))
  (dolist (super direct-superclasses)
    (when (semi-standard-class-p super)
      (add-finalized-direct-subclass super class)))
  (setf (class-subclass-of-stablehash-p class)
        (std-compute-subclass-of-stablehash-p class))
  (setf (class-funcallablep class)
        ; <funcallable-standard-object> or a subclass of it?
        (if (gethash <function> (class-all-superclasses class)) t nil))
  (setf (class-instance-size class)
        (if (class-funcallablep class)
          3  ; see comments in clos-genfun1.lisp
          1)) ; slot 0 is the class_version pointer
  (setf (class-slots class) (checked-compute-slots class))
  (when (< (class-initialized class) 5)
    (setf (class-initialized class) 5))
  (setf (class-instance-size class) (compute-instance-size class))
  (setf (class-slot-location-table class) (compute-slot-location-table class))
  (let ((shared-size (compute-shared-size class)))
    (when (plusp shared-size)
      (setf (cv-shared-slots (class-current-version class))
            (create-shared-slots-vector class shared-size old-slot-location-table))))
  ;; CLtL2 28.1.3.3., ANSI CL 4.3.4.2. Inheritance of Class Options
  (setf (class-default-initargs class) (checked-compute-default-initargs class))
  (setf (class-valid-initargs-from-slots class)
        (remove-duplicates (mapcap #'slot-definition-initargs (class-slots class))))
  (when (< (class-initialized class) 6)
    (setf (class-initialized class) 6))
  (system::note-new-standard-class))

;; ------------- Redefining an instance of <semi-standard-class> -------------

;; Preliminary definition.
(predefun make-instances-obsolete (class)
  (make-instances-obsolete-<semi-standard-class> class))

(defun make-instances-obsolete-<semi-standard-class> (class)
  (when (>= (class-initialized class) 6) ; nothing to do if not yet finalized
    ;; Recurse to the subclasses. (Even if there are no direct instances of
    ;; this class: the subclasses may have instances.)
    (mapc #'make-instances-obsolete-<semi-standard-class>-nonrecursive
          (list-all-finalized-subclasses class))))

(defun make-instances-obsolete-<semi-standard-class>-nonrecursive (class)
  (if (and (>= (class-initialized class) 4) ; already finalized?
           (subclassp class <metaobject>))
    ; Don't obsolete metaobject instances.
    (let ((name (class-name class))
          (caller *make-instances-obsolete-caller*)
          ;; Rebind *make-instances-obsolete-caller* because WARN may enter a
          ;; nested REP-loop.
          (*make-instances-obsolete-caller* 'make-instances-obsolete))
      (clos-warning (TEXT "~S: Class ~S (or one of its ancestors) is being redefined, but its instances cannot be made obsolete")
        caller name))
    (progn
      (when (class-instantiated class) ; don't warn if there are no instances
        (let ((name (class-name class))
              (caller *make-instances-obsolete-caller*)
              ;; Rebind *make-instances-obsolete-caller* because WARN may enter a
              ;; nested REP-loop.
              (*make-instances-obsolete-caller* 'make-instances-obsolete))
          (if (eq caller 'defclass)
            (clos-warn 'simple-class-obsolescence-warning (TEXT "~S: Class ~S (or one of its ancestors) is being redefined, instances are obsolete")
              caller name)
            (clos-warn 'simple-class-obsolescence-warning (TEXT "~S: instances of class ~S are made obsolete")
              caller name))))
      ;; Create a new class-version. (Even if there are no instances: the
      ;; shared-slots may need change.)
      (let* ((copy (copy-standard-class class))
             (old-version (class-current-version copy))
             (new-version
               (make-class-version :newest-class class
                                   :class class
                                   :serial (1+ (cv-serial old-version)))))
        (setf (cv-class old-version) copy)
        (setf (cv-next old-version) new-version)
        (setf (class-current-version class) new-version)))))

;; After a class redefinition, finalize the subclasses so that the instances
;; can be updated.
(defun update-subclasses-for-redefined-class (class was-finalized must-be-finalized old-direct-superclasses)
  (when was-finalized ; nothing to do if not finalized before the redefinition
    ;; Handle the class itself specially, because its superclasses list now is
    ;; not the same as before.
    (setf (class-initialized class) 2) ; mark as not yet finalized
    (setf (class-precedence-list class) nil) ; mark as not yet finalized
    (setf (class-all-superclasses class) nil) ; mark as not yet finalized
    (if must-be-finalized
      ;; The class remains finalized.
      (progn
        (finalize-inheritance class)
        (let ((new-direct-superclasses (class-direct-superclasses class)))
          (unless (equal old-direct-superclasses new-direct-superclasses)
            (let ((removed-direct-superclasses
                    (set-difference old-direct-superclasses new-direct-superclasses))
                  (added-direct-superclasses
                    (set-difference new-direct-superclasses old-direct-superclasses)))
              (dolist (super removed-direct-superclasses)
                (when (semi-standard-class-p super)
                  (remove-finalized-direct-subclass super class)))
              (dolist (super added-direct-superclasses)
                (when (semi-standard-class-p super)
                  (add-finalized-direct-subclass super class)))))))
      ;; The class becomes unfinalized.
      (dolist (super old-direct-superclasses)
        (when (semi-standard-class-p super)
          (remove-finalized-direct-subclass super class))))
    ;; Now handle the true subclasses.
    (mapc #'update-subclasses-for-redefined-class-nonrecursive
          (rest (list-all-finalized-subclasses class)))))

(defun update-subclasses-for-redefined-class-nonrecursive (class)
  (when (>= (class-initialized class) 6) ; nothing to do if not yet finalized
    (setf (class-initialized class) 2) ; mark as not yet finalized
    (setf (class-precedence-list class) nil) ; mark as not yet finalized
    (setf (class-all-superclasses class) nil) ; mark as not yet finalized
    (if (class-instantiated class)
      ;; The class remains finalized.
      (finalize-inheritance class)
      ;; The class becomes unfinalized. If it has an instantiated subclass, the
      ;; subclass' finalize-inheritance invocation will re-finalize this one.
      (dolist (super (class-direct-superclasses class))
        (when (semi-standard-class-p super)
          (remove-finalized-direct-subclass super class))))))

;; After a class redefinition that changed the class-precedence-list,
;; update the generic functions that use specializers whose object is a
;; direct instance of this class or of a subclass.
(defun update-subclass-instance-specializer-generic-functions (class)
  (dolist (subclass (list-all-finalized-subclasses class))
    ;; Since the CPL of the class has changed, the CPL of the subclass has
    ;; most likely changed as well. It is not worth testing whether it has
    ;; really changed.
    (dolist (specializer (list-direct-instance-specializers subclass))
      ;; specializer's location in the type hierarchy has now changed.
      (dolist (gf (specializer-direct-generic-functions specializer))
        (when (typep-class gf <standard-generic-function>)
          ;; Clear the discriminating function.
          ;; The effective method cache does not need to be invalidated.
          #|(setf (std-gf-effective-method-cache gf) '())|#
          (finalize-fast-gf gf))))))

;; After a class redefinition that changed the class-precedence-list,
;; update the generic functions that could be affected.
(defun update-subclass-cpl-specializer-generic-functions (class old-cpl new-cpl)
  ;; Class definitions change the type hierarchy, therefore the discriminating
  ;; function of some generic functions has to be invalidated and recomputed
  ;; later.
  ;; The effective method cache does not need to be invalidated, since it takes
  ;; a sorted method list as input and compute-effective-method-as-function
  ;; doesn't do computations in the type hierarchy.
  ;;
  ;; Now, which generic functions are affected? The discriminating function of
  ;; a generic depends on the following. (x denotes an object occurring as
  ;; argument, and x-class means (class-of x).)
  ;; 1. The computation of the applicable method list for given arguments x
  ;;    depends on
  ;;      (subclassp x-class specializer)
  ;;    for all specializers occurring in methods of the GF.
  ;; 2. The discriminating function is also free to exploit the result of
  ;;      (subclassp specializer1 specializer2)
  ;;    for any two specializer1, specializer2 occurring in methods of the GF.
  ;; 3. The sorting of the applicable method list for given arguments x
  ;;    depends on the relative order of specializer1 and specializer2 in
  ;;    (cpl x-class), for any two specializer1, specializer2 occurring in
  ;;    methods of the GF.
  ;;
  ;; What effects can a change of (cpl class) = old-cpl -> new-cpl have?
  ;; Assume that some classes S+ are added, some classes S- are removed from
  ;; the CPL, and some classes S* are reordered in the CPL. What effects does
  ;; this have on (cpl o-class), where o-class is any other class?
  ;; - If o-class is not a subclass of class, (cpl o-class) doesn't change.
  ;; - If o-class if subclass of class,
  ;;     the elements of S+ are added or, if already present, possibly
  ;;     reordered,
  ;;     the elements of S- are possibly removed or reordered,
  ;;     the elements of S* are possibly reordered.
  ;;   ("Possibly" because o-class can also inherit from other classes that
  ;;   are not under the given class but under elements of S+, S-, S*.)
  ;;
  ;; Now back to the problem of finding the affected generic functions.
  ;; 1. (subclassp x-class specializer) == (member specializer (cpl x-class))
  ;;    - doesn't change if x-class is not a subclass of class,
  ;;    - doesn't change if specializer is not an element of S+ or S-.
  ;;    Because of the implicit "for all x", we cannot exploit the first
  ;;    statement. But the second statement tells us that we have to go
  ;;    from the elements of S+ and S- to the methods and generic functions
  ;;    using these classes as specializers.
  ;; 2. (subclassp specializer1 specializer2)
  ;;    == (member specializer2 (cpl specializer1))
  ;;    - doesn't change if specializer1 is not a subclass of class,
  ;;    - doesn't change if specializer2 is not an element of S+ or S-.
  ;;    So we have to intersect
  ;;    - the set of GFs using a subclass of class as specializer,
  ;;    - the set of GFs using an element of S+ or S- as specializer.
  ;;    This is a subset of the one we got in point 1. It is redundant.
  ;; 3. We know that if
  ;;          old (cpl x-class) = (... specializer1 ... specializer2 ...)
  ;;    and   new (cpl x-class) = (... specializer2 ... specializer1 ...)
  ;;    then x-class is a subclass of the given class, and one of
  ;;    specializer1, specializer2 (at least) is a member of S+, S- or S*.
  ;;    Because of the implicit "for all x", the first condition is hard to
  ;;    exploit: we need to recurse through all x-class that are subclasses
  ;;    the given class. It is easier to exploit the second condition:
  ;;    Go from the elements of S+, S-, S* to the methods and generic functions
  ;;    using these classes as specializers.
  ;;
  ;; Cf. MOP p. 41 compute-discriminating-function item (iv). This says that
  ;; all generic functions which use a specializer whose class precedence list
  ;; has changed (i.e. essentially a specializer which is a subclass of the
  ;; given class) should invalidate their discriminating function. This is not
  ;; needed!
  ;;
  ;; Cf. MOP p. 41 compute-discriminating-function item (v). This says that
  ;; all generic functions which have a cache entry containing a class whose
  ;; class precedence list has changed (i.e. essentially a subclass of the
  ;; given class) should invalidate their discriminating function. This is
  ;; also far more than is needed; all that's needed is 1. and 3.
  ;;
  (declare (ignore class))
  (let* ((added-superclasses (set-difference new-cpl old-cpl))
         (removed-superclasses (set-difference old-cpl new-cpl))
         (permuted-superclasses
           (let ((common-superclasses-in-old-order
                   (remove-if #'(lambda (x) (memq x removed-superclasses))
                              (the list old-cpl)))
                 (common-superclasses-in-new-order
                   (remove-if #'(lambda (x) (memq x added-superclasses))
                              (the list new-cpl))))
             (assert (= (length common-superclasses-in-old-order)
                        (length common-superclasses-in-new-order)))
             (subseq common-superclasses-in-old-order
                     0
                     (or (mismatch common-superclasses-in-old-order
                                   common-superclasses-in-new-order
                                   :test #'eq
                                   :from-end t)
                         0)))))
    ;; Build the set of affected generic functions.
    (let ((gf-set
            (make-hash-table :key-type 'generic-function :value-type '(eql t)
                             :test 'ext:fasthash-eq)))
      (dolist (specializer (append added-superclasses removed-superclasses
                                   permuted-superclasses))
        (dolist (gf (specializer-direct-generic-functions specializer))
          (setf (gethash gf gf-set) t)))
      #|
      (format *debug-io* "~&added = ~:S, removed = ~:S, permuted = ~:S, affected = ~:S~%"
                         added-superclasses removed-superclasses permuted-superclasses
                         (let ((l '()))
                           (maphash #'(lambda (gf ignored)
                                        (declare (ignore ignored))
                                        (push gf l))
                                    gf-set)
                           l))
      |#
      ;; Clear their discriminating function.
      (maphash #'(lambda (gf ignored)
                   (declare (ignore ignored))
                   (when (typep-class gf <standard-generic-function>)
                     (finalize-fast-gf gf)))
               gf-set))))

;; Store the information needed by the update of obsolete instances in a
;; class-version object. Invoked when an instance needs to be updated.
(defun class-version-compute-slotlists (old-version)
  (let ((old-class (cv-class old-version))
        (new-class (cv-class (cv-next old-version)))
        ; old-class is already finalized - otherwise no instance could exist.
        ; new-class is already finalized, because ensure-class guarantees it.
        (kept2 '())
        (added '())
        (discarded '())
        (discarded2 '()))
    (dolist (old-slot (class-slots old-class))
      (let* ((name (slot-definition-name old-slot))
             (new-slot (find name (class-slots new-class)
                             :test #'eq :key #'slot-definition-name)))
        (if (and new-slot (atom (slot-definition-location new-slot)))
          ;; Local slot remains local, or shared slot becomes local.
          (setq kept2 (list* (slot-definition-location old-slot)
                             (slot-definition-location new-slot)
                             kept2))
          (if (atom (slot-definition-location old-slot))
            ;; Local slot is discarded or becomes shared.
            (setq discarded (cons name discarded)
                  discarded2 (list* name (slot-definition-location old-slot) discarded2))))))
    (dolist (new-slot (class-slots new-class))
      (let* ((name (slot-definition-name new-slot))
             (old-slot (find name (class-slots old-class)
                             :test #'eq :key #'slot-definition-name)))
        (unless old-slot
          ;; Newly added local slot.
          (setq added (cons name added)))))
    (setf (cv-kept-slot-locations old-version) kept2)
    (setf (cv-added-slots old-version) added)
    (setf (cv-discarded-slots old-version) discarded)
    (setf (cv-discarded-slot-locations old-version) discarded2)
    (setf (cv-slotlists-valid-p old-version) t)))

;; -------------- Auxiliary functions for <semi-standard-class> --------------

;;; Maintaining the list of eql-specializers of direct instances that are or
;;; were used in a method. (We need this for notifying the generic functions
;;; to which these methods belong, when the class or a superclass of it is
;;; redefined in a way that changes the class-precedence-list.)

#|
;; Adds a class to the list of direct instance specializers.
(defun add-direct-instance-specializer (class eql-specializer) ...)
;; Removes a class from the list of direct instance specializers.
(defun remove-direct-instance-specializer (class eql-specializer) ...)
;; Returns the currently existing direct instance specializers, as a freshly
;; consed list.
(defun list-direct-instance-specializers (class) ...)
|#
(def-weak-set-accessors class-direct-instance-specializers-table eql-specializer
  add-direct-instance-specializer
  remove-direct-instance-specializer
  list-direct-instance-specializers)

;;; Maintaining the weak references to the finalized direct subclasses.
;;; (We need only the finalized subclasses, because:
;;;  - The only use of these references is for make-instances-obsolete and for
;;;    update-subclasses-for-redefined-class.
;;;  - A non-finalized class cannot have instances.
;;;  - Without an instance one cannot even access the shared slots.)

;;; The finalized-direct-subclasses slot can be either
;;; - NIL or a weak-list (for saving memory when there are few subclasses), or
;;; - a weak-hash-table (for speed when there are many subclasses).

#|
;; Adds a class to the list of direct subclasses.
(defun add-finalized-direct-subclass (class subclass) ...)
;; Removes a class from the list of direct subclasses.
(defun remove-finalized-direct-subclass (class subclass) ...)
;; Returns the currently existing direct subclasses, as a freshly consed list.
(defun list-finalized-direct-subclasses (class) ...)
|#
(def-weak-set-accessors class-finalized-direct-subclasses-table class
  add-finalized-direct-subclass
  remove-finalized-direct-subclass
  list-finalized-direct-subclasses)

;; Returns the currently existing finalized subclasses, in top-down order,
;; including the class itself as first element.
(defun list-all-finalized-subclasses (class)
  ; Use a breadth-first search which removes duplicates.
  (let ((as-list '())
        (as-set (make-hash-table :key-type 'defined-class :value-type '(eql t)
                                 :test 'ext:stablehash-eq :warn-if-needs-rehash-after-gc t
                                 :rehash-size 2s0))
        (pending (list class)))
    (loop
      (unless pending (return))
      (let ((new-pending '()))
        (dolist (class pending)
          (unless (gethash class as-set)
            (push class as-list)
            (setf (gethash class as-set) t)
            (setq new-pending
              (nreconc (if (semi-standard-class-p class)
                         ; <semi-standard-class> stores the finalized direct-subclasses.
                         (list-finalized-direct-subclasses class)
                         ; <defined-class> stores only the complete direct-subclasses list.
                         (remove-if-not #'(lambda (c) (= (class-initialized c) 6))
                                        (checked-class-direct-subclasses class)))
                       new-pending))))
        (setq pending (nreverse new-pending))))
    ;; Now reorder the list so that superclasses come before, not after, a
    ;; class. This is needed by update-subclasses-for-redefined-class. (It's
    ;; a "topological sorting" algorithm w.r.t. to the superclass relation.)
    (let ((tsorted-list '()))
      (labels ((add-with-superclasses-first (cls)
                 (when (gethash cls as-set)
                   (remhash cls as-set)
                   (dolist (supercls (class-direct-superclasses cls))
                     (add-with-superclasses-first supercls))
                   (push cls tsorted-list))))
        (mapc #'add-with-superclasses-first as-list))
      (setq tsorted-list (nreverse tsorted-list))
      (assert (eq (first tsorted-list) class))
      tsorted-list)))

;; --------------- Creation of an instance of <standard-class> ---------------

(defun make-instance-<standard-class> (metaclass &rest args
                                       &key name
                                            (direct-superclasses '())
                                            (direct-slots '())
                                            (direct-default-initargs '())
                                       &allow-other-keys)
  ;; metaclass = <standard-class>
  ;; Don't add functionality here! This is a preliminary definition that is
  ;; replaced with #'make-instance later.
  (declare (ignore metaclass name direct-superclasses direct-slots
                   direct-default-initargs))
  (let ((class (allocate-metaobject-instance *<standard-class>-class-version*
                                             *<standard-class>-instance-size*)))
    (apply #'initialize-instance-<standard-class> class args)))

(defun initialize-instance-<standard-class> (class &rest args
                                             &key &allow-other-keys)
  ;; Don't add functionality here! This is a preliminary definition that is
  ;; replaced with #'initialize-instance later.
  (apply #'shared-initialize-<standard-class> class 't args)
  (install-class-direct-accessors class)
  class)

(defun shared-initialize-<standard-class> (class situation &rest args
                                           &key (direct-superclasses '() direct-superclasses-p)
                                                ((:direct-slots direct-slots-as-lists) '() direct-slots-as-lists-p)
                                                ((direct-slots direct-slots-as-metaobjects) '() direct-slots-as-metaobjects-p)
                                                (direct-default-initargs '() direct-default-initargs-p)
                                                (documentation nil documentation-p)
                                                (generic-accessors t generic-accessors-p)
                                                (fixed-slot-locations nil fixed-slot-locations-p)
                                           &allow-other-keys)
  (declare (ignore direct-superclasses direct-superclasses-p
                   direct-slots-as-lists direct-slots-as-lists-p
                   direct-slots-as-metaobjects direct-slots-as-metaobjects-p
                   direct-default-initargs direct-default-initargs-p
                   documentation documentation-p generic-accessors
                   generic-accessors-p fixed-slot-locations
                   fixed-slot-locations-p))
  (apply #'shared-initialize-<semi-standard-class> class situation args)
  class)

;; ---------------------------------------------------------------------------

;; Bootstrapping
(progn
  (setq <function> nil)

  ;; 1. Define the class <t>.
  (setq <t>
        (make-instance-<built-in-class> nil
          :name 't
          :direct-superclasses '()
          'prototype (byte 1 0)))
  (setf (find-class 't) <t>)

  ;; 2. Define the class <standard-object>.
  (setq <standard-object>
        (let ((*allow-mixing-metaclasses* t))
          (make-instance-<standard-class> nil
            :name 'standard-object
            :direct-superclasses `(,<t>)
            :direct-slots '()
            :slots '()
            :slot-location-table empty-ht
            :instance-size 1
            :direct-default-initargs '()
            :default-initargs '())))
  (setf (find-class 'standard-object) <standard-object>)

  ;; 3. Define the class <metaobject>.
  (setq <metaobject>
        (macrolet ((form () *<metaobject>-defclass*))
          (form)))

  ;; 4. Define the class <standard-stablehash>.
  (macrolet ((form () *<standard-stablehash>-defclass*))
    (form))

  ;; 5. Define the class <specializer>.
  (macrolet ((form () *<specializer>-defclass*))
    (form))

  ;; 6. Define the classes <super-class>, <potential-class>.
  (macrolet ((form () *<super-class>-defclass*))
    (form))
  (setq <potential-class>
        (macrolet ((form () *<potential-class>-defclass*))
          (form)))

  ;; 7. Define the class <defined-class>.
  (setq <defined-class>
        (macrolet ((form () *<defined-class>-defclass*))
          (form)))

  ;; 8. Define the class <built-in-class>.
  (setq <built-in-class>
        (macrolet ((form () *<built-in-class>-defclass*))
          (form)))
  (replace-class-version <built-in-class>
                         *<built-in-class>-class-version*)

  ;; 9. Define the classes <slotted-class>, <semi-standard-class>,
  ;; <standard-class>, <structure-class>.
  (macrolet ((form () *<slotted-class>-defclass*))
    (form))
  (setq <semi-standard-class>
    (macrolet ((form () *<semi-standard-class>-defclass*))
      (form)))
  (setq <standard-class>
    (macrolet ((form () *<standard-class>-defclass*))
      (form)))
  (replace-class-version <standard-class>
                         *<standard-class>-class-version*)
  (setq <structure-class>
    (macrolet ((form () *<structure-class>-defclass*))
      (form)))
  (replace-class-version <structure-class>
                         *<structure-class>-class-version*)

  ;; 10. Define the class <structure-object>.
  (setq <structure-object>
        (let ((*allow-mixing-metaclasses* t))
          (make-instance-<structure-class> <structure-class>
            :name 'structure-object
            :direct-superclasses `(,<t>)
            :direct-slots '()
            :direct-default-initargs '()
            'names (list 'structure-object))))
  (setf (find-class 'structure-object) <structure-object>)

  ;; 11. Define other classes whose definition was delayed.

  ;; Define the class <slot-definition>.
  (macrolet ((form () *<slot-definition>-defclass*))
    (form))

  ;; Define the class <direct-slot-definition>.
  (setq <direct-slot-definition>
        (macrolet ((form () *<direct-slot-definition>-defclass*))
          (form)))

  ;; Define the class <effective-slot-definition>.
  (setq <effective-slot-definition>
        (macrolet ((form () *<effective-slot-definition>-defclass*))
          (form)))

  ;; Define the class <standard-slot-definition>.
  (macrolet ((form () *<standard-slot-definition>-defclass*))
    (form))

  ;; Define the class <standard-direct-slot-definition>.
  (setq <standard-direct-slot-definition>
        (macrolet ((form () *<standard-direct-slot-definition>-defclass*))
          (form)))
  (replace-class-version (find-class 'standard-direct-slot-definition)
                         *<standard-direct-slot-definition>-class-version*)

  ;; Define the class <standard-effective-slot-definition>.
  (setq <standard-effective-slot-definition>
        (macrolet ((form () *<standard-effective-slot-definition>-defclass*))
          (form)))
  (replace-class-version (find-class 'standard-effective-slot-definition)
                         *<standard-effective-slot-definition>-class-version*)

  ;; Define the class <structure-direct-slot-definition>.
  (setq <structure-direct-slot-definition>
        (macrolet ((form () *<structure-direct-slot-definition>-defclass*))
          (form)))
  (replace-class-version (find-class 'structure-direct-slot-definition)
                         *<structure-direct-slot-definition>-class-version*)

  ;; Define the class <structure-effective-slot-definition>.
  (setq <structure-effective-slot-definition>
        (macrolet ((form () *<structure-effective-slot-definition>-defclass*))
          (form)))
  (replace-class-version (find-class 'structure-effective-slot-definition)
                         *<structure-effective-slot-definition>-class-version*)

  ;; Define the class <eql-specializer>.
  (setq <eql-specializer>
        (macrolet ((form () *<eql-specializer>-defclass*))
          (form)))
  (replace-class-version (find-class 'eql-specializer)
                         *<eql-specializer>-class-version*)

  ;; Define the classes <forward-reference-to-class>,
  ;; <misdesigned-forward-referenced-class>.
  (setq <forward-reference-to-class>
        (macrolet ((form () *<forward-reference-to-class>-defclass*))
                     (form)))
  (setq <misdesigned-forward-referenced-class>
        (macrolet ((form () *<misdesigned-forward-referenced-class>-defclass*))
                     (form)))

);progn

;;; Install built-in classes:
;; See CLtL2 p. 783 table 28-1, ANSI CL 4.3.7.
(macrolet ((def (&rest classes)
             (setq classes (reverse classes))
             (let* ((prototype-form (pop classes))
                    (new (pop classes))
                    (name (intern (string-trim "<>" (symbol-name new)))))
               `(setf (find-class ',name)
                  (setq ,new
                    (make-instance-<built-in-class> <built-in-class>
                      :name ',name
                      :direct-superclasses (list ,@classes)
                      ,@(unless (eq prototype-form '-+-ABSTRACT-+-)
                          `('prototype ,prototype-form))))))))
 ;(def <t>                                           (byte 1 0))
  (def <t> <character>                               #\Space)
  (def <t> <function>                                #'cons)
  (def <t> <hash-table>                              empty-ht)
  (def <t> <package>                                 (find-package "KEYWORD"))
  (def <t> <pathname>                                (make-pathname))
  #+LOGICAL-PATHNAMES
  (def     <pathname> <logical-pathname>             (logical-pathname ":"))
  (def <t> <random-state>                            *random-state*)
  (def <t> <readtable>                               *readtable*)
  (def <t> <stream>                                  -+-ABSTRACT-+-)
  (def     <stream> <file-stream>                    (open *load-pathname* :direction :probe))
  (def     <stream> <synonym-stream>                 (make-synonym-stream '*terminal-io*))
  (def     <stream> <broadcast-stream>               (make-broadcast-stream))
  (def     <stream> <concatenated-stream>            (make-concatenated-stream))
  (def     <stream> <two-way-stream>                 (make-two-way-stream (make-concatenated-stream) (make-broadcast-stream)))
  (def     <stream> <echo-stream>                    (make-echo-stream (make-concatenated-stream) (make-broadcast-stream)))
  (def     <stream> <string-stream>                  (make-string-output-stream))
  (def <t> <symbol>                                  't)
  (def <t> <sequence>                                -+-ABSTRACT-+-)
  (def     <sequence> <list>                         -+-ABSTRACT-+-)
  (def                <list> <cons>                  '(t))
  (def                <list> <symbol> <null>         'nil)
  (def <t>            <array>                        '#2A())
  (def     <sequence> <array> <vector>               '#())
  (def                        <vector> <bit-vector>  '#*)
  (def                        <vector> <string>      "")
  (def <t> <number>                                  -+-ABSTRACT-+-)
  (def     <number> <complex>                        #c(3 4))
  (def     <number> <real>                           -+-ABSTRACT-+-)
  (def              <real> <float>                   1.0s0)
  (def              <real> <rational>                -+-ABSTRACT-+-)
  (def                     <rational> <ratio>        1/2)
  (def                     <rational> <integer>      0)
)

;; Continue bootstrapping.
(%defclos
  ;; distinctive marks for CLASS-P
  *<standard-class>-class-version*
  *<structure-class>-class-version*
  *<built-in-class>-class-version*
  <defined-class>
  <potential-class>
  ;; built-in-classes for CLASS-OF - order in sync with constobj.d
  (vector <array> <bit-vector> <character> <complex> <cons> <float> <function>
          <hash-table> <integer> <list> <null> <package> <pathname>
          #+LOGICAL-PATHNAMES <logical-pathname>
          <random-state> <ratio> <readtable>
          <stream> <file-stream> <synonym-stream> <broadcast-stream>
          <concatenated-stream> <two-way-stream> <echo-stream> <string-stream>
          <string> <symbol> <t> <vector>))

;;; Intersection of two built-in-classes:
;; Deviations from the single-inheritance are only
;; (AND <sequence> <array>) = <vector> and (AND <list> <symbol>) = <null>.
(defun bc-p (class)
  (or (built-in-class-p class)
      (eq class <standard-object>)
      (eq class <structure-object>)))
(defun bc-and (class1 class2) ; returns (AND class1 class2)
  (cond ((subclassp class1 class2) class1)
        ((subclassp class2 class1) class2)
        ((or (and (subclassp <sequence> class1) (subclassp <array> class2))
             (and (subclassp <sequence> class2) (subclassp <array> class1)))
         <vector>)
        ((or (and (subclassp <list> class1) (subclassp <symbol> class2))
             (and (subclassp <list> class2) (subclassp <symbol> class1)))
         <null>)
        (t nil)))
(defun bc-and-not (class1 class2) ; returns a class c with
                                  ; (AND class1 (NOT class2)) <= c <= class1
  (cond ((subclassp class1 class2) nil)
        ((and (eq class1 <sequence>) (subclassp <vector> class2)) <list>)
        ((and (eq class1 <sequence>) (subclassp <list> class2)) <vector>)
        ((and (eq class1 <list>) (subclassp <null> class2)) <cons>)
        (t class1)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-class3.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-class2.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP
;;;; Class metaobjects
;;;; Part 2: The class namespace.
;;;; Bruno Haible 21.8.1993 - 2004
;;;; Sam Steingold 1998 - 2004
;;;; German comments translated into English: Stefan Kain 2002-04-08

(in-package "CLOS")


;;; Predefined classes (see ANSI CL 4.3.7.):

;; Metaclasses:
(defvar <potential-class>)             ; <standard-class>
(defvar <defined-class>)               ; <standard-class>
(defvar <standard-class>)              ; <standard-class>
(defvar <funcallable-standard-class>)  ; <standard-class>
(defvar <structure-class>)             ; <standard-class>
(defvar <built-in-class>)              ; <standard-class>
;; Not really metaclasses:
(defvar <forward-reference-to-class>)  ; <standard-class>
(defvar <misdesigned-forward-referenced-class>) ; <standard-class>
;; Classes:
(defvar <standard-object>)             ; <standard-class>
(defvar <funcallable-standard-object>) ; <funcallable-standard-class>
(defvar <structure-object>)            ; <structure-class>
(defvar <generic-function>)            ; <funcallable-standard-class>
(defvar <standard-generic-function>)   ; <funcallable-standard-class> ; ABI
;(defvar <method>)                     ; <standard-class>
;(defvar <standard-method>)            ; <standard-class>
(defvar <standard-reader-method>)      ; <standard-class>
(defvar <standard-writer-method>)      ; <standard-class>
;(defvar <method-combination>)         ; <standard-class>
(defvar <array>)                       ; <built-in-class>
(defvar <bit-vector>)                  ; <built-in-class>
(defvar <character>)                   ; <built-in-class>
(defvar <complex>)                     ; <built-in-class>
(defvar <cons>)                        ; <built-in-class>
(defvar <float>)                       ; <built-in-class>
(defvar <function>)                    ; <built-in-class>
(defvar <hash-table>)                  ; <built-in-class>
(defvar <integer>)                     ; <built-in-class>
(defvar <list>)                        ; <built-in-class>
(defvar <null>)                        ; <built-in-class>
(defvar <number>)                      ; <built-in-class>
(defvar <package>)                     ; <built-in-class>
(defvar <pathname>)                    ; <built-in-class>
#+LOGICAL-PATHNAMES
(defvar <logical-pathname>)            ; <built-in-class>
(defvar <random-state>)                ; <built-in-class>
(defvar <ratio>)                       ; <built-in-class>
(defvar <rational>)                    ; <built-in-class>
(defvar <readtable>)                   ; <built-in-class>
(defvar <real>)                        ; <built-in-class>
(defvar <sequence>)                    ; <built-in-class>
(defvar <stream>)                      ; <built-in-class>
(defvar <file-stream>)                 ; <built-in-class>
(defvar <synonym-stream>)              ; <built-in-class>
(defvar <broadcast-stream>)            ; <built-in-class>
(defvar <concatenated-stream>)         ; <built-in-class>
(defvar <two-way-stream>)              ; <built-in-class>
(defvar <echo-stream>)                 ; <built-in-class>
(defvar <string-stream>)               ; <built-in-class>
(defvar <string>)                      ; <built-in-class>
(defvar <symbol>)                      ; <built-in-class>
(defvar <t>)                           ; <built-in-class>
(defvar <vector>)                      ; <built-in-class>
;; Condition classes and RESTART are defined later, in condition.lisp.


;;; Global management of classes and their names:

#|| ; see PREDTYPE.D
 (defun find-class (symbol &optional (errorp t) environment)
   (declare (ignore environment)) ; ignore distinction between
                                  ; compile-time and run-time environment
   (unless (symbolp symbol)
     (error-of-type 'type-error
       :datum symbol :expected-type 'symbol
       (TEXT "~S: argument ~S is not a symbol")
       'find-class symbol))
   (let ((class (get symbol 'CLOSCLASS)))
     (if (not (defined-class-p class))
       (if errorp
         (error-of-type 'error
           (TEXT "~S: ~S does not name a class")
           'find-class symbol)
         nil)
       class)))
||#

(defun (setf find-class) (new-value symbol &optional errorp environment)
  (declare (ignore errorp environment)) ; ignore distinction between
                                        ; compile-time and run-time environment
  (unless (symbolp symbol)
    (error-of-type 'type-error
      :datum symbol :expected-type 'symbol
      (TEXT "~S: argument ~S is not a symbol")
      '(setf find-class) symbol))
  (unless (or (null new-value) (defined-class-p new-value))
    (error-of-type 'type-error
      :datum new-value :expected-type 'class
      (TEXT "~S: ~S is not a class")
      '(setf find-class) new-value))
  (let ((h (get symbol 'CLOSCLASS)))
    (when (defined-class-p h)
      (when (and (built-in-class-p h) (eq (class-name h) symbol)) ; protect structure classes, too??
        (error-of-type 'error
          (TEXT "~S: cannot redefine built-in class ~S")
          '(setf find-class) h)))
    ;; Should we do (setf (class-name h) nil) ? No, because CLHS of FIND-CLASS
    ;; says that "the class object itself is not affected".
    (sys::check-redefinition symbol '(setf find-class)
                             (and (defined-class-p h) (TEXT "class")))
    (when (and h (forward-reference-to-class-p h) new-value)
      ;; Move the list of subclasses from the old class object to the new one.
      (dolist (subclass (class-direct-subclasses h))
        (add-direct-subclass new-value subclass))))
  (if new-value
    (setf (get symbol 'CLOSCLASS) new-value)
    (progn (remprop symbol 'CLOSCLASS) nil)))

;; Converts a class to a pretty printing type.
(defun class-pretty (class)
  (if (or (forward-reference-to-class-p class)
          (eq (find-class (class-name class) nil) class))
    (class-name class)
    class))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-class2.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-class1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP
;;;; Class metaobjects
;;;; Part 1: Class definitions, preliminary accessors.
;;;; Bruno Haible 2004-05-25
;;;; Sam Steingold 2005-2006

(in-package "CLOS")


;;; Low-level representation:

;; In the runtime-system, the type "CLOS instance" exists.
;; The first component is the class-version, the rest are the local slot
;; values.

;; Classes are instances of type CLASS,

;; The "value" of a slot that is unbound, is #<UNBOUND> - what else?

;;; see RECORD.D :
;; (STD-INSTANCE-P obj) tests, if an object is a CLOS-instance.
;; (ALLOCATE-STD-INSTANCE class n) returns a non-funcallable CLOS-instance
;; with Class class and n-1 additional slots.
;; (ALLOCATE-FUNCALLABLE-INSTANCE class n) returns a funcallable CLOS-instance
;; with Class class and n-3 additional slots.

;;; see IO.D :
;; CLOS-instances are printed via (PRINT-OBJECT object stream).

;; (CLASS-OF object) see PREDTYPE.D, uses property CLOSCLASS.

;;; ===========================================================================

;;; Auxiliary stuff.

;; An empty hash table.
(defconstant empty-ht
             (make-hash-table :key-type 'symbol :value-type 't
                              :test 'eq :warn-if-needs-rehash-after-gc t
                              :size 0))

;;; ===========================================================================

;;; The abstract class <super-class> allows defined classes and
;;; forward-references to classes to be treated in a homogenous way.

(defvar *<super-class>-defclass*
  '(defclass super-class (standard-stablehash metaobject)
     (($classname          ; (class-name class) = (class-classname class),
                           ; a symbol
        :type symbol
        :initarg :name)
      ($direct-subclasses  ; set of all direct subclasses, as a weak-list or
                           ; weak-hash-table or NIL
        :type (or hash-table weak-list null)
        :initform nil))
     (:fixed-slot-locations nil)))

;;; ===========================================================================

;;; The abstract class <potential-class> is the abstract base class of all
;;; classes.

(defvar *<potential-class>-defclass*
  '(defclass potential-class (specializer super-class)
     ()
     (:fixed-slot-locations t)))

;; Fixed slot locations.
(defconstant *<potential-class>-classname-location* 3)
(defconstant *<potential-class>-direct-subclasses-location* 4)

;; Preliminary accessors.
(predefun class-classname (object)
  (sys::%record-ref object *<potential-class>-classname-location*))
(predefun (setf class-classname) (new-value object)
  (setf (sys::%record-ref object *<potential-class>-classname-location*) new-value))
(predefun class-direct-subclasses-table (object)
  (if (potential-class-p object)
    (sys::%record-ref object *<potential-class>-direct-subclasses-location*)
    (slot-value object '$direct-subclasses)))
(predefun (setf class-direct-subclasses-table) (new-value object)
  (if (potential-class-p object)
    (setf (sys::%record-ref object *<potential-class>-direct-subclasses-location*) new-value)
    (setf (slot-value object '$direct-subclasses) new-value)))

;; Initialization of a <potential-class> instance.
(defun shared-initialize-<potential-class> (class situation &rest args
                                            &key (name nil name-p)
                                            &allow-other-keys)
  (apply #'shared-initialize-<specializer> class situation args)
  (unless *classes-finished*
    ; Bootstrapping: Simulate the effect of #'%shared-initialize.
    (when (eq situation 't) ; called from initialize-instance?
      (setf (class-direct-subclasses-table class) nil)))
  (when (or (eq situation 't) name-p)
    (setf (class-classname class) (check-symbol name '(setf class-name))))
  class)

;;; ===========================================================================

;;; The class <forward-referenced-class> allows forward-references to classes
;;; to collect their direct subclasses already before they are defined:
;;;     (defclass b (a) ())
;;;     (defclass a () ())
;;;     (class-direct-subclasses (find-class 'a)) => (#<STANDARD-CLASS B>)

;;; A forward-referenced-class's name is always a symbol that cannot be
;;; changed, and the forward-referenced-class is available as
;;; (get name 'CLOSCLASS), until it is replaced with the defined class.

;;; The MOP specification regarding <forward-referenced-class> is severely
;;; misdesigned. The actual meaning of a <forward-referenced-class> is a
;;; forward-reference to (= placeholder for) a not yet defined class. The only
;;; place where it is used is in the direct-superclasses list of some classes
;;; that are not yet finalized.
;;;
;;; Putting it under <class> is a mistake because:
;;;   1. Classes fundamentally describe the slots and operations available
;;;      on its (direct and indirect) instances. But a forward-referenced
;;;      class can never have (direct and indirect) instances, since the
;;;      slots and operations are not yet known.
;;;   2. All the generic functions on <class>, such as class-precedence-list
;;;      or class-direct-default-initargs, make no sense on a
;;;      <forward-referenced-class> - since the real information is not yet
;;;      available.
;;;   3. <class> inherits from <specializer>, but it makes no sense to use
;;;      a <forward-referenced-class> as a specializer in a method or as a
;;;      type in TYPEP or SUBTYPEP.
;;;
;;; This is also backed by the fact that this MOP implementation has three
;;; times more tests for <defined-class> (i.e. for <class> without
;;; <forward-referenced-class>) than for <potential-class>.
;;;
;;; A better design would be to define an abstract class <superclass> and
;;; let <forward-referenced-class> inherit from it:
;;;   (defclass super-class () ...)
;;;   (defclass class (super-class specializer) ...)
;;;   (defclass forward-referenced-class (super-class) ...)
;;; and (class-direct-superclasses class) would simply be a list of
;;; <super-class> instances.

;; The proper <forward-referenced-class> inherits from <super-class> but
;; not from <specializer>.
(defvar *<forward-reference-to-class>-defclass*
  '(defclass forward-reference-to-class (super-class)
     ()
     (:fixed-slot-locations nil)))

;; The crappy <forward-referenced-class> from the MOP is subclass of
;; <potential-class> and thus also of <specializer>.
(defvar *<misdesigned-forward-referenced-class>-defclass*
  '(defclass misdesigned-forward-referenced-class (forward-reference-to-class potential-class)
     ()
     (:fixed-slot-locations nil)))

;;; ===========================================================================

;;; The abstract class <defined-class> allows built-in objects, user-defined
;;; objects and proxies to external worlds to be treated in a homogenous way.

(defvar *<defined-class>-defclass*
  '(defclass defined-class (potential-class)
     (($direct-superclasses ; list of all direct superclasses (or their names,
                           ; while the class is waiting to be finalized)
        :type list
        :initarg :direct-superclasses)
      ($all-superclasses   ; hash table of all superclasses (including
                           ; the class itself)
        :type hash-table)
      ($precedence-list    ; ordered list of all superclasses (with the class
                           ; itself first), or NIL while the class is waiting
                           ; to be finalized
        :type list)
      ($direct-slots       ; list of all freshly added slots (as
                           ; direct-slot-definition instances)
        :type list
        :initarg :direct-slots)
      ($slots              ; list of all slots (as effective-slot-definition
                           ; instances)
        :type list)
      ($slot-location-table ; hash table slotname -> descriptor
                           ; where the descriptor is either
                           ; - the location of the slot (a fixnum or cons), or
                           ; - its effective slot definition
        :type hash-table
        :initform empty-ht)
      ($direct-default-initargs ; freshly added default-initargs
                           ; (as alist initarg -> (form function))
        :type list
        :initarg :direct-default-initargs)
      ($default-initargs   ; default-initargs
                           ; (as alist initarg -> (form function))
        )
      ($documentation      ; string or NIL
        :type (or string null)
        :initarg :documentation)
      ($listeners          ; list of objects to be notified upon a change
        :type list
        :initform nil)
      ($initialized        ; describes which parts of the class are initialized
        :type (integer 0 6) ; 0 = nothing
                            ; 1 = name
                            ; 2 = likewise, plus direct-... info
                            ; 3 = likewise, plus class-precedence-list
                            ; 4 = likewise, plus class-all-superclasses
                            ; 5 = likewise, plus class-slots
                            ; 6 = likewise, plus slot-location-table, default-initargs
        :initform 0))
     (:fixed-slot-locations t)))

;; Fixed slot locations.
(defconstant *<defined-class>-direct-superclasses-location* 5)
(defconstant *<defined-class>-all-superclasses-location* 6)
(defconstant *<defined-class>-precedence-list-location* 7)
(defconstant *<defined-class>-direct-slots-location* 8)
(defconstant *<defined-class>-slots-location* 9)
(defconstant *<defined-class>-slot-location-table-location* 10)
(defconstant *<defined-class>-direct-default-initargs-location* 11)
(defconstant *<defined-class>-default-initargs-location* 12)
(defconstant *<defined-class>-documentation-location* 13)
(defconstant *<defined-class>-listeners-location* 14)
(defconstant *<defined-class>-initialized-location* 15)

;; Preliminary accessors.
(predefun class-direct-superclasses (object)
  (sys::%record-ref object *<defined-class>-direct-superclasses-location*))
(predefun (setf class-direct-superclasses) (new-value object)
  (setf (sys::%record-ref object *<defined-class>-direct-superclasses-location*) new-value))
(predefun class-all-superclasses (object)
  (sys::%record-ref object *<defined-class>-all-superclasses-location*))
(predefun (setf class-all-superclasses) (new-value object)
  (setf (sys::%record-ref object *<defined-class>-all-superclasses-location*) new-value))
(predefun class-precedence-list (object)
  (sys::%record-ref object *<defined-class>-precedence-list-location*))
(predefun (setf class-precedence-list) (new-value object)
  (setf (sys::%record-ref object *<defined-class>-precedence-list-location*) new-value))
(predefun class-direct-slots (object)
  (sys::%record-ref object *<defined-class>-direct-slots-location*))
(predefun (setf class-direct-slots) (new-value object)
  (setf (sys::%record-ref object *<defined-class>-direct-slots-location*) new-value))
(predefun class-slots (object)
  (sys::%record-ref object *<defined-class>-slots-location*))
(predefun (setf class-slots) (new-value object)
  (setf (sys::%record-ref object *<defined-class>-slots-location*) new-value))
(predefun class-slot-location-table (object)
  (sys::%record-ref object *<defined-class>-slot-location-table-location*))
(predefun (setf class-slot-location-table) (new-value object)
  (setf (sys::%record-ref object *<defined-class>-slot-location-table-location*) new-value))
(predefun class-direct-default-initargs (object)
  (sys::%record-ref object *<defined-class>-direct-default-initargs-location*))
(predefun (setf class-direct-default-initargs) (new-value object)
  (setf (sys::%record-ref object *<defined-class>-direct-default-initargs-location*) new-value))
(predefun class-default-initargs (object)
  (sys::%record-ref object *<defined-class>-default-initargs-location*))
(predefun (setf class-default-initargs) (new-value object)
  (setf (sys::%record-ref object *<defined-class>-default-initargs-location*) new-value))
(predefun class-documentation (object)
  (sys::%record-ref object *<defined-class>-documentation-location*))
(predefun (setf class-documentation) (new-value object)
  (setf (sys::%record-ref object *<defined-class>-documentation-location*) new-value))
(predefun class-listeners (object)
  (sys::%record-ref object *<defined-class>-listeners-location*))
(predefun (setf class-listeners) (new-value object)
  (setf (sys::%record-ref object *<defined-class>-listeners-location*) new-value))
(predefun class-initialized (object)
  (sys::%record-ref object *<defined-class>-initialized-location*))
(predefun (setf class-initialized) (new-value object)
  (setf (sys::%record-ref object *<defined-class>-initialized-location*) new-value))

(defun canonicalized-slot-p (x)
  ; A "canonicalized slot specification" is a special kind of property list.
  ; See MOP p. 13-15.
  (and (proper-list-p x)
       (evenp (length x))
       (let ((default '#:default))
         (not (eq (getf x ':name default) default)))))

(defun canonicalized-default-initarg-p (x)
  ; A "canonicalized default initarg" is an element of an alist mapping
  ; a slot name (a symbol) to a list of the form (form function).
  ; See MOP p. 16.
  (and (consp x) (symbolp (first x))
       (consp (cdr x)) (consp (cddr x)) (functionp (third x))
       (null (cdddr x))))

;; Initialization of a <defined-class> instance.
(defun shared-initialize-<defined-class> (class situation &rest args
                                          &key (name nil)
                                               (direct-superclasses nil direct-superclasses-p)
                                               ((:direct-slots direct-slots-as-lists) '() direct-slots-as-lists-p)
                                               ((direct-slots direct-slots-as-metaobjects) '() direct-slots-as-metaobjects-p)
                                               (direct-default-initargs nil direct-default-initargs-p)
                                               (documentation nil documentation-p)
                                          &allow-other-keys
                                          &aux old-direct-superclasses)
  (setq old-direct-superclasses
        (if (eq situation 't) ; called from initialize-instance?
          '()
          (sys::%record-ref class *<defined-class>-direct-superclasses-location*)))
  (apply #'shared-initialize-<potential-class> class situation args)
  (unless *classes-finished*
    ; Bootstrapping: Simulate the effect of #'%shared-initialize.
    (when (eq situation 't) ; called from initialize-instance?
      (setf (class-slot-location-table class) empty-ht)
      (setf (class-listeners class) nil)
      (setf (class-initialized class) 0)))
  (when (eq situation 't)
    ; shared-initialize-<potential-class> has initialized the name.
    (setf (class-initialized class) 1))
  ; Get the name, for error message purposes.
  (setq name (class-classname class))
  (when (or (eq situation 't) direct-superclasses-p)
    ; Check the direct-superclasses.
    (unless (proper-list-p direct-superclasses)
      (error (TEXT "(~S ~S) for class ~S: The ~S argument should be a proper list, not ~S")
             (if (eq situation 't) 'initialize-instance 'shared-initialize)
             'class name ':direct-superclasses direct-superclasses))
    (unless (every #'(lambda (x)
                       (or (defined-class-p x)
                           (forward-reference-to-class-p x)))
                   direct-superclasses)
      (error (TEXT "(~S ~S) for class ~S: The direct-superclasses list should consist of classes, not ~S")
             (if (eq situation 't) 'initialize-instance 'shared-initialize)
             'class name direct-superclasses))
    (when (and (> (length direct-superclasses) 1)
               (typep class <structure-class>))
      (error (TEXT "(~S ~S) for class ~S: The metaclass ~S forbids more than one direct superclass: It does not support multiple inheritance.")
             (if (eq situation 't) 'initialize-instance 'shared-initialize)
             'class name (class-of class)))
    (dolist (sc direct-superclasses)
      (when (defined-class-p sc)
        (check-allowed-superclass class sc)))
    (when (null direct-superclasses)
      (setq direct-superclasses (default-direct-superclasses class))))
  (when (or (eq situation 't) direct-slots-as-lists-p)
    ; Check the direct-slots.
    (unless (proper-list-p direct-slots-as-lists)
      (error (TEXT "(~S ~S) for class ~S: The ~S argument should be a proper list, not ~S")
             (if (eq situation 't) 'initialize-instance 'shared-initialize)
             'class name ':direct-slots direct-slots-as-lists))
    (dolist (sl direct-slots-as-lists)
      (unless (canonicalized-slot-p sl)
        (error (TEXT "(~S ~S) for class ~S: The direct slot specification ~S is not in the canonicalized form (slot-name initform initfunction).")
               (if (eq situation 't) 'initialize-instance 'shared-initialize)
               'class name sl))))
  (when (or (eq situation 't) direct-default-initargs-p)
    ; Check the direct-default-initargs.
    (unless (proper-list-p direct-default-initargs)
      (error (TEXT "(~S ~S) for class ~S: The ~S argument should be a proper list, not ~S")
             (if (eq situation 't) 'initialize-instance 'shared-initialize)
             'class name ':direct-default-initargs direct-default-initargs))
    (dolist (definitarg direct-default-initargs)
      (unless (canonicalized-default-initarg-p definitarg)
        (error (TEXT "(~S ~S) for class ~S: The direct default initarg ~S is not in canonicalized form (a property list).")
               (if (eq situation 't) 'initialize-instance 'shared-initialize)
               'class name definitarg))))
  (when (or (eq situation 't) documentation-p)
    ; Check the documentation.
    (unless (or (null documentation) (stringp documentation))
      (error (TEXT "(~S ~S) for class ~S: The ~S argument should be a string or NIL, not ~S")
             (if (eq situation 't) 'initialize-instance 'shared-initialize)
             'class name :documentation documentation)))
  ; Fill the slots.
  (when (or (eq situation 't) direct-superclasses-p)
    (setf (class-direct-superclasses class) (copy-list direct-superclasses))
    (update-subclasses-sets class old-direct-superclasses direct-superclasses))
  (when (or (eq situation 't) direct-slots-as-lists-p direct-slots-as-metaobjects-p)
    (setf (class-direct-slots class)
          (if direct-slots-as-metaobjects-p
            direct-slots-as-metaobjects
            (convert-direct-slots class direct-slots-as-lists))))
  (when (or (eq situation 't) direct-default-initargs-p)
    (setf (class-direct-default-initargs class) direct-default-initargs))
  (when (or (eq situation 't) documentation-p)
    (setf (class-documentation class) documentation))
  ; The following slots are initialized by the subclass' shared-initialize:
  ;   all-superclasses
  ;   precedence-list
  ;   slots
  ;   slot-location-table
  ;   default-initargs
  ; Now allow the user to call some class-xxx accessor functions.
  (when (eq situation 't)
    (setf (class-initialized class) 2))
  class)

;;; ===========================================================================

;;; The class <built-in-class> represents those classes for which the user
;;; cannot create subclasses.

(defvar <built-in-class> 'built-in-class)
(defvar *<built-in-class>-defclass*
  '(defclass built-in-class (defined-class)
     (($prototype          ; class prototype - an instance
        :type t))
     (:fixed-slot-locations t)))
(defvar *<built-in-class>-class-version* (make-class-version))

;; Fixed slot locations.
(defconstant *<built-in-class>-prototype-location* 16)

(defconstant *<built-in-class>-instance-size* 17)

;;; ===========================================================================

;;; The class <slotted-class> represents those classes for which the local
;;; slot values are stored in the instance. It also represents common
;;; behaviour of <standard-class> and <structure-class>.

(defvar *<slotted-class>-defclass*
  '(defclass slotted-class (defined-class)
     (($subclass-of-stablehash-p ; true if <standard-stablehash> or
                           ; <structure-stablehash> is among the superclasses
        :type boolean)
      ($generic-accessors  ; flag whether to create the accessors as methods;
                           ; if false, regular functions are used
        :initform t)
      ($direct-accessors   ; automatically generated accessor methods
                           ; (as plist)
        :type list
        :initform '())
      ($valid-initargs-from-slots ; list of valid initargs, computed from slots
        :type list)        ; (not including those declared valid by methods!)
      ($instance-size      ; number of local slots of the direct instances + 1
        :type (integer 1 *)))
     (:fixed-slot-locations t)))

;; Fixed slot locations.
(defconstant *<slotted-class>-subclass-of-stablehash-p-location* 16)
(defconstant *<slotted-class>-generic-accessors-location* 17)
(defconstant *<slotted-class>-direct-accessors-location* 18)
(defconstant *<slotted-class>-valid-initargs-from-slots-location* 19)
(defconstant *<slotted-class>-instance-size-location* 20)

;; Preliminary accessors.
(predefun class-subclass-of-stablehash-p (object)
  (sys::%record-ref object *<slotted-class>-subclass-of-stablehash-p-location*))
(predefun (setf class-subclass-of-stablehash-p) (new-value object)
  (setf (sys::%record-ref object *<slotted-class>-subclass-of-stablehash-p-location*) new-value))
(predefun class-generic-accessors (object)
  (sys::%record-ref object *<slotted-class>-generic-accessors-location*))
(predefun (setf class-generic-accessors) (new-value object)
  (setf (sys::%record-ref object *<slotted-class>-generic-accessors-location*) new-value))
(predefun class-direct-accessors (object)
  (sys::%record-ref object *<slotted-class>-direct-accessors-location*))
(predefun (setf class-direct-accessors) (new-value object)
  (setf (sys::%record-ref object *<slotted-class>-direct-accessors-location*) new-value))
(predefun class-valid-initargs-from-slots (object)
  (sys::%record-ref object *<slotted-class>-valid-initargs-from-slots-location*))
(predefun (setf class-valid-initargs-from-slots) (new-value object)
  (setf (sys::%record-ref object *<slotted-class>-valid-initargs-from-slots-location*) new-value))
(predefun class-instance-size (object)
  (sys::%record-ref object *<slotted-class>-instance-size-location*))
(predefun (setf class-instance-size) (new-value object)
  (setf (sys::%record-ref object *<slotted-class>-instance-size-location*) new-value))

;; Initialization of a <slotted-class> instance.
(defun shared-initialize-<slotted-class> (class situation &rest args
                                          &key (generic-accessors t generic-accessors-p)
                                          &allow-other-keys)
  (apply #'shared-initialize-<defined-class> class situation args)
  (unless *classes-finished*
    ; Bootstrapping: Simulate the effect of #'%shared-initialize.
    (when (eq situation 't) ; called from initialize-instance?
      (setf (class-direct-accessors class) '())))
  (when (or (eq situation 't) generic-accessors-p)
    (setf (class-generic-accessors class) generic-accessors))
  ; The following slots are initialized by the subclass' shared-initialize:
  ;   subclass-of-stablehash-p
  ;   valid-initargs-from-slots
  ;   instance-size
  class)

;;; ===========================================================================

;;; The class <structure-class> represents classes like those defined through
;;; DEFSTRUCT.

(defvar <structure-class> 'structure-class)
(defvar *<structure-class>-defclass*
  '(defclass structure-class (slotted-class)
     (($names              ; encoding of the include-nesting, a list
                           ; (name_1 ... name_i-1 name_i) with name=name_1,
        :type cons)        ; name_1 contains name_2, ..., name_i-1 contains name_i.
      ($kconstructor       ; name of keyword constructor function
        :type symbol)
      ($boa-constructors   ; list of all BOA constructor function names
       :type list)
      ($copier             ; name of the copier function
       :type symbol)
      ($predicate          ; name of the predicate function
       :type symbol)
      ($prototype          ; class prototype - an instance or NIL
        :type (or structure-object null)))
     (:fixed-slot-locations t)))
(defvar *<structure-class>-class-version* (make-class-version))

;; Fixed slot locations.
(defconstant *<structure-class>-names-location* 21)
(defconstant *<structure-class>-kconstructor-location* 22)
(defconstant *<structure-class>-boa-constructors-location* 23)
(defconstant *<structure-class>-copier-location* 24)
(defconstant *<structure-class>-predicate-location* 25)
(defconstant *<structure-class>-prototype-location* 26)

;; Preliminary accessors.
(predefun class-names (object)
  (sys::%record-ref object *<structure-class>-names-location*))
(predefun (setf class-names) (new-value object)
  (setf (sys::%record-ref object *<structure-class>-names-location*) new-value))
(predefun class-kconstructor (object)
  (sys::%record-ref object *<structure-class>-kconstructor-location*))
(predefun (setf class-kconstructor) (new-value object)
  (setf (sys::%record-ref object *<structure-class>-kconstructor-location*) new-value))
(predefun class-boa-constructors (object)
  (sys::%record-ref object *<structure-class>-boa-constructors-location*))
(predefun (setf class-boa-constructors) (new-value object)
  (setf (sys::%record-ref object *<structure-class>-boa-constructors-location*) new-value))
(predefun class-copier (object)
  (sys::%record-ref object *<structure-class>-copier-location*))
(predefun (setf class-copier) (new-value object)
  (setf (sys::%record-ref object *<structure-class>-copier-location*) new-value))
(predefun class-predicate (object)
  (sys::%record-ref object *<structure-class>-predicate-location*))
(predefun (setf class-predicate) (new-value object)
  (setf (sys::%record-ref object *<structure-class>-predicate-location*) new-value))

(defconstant *<structure-class>-instance-size* 27)

;;; ===========================================================================

;;; The class <semi-standard-class> is a common superclass of <standard-class>
;;; and <funcallable-standard-class>. Both implement the "default" CLOS
;;; behaviour.

(defvar <semi-standard-class> 'semi-standard-class)
(defvar *<semi-standard-class>-defclass*
  '(defclass semi-standard-class (slotted-class)
     (($current-version    ; most recent class-version, points back to this
                           ; class
        :type simple-vector)
      ($funcallablep       ; flag whether direct instances are funcallable
        :type boolean)
      ($fixed-slot-locations ; flag whether to guarantee same slot locations
                           ; in all subclasses
        :initarg :fixed-slot-locations
        )
      ($instantiated       ; true if an instance has already been created
        :type boolean
        :initform nil)
      ($direct-instance-specializers ; set of all eql-specializers of direct
                           ; instances that may be used in methods, as a
                           ; weak-list or weak-hash-table or NIL
        :type (or hash-table weak-list null)
        :initform nil)
      ($finalized-direct-subclasses ; set of all finalized direct subclasses,
                           ; as a weak-list or weak-hash-table or NIL
        :type (or hash-table weak-list null)
        :initform '())
      ($prototype          ; class prototype - an instance or NIL
        :type (or standard-object null)))
     (:default-initargs :fixed-slot-locations nil)
     (:fixed-slot-locations t)))

;; Fixed slot locations.
(defconstant *<semi-standard-class>-current-version-location* 21)
(defconstant *<semi-standard-class>-funcallablep-location* 22)
(defconstant *<semi-standard-class>-fixed-slot-locations-location* 23)
(defconstant *<semi-standard-class>-instantiated-location* 24)
(defconstant *<semi-standard-class>-direct-instance-specializers-location* 25)
(defconstant *<semi-standard-class>-finalized-direct-subclasses-location* 26)
(defconstant *<semi-standard-class>-prototype-location* 27)

;; Preliminary accessors.
(predefun class-current-version (object)
  (sys::%record-ref object *<semi-standard-class>-current-version-location*))
(predefun (setf class-current-version) (new-value object)
  (setf (sys::%record-ref object *<semi-standard-class>-current-version-location*) new-value))
(predefun class-funcallablep (object)
  (sys::%record-ref object *<semi-standard-class>-funcallablep-location*))
(predefun (setf class-funcallablep) (new-value object)
  (setf (sys::%record-ref object *<semi-standard-class>-funcallablep-location*) new-value))
(predefun class-fixed-slot-locations (object)
  (sys::%record-ref object *<semi-standard-class>-fixed-slot-locations-location*))
(predefun (setf class-fixed-slot-locations) (new-value object)
  (setf (sys::%record-ref object *<semi-standard-class>-fixed-slot-locations-location*) new-value))
(predefun class-instantiated (object)
  (sys::%record-ref object *<semi-standard-class>-instantiated-location*))
(predefun (setf class-instantiated) (new-value object)
  (setf (sys::%record-ref object *<semi-standard-class>-instantiated-location*) new-value))
(predefun class-direct-instance-specializers-table (object)
  (sys::%record-ref object *<semi-standard-class>-direct-instance-specializers-location*))
(predefun (setf class-direct-instance-specializers-table) (new-value object)
  (setf (sys::%record-ref object *<semi-standard-class>-direct-instance-specializers-location*) new-value))
(predefun class-finalized-direct-subclasses-table (object)
  (sys::%record-ref object *<semi-standard-class>-finalized-direct-subclasses-location*))
(predefun (setf class-finalized-direct-subclasses-table) (new-value object)
  (setf (sys::%record-ref object *<semi-standard-class>-finalized-direct-subclasses-location*) new-value))
(predefun class-prototype (object)
  (sys::%record-ref object *<semi-standard-class>-prototype-location*))
(predefun (setf class-prototype) (new-value object)
  (setf (sys::%record-ref object *<semi-standard-class>-prototype-location*) new-value))

;;; ===========================================================================

;;; The class <standard-class> represents classes with the "default" CLOS
;;; behaviour.

(defvar <standard-class> 'standard-class) ; ABI
(defvar *<standard-class>-defclass*
  '(defclass standard-class (semi-standard-class)
     ()
     (:fixed-slot-locations t)))
(defvar *<standard-class>-class-version* (make-class-version))

(defconstant *<standard-class>-instance-size* 28)

;; For DEFCLASS macro expansions.
(defconstant *<standard-class>-valid-initialization-keywords* ; ABI
             '(:name :direct-superclasses :direct-slots :direct-default-initargs
               :documentation :generic-accessors :fixed-slot-locations))
(defconstant *<standard-class>-default-initargs* '(:fixed-slot-locations nil))

;;; ===========================================================================

;;; The classes <funcallable-standard-class> and <funcallable-standard-object>
;;; can be defined later.

(defvar <funcallable-standard-class> nil)
(defvar *<funcallable-standard-class>-class-version* nil)
(defvar <funcallable-standard-object> nil)

;;; ===========================================================================

;;; Type tests.

(defun built-in-class-p (object) ; ABI
  (and (std-instance-p object)
       (let ((cv (sys::%record-ref object 0)))
         ; Treat the most frequent cases first, for speed and bootstrapping.
         (cond ((eq cv *<standard-class>-class-version*) nil)
               ((eq cv *<structure-class>-class-version*) nil)
               ((eq cv *<built-in-class>-class-version*) t)
               (t ; Now a slow, but general instanceof test.
                 (gethash <built-in-class>
                          (class-all-superclasses (class-of object))))))))

(defun structure-class-p (object) ; ABI
  (and (std-instance-p object)
       (let ((cv (sys::%record-ref object 0)))
         ; Treat the most frequent cases first, for speed and bootstrapping.
         (cond ((eq cv *<standard-class>-class-version*) nil)
               ((eq cv *<structure-class>-class-version*) t)
               ((eq cv *<built-in-class>-class-version*) nil)
               (t ; Now a slow, but general instanceof test.
                 (gethash <structure-class>
                          (class-all-superclasses (class-of object))))))))

(defun semi-standard-class-p (object)
  (and (std-instance-p object)
       (let ((cv (sys::%record-ref object 0)))
         ; Treat the most frequent cases first, for speed and bootstrapping.
         (cond ((eq cv *<standard-class>-class-version*) t)
               ((eq cv *<structure-class>-class-version*) nil)
               ((eq cv *<built-in-class>-class-version*) nil)
               (t ; Now a slow, but general instanceof test.
                 (gethash <semi-standard-class>
                          (class-all-superclasses (class-of object))))))))

(defun standard-class-p (object) ; ABI
  (and (std-instance-p object)
       (let ((cv (sys::%record-ref object 0)))
         ; Treat the most frequent cases first, for speed and bootstrapping.
         (cond ((eq cv *<standard-class>-class-version*) t)
               ((eq cv *<structure-class>-class-version*) nil)
               ((eq cv *<built-in-class>-class-version*) nil)
               (t ; Now a slow, but general instanceof test.
                 (gethash <standard-class>
                          (class-all-superclasses (class-of object))))))))

(sys::def-atomic-type potential-class potential-class-p)
(sys::def-atomic-type defined-class defined-class-p)
(sys::def-atomic-type built-in-class built-in-class-p)
(sys::def-atomic-type structure-class structure-class-p)
(sys::def-atomic-type standard-class standard-class-p)

(defun forward-reference-to-class-p (object)
  (and (std-instance-p object)
       (gethash <forward-reference-to-class>
                (class-all-superclasses (class-of object)))))

;;; ===========================================================================

;;; Copying.
(defun copy-standard-class (class)
  (let* ((n (sys::%record-length class))
         (copy (allocate-metaobject-instance (sys::%record-ref class 0) n)))
    (dotimes (i n) (setf (sys::%record-ref copy i) (sys::%record-ref class i)))
    copy))

(defun print-object-<potential-class> (object stream)
  (if (and *print-readably* (defined-class-p object))
    ; Only defined-class instances can be restored through FIND-CLASS.
    (write (sys::make-load-time-eval `(FIND-CLASS ',(class-classname object)))
           :stream stream)
    (print-unreadable-object (object stream :type t)
      (let ((name (class-classname object)))
        ;; The class <string> has two names: cl:string and cs-cl:string.
        ;; Which one we show, depends on *package*.
        (when (and (eq name 'string)
                   (eq (find-symbol "STRING" *package*) 'cs-cl:string))
          (setq name 'cs-cl:string))
        (write name :stream stream))
      (when (semi-standard-class-p object)
        (if (and (slot-boundp object '$current-version)
                 (class-version-p (class-current-version object))
                 (slot-boundp object '$precedence-list))
          (progn
            (when (< (class-initialized object) 3) ; not yet finalized?
              (write-string " " stream)
              (write :incomplete :stream stream))
            ;; FIXME: Overhaul this questionable and confusing feature.
            (let ((serial (cv-serial (class-current-version object))))
              (unless (eql serial 0)
                (write-string " " stream)
                (write :version :stream stream)
                (write-string " " stream)
                (write serial :stream stream))))
          (progn
            (write-string " " stream)
            (write :uninitialized :stream stream)))))))

(defun print-object-<forward-reference-to-class> (object stream)
  (print-unreadable-object (object stream :type t)
    (write (slot-value object '$classname) :stream stream)))

;; Preliminary.
;; Now we can at least print classes.
(predefun print-object (object stream)
  (cond ((potential-class-p object) (format stream "#<CLASS ~S>" (class-classname object)))
        (t (write-string "#<UNKNOWN>" stream))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-class1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clos-class0.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Common Lisp Object System for CLISP: Classes
;;;; Bruno Haible 21.8.1993 - 2004
;;;; Sam Steingold 1998 - 2004, 2007
;;;; German comments translated into English: Stefan Kain 2002-04-08

(in-package "CLOS")

;; A vector that looks like a class. Needed to make instance_of_stablehash_p
;; work already during bootstrapping.
(defvar *dummy-class*
        (vector nil ; inst_class_version
                nil ; $hashcode
                nil ; $direct-generic-functions
                nil ; $direct-methods
                nil ; $classname
                nil ; $direct-subclasses
                nil ; $direct-superclasses
                nil ; $all-superclasses
                nil ; $precedence-list
                nil ; $direct-slots
                nil ; $slots
                nil ; $slot-location-table
                nil ; $direct-default-initargs
                nil ; $default-initargs
                nil ; $documentation
                nil ; $initialized
                t   ; $subclass-of-stablehash-p
                nil ; $generic-accessors
                nil ; $direct-accessors
                nil ; $valid-initargs
                nil ; $instance-size
)       )

;; A new class-version is created each time a class is redefined.
;; Used to keep the instances in sync through lazy updates.
;; Note: Why are the shared-slots an element of the class-version, not of the
;;   class? Answer: When a class is redefined in such a way that a shared slot
;;   becomes local, the update of the instances of its subclasses needs to
;;   access the value of the shared slot before the redefinition. This is
;;   prepared by class-version-compute-slotlists for each subclass; but when
;;   this is run, the pair (class . index) is not sufficient any more to
;;   retrieve the value. Hence we use a pair (class-version . index) instead.
;;   Then, storing the shared-slots vector in the class-version avoids an
;;   indirection:    class-version -> shared-slots
;;   instead of      class-version -> class -> shared-slots.
#|
(defstruct (class-version (:type vector) (:predicate nil) (:copier nil) (:conc-name "CV-"))
  newest-class             ; the CLASS object describing the newest available version
  class                    ; the CLASS object describing the slots
  shared-slots             ; simple-vector with the values of all shared slots, or nil
  serial                   ; serial number of this class version
  (next nil)               ; next class-version, or nil
  (slotlists-valid-p nil)  ; true if the following fields are already computed
  kept-slot-locations      ; plist of old and new slot locations of those slots
                           ; that remain local or were shared and become local
  added-slots              ; list of local slots that are added in the next version
  discarded-slots          ; list of local slots that are removed or become
                           ; shared in the next version
  discarded-slot-locations ; plist of local slots and their old slot locations
                           ; that are removed or become shared in the next version
)
|#
(defun make-class-version (&key (newest-class *dummy-class*)
                                (class *dummy-class*)
                                shared-slots serial next
                                slotlists-valid-p kept-slot-locations
                                added-slots discarded-slots discarded-slot-locations)
  (vector newest-class class shared-slots serial next
          slotlists-valid-p kept-slot-locations
          added-slots discarded-slots discarded-slot-locations))
(proclaim '(inline cv-newest-class))
(defun cv-newest-class (object) (svref object 0))
(defsetf cv-newest-class (object) (value) `(setf (svref ,object 0) ,value))
(proclaim '(inline cv-class))
(defun cv-class (object) (svref object 1))
(defsetf cv-class (object) (value) `(setf (svref ,object 1) ,value))
(proclaim '(inline cv-shared-slots))
(defun cv-shared-slots (object) (svref object 2))
(defsetf cv-shared-slots (object) (value) `(setf (svref ,object 2) ,value))
(proclaim '(inline cv-serial))
(defun cv-serial (object) (svref object 3))
(defsetf cv-serial (object) (value) `(setf (svref ,object 3) ,value))
(proclaim '(inline cv-next))
(defun cv-next (object) (svref object 4))
(defsetf cv-next (object) (value) `(setf (svref ,object 4) ,value))
(proclaim '(inline cv-slotlists-valid-p))
(defun cv-slotlists-valid-p (object) (svref object 5))
(defsetf cv-slotlists-valid-p (object) (value) `(setf (svref ,object 5) ,value))
(proclaim '(inline cv-kept-slot-locations))
(defun cv-kept-slot-locations (object) (svref object 6))
(defsetf cv-kept-slot-locations (object) (value) `(setf (svref ,object 6) ,value))
(proclaim '(inline cv-added-slots))
(defun cv-added-slots (object) (svref object 7))
(defsetf cv-added-slots (object) (value) `(setf (svref ,object 7) ,value))
(proclaim '(inline cv-discarded-slots))
(defun cv-discarded-slots (object) (svref object 8))
(defsetf cv-discarded-slots (object) (value) `(setf (svref ,object 8) ,value))
(proclaim '(inline cv-discarded-slot-locations))
(defun cv-discarded-slot-locations (object) (svref object 9))
(defsetf cv-discarded-slot-locations (object) (value) `(setf (svref ,object 9) ,value))
(defun class-version-p (object) (and (simple-vector-p object) (eql (length object) 10)))

;; Indicates whether all class-version instances are filled, so that CLASS-OF
;; works.
(defvar *classes-finished* nil)

;; Preliminary.
;; This is needed so that <standard-object> and <structure-object> instances
;; can be printed as long as 1. some class-versions are not yet filled (delayed
;; defclass) and 2. PRINT-OBJECT is not yet defined.
(predefun print-object (object stream)
  (declare (ignore object))
  (write-string "#<UNKNOWN>" stream))

(defvar *enable-clos-warnings* nil)
(defun clos-warn (type format &rest args)
  ;; type MUST be a SIMPLE-* condition!
  (when *enable-clos-warnings*
    (apply 'sys::warn-of-type type format args)))
(defmacro clos-warning (format &rest args)
  `(clos-warn 'simple-clos-warning ,format .,args))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clos-class0.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./loop.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ANSI CL Loop
;; (LOOP {loop-clause}*), CLtL2 p. 163,709-747
;; <http://www.lisp.org/HyperSpec/Body/sec_6-1.html>
;; <http://www.lisp.org/HyperSpec/Body/mac_loop.html>
;; Bruno Haible 1991-2004
;; Sam Steingold 1999-2011, 2017

(in-package "COMMON-LISP")
(export '(loop loop-finish))
(pushnew ':loop *features*)

(in-package "SYSTEM")

;; Parser auxiliary functions

;; (loop-keywordp obj) determines whether OBJ is a loop keyword,
;; and then returns the appropriate unique symbol, otherwise NIL.
(defun loop-keywordp (obj)
  (and (symbolp obj)
       (gethash (symbol-name obj)
         (load-time-value
           (make-hash-table
             :key-type 'string :value-type 'symbol
             :test 'fasthash-equal :warn-if-needs-rehash-after-gc t
             :initial-contents
               (mapcar #'(lambda (s) (cons (symbol-name s) s))
                 '(named
                   for as and from downfrom upfrom to downto upto below
                   above by in on = then across being each the hash-key
                   hash-keys hash-value hash-values of using symbol
                   present-symbol internal-symbol external-symbol symbols
                   present-symbols internal-symbols external-symbols
                   repeat
                   while until always never thereis
                   collect collecting append appending nconc nconcing
                   count counting sum summing maximize maximizing
                   minimize minimizing into
                   with
                   if when unless else end it
                   do doing return
                   of-type
                   initially finally)))))))

(defvar *whole*)                ; the entire form (LOOP ...)

;; (loop-syntax-error loop-keyword) reports a syntax error.
(defun loop-syntax-error (loop-keyword &optional location)
  (error-of-type 'source-program-error
    :form *whole*
    :detail (list loop-keyword location)
    (TEXT "~S: syntax error after ~A at ~A in ~S")
    'loop (symbol-name loop-keyword)
    (if location (prin1-to-string location) (TEXT "end of form")) *whole*))

;; destructuring:

;; (destructure-vars pattern) returns the list of variables occuring
;; in the pattern.
(defun destructure-vars (pattern)
  (let ((vars '()))
    (labels ((accumulate (pattern)
               (cond ((null pattern))
                     ((atom pattern) (push pattern vars))
                     (t
                       (accumulate (car pattern))
                       (accumulate (cdr pattern))))))
      (accumulate pattern))
    (nreverse vars)))

;; (empty-tree-p pattern) determine whether the pattern has no variables
;; at all.
(defun empty-tree-p (pattern)
  (cond ((null pattern) t)
        ((atom pattern) nil)
        (t (and (empty-tree-p (car pattern))
                (empty-tree-p (cdr pattern))))))

;; (destructure-type pattern type) returns the list of declaration
;; specifiers, that declare that each variable in 'pattern' is of the
;; corresponding type in 'type'.
(defun destructure-type (pattern type)
  (let ((declspecs '()))
    (labels ((accumulate (pattern type)
               (cond ((null pattern))
                     ((atom pattern)
                       (push `(TYPE ,type ,pattern) declspecs))
                     ((consp type)
                       (accumulate (car pattern) (car type))
                       (accumulate (cdr pattern) (cdr type)))
                     (t
                       (let ((vars (destructure-vars pattern)))
                         (when vars
                           (push `(TYPE ,type ,@vars) declspecs)))))))
      (accumulate pattern type))
    (nreverse declspecs)))

;; (simple-type-p type) determines whether 'type' contains, after
;; destructuring, only NIL, T, FIXNUM, FLOAT, and therefore can be
;; used without OF-TYPE.
(defun simple-type-p (type)
  (if (atom type)
    (case type
      ((NIL T FIXNUM FLOAT) t)
      (t nil))
    (and (simple-type-p (car type))
         (simple-type-p (cdr type)))))

(defvar *helpvars*) ;; vector of auxiliary variables for destructuring
(defvar *nullvar*)

;; (helpvar n) returns the (n+1)-st auxiliary variable (n>=0).
;; At least n auxiliary variable must already have been used.
(defun helpvar (n)
  ;; '*helpvars*' is extended if necessary.
  (when (= n (fill-pointer *helpvars*))
    (vector-push-extend (gensym "PATTERN-") *helpvars*))
  (aref *helpvars* n))

;; (destructure pattern form) returns a list of lists (variable_i form_i).
;; variable_i is a variable from 'pattern', form_i is a form, whose
;; result must be bound or assigned to variable_i. The order of the
;; bindings/assignments doesn't matter, i.e. both LET and LET*, or
;; both PSETQ and SETQ are possible.
(defun destructure (pattern form)
  (labels ((destructure-tree (pattern form helpvar-count)
             ; helpvar-count = Anzahl der belegten Hilfsvariablen
             (cond ((empty-tree-p pattern) nil)
                   ((atom pattern) (list (list pattern form)))
                   ((empty-tree-p (car pattern))
                    (destructure-tree (cdr pattern) `(CDR ,form) helpvar-count))
                   ((empty-tree-p (cdr pattern))
                    (destructure-tree (car pattern) `(CAR ,form) helpvar-count))
                   (t ; muss form zwischendurch einer Hilfsvariablen zuweisen
                     (let ((helpvar (helpvar helpvar-count)))
                       (nconc (destructure-tree (car pattern) `(CAR (SETQ ,helpvar ,form)) (1+ helpvar-count))
                              (destructure-tree (cdr pattern) `(CDR ,helpvar) helpvar-count)))))))
    (or (destructure-tree pattern form 0)
        ; no variables -> must nevertheless evaluate form!
        (list (list (or *nullvar* (setq *nullvar* (gensym "NULLVAR-"))) form)))))

;; (default-bindings vars declspecs).
;; vars = (var ...) is a list of variables without init forms.
;; Returns the binding list ((var var-init) ...), where var-init is
;; compatible with the declspecs.
(defun default-bindings (vars declspecs)
  ; Use NIL or 0 or 0.0 if it fits the declarations.
  ; Otherwise use NIL and extend the type declarations.
  (let ((bindings (mapcar #'(lambda (var) (list var 'NIL)) vars)))
    (dolist (declspec declspecs)
      (when (eq (first declspec) 'TYPE)
        ; declspec is of form (TYPE type . vars)
        (let* ((type (second declspec))
               (dtype (type-for-discrimination type))
               h)
          (cond ((typep 'NIL dtype)) ; OK
                ((or (typep (setq h '0) dtype) (typep (setq h '0.0) dtype))
                 (dolist (var (cddr declspec))
                   (setf (second (find var bindings :key #'first)) h)))
                (t (setf (second declspec) `(OR NULL ,type)))))))
    bindings))

;; A loop-initialization describes at macro expansion time the task
;; to initialise one or more variables. The initialization may end up
;; generating code in the prologue or in the inner loop.
(defstruct (loop-initialization
             (:copier nil)
             (:conc-name "LI-")
             (:predicate nil)
             (:constructor make-loop-init))
  ;; How to generate the Lisp code.
  specform           ; special form: LET or MULTIPLE-VALUE-BIND or PROGN
  bindings           ; for LET: list of bindings,
                     ; for MULTIPLE-VALUE-BIND: varlist and form
  declspecs          ; list of declspecs
  (endtest-forms nil) ; more forms to be inserted after the declarations,
                      ; within the tagbody.
  ;; Properties of this initialization.
  everytime ; If the assignment has to be evaluated in the prologue only: NIL.
            ; If the assignment has to be evaluated once for each iteration:
            ; a cons, pointing at the right place in the stepafter-code.
  (requires-stepbefore nil) ; True if the variables can get their values only
                            ; in the stepbefore-code or preamble,
                            ; false if the first assignment can be merged
                            ; with the initial binding.
  (depends-preceding nil) ; True if everytime=NIL and the values may depend
                          ; on preceding variables, so that these preceding
                          ; variables must get their values no later than in
                          ; the preamble (= prologue + startup)
  preamble                      ; cons = location in preamble
  (later-depend nil)) ; True if some later variables depend on these values,
                      ; so that these values
                      ; must be computed no later than in the preamble.

(proclaim '(inline li-vars))
(defun li-vars (li)
  (case (li-specform li)
    ((MULTIPLE-VALUE-BIND) (first (li-bindings li)))
    ((LET) (mapcar #'first (li-bindings li)))))

; (wrap-initializations initializations form) wickelt eine (umgedrehte!)
; Liste von Initialisierungen um form herum und liefert die neue Form.
(defun wrap-initializations (initializations form)
  (dolist (initialization initializations)
    (let ((name (li-specform initialization))
          (bindings (li-bindings initialization))
          (declarations (li-declspecs initialization)))
      (setq form
            `(,name
              ,@(case name (MULTIPLE-VALUE-BIND bindings) (LET `(,bindings)))
              ,@(if declarations `((DECLARE ,@declarations)))
              ,@(li-endtest-forms initialization)
              ,form))))
  form)

(defun wrap-unwind-protect (protect-forms form)
  (if protect-forms
      `(unwind-protect ,form ,@protect-forms)
      form))

;; Variable containing the last test result, called "it".
(defvar *last-it*)
;; Flag whether this variable is used.
(defvar *used-it*)

;;; (revadd a b c d) ==
;;; (SETF A (REVAPPEND B (REVAPPEND C (REVAPPEND D A))))
(defmacro revadd (place &rest forms)
  (labels ((expand (rest)
             (if rest `(revappend ,(car rest) ,(expand (cdr rest))) place)))
    `(setf ,place ,(expand forms))))

;; The bulk of the expander.
(defun expand-loop (*whole* body)
  (let ((body-rest body) ; alle Parse-Funktionen verkrzen body-rest
        (block-name 'NIL) ; Name des umgebenden BLOCKs
        (already-within-main nil) ; im zweiten Teil von {variables}* {main}* ?
        (*helpvars* (make-array 1 :fill-pointer 0 :adjustable t))
        (*nullvar* nil)
        (*last-it* nil)
        (var-list nil)          ; all variables seen so far
        (start-bindings nil)    ; bindings for start forms
        (acculist-var nil) ; Akkumulationsvariable fr collect, append etc.
        (accuvar-tailvar-alist nil) ; alist of (accu-var . tail-var)
        (accunum-var nil) ; Akkumulationsvariable fr count, sum etc.
        (accu-vars-nil nil) ; Akkumulationsvariablen mit Initialwert NIL
        (accu-vars-0 nil) ; Akkumulationsvariablen mit Initialwert 0
        (accu-table (make-hash-table :warn-if-needs-rehash-after-gc t
                                     :test 'stablehash-eq)) ; var --> clauses
        (accu-declarations nil) ; Typdeklarationen (umgedrehte Liste von declspecs)
        (initializations nil) ; Bindungen: (init ...) (umgedrehte Liste)
        (seen-for-as-= nil) ; schon eine FOR-AS-= Klausel gesehen?
        (seen-endtest nil) ; schon eine FOR-AS Klausel mit Abbruchbedingung gesehen?
        (preamble nil) ; annotated: ([:INITIALLY|:START] . code) (reversed)
        (stepbefore-code nil) ; Code zum Abbruch vor dem Schleifendurchlauf (umgedrehte Liste)
        (main-code nil) ; Code im Hauptteil der Schleife (umgedrehte Liste)
        (stepafter-code nil) ; Code zur Vorbereitung des nchsten Schleifendurchlaufs (umgedrehte Liste)
        (accu-vars-nreverse nil) ; Akkumulationsvariablen, die am Schluss umzudrehen sind
        (finally-code nil) ; finally-Code (umgedrehte Liste)
        (backward-consing-p     ; is backward-consing possible?
         (do ((rest *whole* (cdr rest)))
             ((endp rest) t)
           (case (loop-keywordp (car rest))
             ((NCONC NCONCING APPEND APPENDING)
              (unless (eq (loop-keywordp (caddr rest)) 'INTO)
                (return nil))))))
        (protect-forms '())
        (results nil)) ; alist (value-form . (clause list))
    (labels
      ((next-kw () ; Schaut, ob als nchstes ein Keyword kommt.
                   ; Wenn ja, wird es geliefert. Wenn nein, Ergebnis NIL.
         (and (consp body-rest) (loop-keywordp (first body-rest))))
       (preamble (kind &optional form) (car (push (cons kind form) preamble)))
       (cons-forward (form accuvar accufuncsym)
         (let ((tailvar
                (cdr (or (assoc accuvar accuvar-tailvar-alist)
                         (car (setq accuvar-tailvar-alist
                                    (acons accuvar
                                           (gensym (symbol-name accuvar))
                                           accuvar-tailvar-alist))))))
               (incrementvar (gensym "ADDLIST-")))
           (push accuvar accu-vars-nil)
           (push tailvar accu-vars-nil)
           `(LET ((,incrementvar
                   ,(ecase accufuncsym
                      (CONS `(LIST ,form))
                      (REVAPPEND `(COPY-LIST ,form))
                      (NRECONC `,form))))
              (IF ,accuvar
                ,(case accufuncsym
                   (CONS `(SETF ,tailvar (SETF (CDR ,tailvar) ,incrementvar)))
                   (t `(SETF ,tailvar (LAST (RPLACD ,tailvar ,incrementvar)))))
                ,(case accufuncsym
                   (CONS `(SETF ,tailvar (SETF ,accuvar ,incrementvar)))
                   (t `(SETF ,tailvar (LAST (SETF ,accuvar
                                                  ,incrementvar)))))))))
       (compatible-p (kw1 kw2)
         ;; <http://www.lisp.org/HyperSpec/Body/sec_6-1-3.html>
         (let ((ht #,(make-hash-table
                      :warn-if-needs-rehash-after-gc t
                      :test 'stablehash-eq
                      :initial-contents
                      '((collect . list) (collecting . list)
                        (append . list) (appending . list)
                        (nconc . list) (nconcing . list)
                        (sum . sum-count) (summing . sum-count)
                        (count . sum-count) (counting . sum-count)
                        (maximize . max-min) (maximizing . max-min)
                        (minimize . max-min) (minimizing . max-min)))))
           (eq (gethash kw1 ht) (gethash kw2 ht))))
       (new-accu-var (var clause)
         (let ((others (gethash var accu-table)) bad)
           (when (setq bad (find (first clause) others
                                 :key #'first :test-not #'compatible-p))
             (error-of-type 'source-program-error
               :form *whole* :detail clause
               (TEXT "~S: variable ~S is used in incompatible clauses~{ ~A ~S~} and~{ ~A ~S~}")
               *whole* var clause bad))
           (setf (gethash var accu-table) (cons clause others))))
       (new-result (form clause)
         (let ((pair (assoc form results :test #'equal)))
           (if pair
               (push clause (cdr pair))
               (push (list form clause) results))
           results))
       (acculist-var (keyword form)
         (or acculist-var
             (progn (setq acculist-var (gensym "ACCULIST-VAR-"))
                    (push acculist-var accu-vars-nil)
                    (let ((clause (list keyword form)))
                      (new-accu-var acculist-var clause)
                      (unless backward-consing-p
                        (new-result acculist-var clause)))
                    acculist-var)))
       (cons-backward (keyword form) ; accuvar is NIL, accufuncsym is CONS
         (let ((accuvar (acculist-var keyword form)))
           (new-result `(SYS::LIST-NREVERSE ,accuvar) `(,keyword ,form))
           `(SETQ ,accuvar (CONS ,form ,accuvar))))
       (parse-kw-p (kw) ; Schaut, ob als nchstes das Keyword kw kommt.
                        ; Wenn ja, wird es bergangen. Wenn nein, Ergebnis NIL.
         (and (consp body-rest) (eq (loop-keywordp (first body-rest)) kw)
              (progn (pop body-rest) t)))
       (parse-form (kw) ; Nach kw: parst expr
         (unless (consp body-rest) (loop-syntax-error kw))
         (pop body-rest))
       (parse-form-or-it (kw) ; Nach kw: parst expr, das auch 'it' sein kann
         (unless (consp body-rest) (loop-syntax-error kw))
         (let ((form (pop body-rest)))
           (if (eq (loop-keywordp form) 'it)
             (if *last-it*
               (progn (setq *used-it* t) *last-it*)
               form)
             form)))
       (parse-var-typespec () ;; parse var [typespec]
         ;; return the variable pattern and the list of declspecs
         (unless (consp body-rest)
           (error-of-type 'source-program-error
             :form *whole* :detail body-rest
             (TEXT "~S: missing variable.") 'loop))
         (let ((pattern (pop body-rest))
               (typedecl nil))
           (block nil
             (unless (consp body-rest) (return))
             (case (loop-keywordp (first body-rest))
               ((NIL)           ; no loop keyword ->interpret as typespec
                (setq typedecl (pop body-rest))
                (unless (simple-type-p typedecl)
                  (warn (TEXT "~S: After ~S, ~S is interpreted as a type specification")
                        'loop pattern typedecl)))
               ((OF-TYPE)       ; OF-TYPE -> expect a typespec
                (pop body-rest)
                (setq typedecl (parse-form 'of-type)))
               (T (return)))    ; other
             (setq typedecl (destructure-type pattern typedecl)))
           (values pattern typedecl)))
       (parse-progn (kw) ; parses {compound-form}* and return the list of forms
         (let ((list nil) form)
           (loop
             (unless (and (consp body-rest)
                          (not (loop-keywordp (first body-rest))))
               (return))
             (setq form (pop body-rest))
             (when (atom form)
               (if *loop-ansi*
                 (loop-syntax-error kw form)
                 (warn (TEXT "~S: non-compound form ~S after ~A: permitted by CLtL2, forbidden by ANSI CL.") 'loop form (symbol-name kw))))
             (push form list))
           (nreverse list)))
       (parse-nonempty-progn (kw) ; after kw: [ANSI] {compound-form}+ [CLTL2] {expr}*
         (let ((exprs (parse-progn kw)))
           (unless exprs
             (if *loop-ansi*
               (loop-syntax-error kw)
               (warn (TEXT "~S: missing forms after ~A: permitted by CLtL2, forbidden by ANSI CL.") 'loop (symbol-name kw))))
           exprs))
       (parse-unconditional () ;; parse an unconditional
         ;; unconditional ::= {do | doing} {compound-form}*
         ;; unconditional ::= return expr
         ;; Returns a lisp form or NIL when no unconditional was parsed.
         (let ((kw (next-kw)))
           (case kw
             ((DO DOING)
              (pop body-rest)
              `(PROGN ,@(parse-nonempty-progn kw)))
             ((RETURN)
              (pop body-rest)
              `(RETURN-FROM ,block-name ,(parse-form-or-it kw)))
             (t 'NIL))))
       (parse-clause () ;; parses a clause
         ;; clause ::= accumulation | conditional | unconditional
         ;; accumulation ::= {collect | collecting | append | appending |
         ;;                   nconc | nconcing} expr [into var]
         ;; accumulation ::= {count | counting | sum | summing |
         ;;                   maximize | maximizing | minimize |
         ;;                   minimizing} expr [into var] [typespec]
         ;; conditional ::= {if | when | unless} expr clause {and clause}*
         ;;                 [else clause {and clause}*] [end]
         ;; Returns a lisp form or NIL when no clause was parsed.
         (or (parse-unconditional)
             (let ((kw (next-kw)))
               (case kw
                 ((COLLECT COLLECTING APPEND APPENDING NCONC NCONCING)
                  (pop body-rest)
                  ;; It seems permitted to write
                  ;;   (loop ...  collect i into c collect (copy-list c))
                  ;; Therefore we must use forward-consing collection
                  ;; (keeping the tail in a separate variable) if the
                  ;; accumulation variable is named, and can use the more
                  ;; efficient backward-consing (with nreverse at the end)
                  ;; only for unnamed accumulation.
                  ;; Also, APPEND/NCONC require forward-consing because
                  ;; REVAPPEND/NRECONC drop the last atom in dotted lists
                  (let ((form (parse-form-or-it kw))
                        (accuvar nil)
                        (accufuncsym
                          (case kw
                            ((COLLECT COLLECTING) 'CONS)
                            ((APPEND APPENDING) 'REVAPPEND)
                            ((NCONC NCONCING) 'NRECONC))))
                    (when (parse-kw-p 'into)
                      (unless (and (consp body-rest)
                                   (symbolp (setq accuvar (pop body-rest))))
                        (loop-syntax-error 'into accuvar)))
                    (cond (accuvar ; named acc var -> forward-consing.
                           (cons-forward form accuvar accufuncsym))
                          ((or (eq accufuncsym 'REVAPPEND)
                               (eq accufuncsym 'NRECONC)
                               (null backward-consing-p))
                           ;; REVAPPEND/NRECONC now or before
                           (when backward-consing-p
                             (error "~s: internal error: backward consing should be illegal!" *whole*))
                           (cons-forward form (acculist-var kw form)
                                         accufuncsym))
                          (t ; Unnamed acc var & CONS -> cons-backward
                           (cons-backward kw form)))))
                 ((COUNT COUNTING SUM SUMMING MAXIMIZE MAXIMIZING
                   MINIMIZE MINIMIZING)
                  (pop body-rest)
                  (let* ((form (parse-form-or-it kw)) (type 'fixnum)
                         (accuvar nil) (clause (list kw form)))
                    (when (parse-kw-p 'into)
                      (unless (and (consp body-rest)
                                   (symbolp (setq accuvar (pop body-rest))))
                        (loop-syntax-error 'into accuvar)))
                    (unless accuvar
                      (setq accuvar
                            (or accunum-var
                                (setq accunum-var (gensym "ACCUNUM-VAR-"))))
                      (new-result accuvar clause))
                    (new-accu-var accuvar clause)
                    (when (consp body-rest)
                      (let ((kw2 (loop-keywordp (first body-rest))))
                        (when (or (not kw2) (eq kw2 'of-type))
                          (setq type
                                (if (not kw2) (pop body-rest)
                                  (progn (pop body-rest)
                                         (parse-form 'of-type))))
                          (case kw
                            ((MAXIMIZE MAXIMIZING MINIMIZE MINIMIZING)
                             (setq type `(OR NULL ,type)))) ; wegen Startwert NIL
                          (push `(TYPE ,type ,accuvar) accu-declarations))))
                    (case kw
                      ((MAXIMIZE MAXIMIZING MINIMIZE MINIMIZING)
                       (push accuvar accu-vars-nil))
                      ((COUNT COUNTING SUM SUMMING)
                       (push (list accuvar (coerce 0 type)) accu-vars-0)))
                    (case kw
                      ((COUNT COUNTING) `(WHEN ,form (INCF ,accuvar)))
                      ((SUM SUMMING) `(SETQ ,accuvar (+ ,accuvar ,form)))
                      ((MAXIMIZE MAXIMIZING) `(SETQ ,accuvar (MAX-IF ,form ,accuvar)))
                      ((MINIMIZE MINIMIZING) `(SETQ ,accuvar (MIN-IF ,form ,accuvar))))))
                 ((IF WHEN UNLESS)
                  (pop body-rest)
                  (let* ((condition (parse-form kw))
                         (it-var (gensym "IT-"))
                         used-it
                         (true-form
                           (let ((*last-it* it-var) (*used-it* nil))
                             (prog1
                               (parse-clauses kw)
                               (setq used-it *used-it*))))
                         (false-form 'NIL))
                    (when (parse-kw-p 'else)
                      (setq false-form
                        (let ((*last-it* it-var) (*used-it* nil))
                          (prog1
                            (parse-clauses 'else)
                            (setq used-it (or used-it *used-it*))))))
                    (parse-kw-p 'end)
                    (when used-it
                      (psetq it-var `((,it-var ,condition))
                             condition it-var))
                    (let ((form
                            `(IF ,(if (eq kw 'UNLESS)
                                    `(NOT ,condition) ; UNLESS
                                    `,condition) ; IF, WHEN
                               ,true-form
                               ,false-form)))
                      (if used-it `(LET ,it-var ,form) `,form))))
                 (t 'NIL)))))
       (parse-clauses (kw) ; Nach kw: parst  clause {and clause}*
                           ; oder kurz       {clause}+{and}
         ; Liefert eine Lisp-Form.
         (let ((clauses nil))
           (loop
             (let ((clause (parse-clause)))
               (unless clause (loop-syntax-error kw))
               (push clause clauses))
             (unless (parse-kw-p 'and) (return))
             (setq kw 'and)
             (setq *last-it* nil)) ; 'it' ist nur in der ersten Klausel gltig
           `(PROGN ,@(nreverse clauses))))
       ; Binden und Initialisieren von Variablen:
       ; Nach ANSI-CL 6.1.1.4 gelten zwei Grundregeln:
       ; - Beim Initialisieren von FOR-AS Variablen (auer FOR-AS-=) sind
       ;   mindestens alle vorherigen FOR-AS Variablen sichtbar.
       ; - Beim Initialisieren von FOR-AS-= Variablen sind alle FOR-AS Variablen
       ;   sichtbar.
       ; Zustzlich ist die folgende Grundregel wnschenswert:
       ; - Beim Initialisieren von FOR-AS-= Variablen sind mindestens alle
       ;   vorherigen FOR-AS Variablen initialisiert und deren Abbruch-
       ;   bedingungen abgeprft.
       ; Man knnte erst alle Variablen binden und dann im preamble
       ; die Initialisierungen durchfhren. Wir fhren demgegenber zwei
       ; Optimierungen durch:
       ; - Falls vor der FOR-AS Variablen keine FOR-AS-= Klausel kommt,
       ;   braucht die Variable zum Zeitpunkt ihrer Initialisierung nicht
       ;   sichtbar zu sein, und wir verlagern ihre Initialisierung nach
       ;   vorne, zur Bindung. Das geht aber nur, wenn vor der FOR-AS Variablen
       ;   keine FOR-AS Klausel mit Abbruchbedingung kommt.
       ; - Falls eine Variable gar nicht sichtbar zu sein braucht, weil keine
       ;   FOR-AS-= Klausel vorkommt und hinter ihr auch keine andere FOR-AS
       ;   Klausel strt, knnen die Bindung und die Initialiserung der
       ;   Variablen ins Schleifeninnere verschoben werden.
       (note-initialization (initialization)
         (when (or (li-bindings initialization)
                   (li-declspecs initialization)
                   (li-endtest-forms initialization))
           (when seen-for-as-=
             (setf (li-requires-stepbefore initialization) t))
           (when (li-endtest-forms initialization)
             (setq seen-endtest t))
           (dolist (var (li-vars initialization))
             (when (and (not (eq var *nullvar*)) (memq var var-list))
               (error-of-type 'source-program-error
                 :form *whole* :detail var
                 (TEXT "~S: duplicate iteration variable ~S") *whole* var))
             (push var var-list))
           (push initialization initializations)))
       (make-endtest (endtest-form)
         (make-loop-init
           :specform 'PROGN
           :bindings nil
           :declspecs nil
           :endtest-forms (list endtest-form)
           :everytime (setq stepafter-code (cons 'NIL stepafter-code))
           :preamble (preamble :start)
           :requires-stepbefore seen-endtest)))
      ;; Los geht's!
      ; parst: [named name]
      (when (parse-kw-p 'named)
        (unless (and (consp body-rest) (symbolp (first body-rest)))
          (loop-syntax-error 'named (first body-rest)))
        (setq block-name (pop body-rest)))
      (loop
        ; main ::= clause | termination | initially | finally |
        ;          with | for-as | repeat
        ; termination ::= {while | until | always | never | thereis} expr
        ; initially ::= initially {expr}*
        ; finally ::= finally { unconditional | {expr}* }
        ; with ::= with {var-typespec [= expr]}+{and}
        ; for-as ::= {for | as} {var-typespec ...}+{and}
        ; repeat ::= repeat expr
        (unless (consp body-rest) (return))
        (let ((clause (parse-clause)))
          (if clause
            (progn (setq already-within-main t) (push clause main-code))
            (let ((kw (loop-keywordp (first body-rest))))
              (case kw
                ((WHILE UNTIL ALWAYS NEVER THEREIS REPEAT)
                 (pop body-rest)
                 (setq already-within-main t)
                 (let ((form (parse-form kw)))
                   (push (case kw
                           (WHILE `(UNLESS ,form (LOOP-FINISH)))
                           (UNTIL `(WHEN ,form (LOOP-FINISH)))
                           (ALWAYS
                             (new-result 'T (list kw form))
                             `(UNLESS ,form (RETURN-FROM ,block-name 'NIL)))
                           (NEVER
                             (new-result 'T (list kw form))
                             `(WHEN ,form (RETURN-FROM ,block-name 'NIL)))
                           (THEREIS
                             (let ((dummy (gensym "THEREIS-")))
                               (new-result 'NIL (list kw form))
                               `(BLOCK ,dummy
                                  (RETURN-FROM ,block-name
                                    (OR ,form (RETURN-FROM ,dummy NIL))))))
                           ((REPEAT)
                            (let ((var (gensym "COUNT-")))
                              (note-initialization
                               (make-loop-init
                                :specform 'LET
                                :bindings `((,var ,form))
                                :declspecs nil
                                :everytime nil
                                :requires-stepbefore seen-endtest
                                :preamble (preamble :start)
                                :depends-preceding nil))
                              (note-initialization
                               (make-endtest `(UNLESS (PLUSP ,var)
                                                (LOOP-FINISH))))
                              `(SETQ ,var (1- ,var)))))
                         main-code)))
                ((INITIALLY)
                 (pop body-rest)
                 (preamble :INITIALLY `(PROGN ,@(parse-nonempty-progn kw))))
                ((FINALLY)
                 (pop body-rest)
                 (push (let ((form (parse-unconditional)))
                         (if form
                           (if *loop-ansi*
                             (loop-syntax-error 'FINALLY form)
                             (warn (TEXT "~S: loop keyword immediately after ~A: permitted by CLtL2, forbidden by ANSI CL.") 'loop (symbol-name kw)))
                           (setq form `(PROGN ,@(parse-nonempty-progn kw))))
                          form)
                       finally-code))
                ((WITH FOR AS)
                 (pop body-rest)
                 (when already-within-main
                   (warn (TEXT "~S: ~A clauses should occur before the loop's main body")
                         'loop (symbol-name kw)))
                 (case kw
                   ((WITH)
                    (let ((bindings nil)
                          (declspecs nil))
                      (loop
                        (let (new-bindings)
                          (multiple-value-bind (pattern new-declspecs) (parse-var-typespec)
                            (if (parse-kw-p '=)
                              ; Initialisierungsform angegeben.
                              (let ((form (parse-form '=)))
                                (setq new-bindings (destructure pattern form)))
                              ; keine Initialisierungsform angegeben.
                              (setq new-bindings (default-bindings (destructure-vars pattern) new-declspecs)))
                            (revadd bindings new-bindings)
                            (revadd declspecs new-declspecs)))
                        (unless (parse-kw-p 'and) (return))
                        (setq kw 'and))
                      (note-initialization
                        (make-loop-init
                          :specform 'LET
                          :bindings (nreverse bindings)
                          :declspecs (nreverse declspecs)
                          :everytime nil
                          ;; WITH vars should always be bound on top
                          :requires-stepbefore nil ; seen-endtest
                          :preamble (preamble :start)
                          :depends-preceding t))))
                   ((FOR AS)
                    ; for-as ::= {for | as} for-as-clause {and [{for | as}] for-as-clause}*
                    ; for-as-clause ::= var-typespec
                    ;                   [{from | downfrom | upfrom} expr]
                    ;                   [{to | downto | upto | below | above} expr]
                    ;                   [by expr]
                    ; for-as-clause ::= var-typespec {in | on} expr [by expr]
                    ; for-as-clause ::= var-typespec = expr [then expr]
                    ; for-as-clause ::= var-typespec across expr
                    ; for-as-clause ::= var-typespec being {each | the}
                    ;                   {hash-key[s] | hash-value[s]}
                    ;                   {in | of} expr
                    ;                   [using ( {hash-value | hash-key} var ) ]
                    ; for-as-clause ::= var-typespec being {each | the}
                    ;                   {symbol[s] | present-symbol[s] | internal-symbol[s] | external-symbol[s]}
                    ;                   {in | of} expr
                    (let ((bindings nil)
                          (declspecs nil)
                          (initializations nil)
                          (stepafter nil)
                          (old-seen-endtest seen-endtest)
                          ;; remember the _CURRENT_ location in preamble
                          (preamble-entry (preamble :start))
                          (depends-preceding nil))
                      (flet ((note-initialization (initialization)
                               ;; supersedes the outer definition!
                               ;; Calls to note-initialization must temporarily be suspended.
                               (when (li-endtest-forms initialization)
                                 (setq seen-endtest t))
                               (push initialization initializations)))
                        (loop
                          (multiple-value-bind (pattern new-declspecs) (parse-var-typespec)
                            (let ((preposition (next-kw)))
                              (case preposition
                                ((IN ON)
                                 (pop body-rest)
                                 (let ((start-form (parse-form preposition))
                                       (start-var (gensym "START-"))
                                       (step-function-form '(FUNCTION CDR))
                                       (step-function-var nil))
                                   (push `(,start-var ,start-form) start-bindings)
                                   (when (parse-kw-p 'by)
                                     (setq step-function-form (parse-form 'by))
                                     (unless (and (function-form-p step-function-form)
                                                  (function-name-p (second step-function-form)))
                                       (setq step-function-var (gensym "BY-"))))
                                   (let ((var (if (and pattern (symbolp pattern)
                                                       (eq preposition 'ON))
                                                  pattern (gensym "LIST-"))))
                                     (push `(,var ,start-var) bindings)
                                     (when step-function-var
                                       (push `(,step-function-var ,step-function-form)
                                             bindings))
                                     (note-initialization
                                      (make-endtest
                                       `(WHEN (,(if (eq preposition 'IN)
                                                    'ENDP 'ATOM)
                                                ,var)
                                          (LOOP-FINISH))))
                                     (unless (eq var pattern)
                                       (note-initialization
                                        (make-loop-init
                                         :specform 'LET
                                         :bindings (destructure pattern (if (eq preposition 'IN) `(CAR ,var) var))
                                         :declspecs new-declspecs
                                         :everytime t
                                         :preamble (preamble :start)
                                         :requires-stepbefore seen-endtest)))
                                     (push
                                       (list var
                                             (if step-function-var
                                               `(FUNCALL ,step-function-var ,var)
                                               `(,(second step-function-form) ,var)))
                                       stepafter))))
                                (=
                                 (pop body-rest)
                                 (let* ((first-form (parse-form 'preposition))
                                        (then-form first-form))
                                   (when (parse-kw-p 'then)
                                     (setq then-form (parse-form 'then)))
                                   (revadd bindings (destructure pattern first-form))
                                   (revadd declspecs new-declspecs)
                                   (unless (and (constantp first-form)
                                                (constantp then-form))
                                     (setq seen-for-as-= t)
                                     ;; Even when `first-form' is constant but
                                     ;; `then-form' is not, we must set
                                     ;; `depends-preceding', because the
                                     ;; `stepafter-code' depends on the order of
                                     ;; the steppings, which forbids moving
                                     ;; some code from `preamble' +
                                     ;; `stepafter-code' to `stepbefore-code.'
                                     (setq depends-preceding t))
                                   (revadd stepafter (destructure pattern then-form))))
                                (ACROSS
                                 (pop body-rest)
                                 (let ((vector-form (parse-form preposition))
                                       (start-var (gensym "START-"))
                                       (vector-var (gensym "VECTOR-"))
                                       (index-var (gensym "INDEX-")))
                                   (push `(,start-var ,vector-form) start-bindings)
                                   (push `(,vector-var ,start-var) bindings)
                                   (push `(,index-var 0) bindings)
                                   (note-initialization
                                    (make-endtest `(WHEN (>= ,index-var (LENGTH ,vector-var)) (LOOP-FINISH))))
                                   (note-initialization
                                    (make-loop-init
                                     :specform 'LET
                                     :bindings (destructure pattern `(AREF ,vector-var ,index-var))
                                     :declspecs new-declspecs
                                     :everytime t
                                     :preamble (preamble :start)
                                     :requires-stepbefore seen-endtest))
                                   (push (list index-var `(1+ ,index-var)) stepafter)))
                                (BEING
                                 (pop body-rest)
                                 (let ((plural (next-kw)))
                                   (case plural
                                     ((EACH THE))
                                     (t (loop-syntax-error 'being plural)))
                                   (pop body-rest)
                                   (let ((preposition (next-kw)))
                                     (case preposition
                                       ((HASH-KEY HASH-VALUE
                                         SYMBOL PRESENT-SYMBOL INTERNAL-SYMBOL EXTERNAL-SYMBOL)
                                        (when (eq plural 'THE)
                                          (warn (TEXT "~S: After ~S a plural loop keyword is required, not ~A")
                                                'loop plural (symbol-name preposition))))
                                       ((HASH-KEYS HASH-VALUES
                                         SYMBOLS PRESENT-SYMBOLS INTERNAL-SYMBOLS EXTERNAL-SYMBOLS)
                                        (when (eq plural 'EACH)
                                          (warn (TEXT "~S: After ~S a singular loop keyword is required, not ~A")
                                                'loop plural (symbol-name preposition))))
                                       (t (loop-syntax-error plural preposition)))
                                     (pop body-rest)
                                     (case preposition
                                       ((HASH-KEY HASH-KEYS HASH-VALUE HASH-VALUES)
                                        (let ((other-pattern nil)
                                              (form
                                               (case (next-kw)
                                                 ((IN OF) (pop body-rest)
                                                  (parse-form preposition))
                                                 (t (loop-syntax-error
                                                      preposition (car body-rest)))))
                                              (start-var (gensym "START-")))
                                          (push `(,start-var ,form) start-bindings)
                                          (when (parse-kw-p 'using)
                                            (unless (and (consp body-rest)
                                                         (consp (car body-rest))
                                                         (consp (cdar body-rest))
                                                         (null (cddar body-rest))
                                                         (case (loop-keywordp (caar body-rest))
                                                           ((HASH-KEY HASH-KEYS)
                                                            (case preposition
                                                              ((HASH-VALUE HASH-VALUES) t) (t nil)))
                                                           ((HASH-VALUE HASH-VALUES)
                                                            (case preposition
                                                              ((HASH-KEY HASH-KEYS) t) (t nil)))))
                                              (loop-syntax-error
                                                'using (car body-rest)))
                                            (setq other-pattern (second (pop body-rest))))
                                          (let ((state-var (gensym "WHTI-"))
                                                (nextp-var (gensym "MORE?"))
                                                (nextkey-var (gensym "HASH-KEY-"))
                                                (nextvalue-var (gensym "HASH-VALUE-")))
                                            (multiple-value-bind (nextmain-var nextother-var)
                                                (case preposition
                                                  ((HASH-KEY HASH-KEYS) (values nextkey-var nextvalue-var))
                                                  ((HASH-VALUE HASH-VALUES) (values nextvalue-var nextkey-var)))
                                              (push `(,state-var (SYS::HASH-TABLE-ITERATOR ,start-var)) bindings)
                                              (note-initialization
                                               (make-loop-init
                                                :specform 'MULTIPLE-VALUE-BIND
                                                :bindings `((,nextp-var ,nextkey-var ,nextvalue-var)
                                                            (SYS::HASH-TABLE-ITERATE ,state-var))
                                                :declspecs (unless other-pattern `((IGNORE ,nextother-var)))
                                                :endtest-forms `((UNLESS ,nextp-var (LOOP-FINISH)))
                                                :everytime t
                                                :preamble (preamble :start)
                                                :requires-stepbefore seen-endtest))
                                              (note-initialization
                                               (make-loop-init
                                                :specform 'LET
                                                :bindings (destructure pattern nextmain-var)
                                                :declspecs new-declspecs
                                                :everytime t
                                                :preamble (preamble :start)
                                                :requires-stepbefore seen-endtest))
                                              (when other-pattern
                                                (note-initialization
                                                 (make-loop-init
                                                  :specform 'LET
                                                  :bindings (destructure other-pattern nextother-var)
                                                  :declspecs nil
                                                  :everytime t
                                                  :preamble (preamble :start)
                                                  :requires-stepbefore seen-endtest)))))))
                                       ((SYMBOL SYMBOLS PRESENT-SYMBOL PRESENT-SYMBOLS
                                         INTERNAL-SYMBOL INTERNAL-SYMBOLS EXTERNAL-SYMBOL EXTERNAL-SYMBOLS)
                                        (let ((flags (case preposition
                                                       ((SYMBOL SYMBOLS) '(:internal :external :inherited))
                                                       ((PRESENT-SYMBOL PRESENT-SYMBOLS) '(:internal :external))
                                                       ((INTERNAL-SYMBOL INTERNAL-SYMBOLS) '(:internal))
                                                       ((EXTERNAL-SYMBOL EXTERNAL-SYMBOLS) '(:external))))
                                              (state-var (gensym "WPI-"))
                                              (nextp-var (gensym "MORE?"))
                                              (nextsym-var (gensym "SYMBOL-"))
                                              (form
                                               (case (next-kw)
                                                 ((IN OF) (pop body-rest)
                                                  (parse-form preposition))
                                                 (t '*package*))))
                                          (push `(,state-var (SYS::PACKAGE-ITERATOR ,form ',flags))
                                                bindings)
                                          (note-initialization
                                           (make-loop-init
                                            :specform 'MULTIPLE-VALUE-BIND
                                            :bindings `((,nextp-var ,nextsym-var)
                                                        (SYS::PACKAGE-ITERATE ,state-var))
                                            :declspecs nil
                                            :endtest-forms `((UNLESS ,nextp-var (LOOP-FINISH)))
                                            :everytime t
                                            :preamble (preamble :start)
                                            :requires-stepbefore seen-endtest))
                                          (note-initialization
                                           (make-loop-init
                                            :specform 'LET
                                            :bindings (destructure pattern nextsym-var)
                                            :declspecs new-declspecs
                                            :everytime t
                                            :preamble (preamble :start)
                                            :requires-stepbefore seen-endtest))))))))
                                (t
                                 (unless (symbolp pattern)
                                   (loop-syntax-error kw pattern))
                                 (unless pattern (setq pattern (gensym "FOR-NUM-")))
                                 ;; ANSI CL 6.1.2.1.1 implies that the
                                 ;; start/end/by clauses can come in any
                                 ;; order, but only one of each kind.
                                 (let ((step-start-p nil)
                                       (step-end-p nil)
                                       (step-by-p nil)
                                       step-start-form
                                       step-end-form
                                       step-by-form
                                       step-end-preposition
                                       dir)
                                   (loop
                                     (cond ((and (not step-start-p)
                                                 (setq dir (case preposition
                                                             (FROM 't)
                                                             (UPFROM 'up)
                                                             (DOWNFROM 'down)
                                                             (t nil))))
                                            (setq step-start-p dir)
                                            (pop body-rest)
                                            (setq step-start-form (parse-form preposition))
                                            (push `(,pattern ,step-start-form) bindings))
                                           ((and (not step-end-p)
                                                 (setq dir (case preposition
                                                             (TO 't)
                                                             ((UPTO BELOW) 'up)
                                                             ((DOWNTO ABOVE) 'down)
                                                             (t nil))))
                                            (setq step-end-p dir)
                                            (setq step-end-preposition preposition)
                                            (pop body-rest)
                                            (setq step-end-form (parse-form preposition))
                                            (unless (constantp step-end-form)
                                              (let ((step-end-var (gensym "LIMIT-")))
                                                (push `(,step-end-var ,step-end-form) bindings)
                                                (setq step-end-form step-end-var))))
                                           ((and (not step-by-p)
                                                 (eq preposition 'BY))
                                            (setq step-by-p t)
                                            (pop body-rest)
                                            (setq step-by-form (parse-form 'by))
                                            (unless (constantp step-by-form)
                                              (let ((step-by-var (gensym "BY-")))
                                                (push `(,step-by-var ,step-by-form) bindings)
                                                (setq step-by-form step-by-var))))
                                           (t (return)))
                                     (setq preposition (next-kw)))
                                   ;; All parsing done, gather the declarations:
                                   (revadd declspecs new-declspecs)
                                   ;; Determine the direction of iteration:
                                   (let ((step-direction
                                           (if (or (eq step-start-p 'down) (eq step-end-p 'down))
                                             (if (or (eq step-start-p 'up) (eq step-end-p 'up))
                                               (error-of-type 'source-program-error
                                                 :form *whole* :detail kw
                                                 (TEXT "~S: questionable iteration direction after ~A")
                                                 'loop (symbol-name kw))
                                               'down)
                                             (if (or step-start-p step-end-p step-by-p)
                                               'up
                                               (error-of-type 'source-program-error
                                                 :form *whole* :detail
                                                 (list kw pattern preposition)
                                                 (TEXT "~S: invalid keyword ~A after ~A")
                                                 'loop (symbol-name preposition)
                                                 (symbol-name kw))))))
                                     ;; Determine start, unless given:
                                     (unless step-start-p
                                       (when (eq step-direction 'down)
                                         ; Abwrtsiteration ohne Startwert ist nicht erlaubt.
                                         ; Die zweite optionale Klausel (d.h. preposition) muss abwrts zeigen.
                                         (error-of-type 'source-program-error
                                           :form *whole* :detail preposition
                                           (TEXT "~S: specifying ~A requires FROM or DOWNFROM")
                                           'loop (symbol-name preposition)))
                                       ; Aufwrtsiteration -> Startwert 0
                                       (setq step-start-form '0)
                                       (push `(,pattern ,step-start-form) bindings))
                                     ; Determine step, unless given:
                                     (unless step-by-p (setq step-by-form '1))
                                     ; Determine end test:
                                     (when step-end-p
                                       (let* ((compfun
                                                (if (eq step-direction 'up)
                                                  (if (eq step-end-preposition 'below) '>= '>) ; up
                                                  (if (eq step-end-preposition 'above) '<= '<))) ; down
                                              (endtest
                                                (if (and (constantp step-end-form) (zerop (eval step-end-form)))
                                                  (case compfun
                                                    (>= `(NOT (MINUSP ,pattern)))
                                                    (> `(PLUSP ,pattern))
                                                    (<= `(NOT (PLUSP ,pattern)))
                                                    (< `(MINUSP ,pattern)))
                                                  `(,compfun ,pattern ,step-end-form))))
                                         (note-initialization
                                           (make-endtest `(WHEN ,endtest (LOOP-FINISH))))))
                                     (push
                                       (list pattern `(,(if (eq step-direction 'up) '+ '-) ,pattern ,step-by-form))
                                       stepafter)))))))
                          (unless (parse-kw-p 'and) (return))
                          (setq kw 'and)
                          (case (next-kw) ((FOR AS) (pop body-rest)))))
                      (when (setq stepafter (apply #'append (nreverse stepafter)))
                        (push `(PSETQ ,@stepafter) stepafter-code))
                      (push 'NIL stepafter-code) ; Markierung fr sptere Initialisierungen
                      (note-initialization ; outer `note-initialization'!
                        (make-loop-init
                          :specform 'LET
                          :bindings (nreverse bindings)
                          :declspecs (nreverse declspecs)
                          :everytime nil
                          :requires-stepbefore old-seen-endtest
                          :preamble preamble-entry
                          :depends-preceding depends-preceding))
                      (dolist (initialization (nreverse initializations))
                        (when (li-everytime initialization)
                          (setf (li-everytime initialization) stepafter-code))
                        (note-initialization initialization))))))
                (t (error-of-type 'source-program-error
                     :form *whole* :detail *whole*
                     (TEXT "~S: illegal syntax near ~S in ~S")
                     'loop (first body-rest) *whole*)))))))
      ; Noch einige semantische Tests:
      (when (> (length results) 1)
        (error-of-type 'source-program-error
          :form *whole* :detail *whole*
          (TEXT "~S: ambiguous result:~:{~%~S from ~@{~{~A ~S~}~^, ~}~}")
          *whole* results))
      (unless (null results)
        (push `(RETURN-FROM ,block-name ,(caar results)) finally-code))
      ; Initialisierungen abarbeiten und optimieren:
      (let ((initializations1 ()))
        (unless (zerop (length *helpvars*)) ; `*helpvars*' must be bound first thing
          (push (make-loop-init
                 :specform 'LET
                 :preamble (preamble :start)
                 :bindings
                 (map 'list #'(lambda (var) `(,var NIL)) *helpvars*))
                initializations1))
        (when start-bindings
          (push (make-loop-init
                 :specform 'LET
                 :preamble (preamble :start)
                 :bindings (nreverse start-bindings))
                initializations1))
        ; `depends-preceding' backpropagation:
        (let ((later-depend nil))
          (dolist (initialization initializations)
            (when later-depend (setf (li-later-depend initialization) t))
            (when (li-depends-preceding initialization)
              (setq later-depend t))))
        (dolist (initialization (nreverse initializations))
          (let* ((everytime (li-everytime initialization))
                 (name (li-specform initialization))
                 (bindings (li-bindings initialization))
                 (declarations (li-declspecs initialization))
                 (vars (case name
                         (MULTIPLE-VALUE-BIND (first bindings))
                         (LET (mapcar #'first bindings))))
                 (initforms
                   (case name
                     (MULTIPLE-VALUE-BIND `((MULTIPLE-VALUE-SETQ ,@bindings)))
                     (LET `((SETQ ,@(apply #'append bindings))))))
                 (endtest-forms (li-endtest-forms initialization)))
            (if (li-requires-stepbefore initialization)
              ; wegen seen-for-as-= oder AREF nicht optimierbar
              (progn
                (push
                  (make-loop-init
                    :specform 'LET
                    :bindings (default-bindings vars declarations)
                    :preamble (preamble :start)
                    :declspecs declarations)
                  initializations1)
                (if everytime
                  (if (li-later-depend initialization)
                    (progn ; double code: preamble and stepafter-code
                      (revadd (cdr (li-preamble initialization))
                              initforms endtest-forms)
                      (revadd (cdr everytime) endtest-forms initforms))
                    (revadd stepbefore-code endtest-forms initforms))
                  (revadd (cdr (li-preamble initialization))
                          initforms endtest-forms)))
              ; Initialisierungsklausel nach initializations1 schaffen:
              (progn
                (push
                  (make-loop-init
                    :specform name
                    :bindings bindings
                    :preamble (preamble :start)
                    :declspecs declarations)
                  initializations1)
                (if everytime
                  (progn
                    ; put the initforms into the stepafter-code only.
                    (revadd (cdr everytime) initforms)
                    ; handle the endtest-forms.
                    (if (li-later-depend initialization)
                      (progn ; double endtest: preamble and stepafter-code
                        (revadd (cdr (li-preamble initialization))
                                endtest-forms)
                        (revadd (cdr everytime) endtest-forms))
                      (revadd stepbefore-code endtest-forms)))
                  (revadd (cdr (li-preamble initialization)) endtest-forms))))))
        (flet ((check-accu-var (var)
                 (when (memq var var-list)
                   (error-of-type 'source-program-error
                     :form *whole* :detail var
                     (TEXT "~S: accumulation variable ~S is already bound")
                     *whole* var))))
          (push
           (make-loop-init
            :specform 'LET
            :bindings
            `(,@(mapcar #'(lambda (var) (check-accu-var var) `(,var NIL))
                        (delete-duplicates accu-vars-nil))
              ,@(mapcar #'(lambda (var) (check-accu-var (car var)) var)
                        (delete-duplicates accu-vars-0 :key #'car)))
            :preamble (preamble :start)
            :declspecs (nreverse accu-declarations))
           initializations1))
        (setq preamble
              (mapcan (lambda (rec)
                        (case (car rec)
                          (:start (nreverse
                                   (mapcar (lambda (f) (cons :start f))
                                           (cdr rec))))
                          (:initially (list rec))))
                      preamble))
        ;; Remove the NIL placeholders in stepafter-code.
        (setq stepafter-code (delete 'NIL stepafter-code))
        ;; If preamble and stepafter-code both end in the same
        ;; forms, drag these forms across the label to stepbefore-code.
        (flet ((form-eq (form1 form2) ; Calling EQUAL on user-given forms would be wrong
                 (or (eql form1 form2)
                     (and (consp form1) (consp form2)
                          (eql (length form1) (length form2))
                          (or (eq (car form1) (car form2))
                              (and (case (length form1) ((1 3) t))
                                   (case (car form1) ((SETQ PSETQ) t))
                                   (case (car form2) ((SETQ PSETQ) t))))
                          (every #'eq (cdr form1) (cdr form2))))))
          (loop
            (unless (and (consp preamble) (consp stepafter-code)
                         (eq :start (caar preamble))
                         (form-eq (cdar preamble) (car stepafter-code)))
              (return))
            (setq stepbefore-code
                  (nconc stepbefore-code (list (pop stepafter-code))))
            (pop preamble)))
        ;; Final macroexpansion.
        `(MACROLET ((LOOP-FINISH () (LOOP-FINISH-ERROR)))
           (BLOCK ,block-name
             ,(wrap-initializations initializations1
               (wrap-unwind-protect protect-forms
                `(MACROLET ((LOOP-FINISH () '(GO END-LOOP)))
                   (TAGBODY
                     ,@(if preamble (nreverse (mapcar #'cdr preamble)))
                    BEGIN-LOOP
                     ,@(if stepbefore-code (nreverse stepbefore-code))
                     ,(cons 'PROGN (nreverse main-code))
                     ,@(if stepafter-code (nreverse stepafter-code))
                     (GO BEGIN-LOOP)
                    END-LOOP
                     ,@(mapcar #'(lambda (var)
                                   `(SETQ ,var (SYS::LIST-NREVERSE ,var)))
                               accu-vars-nreverse)
                     (MACROLET ((LOOP-FINISH () (LOOP-FINISH-WARN)
                                  '(GO END-LOOP)))
                       ,@(nreverse finally-code))))))))))))

;; Der eigentliche Macro:
(defmacro loop (&whole whole &body body)
  (if (some #'atom body)
    ;; "extended" loop form
    (expand-loop whole body)
    ;; "simple" loop form
    (let ((tag (gensym "LOOP-")))
      `(BLOCK NIL (TAGBODY ,tag ,@body (GO ,tag))))))
(defmacro loop-finish (&whole whole)
  (error (TEXT "~S is possible only from within ~S")
         whole 'loop))
(defun loop-finish-warn ()
  (warn (TEXT "Use of ~S in FINALLY clauses is deprecated because it can lead to infinite loops.")
        '(loop-finish)))
(defun loop-finish-error ()
  (error (TEXT "~S is not possible here")
         '(loop-finish)))

;; Run-Time-Support:

(defun max-if (x y) ; ABI
  (if y (max x y) x))
(defun min-if (x y) ; ABI
  (if y (min x y) x))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./loop.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./room.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Room, Space

(in-package "SYSTEM")

;;-----------------------------------------------------------------------------
;; ROOM

(definternational room-format (t ENGLISH))
(deflocalized room-format ENGLISH
  (list (formatter "Class~VT# Instances  Size (bytes)  Average size~%")
        (formatter "-----~VT-----------  ------------  ------------~%")
        (formatter      "~VT~8D     ~9D  ~13,3F~%")
) )

(defun room (&optional (kind :default))
  (unless (or (eq kind 'nil) (eq kind ':default) (eq kind 't))
    (error (TEXT "~S: argument must be ~S, ~S or ~S, not ~S")
           'room 'nil 't ':default kind))
  ;; Get the figures now, because (heap-statistics) causes heap allocation.
  (multiple-value-bind (used room static gc-count gc-space gc-time) (sys::%room)
    (when (eq kind 't)
      (let ((stat (heap-statistics)))
        ;; stat = #( ... (classname num-instances . num-bytes) ...)
        (setq stat (sort stat #'> :key #'cddr))
        (let* ((localinfo (localized 'room-format))
               (header-line (first localinfo))
               (separator-line (second localinfo))
               (data-line (third localinfo))
               (midcol (- (or *print-right-margin* sys::*prin-linelength*) 39))
               (total-instances 0)
               (total-bytes 0))
          (fresh-line)
          (format t header-line midcol)
          (format t separator-line midcol)
          (dotimes (i (length stat))
            (let* ((stat-record (svref stat i))
                   (classname (car stat-record))
                   (instances (cadr stat-record))
                   (bytes (cddr stat-record)))
              (when (plusp instances)
                (prin1 classname)
                (format t data-line midcol
                          instances bytes
                          (/ (float bytes 0d0) instances))
                (incf total-instances instances)
                (incf total-bytes bytes))))
          (format t separator-line midcol)
          (write-string (TEXT "Total"))
          (format t data-line midcol
                    total-instances total-bytes
                    (/ (float total-bytes 0d0) total-instances)))))
    (terpri)
    (unless (eq kind 'nil)
      (format t (TEXT "Number of garbage collections: ~16:D~%~
                       Bytes freed by GC:             ~16:D~%~
                       Time spent in GC:              ~16F sec")
              gc-count gc-space
              (float (/ gc-time internal-time-units-per-second)))
      (terpri))
    (format t (TEXT "Bytes permanently allocated:   ~16:D~%~
                     Bytes currently in use:        ~16:D~%~
                     Bytes available until next GC: ~16:D")
            static used room)
    (terpri)
    (values used room static gc-count gc-space gc-time)))

;;-----------------------------------------------------------------------------
;; SPACE

;; Recall the macro SPACE, making (space form) roughly equivalent to
;
; (multiple-value-bind (var1 var2 var3 var4) (%space1)
;   (let ((*gc-statistics* (1+ (max *gc-statistics* 0))))
;     (setq var3 (multiple-value-list form))
;     (setq var4 (%space2))
;   )
;   (%space var1 var2 var3 var4)
;   (values-list var3)
; )

;; It works like this:
;; 1. Do a GC, to eliminate unused objects, and call (heap-statistics)
;;    to get a statistics of all live objects.
;; 2. Enable the GC reclaimage statistics: Call (gc-statistics),
;;    then bind *gc-statistics* to at least 1.
;; 3. Evaluate the form.
;; 4. Convert the form's values to a list.
;; 5. Call (gc), so that the GC eliminates temporarily allocated objects.
;; 6. Call (gc-statistics) again. We can now unbind *gc-statistics*.
;; 7. Call (heap-statistics) again, to get a statistics of all now live
;;    objects.
;; ==> The difference of the two (gc-statistics) calls will comprise exactly
;;     the temporary allocations of the form.
;; ==> The difference of the two (heap-statistics) calls will comprise
;;     - the resulting data structure of the first call to (heap-statistics),
;;     - the permanent allocations of the form,
;;     - the list allocated to hold the form's values,
;;     - the data structures which form the ldifference between the two
;;       calls to (gc-statistics).

(defun %space1 () ; ABI
  (gc)
  (values
    (heap-statistics)
    (gc-statistics)
) )

; %space1 returns two values, so var3 and var4 are initially bound to nil.

(defun %space2 () ; ABI
  (gc)
  (gc-statistics)
)

(defun %space (heap-stat-1 gc-stat-1 vallist gc-stat-2) ; ABI
  (let ((heap-stat-2 (heap-statistics)))
    ;; Now we have all the statistics, and are free to do any kind
    ;; of allocations.
    (let ((ht (make-hash-table :key-type 't :value-type '(cons cons cons)
                               :test 'fasthash-eq)))
      ;; For each type, (gethash type ht) contains a cons
      ;;   (heap-stat-record . gc-stat-record),
      ;; where both records are conses (n-instances . n-bytes).
      (flet ((add (statv accessor incrementer)
               ;; Adds the contents of statv to the hash table.
               ;; accessor = #'car or #'cdr, incrementer = #'+ or #'-.
               (dotimes (i (length statv))
                 (let ((stat-record (svref statv i)))
                   (let ((name (car stat-record))
                         (n-instances (cadr stat-record))
                         (n-bytes (cddr stat-record)))
                     (unless (and (zerop n-instances) (zerop n-bytes))
                       (let ((htx (gethash name ht)))
                         (unless htx
                           (setf (gethash name ht)
                                 (setf htx (cons (cons 0 0) (cons 0 0)))
                         ) )
                         (let ((record (funcall accessor htx)))
                           (setf (car record)
                                 (funcall incrementer (car record) n-instances)
                           )
                           (setf (cdr record)
                                 (funcall incrementer (cdr record) n-bytes)
                           )
            )) ) ) ) ) ) )
        ;; The difference between the two (gc-statistics) calls.
        (do ((l gc-stat-2 (cdr l)))
            ((eq l gc-stat-1))
          (add (car l) #'cdr #'+)
        )
        ;; The difference between the two (heap-statistics) calls.
        (add heap-stat-2 #'car #'+)
        (add heap-stat-1 #'car #'-)
        ;; Adjust for the statistics data structures themselves.
        (add (heap-statistics-statistics heap-stat-1) #'car #'-)
        (add (list-statistics vallist) #'car #'-)
        (add (gc-statistics-statistics gc-stat-1 gc-stat-2) #'car #'-)
      )
      ;; Now transform the hash table into a list, and sort it.
      (let ((statlist '()))
        (maphash #'(lambda (name htx) (push (cons name htx) statlist)) ht)
        ;; statlist is now a list of (name heap-stat-record . gc-stat-record).
        (setq statlist
              (sort statlist #'>
                    :key #'(lambda (r) (+ (cdr (cadr r)) (cdr (cddr r))))
        )     )
        ;; Display the statistics.
        (space-tabulate statlist)
        ;; Done. The return value is ignored.
) ) ) )

(definternational space-format (t ENGLISH))
(deflocalized space-format ENGLISH
  (list (formatter      "~VT     Permanent            Temporary~%")
        (formatter "Class~VTinstances   bytes    instances   bytes~%")
        (formatter "-----~VT--------- ---------  --------- ---------~%")
        (formatter      "~VT~9D ~9D  ~9D ~9D~%")
) )

(defun space-tabulate (statlist)
  (let* ((localinfo (localized 'space-format))
         (header-line1 (first localinfo))
         (header-line2 (second localinfo))
         (separator-line (third localinfo))
         (data-line (fourth localinfo))
         (midcol (- (or *print-right-margin* sys::*prin-linelength*) 40))
         (total-perm-instances 0)
         (total-perm-bytes 0)
         (total-temp-instances 0)
         (total-temp-bytes 0)
         (stream *trace-output*))
    (fresh-line stream)
    (format stream header-line1 midcol)
    (format stream header-line2 midcol)
    (format stream separator-line midcol)
    (dolist (stat-record statlist)
      (let* ((classname (car stat-record))
             (permstat (cadr stat-record))
             (tempstat (cddr stat-record))
             (perm-instances (car permstat))
             (perm-bytes (cdr permstat))
             (temp-instances (car tempstat))
             (temp-bytes (cdr tempstat)))
        (unless (and (zerop perm-instances) (zerop perm-bytes)
                     (zerop temp-instances) (zerop temp-bytes)
                )
          (prin1 classname stream)
          (format stream data-line midcol
                  perm-instances perm-bytes
                  temp-instances temp-bytes
          )
          (incf total-perm-instances perm-instances)
          (incf total-perm-bytes perm-bytes)
          (incf total-temp-instances temp-instances)
          (incf total-temp-bytes temp-bytes)
    ) ) )
    (format stream separator-line midcol)
    (write-string (TEXT "Total")
                  stream
    )
    (format stream data-line midcol
            total-perm-instances total-perm-bytes
            total-temp-instances total-temp-bytes
    )
) )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./room.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./floatprint.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Printing of Floating-Point-Numbers with PRINT and FORMAT
;; Michael Stoll 10.2.1990 - 26.3.1990
;; Bruno Haible 8.9.1990 - 10.9.1990
;; Translation: Stefan Kain 2003-04-26
;;   The German variable names 'unten' and 'oben' where translated with
;;   'below' resp. 'above' in English!
;;   wlog == without loss of generality
;; Bruno Haible 2004-03-27: Fixed printing of short floats like 1782592s0.

;; basic idea:
;; Each real-number /= 0 represents an (open) interval. We print the
;; decimal number with as few digits as possible, that is situated in
;; this interval.
;; In order to also treat big exponents, powers of 2 are approximately
;; turned into powers of 10. If necessary, the computing accuracy is
;; increased. Here we utilize long-floats of arbitrary precision.

(in-package "SYSTEM")

;; based on:
;; (sys::log2 digits) returns ln(2) with at least DIGITS mantissa bits.
;; (sys::log10 digits) returns ln(10) with at least DIGITS mantissa bits.
;; (sys::decimal-string integer) returns for an integer >0
;;   a simple-string with its decimal presentation.
;; (substring string start [end]) like SUBSEQ, however faster for strings.

;; the main function for conversion of floats into the decimal system:
;; For a float X we calculate a Simple-String AS and three Integers K,E,S
;; with the following properties:
;; s = sign(x).
;; If x/=0, consider |x| instead of x. Thus, wlog, let x>0.
;;   Let x1 and x2 be the next smaller resp. the next bigger number for x
;;   of the same floating-point-format. Consequently, the number x represents
;;   the open interval from (x+x1)/2 to (x+x2)/2.
;;   A is an integer >0, with exactly K decimal places (K >= 1), and
;;   (x+x1)/2 < a*10^(-k+e) < (x+x2)/2 .
;;   K is minimal, so A is not divisible by 10.
;;   If fixed-point-adjust is true and 1 <= |x| < 10^7, more precision
;;   is provided by assuming that K needs only to be >= E+1, and no effort
;;   is made to minimize K below E+1 if it would discard nonzero digits.
;; if x=0, then a=0, k=1, e=0.
;; AS is the sequence of digits of A, of length K.
(defun decode-float-decimal (x fixed-point-adjust)
  (declare (type float x))
  (multiple-value-bind (binmant binexpo sign) (integer-decode-float x)
    (if (eql binmant 0) ; x=0 ?
      (values "0" 1 0 0) ; a=0, k=1, e=0, s=0
      ;; x/=0, so sign is the sign of x and
      ;; |x| = 2^binexpo * float(binmant,x) . From now on, let x>0, wlog.
      ;; x = 2^binexpo * float(binmant,x) .
      (let* ((l (integer-length binmant)) ; number of bits of binmant
             (2*binmant (ash binmant 1)) ; 2*binmant
             (above (1+ 2*binmant)) ; upper interval boundary is
                                ; (x+x2)/2 = 2^(binexpo-1) * above
             (below (1- 2*binmant)) ; lower interval boundary is
             (belowshift 0)) ; (x+x1)/2 = 2^(binexpo-1-belowshift) * below
        (when (eql (integer-length below) l)
          ;; normally, integerlength(below) = 1+integerlength(binmant).
          ;; Here, integerlength(below) = l = integerlength(binmant),
          ;; thus, binmant was a power of two. In this case the tolerance
          ;; upwards is 1/2 unit, but the tolerance downwards is only
          ;; 1/4 unit: (x+x1)/2 = 2^(binexpo-2) * (4*binmant-1)
          (setq below (1- (ash 2*binmant 1)) belowshift 1))
        ;; determine d (integer) and a1,a2 (integer, >0) thus that
        ;; the integer a with (x+x1)/2 < 10^d * a < (x+x2)/2 are exactly
        ;; the integer a with a1 <= a <= a2 and 0 <= a2-a1 < 20 .
        ;; Therefore, convert 2^e := 2^(binexpo-1) into the decimal system.
        (let* ((e (- binexpo 1))
               (e-gross (> (abs e) (ash l 1))) ; if |e| is very large, >2*l ?
               g f   ; auxiliary variables in case that |e| is large
               ten-d ; auxiliary variable 10^|d| in case that |e| is small
               d a1 a2); result variables
          (if e-gross ; is |e| really big?
            ;; As 2^e can work only approximately, we need safety bits.
            (prog ((h 16)) ; number of safety bits, must be >= 3
              new-safety-bits
              ;; target: 2^e ~= 10^d * f/2^g, with 1 <= f/2^g < 10.
              (setq g (+ l h)) ; number of valid bits of f
              ;; Estimate d = floor(e*lg(2))
              ;; with help of the rational approximations of lg(2):
              ;;  0 1/3 3/10 28/93 59/196 146/485 643/2136 4004/13301
              ;;  8651/28738 12655/42039 21306/70777 76573/254370 97879/325147
              ;;  1838395/6107016 1936274/6432163 13456039/44699994
              ;;  15392313/51132157 44240665/146964308 59632978/198096465
              ;;  103873643/345060773 475127550/1578339557 579001193/1923400330
              ;; e>=0 : choose lg(2) < a/b < lg(2) + 1/e,
              ;;        then d <= floor(e*a/b) <= d+1 .
              ;; e<0  : then lg(2) - 1/abs(e) < a/b < lg(2),
              ;;        then d <= floor(e*a/b) <= d+1 .
              ;; It is known that abs(e) <= 2^31 + 2^20 .
              ;; Let d be := floor(e*a/b)-1.
              (setq d (1- (if (minusp e)
                            (if (>= e -970)
                              (floor (* e 3) 10) ; 3/10
                              (floor (* e 21306) 70777)) ; 21306/70777
                            (if (<= e 22000)
                              (floor (* e 28) 93) ; 28/93
                              (floor (* e 12655) 42039))))) ; 12655/42039
              ;; The true d is either matched by this estimation
              ;; or undervalued by 1.
              ;; In other "words": 0 < e*log(2)-d*log(10) < 2*log(10).
              ;; now, calculate f/2^g as exp(e*log(2)-d*log(10)) .
              ;; As f < 100*2^g < 2^(g+7), we need g+7 bits relative accuracy
              ;; of the result, i.e g+7 bits absolute accuracy of
              ;; e*log(2)-d*log(10) . With l'=integer-length(e)
              ;;  log(2): g+7+l' bits abs. accuracy, g+7+l' bits rel. acc.,
              ;;  log(10): g+7+l' bits abs. accuracy, g+7+l'+2 bits rel. acc.
              (let ((f/2^g (let ((gen (+ g (integer-length e) 9))) ; accuracy
                             (exp (- (* e (sys::log2 gen))
                                     (* d (sys::log10 gen)))))))
                ;; the calculated f/2^g is >1, <100.
                ;; multiply with 2^g and round to an integer number:
                (setq f (round (scale-float f/2^g g)))) ; returns f
              ;; Possibly correct f and d:
              (when (>= f (ash 10 g)) ; f >= 10*2^g ?
                (setq f (floor f 10) d (+ d 1)))
              ;; Now 2^e ~= 10^d * f/2^g, with 1 <= f/2^g < 10 and
              ;; f an Integer, that deviates from the true value at most by 1:
              ;; 10^d * (f-1)/2^g < 2^e < 10^d * (f+1)/2^g
              ;; we make the open interval now smaller
              ;; from (x+x1)/2 = 2^(binexpo-1-belowshift) * below
              ;; to (x+x2)/2 = 2^(binexpo-1) * above
              ;; into a closed interval
              ;; from 10^d * (f+1)/2^(g+belowshift) * below
              ;; to 10^d * (f-1)/2^g * above
              ;; and search therein numbers of the form a*10^d with integer a.
              ;; since   above - below/2^belowshift >= 3/2
              ;; and  above + below/2^belowshift <= 4*binmant+1 < 2^(l+2) <= 2^(g-1)
              ;; the interval-length is
              ;; = 10^d * ((f-1)*above - (f+1)*below/2^belowshift) / 2^g
              ;; = 10^d * ( f * (above - below/2^belowshift)
              ;;            - (above + below/2^belowshift) ) / 2^g
              ;; >= 10^d * (2^g * 3/2 - 2^(g-1)) / 2^g
              ;; = 10^d * (3/2 - 2^(-1)) = 10^d
              ;; and hence, there is at least one number of this form
              ;; in this interval.
              ;; The numbers of the form 10^d * a in this intervall are those
              ;; with a1 <= a <= a2, and a2 = floor((f-1)*above/2^g) and
              ;; a1 = ceiling((f+1)*below/2^(g+belowshift))
              ;;    = floor(((f+1)*below-1)/2^(g+belowshift))+1 .
              ;; We have now seen, that a1 <= a2 .
              (setq a1 (1+ (ash (1- (* (+ f 1) below)) (- (+ g belowshift)))))
              (setq a2 (ash (* (- f 1) above) (- g)))
              ;; We can also nest the open interval
              ;; from (x+x1)/2 = 2^(binexpo-1-belowshift) * below
              ;; to (x+x2)/2 = 2^(binexpo-1) * above
              ;; into the (closed) interval
              ;; from 10^d * (f-1)/2^(g+belowshift) * below
              ;; to 10^d * (f+1)/2^g * above
              ;; Herein are the numbers of the form 10^d * a
              ;; with a1' <= a <= a2', with a1' <= a1 <= a2 <= a2' and that
              ;; can be calculated with a1' and a2' analogous to a1 and a2.
              ;; As (f-1)*above/2^g and (f+1)*above/2^g differ by 2*above/2^g
              ;; < 2^(l+2-g) < 1, a2 and
              ;; a2' differ by at most 1.
              ;; Likewise, if 'above' is replaced by 'below/2^belowshift':
              ;; a1' and a1 differ by at most 1.
              ;; If a1' < a1 or a2 < a2' , then the power-of-2-approximation-
              ;; 10^d * f/2^g for 2^e has not been accurate enough,
              ;; and we have to repeat everything with increased h.
              ;; Exception (when even higer precision does not help):
              ;;   If the upper or lower interval boundary (x+x2)/2 resp.
              ;;   (x+x1)/2 has itself the shape 10^d * a with integer a.
              ;;   This is tested via:
              ;;     (x+x2)/2 = 2^e * above == 10^d * a  with integer a, if
              ;;    - for e>=0, (then 0 <= d <= e): 5^d | above,
              ;;    - for e<0,  (then e <= d < 0): 2^(d-e) | above, which is
              ;;                the case only for d-e=0 .
              ;;    (x+x1)/2 = 2^(e-belowshift) * below == 10^d * a
              ;;     with integer a, if
              ;;    - for e>0, (then 0 <= d < e): 5^d | below,
              ;;    - for e<=0, (then e <= d <= 0): 2^(d-e+belowshift) | below,
              ;;                which is only the case for d-e+belowshift=0.
              ;; As we deal here with higher |e| , this exceptional cause
              ;; cannot happen here at all!
              ;; Then in case of e>=0: e>=2*l and l>=11 imply
              ;;   e >= (l+2)*ln(10)/ln(5) + ln(10)/ln(2),
              ;;   d >= e*ln(2)/ln(10)-1 >= (l+2)*ln(2)/ln(5),
              ;;   5^d >= 2^(l+2),
              ;;   and because of 0 < below < 2^(l+2) and 0 < above < 2^(l+1)
              ;;   below and above are not divisible by 5^d.
              ;; And in case e<=0: From -e>=2*l and l>=6 can be implied
              ;;   -e >= (l+2)*ln(10)/ln(5),
              ;;   d-e >= e*ln(2)/ln(10)-1-e = (1-ln(2)/ln(10))*(-e)-1
              ;;          = (-e)*ln(5)/ln(10)-1 >= l+1,
              ;;   2^(d-e) >= 2^(l+1),
              ;;   and because of 0 < below < 2^(l+1+belowshift), below is not
              ;;   divisible by 2^(d-e+belowshift) , and because of
              ;;   0 < above < 2^(l+1), above is not divisible by 2^(d-e) .
              (when (or (< (1+ (ash (1- (* (- f 1) below))
                                    (- (+ g belowshift)))) ; a1'
                           a1)
                        (< a2 (ash (* (+ f 1) above) (- g)))) ; a2<a2'
                (setq h (ash h 1)) ; double h
                (go new-safety-bits)) ; and repeat everything
              ;; Now a1 is the smallest and a2 is the biggest value, that is
              ;; possible for a.
              ;; Because of  above - below/2^belowshift <= 2
              ;; the above interval-length is
              ;; = 10^d * ((f-1)*above - (f+1)*below/2^belowshift) / 2^g
              ;; < 10^d * ((f-1)*above - (f-1)*below/2^belowshift) / 2^g
              ;; = 10^d * (f-1)/2^g * (above - below/2^belowshift)
              ;; < 10^d * 10 * 2,
              ;; so there are at most 20 possible values for a.
              )                   ; PROG is done
            ;; |e| is relatively small -> can calculate 2^e and 10^d exactly
            (if (not (minusp e))
              ;; e >= 0. Estimate d = floor(e*lg(2)) as above.
              ;;  e<=2*l<2^21.
              (progn
                (setq d (if (<= e 22000)
                          (floor (* e 28) 93) ;  28/93
                          (floor (* e 4004) 13301))) ;  4004/13301
                ;; The true d is either matched by this estimate
                ;; or overestimated by 1, but we can find this out easily.
                (setq ten-d (expt 10 d)) ; ten-d = 10^d
                (when (< (ash 1 e) ten-d) ; if 2^e < 10^d,
                  (setq d (- d 1) ten-d (floor ten-d 10))) ; correct estimate
                ;; Now 10^d <= 2^e < 10^(d+1) and ten-d = 10^d.
                (if (and fixed-point-adjust
                         (<= binmant (ash 9999999 (- binexpo))))
                  ;; |x| < 10^7 and we want fixed-point notation. Force d
                  ;; to stay <= -1, i.e. return more digits than we would do
                  ;; in scientific notation.
                  (progn
                    ;; Set d = -1 and a1 = a2 = 2^e * 2*binmant / 10^d.
                    ;; Or, since we know that e>=0 implies that these a1 and a2
                    ;; end in a trailing zero and the caller can add zeroes
                    ;; at the end on his own:
                    ;; Set d = 0 and a1 = a2 = 2^e * 2*binmant / 10^d.
                    (setq d 0)
                    (setq a1 (setq a2 (ash binmant (1+ e)))))
                  (progn
                    ;; let a1 be the smallest integer
                    ;;      a > 2^(e-belowshift) * below / 10^d,
                    ;; let a2 be the largest integer a < 2^e * above / 10^d.
                    ;; a1 = 1+floor(below*2^e/(2^belowshift*10^d)),
                    ;; a2 = floor((above*2^e-1)/10^d).
                    (setq a1 (1+ (floor (ash below e) (ash ten-d belowshift))))
                    ;; even mantissas represent top-inclusive intervals
                    (setq a2 (if (evenp binmant)
                                 (floor (ash above e) ten-d)
                                 (floor (1- (ash above e)) ten-d))))))
              ;; e < 0. Estimate d = floor(e*lg(2)) like above.
              ;; |e|<=2*l<2^21.
              (progn
                (setq d (if (>= e -970)
                          (floor (* e 3) 10) ;  3/10
                          (floor (* e 643) 2136))) ;  643/2136
                ;; The true d is either matched by this estimate
                ;; or overestimated by 1, but we can find this out easily.
                (setq ten-d (expt 10 (- d))) ; ten-d = 10^(-d)
                (when (<= (integer-length ten-d) (- e)) ; if 2^e < 10^d,
                  (setq d (- d 1) ten-d (* ten-d 10))) ; correct estimate
                ;; now 10^d <= 2^e < 10^(d+1) and ten-d = 10^(-d).
                ;; let a1 be the smallest integer
                ;;      a > 2^(e-belowshift) * below / 10^d,
                ;; let a2 be the largest integer a < 2^e * above / 10^d.
                ;; a1 = 1+floor(below*10^(-d)/2^(-e+belowshift)),
                ;; a2 = floor((above*10^(-d)-1)/2^(-e))
                (setq a1 (1+ (ash (* below ten-d) (- e belowshift))))
                ;; for some reason the (evenp binmant) does not make a
                ;; difference here
                (setq a2 (ash (1- (* above ten-d)) e)))))
          ;; Now the integer a's with (x+x1)/2 < 10^d * a < (x+x2)/2 are
          ;; exactly the integer a's with a1 <= a <= a2. There are at most 20.
          ;; These are reduced to a single one with three steps:
          ;; 1. Does the region contain a number a that is divisible by 10?
          ;;    yes -> set a1:=ceiling(a1/10), a2:=floor(a2/10), d:=d+1.
          ;;    After that, the region a1 <= a <= a2 contains at most 10
          ;;    possible values for a.
          ;; 2. If now one of the possible values is divisible by 10
          ;;    (there can be only one... :-) ),
          ;;    it is chosen, the others are forgotten.
          ;; 3. Else, the closest value to x is chosen among the other
          ;;    possible values.
          (prog ((d-shift nil) ; flag, if d was incremented in the first step
                 a)            ; the chosen a
            ;; 1.
            (let ((b1 (ceiling a1 10))
                  (b2 (floor a2 10)))
              (if (<= b1 b2) ; still a number divisible by 10?
                (setq a1 b1 a2 b2 d (+ d 1) d-shift t)
                (go no-10-more)))
            ;; 2.
            (when (>= (* 10 (setq a (floor a2 10))) a1)
              ;; Still a number divisible by 10 -> divide by 10.
              (setq d (+ d 1)) ; increase d, ten-d not needed anymore
              ;; Now convert a into a decimal string
              ;; and then discard the zeroes at the tail:
              (let* ((as (sys::decimal-string a)) ; digit sequence for a>0
                     (las (length as)) ; length of the digit sequence
                     (k las) ; length without the discarded zeroes at the tail
                     (ee (+ k d))) ; a * 10^d = a * 10^(-k+ee)
                (loop
                  (let ((k-1 (- k 1)))
                    (unless (eql (schar as k-1) #\0) ; a 0 at the end?
                      (return))
                    ;; yes -> a := a / 10 (but is not needed anymore),
                    ;; d := d+1 (but is not needed anymore),
                    (setq k k-1))) ; k := k-1.
                (when (< k las) (setq as (substring as 0 k)))
                (return (values as k ee sign))))
            ;; 3.
            no-10-more
            (setq a
              (if (eql a1 a2) ; a1=a2 -> there is no more choice:
                a1
                (if e-gross ; a1<a2 -> choose 10^d*a closest to x:
                  ;; choose a = round(f*2*binmant/2^g/(1oder10)) (any rounding)
                  ;;   = ceiling(floor(f*2*binmant/(1oder10)/2^(g-1))/2)
                  (ash (1+ (ash (let ((z (* f 2*binmant)))
                                  (if d-shift (floor z 10) z))
                                (- 1 g)))
                       -1)
                  ;; |e| small -> analogous as a2 was computed above
                  (if (not (minusp e))
                    ;; e>=0: a = round(2^e*2*binmant/10^d)
                    (round (ash 2*binmant e) ; 10^d according to d-shift
                           (if d-shift (* 10 ten-d) ten-d))
                    ;; e<0, so d<0, now (because of step 1) d<=0.
                    ;; a = round(2*binmant*10^(-d)/2^(-e))
                    (ash (1+ (ash
                               (* 2*binmant ; 10^(-d) according to d-shift
                                  (if d-shift (floor ten-d 10) ten-d))
                               (+ e 1)))
                         -1)))))
            (let* ((as (sys::decimal-string a)) ; digit sequence of a
                   (k (length as)))
              (return (values as k (+ k d) sign)))))))))

;; output function for PRINT/WRITE of floats:
(defun write-float-decimal (stream arg #| &optional (plus-sign-flag nil) |# )
  (unless (floatp arg)
    (error-of-type 'type-error
      :datum arg :expected-type 'float
      (TEXT "argument is not a float: ~S")
      arg))
  (multiple-value-bind (mantstring mantlen expo sign)
      (decode-float-decimal arg t)
    ;; arg in decimal representation: +/- 0.mant * 10^expo, whereby
    ;;  mant is the mantissa: as Simple-String mantstring of length mantlen,
    ;;  expo is the decimal-exponent,
    ;;  sign is the sign (-1 or 0 or 1).
    (if (eql sign -1) ; arg < 0 ?
      (write-char #\- stream)
      #| (if plus-sign-flag (write-char #\+ stream)) |#
    )
    (let ((flag (<= -2 expo 7))) ; arg=0 or 10^-3 <= (abs arg) < 10^7 ?
      ;; What to print? definition by cases:
      ;; flag set -> "fixed-point notation":
      ;;  expo <= 0 -> zero, decimal dot, -expo zeroes, all digits
      ;;  0 < expo < mantlen ->
      ;;     the first expo digits, decimal dot, the remaining digits
      ;;  expo >= mantlen -> all digits, expo-mantlen zeroes, decimal dot, zero
      ;;  if possible, no exponent; if necessary, exponent 0.
      ;; flag deleted -> "scientific notation":
      ;;   first digit, decimal dot, the remaining digits, with mantlen=1
      ;;    a zero exponent.
      (if (and flag (not (plusp expo)))
        ;; "fixed-point notation" with expo <= 0
        ;; first null and decimal dot, then -expo zeroes, then all digits
        (progn
          (write-char #\0 stream)
          (write-char #\. stream)
          (do ((i expo (+ i 1)))
              ((eql i 0))
            (write-char #\0 stream))
          (write-string mantstring stream)
          (setq expo 0)) ; exponent to print is 0
        ;; "fixed-point notation" with expo > 0 or "scientific notation"
        (let ((scale (if flag expo 1)))
          ;; the decimal dot is shifted by scale digits to the right,
          ;; i.e. there are scale digits in front of the dot. scale > 0.
          (if (< scale mantlen)
            ;; first scale digits, then decimal dot, then remaining digits:
            (progn
              (write-string mantstring stream :end scale)
              (write-char #\. stream)
              (write-string mantstring stream :start scale))
            ;; scale>=mantlen -> there are no digits behind the dot.
            ;; all digits, then scale-mantlen zeroes, then dot and zero
            (progn
              (write-string mantstring stream)
              (do ((i mantlen (+ i 1)))
                  ((eql i scale))
                (write-char #\0 stream))
              (write-char #\. stream)
              (write-char #\0 stream)))
          (decf expo scale))) ; the exponent to print is smaller by scale.
      ;; now let's go for the exponent:
      (let ((e-marker
              (cond ((and (not *PRINT-READABLY*)
                          (case *READ-DEFAULT-FLOAT-FORMAT*
                            (SHORT-FLOAT (short-float-p arg))
                            (SINGLE-FLOAT (single-float-p arg))
                            (DOUBLE-FLOAT (double-float-p arg))
                            (LONG-FLOAT (long-float-p arg))))
                     #\E)
                    ((short-float-p arg) #\s)
                    ((single-float-p arg) #\f)
                    ((double-float-p arg) #\d)
                    ((long-float-p arg) #\L))))
        (unless (and flag (eql e-marker #\E)) ; poss. omit Exponent entirely
          (write-char e-marker stream)
          (write expo :base 10 :radix nil :readably nil :stream stream))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./floatprint.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./runprog.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Running external programs

(in-package "EXT")
#+WIN32 (export '(execute))
#+(or UNIX WIN32) (export '(run-shell-command run-program))
(in-package "SYSTEM")

;;-----------------------------------------------------------------------------

#+(or UNIX WIN32)
;; UNIX:
; Must quote the program name and arguments since Unix shells interpret
; characters like #\Space, #\', #\<, #\>, #\$ etc. in a special way. This
; kind of quoting should work unless the string contains #\Newline and we
; call csh. But we are lucky: only /bin/sh will be used.
;; WIN32:
; Must quote program name and arguments since Win32 interprets characters
; like #\Space, #\Tab, #\\, #\" (but not #\< and #\>) in a special way:
; - Space and Tab are interpreted as delimiters. They are not treated as
;   delimiters if they are surrounded by double quotes: "...".
; - Unescaped double quotes are removed from the input. Their only effect is
;   that within double quotes, space and tab are treated like normal characters.
; - Backslashes not followed by double quotes are not special.
; - But 2*n+1 backslashes followed by a double quote become
;   n backslashes followed by a double quote (n >= 0):
;     \" -> "
;     \\\" -> \"
;     \\\\\" -> \\"
; The high-level Win32 command interpreter cmd.exe (but not the low-level
; function CreateProcess()) also interprets #\&, #\<, #\>, #\| as special
; delimiters and makes #\^ disappear. To avoid this, quote them like spaces.
(labels (#+UNIX
         (shell-simple-quote (string)
           (shell-quote string)
         )
         #+UNIX
         (shell-quote (string) ; surround a string by single quotes
           (if (eql (length string) 0)
             "''"
             (let ((qchar nil) ; last quote character: nil or #\' or #\"
                   (qstring (make-array 10 :element-type 'character
                                           :adjustable t :fill-pointer 0)))
               (map nil #'(lambda (c)
                            (let ((q (if (eql c #\') #\" #\')))
                              (unless (eql qchar q)
                                (when qchar (vector-push-extend qchar qstring))
                                (vector-push-extend (setq qchar q) qstring)
                              )
                              (vector-push-extend c qstring)))
                        string
               )
               (when qchar (vector-push-extend qchar qstring))
               qstring
         ) ) )
         #+WIN32
         (shell-simple-quote (string) ; protect against spaces only
           ; Also protect the characters which are special for the command
           ; interpreter. This is needed only if the command interpreter
           ; will be called, but doesn't hurt if CreateProcess() will be
           ; called directly.
           (if (or (eql (length string) 0)
                   (some #'(lambda (c)
                             (or ; space?
                                 (<= (char-code c) 32)
                                 ; special delimiter?
                                 (eql c #\&)
                                 (eql c #\<)
                                 (eql c #\>)
                                 (eql c #\|)
                                 (eql c #\^)
                           ) )
                         string
               )   )
             (string-concat "\"" string "\"")
             string
         ) )
         #+WIN32
         (shell-quote (string) ; full protection
           (let ((quote-around
                   (or (eql (length string) 0)
                       (some #'(lambda (c)
                                 (or ; space?
                                     (<= (char-code c) 32)
                                     ; special delimiter?
                                     (eql c #\&)
                                     (eql c #\<)
                                     (eql c #\>)
                                     (eql c #\|)
                                     (eql c #\^)
                               ) )
                             string)))
                 (qstring (make-array 10 :element-type 'character
                                         :adjustable t :fill-pointer 0))
                 (backslashes 0))
             (when quote-around
               (vector-push-extend #\" qstring)
             )
             (map nil #'(lambda (c)
                          (when (eql c #\")
                            (dotimes (i (+ backslashes 1))
                              (vector-push-extend #\\ qstring)
                          ) )
                          (vector-push-extend c qstring)
                          (if (eql c #\\)
                            (incf backslashes)
                            (setq backslashes 0)
                        ) )
                      string
             )
             (when quote-around
               (dotimes (i backslashes)
                 (vector-push-extend #\\ qstring)
               )
               (vector-push-extend #\" qstring)
             )
             qstring
         ) )
         ; conversion to a string that works for a pathname as well
         (xstring (object)
           (if (pathnamep object)
             (namestring (absolute-pathname object))
             (if (symbolp object)
               (princ-to-string object)
               (string object)))))
  #+WIN32
  (defun execute (programfile &rest arguments)
    (shell
      (apply #'string-concat
             (shell-simple-quote (xstring programfile))
             (mapcan #'(lambda (argument)
                         (list " " (shell-quote (xstring argument)))
                       )
                     arguments
  ) ) )      )
  (defun run-shell-command (command &key (input ':terminal) (output ':terminal)
                                         (if-output-exists ':overwrite)
                                         (wait t)
                                         #+UNIX (may-exec nil)
                                         #+WIN32 (indirectp t)
                           )
    (case input
      ((:TERMINAL :STREAM) )
      (t (if (eq input 'NIL)
           (setq input #+UNIX "/dev/null" #+WIN32 "nul")
           (setq input (xstring input))
         )
         (setq command (string-concat command " < " (shell-quote input)))
         #+WIN32 (setq indirectp t)
    ) )
    (case output
      ((:TERMINAL :STREAM) )
      (t (if (eq output 'NIL)
           (setq output #+UNIX "/dev/null" #+WIN32 "nul"
                 if-output-exists ':OVERWRITE
           )
           (progn
             (setq output (xstring output))
             (when (and (eq if-output-exists ':ERROR) (probe-file output))
               (setq output (pathname output))
               (error-of-type 'file-error
                 :pathname output
                 (TEXT "~S: File ~S already exists")
                 'run-shell-command output
         ) ) ) )
         (setq command
               (string-concat command
                 (ecase if-output-exists
                   ((:OVERWRITE :ERROR) " > ")
                   (:APPEND " >> ")
                 )
                 (shell-quote output)
         )     )
         #+WIN32 (setq indirectp t)
    ) )
    #-WIN32
    (unless wait
      (setq command (string-concat command " &")))
    #+WIN32
    (unless wait
      (setq indirectp t)
      (setf command (string-concat "start " command)))
    #+UNIX
    (when may-exec
      ;; If the executing shell is "/bin/sh" and command is a
      ;; "simple command" in the sense of sh(1), we can optimize it a bit:
      (setq command (string-concat "exec " command))
    )
    #+WIN32
    (when indirectp
      (setq command (string-concat (shell-name) " /c " command))
    )
    (if (eq input ':STREAM)
      (if (eq output ':STREAM)
        (make-pipe-io-stream command)
        (make-pipe-output-stream command))
      (if (eq output ':STREAM)
        (make-pipe-input-stream command)
        (shell command))))
  (defun run-program (program &key (arguments '())
                                   (input ':terminal) (output ':terminal)
                                   (if-output-exists ':overwrite)
                                   (wait t)
                                   #+WIN32 (indirectp nil)
                     )
    (run-shell-command
      (apply #'string-concat
             (shell-simple-quote (xstring program))
             (mapcan #'(lambda (argument)
                         (list " " (shell-quote (xstring argument)))
                       )
                     arguments
      )      )
      #+UNIX :may-exec #+UNIX t
      #+WIN32 :indirectp #+WIN32 indirectp
      :wait wait
      :input input :output output :if-output-exists if-output-exists
  ) )
)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./runprog.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./condition.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Condition System for CLISP
;;; David Gadbois <gadbois@cs.utexas.edu> 30.11.1993
;;; Bruno Haible 24.11.1993, 2.12.1993 -- 2005
;;; Sam Steingold 1998-2005, 2007-2011

(in-package "COMMON-LISP")
;;; exports:
(export
 '(;; types:
   restart condition serious-condition error program-error control-error
   arithmetic-error division-by-zero floating-point-overflow
   floating-point-underflow floating-point-inexact
   floating-point-invalid-operation
   cell-error unbound-variable undefined-function unbound-slot
   type-error package-error print-not-readable parse-error stream-error
   end-of-file reader-error file-error storage-condition warning
   style-warning simple-condition simple-error simple-type-error simple-warning
   ;; macros:
   define-condition handler-bind ignore-errors handler-case
   with-condition-restarts restart-bind restart-case
   with-simple-restart check-type assert etypecase ctypecase ecase ccase
   ;; functions:
   make-condition arithmetic-error-operation arithmetic-error-operands
   cell-error-name unbound-slot-instance type-error-datum
   type-error-expected-type package-error-package print-not-readable-object
   stream-error-stream file-error-pathname
   simple-condition-format-control simple-condition-format-arguments
   signal restart-name compute-restarts find-restart invoke-restart
   invoke-restart-interactively invoke-debugger break error cerror warn
   ;; functions and restart names:
   abort continue muffle-warning store-value use-value
   ;; variables:
   *break-on-signals* *debugger-hook*))
;; extensions:
(in-package "EXT")
(export
 '(muffle-cerrors appease-cerrors exit-on-error with-restarts os-error
   #+(or :win32 :cygwin) os-error-win32 os-error-code
   os-stream-error os-file-error
   abort-on-error set-global-handler without-global-handlers
   source-program-error source-program-error-form source-program-error-detail
   simple-condition-format-string simple-charset-type-error retry)
 "EXT")
(in-package "CUSTOM")
(common-lisp:export
 '(*break-on-warnings* *report-error-print-backtrace*)
 "CUSTOM")
(ext:re-export "CUSTOM" "EXT")
(common-lisp:in-package "SYSTEM")

;;; Overview of Concepts

;; A condition is some information about an exceptional situation the program
;; cannot or does not want handle locally.
;; A handler is some code that tries to do recovery from exceptional situations
;; that happen elsewhere, or that decides to transfer control.
;; A restart is a point where control may be transferred to, together with a
;; description what is about to happen in this case.

;;; The CONDITION type

; The condition type system is integrated with CLOS.
(clos:defclass condition () ())

;; 29.3.18. Printing Conditions when *print-escape*
;;          and *print-readably* are NIL.
;; <http://www.lisp.org/HyperSpec/Body/sec_9-1-3.html>
(definternational print-condition-format
  (t ENGLISH))
(deflocalized print-condition-format ENGLISH
  (formatter "Condition of type ~S."))
(clos:defmethod clos:print-object ((condition condition) stream)
  (if (or *print-escape* *print-readably*)
    (clos:call-next-method)
    (progn
      (format stream (localized 'print-condition-format) (type-of condition))
      condition)))
; Entry-points used by other parts of CLISP.
(defun print-condition (condition stream)
  (let ((*print-escape* nil)
        (*print-readably* nil))
    (print-object condition stream)))
(defun pretty-print-condition (condition stream &key (text-indent 6))
  (with-fill-stream (out stream :text-indent text-indent)
    (print-condition condition out)))

;;; 29.4.5. Defining Conditions
;;; <http://www.lisp.org/HyperSpec/Body/sec_9-1-2.html>
;; DEFINE-CONDITION, CLtL2 p. 898
(defmacro define-condition (&whole whole-form
                            name parent-types slot-specs &rest options)
  (setq name (check-not-declaration name 'define-condition))
  (unless (and (listp parent-types) (every #'symbolp parent-types))
    (error-of-type 'source-program-error
      :form whole-form
      :detail parent-types
      (TEXT "~S: the parent-type list must be a list of symbols, not ~S")
      'define-condition parent-types))
  (unless (listp slot-specs)
    (error-of-type 'source-program-error
      :form whole-form
      :detail slot-specs
      (TEXT "~S: the slot description list must be a list, not ~S")
      'define-condition slot-specs))
  (let ((default-initargs-option nil)
        (docstring-option nil)
        (report-function nil))
    (dolist (option options)
      (if (listp option)
        (cond ((and (eq (car option) ':DEFAULT-INITARGS) (oddp (length option)))
               (setq default-initargs-option option))
              ((and (keywordp (car option)) (eql (length option) 2))
               (case (first option)
                 (:DOCUMENTATION (setq docstring-option option))
                 (:REPORT (setq report-function (rest option)))
                 (T (error-of-type 'source-program-error
                      :form whole-form
                      :detail (first option)
                      (TEXT "~S ~S: unknown option ~S")
                      'define-condition name (first option)))))
              (t
               (error-of-type 'source-program-error
                 :form whole-form
                 :detail option
                 (TEXT "~S ~S: invalid syntax in ~S option: ~S")
                 'define-condition name 'define-condition option)))
        (error-of-type 'source-program-error
          :form whole-form
          :detail option
          (TEXT "~S ~S: not a ~S option: ~S")
          'define-condition name 'define-condition option)))
    (let ((defclass-form
            `(CLOS:DEFCLASS ,name
               ,(or parent-types '(CONDITION))
               ,slot-specs
               ,@(if docstring-option `(,docstring-option))
               ,@(if default-initargs-option `(,default-initargs-option)))))
      `(PROGN
         ,defclass-form
         ,@(when report-function
             `((CLOS:DEFMETHOD PRINT-OBJECT ((CONDITION ,name) STREAM)
                 (IF (OR *PRINT-ESCAPE* *PRINT-READABLY*)
                   (CLOS:CALL-NEXT-METHOD)
                   (PROGN
                     ,(if (stringp (first report-function))
                       `(WRITE-STRING ,(first report-function) STREAM)
                       `(FUNCALL (FUNCTION ,@report-function) CONDITION STREAM))
                     CONDITION)))))
         ',name))))

;;; 29.4.6. Creating Conditions

(defun find-subclasses-of-type (type class)
  "Find all subclasses of CLASS that are subtypes of the given TYPE."
  (if (subtypep class type)
      (list class)
      (delete-duplicates
       (loop :for c :in (clos:class-direct-subclasses class)
         :nconc (find-subclasses-of-type type c)))))

#+(or) ; not used
(defun prune-subclasses (classes)
  "Delete classes that are subclasses of other classes."
  (do ((tail classes (cdr tail)) this)
      ((endp tail) (delete nil classes))
    (setq this (car tail))
    (when (loop :for c :in classes
            ;; when THIS is a subclass of C, remove THIS
            :thereis (and c (not (eq this c)) (clos::subclassp this c)))
      (setf (car tail) nil))))

;; MAKE-CONDITION, CLtL2 p. 901
(defun make-condition (type &rest slot-initializations)
  (unless (subtypep type 'condition)
    (error-of-type 'error
      (TEXT "~S: type ~S is not a subtype of ~S")
      'make-condition type 'condition))
  (let ((class (or (and (symbolp type) (find-class type nil))
                   ;; not a specific class - find a maximal subclass of
                   ;; CONDITION that has the given TYPE
                   (car (last (sort (find-subclasses-of-type
                                     type (find-class 'condition))
                                    #'clos::subclassp))))))
    (if class
        (apply #'clos:make-instance class slot-initializations)
        (error-of-type 'error
          (TEXT "~S: cannot find a ~S class that is a subtype of ~S")
                'make-condition 'condition type))))

;; canonicalize a condition argument, CLtL2 p. 888

(defun try-coerce-to-condition (datum arguments
                                caller-name
                                default-type &rest more-initargs)
  (typecase datum
    (condition
      (when arguments
        (unless (eq caller-name 'cerror)
          (error-of-type 'type-error
            :datum arguments :expected-type 'null
            (TEXT "~S ~S: superfluous arguments ~S")
            caller-name datum arguments)))
      datum)
    (null                       ; os-error and subclasses
      (apply #'make-condition default-type more-initargs))
    (symbol
      (apply #'make-condition datum arguments))
    ((or string function)
      (apply #'make-condition default-type
             :format-control datum
             :format-arguments arguments
             more-initargs))
    (t
      (error-of-type 'type-error
        :datum datum :expected-type '(or condition symbol string function)
        (TEXT "~S: the condition argument must be a string, a symbol or a condition, not ~S")
        caller-name datum))))

(defun valid-condition-designator-p (datum+arguments)
  (handler-case
      (try-coerce-to-condition (car datum+arguments) (cdr datum+arguments)
                               'coerce-to-condition 'simple-error) ; hmmpf
    (ERROR () nil)
    (:NO-ERROR (&rest values) (declare (ignore values)) t)))

(defun coerce-to-condition (datum arguments
                            caller-name
                            default-type &rest more-initargs)
  (handler-case
      (apply #'try-coerce-to-condition datum arguments
             caller-name default-type more-initargs)
    (TYPE-ERROR (error) (error error))
    (ERROR (error)
      ;; ANSI CL wants a type error here.
      (error-of-type 'type-error
        :datum (cons datum arguments)
        :expected-type '(satisfies valid-condition-designator-p)
        "~A" error))))

;;; 29.5. Predefined Condition Types

; Hierarchy:
;
;   condition
;   |
;   |-- simple-condition
;   |
;   |-- serious-condition
;   |   |
;   |   |-- error
;   |   |   |
;   |   |   |-- simple-error
;   |   |   |
;   |   |   |-- arithmetic-error
;   |   |   |   |
;   |   |   |   |-- division-by-zero
;   |   |   |   |
;   |   |   |   |-- floating-point-overflow
;   |   |   |   |
;   |   |   |   |-- floating-point-underflow
;   |   |   |   |
;   |   |   |   |-- floating-point-inexact
;   |   |   |   |
;   |   |   |   |-- floating-point-invalid-operation
;   |   |   |
;   |   |   |-- cell-error
;   |   |   |   |
;   |   |   |   |-- unbound-variable
;   |   |   |   |
;   |   |   |   |-- undefined-function
;   |   |   |   |
;   |   |   |   |-- unbound-slot
;   |   |   |
;   |   |   |-- control-error
;   |   |   |
;   |   |   |-- file-error
;   |   |   |
;   |   |   |-- os-error
;   |   |   |
;   |   |   |-- package-error
;   |   |   |
;   |   |   |-- print-not-readable
;   |   |   |
;   |   |   |-- program-error
;   |   |   |   |
;   |   |   |   +---------------------------------------+
;   |   |   |                                           |
;   |   |   |-- parse-error                             |
;   |   |   |   |                                       |
;   |   |   |   +-------------------+                   |
;   |   |   |                       |                   |
;   |   |   |-- stream-error        |                   |
;   |   |   |   |                   |                   |
;   |   |   |   |-- end-of-file     |                   |
;   |   |   |   |                   |                   |
;   |   |   |   +-------------------+-- reader-error    |
;   |   |   |                                           |
;   |   |   |-- type-error                              |
;   |   |       |                                       |
;   |   |       |-- simple-type-error                   |
;   |   |       |                                       |
;   |   |       +---------------------------------------+-- argument-list-dotted
;   |   |
;   |   |-- storage-condition
;   |   |
;   |   |-- interrupt-condition
;   |
;   |-- warning
;       |
;       |-- simple-warning
;       |
;       |-- style-warning
;       |   |
;       |   |-- simple-style-warning
;       |   |
;       |   |------------+
;       |                |
;       |-- clos-warning |
;           |            |
;           |------------+-- clos-style-warning
;           |                |
;           |                |-- gf-already-called-warning
;           |                |
;           |                |-- gf-replacing-method-warning
;           |                |
;           |                |-- class-obsolescence-warning
;           |
;           |-- clos-novice-warning

;; X3J13 writeup <CONDITION-SLOTS:HIDDEN> wants the slot names to be hidden,
;; (e.g. no slot named `package', `stream', `pathname'), hence we prepend $.

; conditions that require interactive intervention
(define-condition serious-condition () ())

  ; serious conditions that occur deterministically
  (define-condition error (serious-condition) ())

    ; mostly statically detectable errors of a program
    (define-condition program-error (error) ())
    ; all the other errors must be detected by the runtime system

      ; statically detectable errors of a program, source available [CLISP specific]
      (define-condition source-program-error (program-error)
        (;; The "outer-most" bad form, i.e. the list whose first element is the
         ;; macro or special-operator name.
         ($form   :initarg :form   :reader source-program-error-form)
         ;; The "inner-most" detail of the bad form, e.g., when a string is
         ;; given as a variable name, this is the string, not the whole form.
         ($detail :initarg :detail :reader source-program-error-detail)))

    ; not statically detectable errors in program control
    (define-condition control-error (error) ())

    ; errors that occur while doing arithmetic operations
    (define-condition arithmetic-error (error)
      (($operation :initarg :operation :reader arithmetic-error-operation)
       ($operands  :initarg :operands  :reader arithmetic-error-operands)))

      ; trying to evaluate a mathematical function at a singularity
      (define-condition division-by-zero (arithmetic-error) ())

      ; trying to get too close to infinity in the floating point domain
      (define-condition floating-point-overflow (arithmetic-error) ())

      ; trying to get too close to zero in the floating point domain
      (define-condition floating-point-underflow (arithmetic-error) ())

      (define-condition floating-point-inexact (arithmetic-error) ())

      (define-condition floating-point-invalid-operation (arithmetic-error) ())

    ; trying to access a location which contains #<UNBOUND>
    (define-condition cell-error (error)
      (($name :initarg :name :reader cell-error-name)))

      ; trying to get the value of an unbound variable
      (define-condition unbound-variable (cell-error) ())

      ; trying to get the global function definition of an undefined function
      (define-condition undefined-function (cell-error) ())

      ; trying to get the value of an unbound slot
      (define-condition unbound-slot (cell-error)
        (($instance :initarg :instance :reader unbound-slot-instance)))

    ; when some datum does not belong to the expected type
    (define-condition type-error (error)
      (($datum         :initarg :datum         :reader type-error-datum)
       ($expected-type :initarg :expected-type :reader type-error-expected-type)))

      ; when some keyword does not belong to one of the allowed keywords [CLISP specific]
      ; ANSI CL 3.5.1.4., 3.5.1.5. want this to be a subclass of PROGRAM-ERROR.
      (define-condition keyword-error (program-error type-error) ())

      ; when some character does not belong to a given character set [CLISP specific]
      (define-condition charset-type-error (type-error) ())

      ; when an argument list in APPLY is dotted [CLISP specific]
      ; ANSI CL 3.5.1.2. want this to be a subclass of PROGRAM-ERROR.
      ; For the use of APPLY in the expansion of the FORMATTER macro, this
      ; must also be a subclass of TYPE-ERROR.
      (define-condition argument-list-dotted (program-error type-error) ())

    ; errors during operation on packages
    (define-condition package-error (error)
      (($package :initarg :package :reader package-error-package)))

    ; attempted violation of *PRINT-READABLY*
    (define-condition print-not-readable (error)
      (($object :initarg :object :reader print-not-readable-object)))

    ; errors related to parsing
    (define-condition parse-error (error) ())

    ; errors while doing stream I/O
    (define-condition stream-error (error)
      (($stream :initarg :stream :reader stream-error-stream)))

      ; unexpected end of stream
      (define-condition end-of-file (stream-error) ())

      ; parsing/tokenization error during READ
      (define-condition reader-error (parse-error stream-error) ())

    ; errors with pathnames, OS level errors with streams
    (define-condition file-error (error)
      (($pathname :initarg :pathname :reader file-error-pathname)))

    ; general OS errors [CLISP specific]
    (define-condition os-error (error)
      (($code :initarg :code :reader os-error-code))
      (:report (lambda (condition stream)
                 (let ((code (os-error-code condition)))
                   (format stream "~S(~A): ~A" (type-of condition) code
                           (sys::strerror code))))))

      #+(or :win32 :cygwin)
      (define-condition os-error-win32 (os-error) ()
        (:report (lambda (condition stream)
                   (let ((code (os-error-code condition)))
                     (format stream "~S(~A): ~A" (type-of condition) code
                             (sys::format-message code))))))
      (define-condition os-stream-error (os-error stream-error) ())
      (define-condition os-file-error (os-error file-error) ())

  ; "Virtual memory exhausted"
  (define-condition storage-condition (serious-condition) ())

  ; "User break" [CLISP specific]
  (define-condition interrupt-condition (serious-condition) ())

; conditions for which user notification is appropriate
(define-condition warning () ())

  ; conditions which are a matter of programming style (not serious)
  (define-condition style-warning (warning) ())

  ; CLOS user notifications [CLISP specific]
  (define-condition clos:clos-warning (warning) ())
    (define-condition clos:clos-novice-warning (clos:clos-warning) ())

    (define-condition clos:clos-style-warning (style-warning clos:clos-warning) ())

      ; CLOS: generic function is being modified, but has already been called
      (define-condition clos:gf-already-called-warning (clos:clos-style-warning) ())

      ; CLOS: replacing method in a GF
      (define-condition clos:gf-replacing-method-warning (clos:clos-style-warning) ())

      ; CLOS: class obsolescence
      (define-condition clos:class-obsolescence-warning (clos:clos-style-warning) ())


;; These shouldn't be separate types but we cannot adjoin slots without
;; defining subtypes.

; conditions usually created by SIGNAL
(define-condition simple-condition ()
  (($format-control :initarg :format-control :initform nil
                    :reader simple-condition-format-string ; for CLtL2 backward compatibility
                    :reader simple-condition-format-control)
   ($format-arguments :initarg :format-arguments :initform nil
                      :reader simple-condition-format-arguments))
  (:report
    (lambda (condition stream)
      (let ((fstring (simple-condition-format-control condition)))
       (if fstring
          (apply #'format stream fstring
                (simple-condition-format-arguments condition))
         (clos:call-next-method))))))

;; conditions usually created by ERROR or CERROR
(define-condition simple-error (simple-condition error) ())

;; conditions usually created by CHECK-TYPE
(define-condition simple-type-error (simple-condition type-error) ())

;; conditions usually created by WARN
(define-condition simple-warning (simple-condition warning) ())

(define-condition simple-style-warning (simple-condition style-warning) ())

;; CLOS warnings
(define-condition clos::simple-clos-warning (simple-condition clos:clos-warning) ())
(define-condition clos::simple-clos-novice-warning (simple-condition clos:clos-novice-warning) ())
(define-condition clos::simple-clos-style-warning (simple-condition clos:clos-style-warning) ())
(define-condition clos::simple-gf-already-called-warning (simple-condition clos:gf-already-called-warning) ())
(define-condition clos::simple-gf-replacing-method-warning (simple-condition clos:gf-replacing-method-warning) ())
(define-condition clos::simple-class-obsolescence-warning (simple-condition clos:class-obsolescence-warning) ())

;; All conditions created by the C runtime code are of type simple-condition.
;; Need the following types. Don't use them for discrimination.
(define-condition simple-serious-condition (simple-condition serious-condition) ())
(define-condition simple-program-error (simple-error program-error) ())
(define-condition simple-source-program-error (simple-error source-program-error) ())
(define-condition simple-control-error (simple-error control-error) ())
(define-condition simple-arithmetic-error (simple-error arithmetic-error) ())
(define-condition simple-division-by-zero (simple-error division-by-zero) ())
(define-condition simple-floating-point-overflow (simple-error floating-point-overflow) ())
(define-condition simple-floating-point-underflow (simple-error floating-point-underflow) ())
(define-condition simple-cell-error (simple-error cell-error) ())
(define-condition simple-unbound-variable (simple-error unbound-variable) ())
(define-condition simple-undefined-function (simple-error undefined-function) ())
(define-condition simple-unbound-slot (simple-error unbound-slot) ())
(define-condition simple-keyword-error (simple-error keyword-error) ())
(define-condition simple-charset-type-error (simple-error charset-type-error) ())
(define-condition simple-argument-list-dotted (simple-error argument-list-dotted) ())
(define-condition simple-package-error (simple-error package-error) ())
(define-condition simple-print-not-readable (simple-error print-not-readable) ())
(define-condition simple-parse-error (simple-error parse-error) ())
(define-condition simple-stream-error (simple-error stream-error) ())
(define-condition simple-end-of-file (simple-error end-of-file) ())
(define-condition simple-reader-error (simple-error reader-error) ())
(define-condition simple-file-error (simple-error file-error) ())
(define-condition simple-storage-condition (simple-condition storage-condition) ())
(define-condition simple-interrupt-condition (simple-condition interrupt-condition) ())

;; for NO-APPLICABLE-METHOD, NO-PRIMARY-METHOD, NO-NEXT-METHOD
(define-condition method-call-error (simple-error)
  (($gf :initarg :generic-function :reader method-call-error-generic-function)
   ($method :initarg :method :reader method-call-error-method)
   ($args :initarg :argument-list :reader method-call-error-argument-list)))
(define-condition method-call-type-error
    (simple-type-error method-call-error) ())

;; Bootstrapping
(%defclcs
 ;; The order of the types in this vector must be the same as in lispbibl.d.
 '#((condition                . simple-condition)
    (serious-condition        . simple-serious-condition)
    (error                    . simple-error)
    (program-error            . simple-program-error)
    (source-program-error     . simple-source-program-error)
    (control-error            . simple-control-error)
    (arithmetic-error         . simple-arithmetic-error)
    (division-by-zero         . simple-division-by-zero)
    (floating-point-overflow  . simple-floating-point-overflow)
    (floating-point-underflow . simple-floating-point-underflow)
    (cell-error               . simple-cell-error)
    (unbound-variable         . simple-unbound-variable)
    (undefined-function       . simple-undefined-function)
    (unbound-slot             . simple-unbound-slot)
    (type-error               . simple-type-error)
    (keyword-error            . simple-keyword-error)
    (charset-type-error       . simple-charset-type-error)
    (argument-list-dotted     . simple-argument-list-dotted)
    (package-error            . simple-package-error)
    (print-not-readable       . simple-print-not-readable)
    (parse-error              . simple-parse-error)
    (stream-error             . simple-stream-error)
    (end-of-file              . simple-end-of-file)
    (reader-error             . simple-reader-error)
    (file-error               . simple-file-error)
    (storage-condition        . simple-storage-condition)
    (interrupt-condition      . simple-interrupt-condition)
    (warning                  . simple-warning)))


;;; Handling and Signalling - Primitives

(defvar *break-on-signals* nil)

#|
;; This would be a possible implementation. However, it forces too many
;; variables into closures although in the most frequent case - no condition
;; at all - they won't be needed. Furthermore, it conses too much.

;; List of active invocations of HANDLER-BIND.
 (defvar *handler-clusters* '())

;; HANDLER-BIND, CLtL2 p. 898
 (defmacro handler-bind (clauses &body body)
  `(LET ((*HANDLER-CLUSTERS*
           (CONS
             (LIST ,@(mapcar #'(lambda (clause)
                                 (let ((type (first clause))
                                       (function-form (second clause)))
                                   `(CONS ',type ,function-form)))
                             clauses))
             *HANDLER-CLUSTERS*)))
     (PROGN ,@body)))

;; SIGNAL, CLtL2 p. 888
 (defun signal (datum &rest arguments)
  (let ((condition
         ;; CLtL2 p. 918 specifies this
         (coerce-to-condition datum arguments 'signal 'simple-condition)))
    (when (typep condition *break-on-signals*)
      ; Enter the debugger prior to signalling the condition
      (restart-case (invoke-debugger condition)
        (CONTINUE ())))
    ; CLtL2 p. 884: "A handler is executed in the dynamic context of the
    ; signaler, except that the set of available condition handlers will
    ; have been rebound to the value that was active at the time the condition
    ; handler was made active."
    (let ((*handler-clusters* *handler-clusters*))
      (loop
        (when (null *handler-clusters*) (return))
        (dolist (handler (pop *handler-clusters*))
          (when (typep condition (car handler))
            (funcall (cdr handler) condition)
            (return)))))
    nil))

|#

;; HANDLER-BIND, CLtL2 p. 898
;; Since we can build handler frames only in compiled code there is
;; SYS::%HANDLER-BIND which is analogous to HANDLER-BIND except that the former
;; only occurs in compiled code and has the normal function syntax.
;; cf. compiler.lisp:c-HANDLER-BIND
(defmacro handler-bind (clauses &body body)
  (let* ((typespecs (mapcar #'first clauses))
         (handlers (nconc (mapcar #'rest clauses) (list body)))
         (handler-vars (gensym-list (length handlers))))
    `(LET ,(mapcar #'list
                   handler-vars
                   (mapcar #'(lambda (handler)
                               `(FUNCTION (LAMBDA () (PROGN ,@handler))))
                           handlers))
       (LOCALLY (DECLARE (COMPILE))
         (SYS::%HANDLER-BIND
          ,(car (last handler-vars))
          ,@(mapcan #'(lambda (typespec handler-var)
                        `(',typespec #'(LAMBDA (CONDITION)
                                         (FUNCALL (FUNCALL ,handler-var)
                                                  CONDITION))))
                    typespecs handler-vars))))))

;; SIGNAL, CLtL2 p. 888
;; is in error.d


;;; Handling and Signalling - Part 2

;; IGNORE-ERRORS, CLtL2 p. 897
(defmacro ignore-errors (&body body)
  (let ((blockname (gensym "IGNORE-ERRORS-")))
    `(BLOCK ,blockname
       (HANDLER-BIND
         ((ERROR #'(LAMBDA (CONDITION)
                     (RETURN-FROM ,blockname (VALUES NIL CONDITION)))))
         ,@body))))

;; HANDLER-CASE, CLtL2 p. 895
(defmacro handler-case (&whole whole-form
                        form &rest clauses)
  ;; split off the :NO-ERROR clause and
  ;; add a GO tag to the other clauses (type varlist . body)
  (let ((no-error-clause nil) ; the :no-error clause, if found
        (extended-clauses '())) ; ((tag type varlist . body) ...)
    (do ()
        ((endp clauses))
      (let ((clause (pop clauses)))
        (block check-clause
          (unless (and (consp clause) (consp (cdr clause))
                       (listp (second clause)))
            (error-of-type 'source-program-error
              :form whole-form
              :detail clause
              (TEXT "~S: illegal syntax of clause ~S")
              'handler-case clause))
          (when (eq (first clause) ':no-error)
            (if (null no-error-clause)
              (setq no-error-clause clause)
              (warn (TEXT "~S: multiple ~S clauses: ~S and ~S")
                    'handler-case ':no-error clause no-error-clause))
            (return-from check-clause))
          (let ((varlist (second clause))) ; known to be a list
            (unless (null (cdr varlist))
              (error-of-type 'source-program-error
                :form whole-form
                :detail varlist
                (TEXT "~S: too many variables ~S in clause ~S")
                'handler-case varlist clause)))
          (push (cons (gensym "HANDLER-") clause) extended-clauses))))
    (setq extended-clauses (nreverse extended-clauses))
    (let ((blockname (gensym "HANDLER-CASE-"))
          (tempvar (gensym "CONDITION-")))
      `(BLOCK ,blockname
         (LET (,tempvar) ; tempvar is IGNORABLE since it is a gensym
           (TAGBODY
             (RETURN-FROM ,blockname
               ,(let ((main-form
                        `(HANDLER-BIND
                           ,(mapcar #'(lambda (xclause)
                                        (let ((tag (first xclause))
                                              (type (first (rest xclause)))
                                              (varlist (second (rest xclause))))
                                          `(,type
                                            #'(LAMBDA (CONDITION)
                                                ,(if (null varlist)
                                                   `(DECLARE (IGNORE CONDITION))
                                                   `(SETQ ,tempvar CONDITION))
                                                (GO ,tag)))))
                                    extended-clauses)
                           ,form)))
                  (if no-error-clause
                    `(MULTIPLE-VALUE-CALL #'(LAMBDA ,@(rest no-error-clause))
                       ,main-form)
                    main-form)))
             ,@(mapcap #'(lambda (xclause)
                           (let ((tag (first xclause))
                                 (varlist (second (rest xclause)))
                                 (body (cddr (rest xclause)))) ; may contain declarations
                             `(,tag
                               (RETURN-FROM ,blockname
                                 (LET ,(if (null varlist)
                                         '() `((,@varlist ,tempvar)))
                                   ,@body)))))
                       extended-clauses)))))))


;;; Restarts

;; This stuff is needed only once an exception has already occurred. No need
;; to optimize the hell out of it.

; The default test function for restarts always returns T. See CLtL2 p. 905,909.
(defun default-restart-test (condition)
  (declare (ignore condition))
  t)

; The default interactive function for restarts returns the empty argument list.
(defun default-restart-interactive ()
  '())

;; The RESTART type, CLtL2 p. 916
;; Also defines RESTART-NAME, CLtL2 p. 911
;; Also defines MAKE-RESTART, ABI
(defstruct restart
  name             ; its name, or NIL if it is not named
  (test #'default-restart-test) ; function that tests whether this restart
                                ; applies to a given condition
  (invoke-tag nil) ; tag used to invoke the restart, or nil
  invoke-function  ; function used to invoke the restart, if invoke-tag is nil
  (report nil)     ; function used to print a description of the restart
  (interactive #'default-restart-interactive)
                   ; function used to gather additional data from the user
                   ; before invoking the restart
  (meaningfulp t)  ; whether it makes sense to invoke this restart without
                   ; prior corrective action
)
#| ; We could also define it as a CLOS class:
 (clos:defclass restart ()
  (name            :initarg :name            :reader restart-name)
  (test            :initarg :test            :reader restart-test
                   :initform #'default-restart-test)
  (invoke-tag      :initarg :invoke-tag      :reader restart-invoke-tag
                   :initform nil)
  (invoke-function :initarg :invoke-function :reader restart-invoke-function)
  (report          :initarg :report          :reader restart-report
                   :initform nil)
  (interactive     :initarg :interactive     :reader restart-interactive
                   :initform #'default-restart-interactive)
  (meaningfulp     :initarg :meaningfulp     :reader restart-meaningfulp
                   :initform t))
|#

;; Printing restarts
(clos:defmethod clos:print-object ((restart restart) stream)
  (if (or *print-escape* *print-readably*)
    (clos:call-next-method)
    (let ((report-function (restart-report restart)))
      (if report-function
        (funcall report-function stream)
        (prin1 (restart-name restart) stream))))
  restart)

;; Expands to the equivalent of `(MAKE-RESTART :NAME name ...)
;; but makes intelligent use of the defaults to reduce code size.
(defun make-restart-form (name test invoke-tag invoke-function report interactive meaningfulp)
  `(MAKE-RESTART
     :NAME ,name
     ,@(if (not (equal test '(FUNCTION DEFAULT-RESTART-TEST)))
         `(:TEST ,test))
     ,@(if (not (equal invoke-tag 'NIL))
         `(:INVOKE-TAG ,invoke-tag))
     :INVOKE-FUNCTION ,invoke-function
     ,@(if (not (equal report 'NIL))
         `(:REPORT ,report))
     ,@(if (not (equal interactive '(FUNCTION DEFAULT-RESTART-INTERACTIVE)))
         `(:INTERACTIVE ,interactive))
     ,@(if (not (equal meaningfulp 'T))
         `(:MEANINGFULP ,meaningfulp))))

;; The list of active restarts.
(defvar *active-restarts* nil) ; ABI

;; A list of pairs of conditions and restarts associated with them. We have to
;; keep the associations separate because there can be a many-to-many mapping
;; between restarts and conditions, and this mapping has dynamic extent.
(defvar *condition-restarts* nil) ; ABI

; Add an association between a condition and a couple of restarts.
(defun add-condition-restarts (condition restarts) ; ABI
  (dolist (restart restarts)
    (push (cons condition restart) *condition-restarts*)))

;; WITH-CONDITION-RESTARTS, CLtL2 p. 910
(defmacro with-condition-restarts (condition-form restarts-form &body body)
  `(LET ((*CONDITION-RESTARTS* *CONDITION-RESTARTS*))
     (ADD-CONDITION-RESTARTS ,condition-form ,restarts-form)
     ;; ANSI CL does not allow declarations at the beginning of the body, but
     ;; we do, as an extension.
     (LET () ,@body)))

;;; 29.4.8. Finding and Manipulating Restarts

; Tests whether a given restart is applicable to a given condition
(defun applicable-restart-p (restart condition)
  (and
   (or (null condition)
       ;; A restart is applicable if it is associated to that condition
       ;; or if it is not associated to any condition.
       (let ((not-at-all t))
         (dolist (asso *condition-restarts* not-at-all)
           (when (eq (cdr asso) restart)
             (if (eq (car asso) condition)
                 (return t)
                 (setq not-at-all nil))))))
   ;; Call the restart's test function:
   (funcall (restart-test restart) condition)))

;; COMPUTE-RESTARTS, CLtL2 p. 910
(defun compute-restarts (&optional condition)
  (remove-if-not #'(lambda (restart) (applicable-restart-p restart condition))
                 *active-restarts*))

;; FIND-RESTART, CLtL2 p. 911
; returns a restart or nil
(defun find-restart (restart-identifier &optional condition)
  ;; cannot use (E)TYPECASE for bootstrapping reasons
  (cond ((null restart-identifier)
         (error-of-type 'error
           (TEXT "~S: ~S is not a valid restart name here. Use ~S instead.")
           'find-restart restart-identifier 'compute-restarts))
        ((symbolp restart-identifier)
         ;;(find restart-identifier *active-restarts*
         ;;      :test (lambda (ri restart)
         ;;              (and (eq (restart-name restart) ri)
         ;;                   (applicable-restart-p restart condition))))
         (dolist (restart *active-restarts*)
           (when (and (eq (restart-name restart) restart-identifier)
                      (applicable-restart-p restart condition))
             (return restart))))
        ((typep restart-identifier 'restart)
         ;;(find restart-identifier *active-restarts*
         ;;      :test (lambda (ri restart)
         ;;              (and (eq restart ri)
         ;;                   (applicable-restart-p restart condition))))
         (dolist (restart *active-restarts*)
           (when (and (eq restart restart-identifier)
                      (applicable-restart-p restart condition))
             (return restart))))
        (t (error-of-type 'type-error
             :datum restart-identifier :expected-type '(or symbol restart)
             (TEXT "~S: invalid restart name ~S")
             'find-restart restart-identifier))))

(defun restart-not-found (restart-identifier)
  (error-of-type 'control-error
    (TEXT "~S: No restart named ~S is visible.")
    'invoke-restart restart-identifier))

(defun %invoke-restart (restart arguments)
  (if (restart-invoke-tag restart)
    (throw (restart-invoke-tag restart) arguments)
    (apply (restart-invoke-function restart) arguments)
    ;; This may return normally, the restart need not transfer control.
    ;; (See CLtL2 p. 880.)
    ))

;; INVOKE-RESTART, CLtL2 p. 911
(defun invoke-restart (restart-identifier &rest arguments)
  (let ((restart (find-restart restart-identifier)))
    (unless restart (restart-not-found restart-identifier))
    (%invoke-restart restart arguments)))

(defun invoke-restart-condition (restart-identifier condition &rest arguments)
  (let ((restart (find-restart restart-identifier condition)))
    (unless restart (restart-not-found restart-identifier))
    (%invoke-restart restart arguments)))

(defun invoke-restart-condition-if-exists (restart-identifier condition &rest arguments)
  (let ((restart (find-restart restart-identifier condition)))
    (when restart
      (%invoke-restart restart arguments))))

;; INVOKE-RESTART-INTERACTIVELY, CLtL2 p. 911
(defun invoke-restart-interactively (restart-identifier)
  (let ((restart (find-restart restart-identifier)))
    (unless restart (restart-not-found restart-identifier))
    (let ((arguments (funcall (restart-interactive restart))))
      (%invoke-restart restart arguments))))

;;; 29.4.7. Establishing Restarts

;; This conses out the wazoo, but there seems to be no good way around it short
;; of special casing things a zillion ways.  The main problem is that someone
;; could write:
;;
;; (restart-bind ((nil *fun-1*
;;                     :interactive-function *fun-2*
;;                     :report-function *fun-3*
;;                     :test-function *fun-4*
;;                 )) ...)
;;
;; and it is supposed to work.

;; RESTART-BIND, CLtL2 p. 909
(defmacro restart-bind (&whole whole-form
                        restart-specs &body body)
  (setq body `(PROGN ,@body))
  (unless (listp restart-specs)
    (error-of-type 'source-program-error
      :form whole-form
      :detail restart-specs
      (TEXT "~S: not a list: ~S")
      'restart-bind restart-specs))
  (if restart-specs
    `(LET ((*ACTIVE-RESTARTS*
            (LIST*
             ,@(mapcar #'(lambda (spec)
                           (unless (and (listp spec) (consp (cdr spec))
                                        (symbolp (first spec)))
                             (error-of-type 'source-program-error
                               :form whole-form
                               :detail spec
                               (TEXT "~S: invalid restart specification ~S")
                               'restart-bind spec))
                           (apply #'(lambda (name function
                                             &key (test-function '(FUNCTION DEFAULT-RESTART-TEST))
                                                  (interactive-function '(FUNCTION DEFAULT-RESTART-INTERACTIVE))
                                                  (report-function 'NIL)
                                                  ((meaningfulp meaningfulp) 'T))
                                      (when (and (null name) (eq report-function 'NIL))
                                        ;; CLtL2 p. 906: "It is an error if an unnamed restart is used
                                        ;; and no report information is provided."
                                        (error-of-type 'source-program-error
                                          :form whole-form
                                          :detail spec
                                          (TEXT "~S: unnamed restarts require ~S to be specified: ~S")
                                          'restart-bind ':REPORT-FUNCTION spec))
                                      (make-restart-form
                                        `',name
                                        test-function
                                        'NIL
                                        function
                                        report-function
                                        interactive-function
                                        meaningfulp))
                                  spec))
                       restart-specs)
             *ACTIVE-RESTARTS*)))
       ,body)
    body))

;; RESTART-CASE, CLtL2 p. 903
;; WITH-RESTARTS
;; Syntax: (RESTART-CASE form {restart-clause}*)
;;         (WITH-RESTARTS ({restart-clause}*) {form}*)
;; restart-clause ::=   (restart-name arglist {keyword value}* {form}*)
;;                    | (restart-name {keyword value}* arglist {form}*)

;; There are a number of special cases we could optimize for. If we
;; can determine that we will not have to cons any closures at
;; runtime, then we could statically allocate the list of restarts.
;;
;; Since we have to deal with the wacky way RESTART-CASE interacts with
;; WITH-CONDITION-RESTARTS, we do not go through RESTART-BIND.

(eval-when (compile load eval)
  (defun expand-restart-case (caller whole-form restart-clauses form)
    (unless (listp restart-clauses)
      (error-of-type 'source-program-error
        :form whole-form
        :detail restart-clauses
        (TEXT "~S: not a list: ~S")
        caller restart-clauses))
    (let ((xclauses ;; list of expanded clauses
           ;; ((tag name test interactive report lambdalist . body) ...)
           (mapcar
            #'(lambda (restart-clause &aux (clause restart-clause))
                (unless (and (consp clause) (consp (cdr clause))
                             (symbolp (first clause)))
                  (error-of-type 'source-program-error
                    :form whole-form
                    :detail clause
                    (TEXT "~S: invalid restart specification ~S")
                    caller clause))
                (let ((name (pop clause))
                      (passed-arglist nil)
                      (passed-keywords nil)
                      arglist
                      (keywords '()))
                  (loop
                    (when (endp clause) (return))
                    (cond ((and (not passed-arglist) (listp (first clause)))
                           (setq arglist (pop clause))
                           (setq passed-arglist t)
                           (when keywords (setq passed-keywords t)))
                          ((and (not passed-keywords) (consp (cdr clause))
                                (symbolp (first clause)))
                           (push (pop clause) keywords)
                           (push (pop clause) keywords))
                          (t (return))))
                  (unless passed-arglist
                    (error-of-type 'source-program-error
                      :form whole-form
                      :detail clause
                      (TEXT "~S: missing lambda list in restart specification ~S")
                      caller clause))
                  (multiple-value-bind (test interactive report meaningfulp)
                      (apply #'(lambda (&key (test 'DEFAULT-RESTART-TEST)
                                             (interactive 'DEFAULT-RESTART-INTERACTIVE)
                                             (report 'DEFAULT-RESTART-REPORT)
                                             ((meaningfulp meaningfulp) 'T))
                                 (values test interactive report meaningfulp))
                             (nreverse keywords))
                    (when (and (null name) (eq report 'DEFAULT-RESTART-REPORT))
                      ;; CLtL2 p. 906: "It is an error if an unnamed restart
                      ;; is used and no report information is provided."
                      (error-of-type 'source-program-error
                        :form whole-form
                        :detail restart-clause
                        (TEXT "~S: unnamed restarts require ~S to be specified: ~S")
                        caller ':REPORT restart-clause))
                    (when (and (consp arglist) (not (member (first arglist) lambda-list-keywords))
                               (eq interactive 'DEFAULT-RESTART-INTERACTIVE))
                      ;; restart takes required arguments but does not have an
                      ;; interactive function that will prompt for them.
                      (warn (TEXT "~S: restart cannot be invoked interactively because it is missing a ~S option: ~S")
                            caller ':INTERACTIVE restart-clause))
                    `(,(gensym) ,name ,test ,interactive ,report ,meaningfulp
                       ,arglist ,@clause))))
            restart-clauses))
          (blockname (gensym "RESTART-"))
          (arglistvar (gensym "ARGS-"))
          (associate
           ;; Yick.  As a pretty lame way of allowing for an association
           ;; between conditions and restarts, RESTART-CASE has to
           ;; notice if its body is signalling a condition, and, if so,
           ;; associate the restarts with the condition.
           (and (consp form)
                (case (first form)
                  ((SIGNAL ERROR CERROR WARN ERROR-OF-TYPE) t)
                  (t nil))
                (gensym "RESTARTS-"))))
      `(BLOCK ,blockname
         (LET (,arglistvar) ; arglistvar is IGNORABLE since it is a gensym
           (TAGBODY
             ,(let ((restart-forms
                     (mapcar #'(lambda (xclause)
                                 (let ((tag (first xclause))
                                       (name (second xclause))
                                       (test (third xclause))
                                       (interactive (fourth xclause))
                                       (report (fifth xclause))
                                       (meaningfulp (sixth xclause)))
                                   (make-restart-form
                                     `',name
                                     `(FUNCTION ,test)
                                     'NIL
                                     `(FUNCTION (LAMBDA (&REST ARGUMENTS)
                                        (SETQ ,arglistvar ARGUMENTS)
                                        (GO ,tag)))
                                     (if (eq report 'DEFAULT-RESTART-REPORT)
                                       `NIL
                                       `(FUNCTION
                                          ,(if (stringp report)
                                             `(LAMBDA (STREAM)
                                                (WRITE-STRING ,report STREAM))
                                             report)))
                                     `(FUNCTION ,interactive)
                                     meaningfulp)))
                             xclauses))
                    (form `(RETURN-FROM ,blockname ,form)))
                 `(LET* ,(if associate
                           `((,associate (LIST ,@restart-forms))
                             (*ACTIVE-RESTARTS*
                              (APPEND ,associate *ACTIVE-RESTARTS*))
                             (*CONDITION-RESTARTS* *CONDITION-RESTARTS*))
                           `((*ACTIVE-RESTARTS*
                              (LIST* ,@restart-forms *ACTIVE-RESTARTS*))))
                    ,(if associate
                       #| ; This code resignals the condition in a different dynamic context!
                       `(LET ((CONDITION
                               (HANDLER-CASE ,form ; evaluate the form
                                (CONDITION (C) C)))) ; catch the condition
                         (WITH-CONDITION-RESTARTS CONDITION ,associate ; associate the condition with the restarts
                           (SIGNAL CONDITION))) ; resignal the condition
                         |#
                       #| ; This code invokes the debugger even if it shouldn't!
                       `(HANDLER-BIND
                         ((CONDITION ; catch the condition
                           #'(LAMBDA (CONDITION)
                              (WITH-CONDITION-RESTARTS CONDITION ,associate  ; associate the condition with the restarts
                               (SIGNAL CONDITION) ; resignal the condition
                               (INVOKE-DEBUGGER CONDITION))))) ; this is weird!
                         ,form)
                       |#
                       `(HANDLER-BIND
                            ((CONDITION ; catch the condition
                              #'(LAMBDA (CONDITION)
                                  (ADD-CONDITION-RESTARTS CONDITION ,associate) ; associate the condition with the restarts
                                  (SIGNAL CONDITION)))) ; resignal the condition
                         ,form)
                       form)))
             ,@(mapcap #'(lambda (xclause)
                           (let ((tag (first xclause))
                                 (lambdabody (cddddr (cddr xclause))))
                             `(,tag
                               (RETURN-FROM ,blockname
                                 (APPLY (FUNCTION (LAMBDA ,@lambdabody))
                                        ,arglistvar)))))
                       xclauses))))))
)

(defmacro restart-case (&whole whole-form
                        form &rest restart-clauses &environment env)
  (expand-restart-case 'restart-case whole-form restart-clauses
                       (macroexpand form env)))

(defmacro with-restarts (&whole whole-form
                         restart-clauses &body body &environment env)
  (expand-restart-case 'with-restarts whole-form restart-clauses
                       (if (cdr body)
                         (cons 'PROGN body)
                         (macroexpand (car body) env))))

;; WITH-SIMPLE-RESTART, CLtL2 p. 902
(defmacro with-simple-restart ((name format-string &rest format-arguments) &body body)
  (if (or format-arguments (not (constantp format-string)))
    `(WITH-RESTARTS
         ((,name
           :REPORT (LAMBDA (STREAM) (FORMAT STREAM ,format-string ,@format-arguments))
           () (VALUES NIL T)))
       ,@body)
    ;; Here's an example of how we can easily optimize things. There is no
    ;; need to refer to anything in the lexical environment, so we can avoid
    ;; consing a restart at run time.
    (let ((blockname (gensym "RESTART-"))
          (tag (gensym "SIMPLE-RESTART-")))
      `(BLOCK ,blockname
         (CATCH ',tag
           (LET ((*ACTIVE-RESTARTS*
                  (CONS
                   (LOAD-TIME-VALUE
                    (MAKE-RESTART :NAME ',name
                                  :INVOKE-TAG ',tag
                                  :REPORT #'(LAMBDA (STREAM)
                                              (FORMAT STREAM ,format-string))))
                   *ACTIVE-RESTARTS*)))
             (RETURN-FROM ,blockname (PROGN ,@body))))
         (VALUES NIL T)))))


;;; 29.4.10. Restart Functions

;; These functions are customary way to pass control from a handler to a
;; restart. They just invoke the restart of the same name.

;; ABORT, CLtL2 p. 913
(defun abort (&optional condition)
  (invoke-restart-condition 'ABORT condition))

;; CONTINUE, CLtL2 p. 913
(defun continue (&optional condition)
  (invoke-restart-condition-if-exists 'CONTINUE condition))

;; MUFFLE-WARNING, CLtL2 p. 913
(defun muffle-warning (&optional condition)
  (invoke-restart-condition 'MUFFLE-WARNING condition))

;; STORE-VALUE, CLtL2 p. 913
(defun store-value (value &optional condition)
  (invoke-restart-condition-if-exists 'STORE-VALUE condition value))

;; USE-VALUE, CLtL2 p. 914
(defun use-value (value &optional condition)
  (invoke-restart-condition-if-exists 'USE-VALUE condition value))

;; like CONTINUE but is not triggered by ^D
(defun retry (&optional condition)
  (invoke-restart-condition-if-exists 'RETRY condition))

;;; 29.4.2. Assertions

;; These macros supersede the corresponding ones from macros2.lisp.

;; Queries the user for the values to put into the given place.
;; Returns a fresh list of length place-numvalues.
(defun prompt-for-new-value (place place-numvalues &optional instead-p) ; ABI
  (cond ((= place-numvalues 1)
         (format *debug-io*
                 (if instead-p
                   (concatenate 'string "~&" (TEXT "Use instead~@[ of ~S~]")
                                (prompt-finish))
                   (prompt-for-new-value-string))
                 place)
         (list (eval (read *debug-io*))))
        (t (do ((ii 1 (1+ ii)) res)
               ((> ii place-numvalues) (nreverse res))
             (fresh-line *debug-io*)
             (format *debug-io*
                     (if instead-p
                       (TEXT "Use instead of ~S [value ~D of ~D]~A")
                       (TEXT "New ~S [value ~D of ~D]~A"))
                     place ii place-numvalues (prompt-finish))
             (push (eval (read *debug-io*)) res)))))

;; CHECK-TYPE, CLtL2 p. 889
(defmacro check-type (place typespec &optional (string nil) &environment env)
  (let ((tag1 (gensym "CHECK-TYPE-"))
        (tag2 (gensym "OK-"))
        (var (gensym)))
    `(TAGBODY
       ,tag1
       (LET ((,var ,place))
         (WHEN (TYPEP ,var ',typespec) (GO ,tag2))
         (CHECK-TYPE-FAILED ',place ,var
                            #'(LAMBDA (NEW-VALUE) (SETF ,place NEW-VALUE))
                            ,(length (nth-value 2 (get-setf-expansion place env)))
                            ,string ',typespec))
       (GO ,tag1)
       ,tag2)))
(defun check-type-failed (place place-oldvalue place-setter place-numvalues string typespec) ; ABI
  (restart-case
    (error-of-type 'type-error
      :datum place-oldvalue :expected-type typespec
      (type-error-string)
      (check-type-error-string place string typespec)
      place-oldvalue)
    ;; Only one restart. Call it STORE-VALUE, not CONTINUE, so that it's not
    ;; chosen by "continue".
    (STORE-VALUE (new-value)
      :report (lambda (stream)
                (format stream (report-one-new-value-string) place))
      :interactive (lambda () (prompt-for-new-value place place-numvalues))
      (funcall place-setter new-value))))

;; ASSERT, CLtL2 p. 891
(defmacro assert (test-form &optional (place-list nil) (datum nil) &rest args
                  &environment env)
  (let ((tag1 (gensym "ASSERT-"))
        (tag2 (gensym "OK-")))
    `(TAGBODY
       ,tag1
       (WHEN ,test-form (GO ,tag2))
       (,@(if place-list
            (let ((all-numvalues '())
                  (all-setter-vars '())
                  (all-setter-forms '()))
              (do ((pl place-list (cdr pl)))
                  ((endp pl))
                (multiple-value-bind (temps subforms stores setterform getterform)
                    (get-setf-expansion (car pl) env)
                  (declare (ignore getterform))
                  (push (length stores) all-numvalues)
                  (setq all-setter-vars
                        (revappend stores all-setter-vars))
                  (push (wrap-let* (mapcar #'list temps subforms) setterform)
                        all-setter-forms)))
              (setq all-numvalues (nreverse all-numvalues))
              (setq all-setter-vars (nreverse all-setter-vars))
              (setq all-setter-forms (nreverse all-setter-forms))
              `(ASSERT-FAILED ',place-list ',all-numvalues
                              #'(LAMBDA ,all-setter-vars ,@all-setter-forms)))
            `(SIMPLE-ASSERT-FAILED))
        ,@(if datum
            `(NIL ,datum ,@args) ; use coerce-to-condition??
            `((ASSERT-ERROR-STRING ',test-form))))
       (GO ,tag1)
       ,tag2)))
(defun assert-failed (place-list place-numvalues-list places-setter error-string &rest condition-datum+args) ; ABI
  (restart-case
    ;; No need for explicit association, see APPLICABLE-RESTART-P.
    (if error-string
      (error ; of-type ??
        "~A" error-string)
      (apply #'error condition-datum+args)) ; use coerce-to-condition??
    ;; Only one restart: CONTINUE.
    (CONTINUE (&rest new-values)
      :REPORT (lambda (stream)
                (apply #'format stream
                       (if (= (length place-list) 1)
                         (report-one-new-value-string)
                         (report-new-values-string))
                       place-list))
      :INTERACTIVE (lambda ()
                     (mapcan #'(lambda (place place-numvalues)
                                 (prompt-for-new-value place place-numvalues))
                             place-list place-numvalues-list))
      (apply places-setter new-values))))
(defun simple-assert-failed (error-string &rest condition-datum+args) ; ABI
  (restart-case
    ;; No need for explicit association, see APPLICABLE-RESTART-P.
    (if error-string
      (error ; of-type ??
        "~A" error-string)
      (apply #'error condition-datum+args)) ; use coerce-to-condition??
    ;; Only one restart: CONTINUE.
    ;; But mark it as not meaningful, because it leads to user frustration.
    (CONTINUE ()
      :REPORT (lambda (stream) (format stream (report-no-new-value-string)))
      MEANINGFULP nil)))

(defun correctable-error (options condition)
  (let ((restarts
         (mapcar (lambda (option)
                   (destructuring-bind (name report . return) option
                     (make-restart
                      :name (etypecase name
                              (string (intern name *keyword-package*))
                              (symbol name))
                      :report (lambda (s) (princ report s))
                      :interactive (if (consp return)
                                     (lambda ()
                                       (apply (car return) (cdr return)))
                                     #'default-restart-interactive)
                      :invoke-function
                        (if (consp return)
                          (lambda (value) ; get `value' from :INTERACTIVE
                            (return-from correctable-error value))
                          (lambda ()
                            (return-from correctable-error return))))))
                 options)))
    (with-condition-restarts condition restarts
      (let ((*active-restarts* (nconc restarts *active-restarts*)))
        (error condition)))))

;; Report an error and try to recover by asking the user to supply a value.
;; Returns
;; 1. value supplied by the user,
;; 2. a boolean indicating whether PLACE should be filled, or 0 for FDEFINITION
(defun check-value (place condition)
  (let ((restarts
         (nconc
          (when (eq place 'SYSTEM::PATHNAME-ENCODING)
            (setq place '*pathname-encoding*) ; make it look nicer
            (list (make-restart ; for direntry_to_string
                   :name 'CONTINUE
                   :report (lambda (stream)
                             (format stream
                                     (TEXT "Discard this directory entry")))
                   :invoke-function
                     (lambda () (return-from check-value (values nil 0))))))
          (unless (eq place '*pathname-encoding*)
            (list (make-restart
                   :name 'USE-VALUE
                   :report
                     (lambda (stream)
                       (format stream (report-one-new-value-string-instead)
                               place))
                   :interactive (lambda () (prompt-for-new-value place 1 t))
                   :invoke-function
                     (lambda (val)
                       (return-from check-value (values val nil))))))
          (when (and (consp place) (eq 'fdefinition (car place)))
            (list (make-restart ; for check_fdefinition() only!
                   :name 'RETRY
                   :report (lambda (stream)
                             (format stream (report-no-new-value-string)))
                   :invoke-function
                     (lambda ()
                       (return-from check-value (values nil 0))))))
          (when place
            (list (make-restart
                   :name 'STORE-VALUE
                   :report
                     (lambda (stream)
                       (format stream (report-one-new-value-string) place))
                   :interactive (lambda () (prompt-for-new-value place 1))
                   :invoke-function
                     (lambda (val)
                       (return-from check-value (values val t)))))))))
    (with-condition-restarts condition restarts
      (let ((*active-restarts* (nconc restarts *active-restarts*)))
        (error condition)))))

(defun retry-function-call (condition function arguments)
  (with-restarts ((retry
                   :report (lambda (out)
                             (format out (TEXT "try calling ~S again")
                                     (function-name function)))
                   () (return-from retry-function-call
                        (apply function arguments)))
                  (return
                   :report (lambda (out)
                             (format out (TEXT "specify return values")))
                   :interactive (lambda () (prompt-for-new-value 'VALUES 1))
                   (l) (return-from retry-function-call (values-list l))))
    (with-condition-restarts condition
        (list (find-restart 'RETRY) (find-restart 'RETURN))
      (error condition))))

;; redefine the function in init.lisp, used by LOAD
(eval-when (compile) (fmakunbound 'eval-loaded-form)) ; avoid a warning
;; FILE is the *LOAD-TRUENAME* of the file being loaded
;; we cannot use *LOAD-TRUENAME* because when the error is in a nested LOAD,
;; we will get the truename of the inner-most file instead of the current one
(defun eval-loaded-form (obj file)
  (flet ((report (word obj out)
           (write-string word out)
           (if (compiled-function-p obj)
               (write (closure-name obj) :stream out
                      :pretty nil :escape nil)
               (write obj :stream out :pretty nil :escape nil
                      :level 2 :length 3))))
    (restart-case (eval-loaded-form-low obj)
      (skip ()
        :report (lambda (out) (report (TEXT "skip ") obj out))
        :interactive default-restart-interactive
        (return-from eval-loaded-form 'skip))
      (retry ()
        :report (lambda (out) (report (TEXT "retry ") obj out))
        :interactive default-restart-interactive
        (return-from eval-loaded-form 'retry))
      (stop ()
        :report (lambda (out) (format out (TEXT "stop loading file ~A") file))
        :interactive default-restart-interactive
        (return-from eval-loaded-form 'stop)))))

;;; 29.4.3. Exhaustive Case Analysis

;; These macros supersede the corresponding ones from macros2.lisp.
(flet ((parenthesize-keys (clauses)
         ;; PARENTHESIZE-KEYS is necessary to avoid confusing
         ;; the symbols OTHERWISE and T used as keys, with the same
         ;; symbols used in the syntax of the non exhaustive CASE.
         (mapcar #'(lambda (c)
                     (cond ((or (eq (car c) 't)
                                (eq (car c) 'otherwise))
                            (warn (TEXT "~S used as a key in ~S, it would be better to use parentheses.")
                                  (car c) c)
                            (cons (list (car c)) (cdr c)))
                           (t c)))
                 clauses)))
  (flet ((typecase-errorstring (keyform keyclauselist)
           (let ((typelist (mapcar #'first keyclauselist)))
             `(TYPECASE-ERROR-STRING ',keyform ',typelist)))
         (typecase-expected-type (keyclauselist)
           `(OR ,@(mapcar #'first keyclauselist)))
         (case-errorstring (keyform keyclauselist)
           (let ((caselist
                   (mapcap #'(lambda (keyclause)
                               (setq keyclause (car keyclause))
                               (if (listp keyclause) keyclause (list keyclause)))
                           keyclauselist)))
             `(CASE-ERROR-STRING ',keyform ',caselist)))
         (case-expected-type (keyclauselist)
           `(MEMBER ,@(mapcap #'(lambda (keyclause)
                                  (setq keyclause (car keyclause))
                                  (if (listp keyclause)
                                      keyclause (list keyclause)))
                              keyclauselist)))
         (simply-error (casename form clauselist errorstring expected-type)
           (let ((var (gensym (string-concat (symbol-name casename) "-KEY-"))))
             `(LET ((,var ,form))
                (,casename ,var ,@(parenthesize-keys clauselist)
                  ;; if a clause contains an OTHERWISE or T key,
                  ;; it is treated as a normal key, as per CLHS.
                  (OTHERWISE
                    (ETYPECASE-FAILED ,var ,errorstring ',expected-type))))))
         (retry-loop (casename place clauselist errorstring expected-type env)
           (let ((g (gensym (symbol-name casename)))
                 (h (gensym "RETRY-")))
             `(BLOCK ,g
                (TAGBODY
                  ,h
                  (RETURN-FROM ,g
                    (,casename ,place ,@(parenthesize-keys clauselist)
                      ;; if a clause contains an OTHERWISE or T key,
                      ;; it is treated as a normal key, as per CLHS.
                      (OTHERWISE
                        (CTYPECASE-FAILED ',place ,place
                                          #'(LAMBDA (NEW-VALUE) (SETF ,place NEW-VALUE))
                                          ,(length (nth-value 2 (get-setf-expansion place env)))
                                          ,errorstring ',expected-type)
                        (GO ,h)))))))))
    (defmacro etypecase (keyform &rest keyclauselist)
      (if (assoc t keyclauselist)
        `(TYPECASE ,keyform ,@keyclauselist)
        (simply-error 'TYPECASE keyform keyclauselist
                      (typecase-errorstring keyform keyclauselist)
                      (typecase-expected-type keyclauselist))))
    (defmacro ctypecase (keyplace &rest keyclauselist &environment env)
      (if (assoc t keyclauselist)
        `(TYPECASE ,keyplace ,@keyclauselist)
        (retry-loop 'TYPECASE keyplace keyclauselist
                    (typecase-errorstring keyplace keyclauselist)
                    (typecase-expected-type keyclauselist)
                    env)))
    (defmacro ecase (keyform &rest keyclauselist)
      (simply-error 'CASE keyform keyclauselist
                    (case-errorstring keyform keyclauselist)
                    (case-expected-type keyclauselist)))
    (defmacro ccase (keyform &rest keyclauselist &environment env)
      (retry-loop 'CASE keyform keyclauselist
                  (case-errorstring keyform keyclauselist)
                  (case-expected-type keyclauselist)
                  env))
    ;; for use in macros: when a file with generated ffi forms is compiled
    ;; (prime example: gtk.lisp), any error message can become cryptic because
    ;; the sources are efemeral - unless the whole form is printed in the error
    (defmacro mecase (whole-form keyform &rest keyclauselist)
      (simply-error 'CASE keyform keyclauselist
                    `(format nil (TEXT "In form ~S~%~A") ,whole-form
                             ,(case-errorstring keyform keyclauselist))
                    (case-expected-type keyclauselist)))
) )
(defun etypecase-failed (value errorstring expected-type) ; ABI
  (error-of-type 'type-error
    :datum value :expected-type expected-type
    (type-error-string)
    errorstring value))
(defun ctypecase-failed (place place-oldvalue place-setter place-numvalues errorstring expected-type) ; ABI
  (restart-case
    (progn ; no need for explicit association, see applicable-restart-p
      (error-of-type 'type-error
        :datum place-oldvalue :expected-type expected-type
        (type-error-string)
        errorstring
        place-oldvalue))
    ;; Only one restart. Call it STORE-VALUE, not CONTINUE, so that it's not
    ;; chosen by "continue".
    (STORE-VALUE (new-value)
      :report (lambda (stream)
                (format stream (report-one-new-value-string) place))
      :interactive (lambda () (prompt-for-new-value place place-numvalues))
      (funcall place-setter new-value))))

;;; 29.4.11. Debugging Utilities

(defvar *debugger-hook* nil)

;; INVOKE-DEBUGGER, CLtL2 p. 915
; is in error.d

;; BREAK, CLtL2 p. 914
; (BREAK [format-string {arg}*])
; we call INVOKE-DEBUGGER and therefore need a condition.
(defun break (&optional (format-string "Break") &rest args)
  (if (not *use-clcs*)
    (progn
      (fresh-line *error-output*)
      (apply #'format *error-output*
                      (concatenate 'string "*** - " format-string)
                      args)
      (elastic-newline *error-output*)
      (funcall *break-driver* t))
    (let ((condition
           (make-condition 'simple-condition
                           :format-control format-string
                           :format-arguments args))
          (*debugger-hook* nil)) ; Issue 91
      (with-restarts
          ((CONTINUE
            :report (lambda (stream)
                      (format stream (TEXT "Return from ~S loop")
                                     'break))
            ()))
        (with-condition-restarts condition (list (find-restart 'CONTINUE))
          (invoke-debugger condition)))))
  nil)

;;; 29.4.1. Signaling Conditions

;; ERROR, CLtL2 p. 886
#| ; is in error.d
 (defun error (errorstring &rest args)
  (if (or *error-handler* (not *use-clcs*))
    (progn
      (if *error-handler*
        (apply *error-handler* nil errorstring args)
        (progn
          (fresh-line *error-output*)
          (write-string "*** - " *error-output*)
          (apply #'format *error-output* errorstring args)
          (elastic-newline *error-output*)))
      (funcall *break-driver* nil))
    (let ((condition (coerce-to-condition errorstring args 'error 'simple-error)))
      (signal condition)
      (invoke-debugger condition))))
|#

;; CERROR, CLtL2 p. 887
(defun cerror (continue-format-string error-format-string &rest args)
  (if *error-handler*
    (apply *error-handler*
           (or continue-format-string t) error-format-string args)
    (if (not *use-clcs*)
      (progn
        (fresh-line *error-output*)
        (write-string "** - " *error-output*)
        (write-string (TEXT "Continuable Error") *error-output*)
        (terpri *error-output*)
        (apply #'format *error-output* error-format-string args)
        (elastic-newline *error-output*)
        (fresh-line *debug-io*)
        (if (interactive-stream-p *debug-io*)
          (progn
            (write-string (TEXT "If you continue (by typing 'continue'): ")
                          *debug-io*)
            (apply #'format *debug-io* continue-format-string args)
            (elastic-newline *debug-io*)
            (funcall *break-driver* t))
          (progn
            (apply #'format *debug-io* continue-format-string args)
            (elastic-newline *debug-io*))))
      (let ((condition (coerce-to-condition error-format-string args
                                            'cerror 'simple-error)))
        (with-restarts
            ((CONTINUE
              :report (lambda (stream)
                        (apply #'format stream continue-format-string args))
              ()))
          (with-condition-restarts condition (list (find-restart 'CONTINUE))
            (signal condition)
            (invoke-debugger condition))))))
  nil)

;;; 29.4.9. Warnings

(defvar *break-on-warnings* nil)

(defun warn-of-type (type format-string &rest args)
  (if (not *use-clcs*)
    (progn
      (fresh-line *error-output*)
      (write-string (TEXT "WARNING:") *error-output*)
      (terpri *error-output*)
      (apply #'format *error-output* format-string args)
      (elastic-newline *error-output*)
      (when *break-on-warnings* (funcall *break-driver* t)))
    (block warn
      (let ((condition (coerce-to-condition format-string args 'warn type)))
        (unless (typep condition 'warning)
          (error-of-type 'type-error
            :datum condition :expected-type 'warning
            (TEXT "~S: This is more serious than a warning: ~A")
            'warn condition))
        (when (boundp '*warning-count*) (incf *warning-count*))
        (when (and (boundp '*style-warning-count*)
                   (typep condition 'style-warning))
          (incf *style-warning-count*))
        (with-restarts ((MUFFLE-WARNING () (return-from warn)))
          (with-condition-restarts condition (list (find-restart 'MUFFLE-WARNING))
            (signal condition)))
        (fresh-line *error-output*)
        (let ((first-line-prefix (TEXT "WARNING: ")))
          (write-string first-line-prefix *error-output*)
          (pretty-print-condition
           condition *error-output*
           :text-indent (string-width first-line-prefix)))
        (elastic-newline *error-output*)
        (when *break-on-warnings*
          (with-restarts
              ((CONTINUE :report
                 (lambda (stream)
                   (format stream (TEXT "Return from ~S loop") 'break))
                 () (return-from warn)))
            (with-condition-restarts condition (list (find-restart 'CONTINUE))
              ;; We don't call  (invoke-debugger condition)  because that
              ;; would tell the user about a "Continuable error".
              ;; Actually, it is only a warning!
              (funcall *break-driver* nil condition nil)))))))
  nil)

;; for X3J13 Issue COMPILER-DIAGNOSTICS:USE-HANDLER
(defun c-warning (type format-string &rest args)
  (let ((*error-output* *c-error-output*))
    (apply #'warn-of-type type (string-concat "~A" format-string)
           (c-current-location) args)))

(defun c-cerror (location detail format-string &rest args)
  (let ((*error-output* *c-error-output*))
    (apply #'cerror-of-type (TEXT "Ignore the error and proceed")
           'simple-source-program-error
           :form *form* :detail detail
           (string-concat location format-string)
           args)))

;; WARN, CLtL2 p. 912
;; (WARN format-string {arg}*)
(defun warn (format-string &rest args)
  (apply #'warn-of-type 'simple-warning format-string args))

#|
Todo:
29.3.6 29.3.7 29.3.8 29.3.9 29.3.10
      29.3.11 29.3.12 29.3.13 29.3.14 29.3.15 29.3.16 29.3.17 29.3.18
29.4. 29.4.9 29.4.11
29.5.
|#


;; Miscellaneous functions that use condition macros.

#+LOGICAL-PATHNAMES
(defun valid-logical-pathname-string-p (string)
  (handler-case (logical-pathname string)
    (TYPE-ERROR () nil)
    (:NO-ERROR (&rest values) (declare (ignore values)) t)))


;; Extensions. They assume *USE-CLCS* is T.

; Which restarts are suitable for automatic invocation?
; - Only CONTINUE restarts.
;   E.g. (check-type x float) has no CONTINUE restart.
; - Only meaningful CONTINUE restarts.
;   E.g. (assert (= 3 4)) has a CONTINUE restart, but it is not meaningful.
; - Only non-interactive CONTINUE restarts.
;   E.g. (assert (>= i 0) (i)) has a CONTINUE restart, but it prompts the user
;   for a new value of i.
(defun find-noninteractively-invokable-continue-restart (condition)
  (let ((restart (find-restart 'CONTINUE condition)))
    (and restart
         (restart-meaningfulp restart)
         (eq (restart-interactive restart) #'default-restart-interactive)
         restart)))

(defun muffle-cerror (condition) ; ABI
  (let ((restart (find-noninteractively-invokable-continue-restart condition)))
    (when restart
      (invoke-restart restart))))
(defmacro muffle-cerrors (&body body)
  "(MUFFLE-CERRORS {form}*) executes the forms, but when a continuable
error occurs, the CONTINUE restart is silently invoked."
  `(HANDLER-BIND ((ERROR #'MUFFLE-CERROR))
     ,@body))
#|| ; This works as well, but looks more like a hack.
 (defmacro muffle-cerrors (&body body)
  (let ((old-debugger-hook (gensym)))
    `(LET* ((,old-debugger-hook *DEBUGGER-HOOK*)
            (*DEBUGGER-HOOK*
             (LAMBDA (CONDITION DEBUGGER-HOOK)
               (CONTINUE CONDITION)
               (WHEN ,old-debugger-hook
                 (FUNCALL ,old-debugger-hook CONDITION ,old-debugger-hook)))))
      (PROGN ,@body))))
||#

(defun appease-cerror (condition) ; ABI
  (let ((restart (find-noninteractively-invokable-continue-restart condition)))
    (when restart
      (warn #'(lambda (stream &rest arguments)
                (print-condition condition stream)
                (let ((report-function (restart-report restart)))
                  (when report-function
                    (terpri stream)
                    (funcall report-function stream)))
                arguments))
      (invoke-restart restart))))
(defmacro appease-cerrors (&body body)
  "(APPEASE-CERRORS {form}*) executes the forms, but turns continuable errors
into warnings. A continuable error is signalled again as a warning, then
its CONTINUE restart is invoked."
  `(HANDLER-BIND ((ERROR #'APPEASE-CERROR))
     ,@body))

(defvar *report-error-print-backtrace* nil)
(defun report-error (condition)
  (when *report-error-print-backtrace*
    (print-backtrace :out *error-output*))
  (fresh-line *error-output*)
  (write-string "*** - " *error-output*)
  (pretty-print-condition condition *error-output*)
  (elastic-newline *error-output*))

(defun exitunconditionally (condition) ; ABI
  (report-error condition)
  (exit t))                     ; exit Lisp with error
(defun exitonerror (condition) ; ABI
  (unless (find-noninteractively-invokable-continue-restart condition)
    (exitunconditionally condition)))
(defmacro exit-on-error (&body body)
  "(EXIT-ON-ERROR {form}*) executes the forms, but exits Lisp if a
non-continuable error or a Ctrl-C interrupt occurs."
  `(HANDLER-BIND ((INTERRUPT-CONDITION #'EXITUNCONDITIONALLY)
                  (SERIOUS-CONDITION #'EXITONERROR))
    ,@body))

(defun abortonerror (condition) ; ABI
  (report-error condition)
  (invoke-restart (find-restart 'abort condition)))

(defmacro abort-on-error (&body body)
  "(ABORT-ON-ERROR {form}*) executes the forms and aborts all errors."
  `(HANDLER-BIND ((SERIOUS-CONDITION #'ABORTONERROR))
     ,@body))

(defgeneric global-handler (condition)
  (:method-combination progn)
  (:documentation "the global error handler, methods should not return")
  (:method progn ((condition t)) nil))

(defun set-global-handler (condition-name handler)
  "Make HANDLER handle CONDITION globally.
HANDLER should be funcallable (symbol or function).
If it returns, the next applicable error handler is invoked.
When HANDLER is nil, remove the global handler for CONDITION.
Returns the added or removed method(s)."
  (let ((clos::*enable-clos-warnings* nil))
    (cond (handler              ; install handler
           (clos::do-defmethod 'global-handler
             (lambda (backpointer)
               (declare (ignore backpointer)) ; we do not need CALL-NEXT-METHOD
               (list
                (lambda (condition)
                  ;; avoid infinite recursion by disabling the handler
                  (let ((clos::*enable-clos-warnings* nil)
                        (old-handler (set-global-handler condition-name nil)))
                    (unwind-protect (funcall handler condition)
                      (when old-handler
                        (clos:add-method #'global-handler old-handler)))))
                t))             ; wants-next-method-p == NIL
             (list :qualifiers #1='(progn) :lambda-list '(condition)
                   'clos::signature #(1 0 NIL NIL NIL NIL)
                   :specializers (list (find-class condition-name)))))
          ((consp condition-name) ; install all these handlers
           (dolist (handler condition-name)
             (clos:add-method #'global-handler handler)))
          ((null condition-name) ; remove all global handlers
           (let ((handlers '()))
             (dolist (method (clos::generic-function-methods #'global-handler))
               (unless (equal '#,(list (find-class 't))
                              (clos::method-specializers method))
                 (push method handlers)
                 (clos:remove-method #'global-handler method)))
             handlers))
          ((symbolp condition-name) ; remove handler for this condition
           (let ((method (find-method #'global-handler #1#
                                      (list (find-class condition-name)) nil)))
             (when method
               (clos:remove-method #'global-handler method)
               method)))
          (t (error "~S(~S ~S): invalid arguments"
                    'set-global-handler condition-name handler)))))

(defmacro without-global-handlers (&body body)
  "Remove all global handlers, execute BODY, restore the handlers."
  (let ((handlers (gensym "HANDLERS-")))
    `(let ((,handlers (set-global-handler nil nil)))
       (unwind-protect (progn ,@body)
         (set-global-handler ,handlers nil)))))

;;; <http://www.lisp.org/HyperSpec/Body/dec_type.html>:
;;;   A symbol cannot be both the name of a type and the name of a
;;;   declaration. Defining a symbol as the name of a class, structure,
;;;   condition, or type, when the symbol has been declared as a
;;;   declaration name, or vice versa, signals an error.
(defun check-not-type (symbol caller)
  (loop
    (setq symbol (check-symbol symbol caller))
    (check-package-lock caller (symbol-package symbol) symbol)
    (when (handler-bind ((error #'(lambda (c)
                                    (declare (ignore c))
                                    (return-from check-not-type symbol))))
            (type-expand symbol))
      (with-restarts ((use-value (new-value)
                        :report
                         (lambda (stream)
                           (format stream (report-one-new-value-string-instead)
                                   symbol))
                         :interactive
                          (lambda () (prompt-for-new-value symbol 1 t))
                         (setq symbol new-value)))
        (error (TEXT "~S: ~S defines a type, cannot be declared a ~S")
               caller symbol 'declaration)))))

(defun check-not-declaration (symbol caller)
  (loop
    (setq symbol (check-symbol symbol caller))
    (check-package-lock caller (symbol-package symbol) symbol)
    (unless (memq symbol (cdr (top-level-declarations)))
      (return-from check-not-declaration symbol))
    (with-restarts ((use-value (new-value)
                      :report
                       (lambda (stream)
                         (format stream (report-one-new-value-string-instead)
                                 symbol))
                       :interactive
                        (lambda () (prompt-for-new-value symbol 1 t))
                       (setq symbol new-value)))
      (error (TEXT "~S: ~S names a ~S, cannot name a type")
             caller symbol 'declaration))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./condition.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./functions.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Utilities for function objects
;;; Sam Steingold 2001-2005, 2008
;;; Bruno Haible 2004

(in-package "COMMON-LISP")
(export '(function-lambda-expression))
(in-package "SYSTEM")

;; The signature of a function object.
(defstruct (signature (:type vector) (:conc-name sig-))
  ;; (name nil     :type (or symbol cons))
  (req-num 0    :type fixnum)
  (opt-num 0    :type fixnum)
  (rest-p nil   :type boolean)
  (keys-p nil   :type boolean)
  (keywords nil :type list)
  (allow-p nil  :type boolean))

;; X3J13 vote <88>
;; function --> lambda expression, CLtL2 p. 682
(defun function-lambda-expression (obj)
  (setq obj (coerce obj 'function))
  (cond #+FFI
        ((eq (type-of obj) 'FFI::FOREIGN-FUNCTION)
         (values nil nil (sys::%record-ref obj 0))) ; ff_name
        ((sys::subr-info obj)
         (values nil nil (sys::subr-info obj)))
        ((sys::%compiled-function-p obj) ; compiled closure?
         (let* ((name (sys::closure-name obj))
                (def (get (if (symbolp name)
                              name (get (second name) 'sys::setf-function))
                          'sys::definition)))
           (values (when def (cons 'LAMBDA (cddar def))) t name)))
        ((sys::closurep obj) ; interpreted closure?
         (values (cons 'LAMBDA (sys::%record-ref obj 1)) ; lambda-expression without docstring (from clos_form)
                 (vector ; environment
                         (sys::%record-ref obj 4) ; venv
                         (sys::%record-ref obj 5) ; fenv
                         (sys::%record-ref obj 6) ; benv
                         (sys::%record-ref obj 7) ; genv
                         (sys::%record-ref obj 8)); denv
                 (sys::closure-name obj))))) ; name

(defun function-name (obj)
  ;; Equivalent to (nth-value 2 (function-lambda-expression obj))
  (setq obj (coerce obj 'function))
  (cond #+FFI
        ((eq (type-of obj) 'FFI::FOREIGN-FUNCTION)
         (sys::%record-ref obj 0)) ; ff_name
        ((sys::subr-info obj))
        ((sys::%compiled-function-p obj) ; compiled closure?
         (sys::closure-name obj))
        ((sys::closurep obj) ; interpreted closure?
         (sys::closure-name obj))))

;; Returns the function definition of a function name, ignoring wrappers
;; installed by TRACE, profilers etc.
(defun unwrapped-fdefinition (funname)
  (let* ((sym (get-funname-symbol funname))
         (def (or (get sym 'sys::traced-definition)
                  (symbol-function sym))))
    (if (macrop def)
      (macro-expander def)
      def)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./functions.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./complete.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Command-line completion hook

(in-package "SYSTEM")


(defun ext:longest-common-prefix (vectors &key (test #'eql))
  "Return the longest common prefix of all vectors in the list."
  (do ((imax (reduce #'min vectors :key #'length))
       (i 0 (1+ i)))
      ((or (= i imax)
           (let ((e (aref (first vectors) i)))
             (dolist (v (rest vectors) nil)
               (unless (funcall test (aref v i) e)
                 (return t)))))
       (subseq (first vectors) 0 i))))

;;-----------------------------------------------------------------------------
;; Completing routine for the GNU Readline library.
;; Input: string (the input line), and the boundaries of the text to be
;; completed:  (subseq string start end)
;; Output: a list of simple-strings. empty, when no meaningful completions.
;; otherwise, CDR = list of all meaningful completions,
;; CAR = the immediate replacement
(let ((state nil))
(defun completion (string start end)
  (let* ((quotedp (and (>= start 1) ; quoted completion?
                       (member (char string (- start 1)) '(#\" #\|))))
         (start1 (if quotedp (1- start) start))
         (functionalp1 (and (>= start1 1)
                            (equal (subseq string (- start1 1) start1) "(")))
         (functionalp2 (and (>= start1 2)
                            (equal (subseq string (- start1 2) start1) "#'")))
         ;; completion of a function or of any symbol?
         (functionalp (or (= start end) functionalp1 functionalp2))
         (search-package-names nil) ; complete among package names
         ;; test for special case: nothing was entered to be completed,
         ;; so we try to DESCRIBE the last function symbol entered
         (void-completion
           (and (= start end)
                (or (>= start (length string))
                    (whitespacep (schar string start))))))
    ;; If nothing useful was entered (just whitespace), print help.
    (when void-completion
      (do ((pos (min end (1- (length string))) (1- pos))
           (depth 0)
           (white end))
          ((or (minusp pos) (plusp depth))
           (setq start (+ pos 2) end white))
        (cond ((char= #\( (schar string pos)) (incf depth))
              ((char= #\) (schar string pos)) (decf depth))
              ((whitespacep (schar string pos)) (setq white pos))))
      (when (< end start)       ; nothing useful was entered - just whitespace
        (sys::help) (terpri)    ; print help
        (return-from completion 0))) ; redraw the prompt
    ;; FIXME: If quotedp is true due to #\", we should better collect matching
    ;;        filenames, not symbols, I think.
    ;; Collect matching symbols.
    (let ((new-state (list* string start end))
          (package *package*)
          (mapfun #'sys::map-symbols)
          (prefix nil))
      ;; Extract the package name:
      (unless quotedp
        (let ((colon (position #\: string :start start :end end)))
          (if colon
            (let ((packname (subseq string start colon))) ; fresh!
              (case (readtable-case *readtable*)
                (:upcase (nstring-upcase packname))
                (:downcase (nstring-downcase packname))
                (:invert (nstring-invertcase packname)))
              (when (equal packname "") (setq packname "KEYWORD"))
              (setq package (find-package packname))
              (unless package
                (return-from completion nil))
              (incf colon)
              (if (and (< colon end) (eql (char string colon) #\:))
                (incf colon)
                (setq mapfun #'sys::map-external-symbols))
              (setq prefix (subseq string start colon))
              (setq start colon))
            (setq search-package-names t))))
      (let* ((case-sensitive-p
               (or quotedp
                   (package-case-sensitive-p package)
                   (case (readtable-case *readtable*)
                     ((:UPCASE :DOWNCASE) nil)
                     ((:PRESERVE :INVERT) t))))
             ;; FIXME: Handling of (readtable-case *readtable*) = :INVERT is
             ;;        incomplete.
             (case-inverted-p (package-case-inverted-p package))
             (known-part (subseq string start end))
             (known-len (length known-part))
             (char-cmp (if case-sensitive-p #'char= #'char-equal))
             (string-cmp (if case-sensitive-p #'string= #'string-equal))
             (return-list '())
             (match-and-collect
              (lambda (name)
                (when (>= (length name) known-len)
                  (when case-inverted-p
                    (setq name (string-invertcase name)))
                  (when (funcall string-cmp name known-part :end1 known-len)
                    (push name return-list)))))
             (gatherer
               (if functionalp
                 (lambda (sym)
                   (when (fboundp sym)
                     (funcall match-and-collect (symbol-name sym))))
                 (lambda (sym) (funcall match-and-collect (symbol-name sym))))))
        (funcall mapfun gatherer package)
        (when (and search-package-names (null return-list))
          (dolist (pack (list-all-packages))
            (funcall match-and-collect (package-name pack))
            (dolist (nick (package-nicknames pack))
              (funcall match-and-collect nick)))
          (when return-list
            (setq return-list
                  (mapcan (lambda (pack)
                            (ext:with-collect (c)
                              (do-external-symbols (s pack)
                                (let ((ret (ext:string-concat
                                            (package-name pack) ":"
                                            (symbol-name s))))
                                  (when case-inverted-p
                                    (setq ret (nstring-invertcase ret)))
                                  (c ret)))))
                          (delete-duplicates
                           (map-into return-list #'find-package
                                     return-list))))))
        ;; Now react depending on the list of matching symbols.
        (when (null return-list)
          (return-from completion nil))
        (when (and void-completion
                   (< end (length string)) (whitespacep (schar string end)))
          (let ((first-matching-name
                  (find known-part return-list :test string-cmp)))
            (when case-inverted-p
              (setq first-matching-name (string-invertcase first-matching-name)))
            (let ((first-matching-sym (find-symbol first-matching-name package)))
              (return-from completion
                (when (and first-matching-sym (fboundp first-matching-sym))
                      ;; FIXME: why not test (null (cdr return-list)) ?
                  (cond ((equalp state new-state)
                         (describe first-matching-sym) (terpri) (terpri))
                        (t (setq state new-state)))
                  0)))))               ; redraw the prompt
        ;; For a function without arguments, append a closing paren.
        (when (and functionalp1
                   (not quotedp)    ; readline will close the quote after #\) !
                   (null (cdr return-list))
                   (let ((name (car return-list)))
                     (when case-inverted-p
                       (setq name (string-invertcase name)))
                     (let ((sym (find-symbol name package)))
                       (and sym (fboundp sym) (functionp (symbol-function sym))
                            (multiple-value-bind (name req-num opt-num rest-p key-p)
                                (function-signature (symbol-function sym))
                              (declare (ignore name))
                              (and (eql req-num 0) (eql opt-num 0)
                                   (not rest-p) (not key-p)))))))
          (setf (car return-list) (string-concat (car return-list) ")")))
        ;; Downcase a function name.
        (when (and (not quotedp) (not case-sensitive-p))
          (map-into return-list #'string-downcase return-list))
        ;; Sort the return-list.
        (setq return-list (sort return-list #'string<))
        ;; Look for the largest common initial piece.
        (push (longest-common-prefix return-list :test char-cmp) return-list)
        ;; Reattach prefix consisting of package name and colons.
        (when prefix
          (mapl #'(lambda (l) (setf (car l) (string-concat prefix (car l))))
                return-list))
        return-list))))
)

(setq custom::*completion* #'completion)

(defun ext:make-completion (list)
  "Return a function suitable for `CUSTOM::*COMPLETION*'."
  (lambda (string start end)
    (let ((return-list
           ;; REMOVE-IF may return its list argument,
           ;; and SORT modifies its argument,
           ;; so we have to use DELETE-IF+COPY-LIST
           ;; to ensure that we do not modify the list argument.
           (delete-if (lambda (s)
                        (let ((s (string s)))
                          (string/= s string
                                    :start1 0 :end1 (min (length s) (- end start))
                                    :start2 start :end2 end)))
                      (copy-list list))))
      (and return-list
           (cons (longest-common-prefix return-list :test #'char=)
                 (sort return-list #'string<))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./complete.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./compiler.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CLISP - compiler
;; Bruno Haible 20.-30.09.1988, 05.-07.10.1988, 10.10.1988, 16.12.1988
;;   Version for KCL 27.06.1989, 05.-07.07.1989
;;   c-VALUES extended on 14.07.1989
;;   label-operand in assemble-LAP corrected on 14.07.1989
;;   ANODE-Components SOURCE, STACKZ eliminated on 14.07.1989
;;     (conditionally dependent on #+CLISP-DEBUG)
;;   Peephole-Optimization-Protocol conditionally dependent on #+PEEPHOLE-DEBUG
;;   Version for CLISP 28.07.1989-11.08.1989
;;   Variable-Optimization 10.03.1991
;; Michael Stoll, September-December 1991:
;;   - Bytecode reworked
;;   - Code-Optimization with reference to Labels/Jumps improved
;;   - small improvement at c-plus/c-minus,
;;     Compilation of CxxxR in succession of (CAR) and (CDR)
;;   - SUBR-calls without Argument-Check at runtime,
;;     SUBRs as constants (via #.#'name)
;;   - Calls of local functions without Argument-Check at run-time
;;   - Recursive calls by subroutine-call JSR, for tail-recursion
;;     JMPTAIL (corresponds to PSETQ with following jump)
;;   - Improvement for the call of a function with Rest-Parameters via APPLY
;; Bruno Haible, February-March 1992:
;;   - more detailed seclass, better PSETQ
;;   - better Constant Folding
;;   - Cross-Compilation
;; Bruno Haible, 03.06.1992:
;;   - Inline-Compilation of calls of global functions
;; Bruno Haible, August 1993:
;;   - support for CLOS: generic functions %GENERIC-FUNCTION-LAMBDA,
;;     Optimization of unused Required-parameters %OPTIMIZE-FUNCTION-LAMBDA
;;   - GENERIC-FLET, GENERIC-LABELS
;;   - Inline-Compilation of (APPLY (FUNCTION ...) ...)
;; Bruno Haible, 09.06.1996:
;;   - Bytecode platform-independent
;; Bruno Haible, 04.12.1998:
;;   - Optimization of generic functions by RETGF
;; further plans:
;;   - change Variable-Environments in a way, so the call of local functions
;;     becomes possible via JSR/JMPTAIL (i.e. belated decision, if
;;     call by CALLC or JSR)
;;   - poss. better Optimization by data-flow-analysis
;;   - Inline-Compilation of calls of local functions

;; Sam Steingold 1999-2011, 2016-2017
;; German comments translated into English: Stefan Kain 2001-12-18
;; "z" at the end of a variable name stands for "zustand" (German for "state")

(in-package "COMMON-LISP")
(export '(ext::eval-env) "EXT")
(export '(custom::*package-tasks-treat-specially*) "CUSTOM")
(ext:re-export "CUSTOM" "EXT")
(export '(compile compile-file disassemble))
(pushnew ':compiler *features*)

(in-package "SYS")

;; some auxilliary functions
(proclaim '(inline env mac-exp))
(defun env () (vector *venv* *fenv*))
(defun mac-exp (mac form &optional (env (env)))
  (funcall *macroexpand-hook* mac form env))

;; Avoid bootstrapping issues with CLOS.
(eval-when (compile load eval)
  (setq clos::*compile-accessor-functions* nil))

(defconstant *keyword-package* (find-package "KEYWORD"))
(defconstant *lisp-package* (find-package "COMMON-LISP"))

;; variables for top-level-call:
(defvar *compiling* nil) ; specifies, if inside the process of compilation
(defvar *error-count*) ; number of errors
(defvar *warning-count*) ; number of warnings
(defvar *style-warning-count*) ; number of style-warnings
(defvar *compile-warnings* t) ; if compiler-warnings are reported
(defvar *compile-verbose* t) ; if compiler-comments are reported
(defvar *compile-print* nil) ; if compiler reports, where he currently is
;; The first argument passed to COMPILE-FILE. Does not necessarily refer to
;; a file!
(defvar *compile-file-pathname* nil) ; CLtL2 p. 680
;; The physical pathname denoting the file being compiled. Determined from
;; *compile-file-pathname*. Includes the file extension.
(defvar *compile-file-resolved-pathname* nil)
;; *compile-file-truename* = (truename *compile-file-resolved-pathname*).
(defvar *compile-file-truename* nil) ; CLtL2 p. 680
(defvar *compile-file-directory* nil) ; for c-REQUIRE
(defvar *compile-file-lineno1* nil)
(defvar *compile-file-lineno2* nil)
(defvar *c-listing-output*) ; Compiler-Listing-Stream or nil
(defvar *c-error-output*) ; Compiler-Error-Stream
;; essentially
;; *c-error-output* = (make-broadcast-stream *error-output* *c-listing-output*)
;; The names of declared dynamic variables
(defvar *known-special-vars* nil)
;; The names and values of constants
(defvar *constant-special-vars* nil)
;; The fnode objects created in this lambda compilation unit
(defvar *fnode-list*)

;; T if called by COMPILE-FILE or LOAD :COMPILE
(defvar *compiling-from-file*)
;; how do we determine what will happen with the compiled code,
;; i.e., will it be evaluated right away or loaded before that?
;; if we are called by COMPILE-FILE, we are writing to *fasoutput-stream*,
;;   *compiling-from-file* is T
;; if we are writing by LOAD :COMPILE, *fasoutput-stream* is nil, but
;;   *compiling-from-file* is T
;; if we are called by COMPILE, both *fasoutput-stream* and
;;   *compiling-from-file* are nil
;; the last 2 cases are when the code can be evaluated right after
;;   compilation, so for them LOAD-TIME-VALUE == EVAL,
;;  ==> defer-eval-after-load == *fasoutput-stream*
;; on the other hand, what do we do with
;;  (eval-when (compile) (funcall (compile nil (lambda () (load-time-value)))))
;;  we need to bind *fasoutput-stream* to NIL in eval-when!

;;; The variables for COMPILE-FILE:
;; The compiler's output file stream, or nil
(defvar *fasoutput-stream* nil)
;; The compiler's library file stream, or nil
(defvar *liboutput-stream* nil)
;; The compiler's C output file name, or nil
(defvar *coutput-file* nil)
;; The compiler's C output file stream, or nil
(defvar *coutput-stream* nil)
;; The names of functions which contained errors
(defvar *functions-with-errors* nil)
;; The names of functions known up to now, modified by the DEFUN macroexpander
;; ((name c-source-point signature side-effect-class) ...)
(defvar *known-functions* nil)
;; The names of unknown functions (up to now)
(defvar *unknown-functions* nil)
;; The names of undeclared dynamic variables (up to now)
(defvar *unknown-free-vars* nil)
;; The names of used obsolete functions (up to now)
(defvar *deprecated-functions* nil)
;; The names of functions declared globally inline (up to now)
(defvar *inline-functions* nil)
;; The names of functions declared globally notinline (up to now)
(defvar *notinline-functions* nil)
;; The alist of global inlinable function definitions
(defvar *inline-definitions* nil)
;; The symbols denoting constants which are declared constant-inline
(defvar *inline-constants* nil)
;; The symbols denoting constants which are declared constant-notinline
(defvar *notinline-constants* nil)
;; The additional user defined declaration types (not really "types")
(defvar *user-declaration-types* nil)
;; The names of modules already compiled
;; (treated as if they were already loaded)
(defvar *compiled-modules* nil)
(defvar *package-tasks-treat-specially* nil
  "Treat package-related operations the same way at compile and load time.")
;; The list of the pending package tasks
(defvar *package-tasks* nil)
;; The data accumulated by the FFI.
(defvar *ffi-module* nil)
;; The load forms generated so far (by `make-load-form').
(defvar *load-forms* nil)

#|
The compiler's target is the virtual machine described in <doc/impbyte.xml>
and <http://clisp.org/impnotes/bytecode.html>.

1. Pass of the Compiler:
   macro-expansion,
   code-generation (symbolically),
   allocation of variables on the STACK or in Closures,
   Optimization on LISP-level.
   Thereafter the stack-layout is definite for each involved function.
   The Information is contained in a graph of ANODEs.
2. Pass of the Compiler:
   resolution of variable references,
   optimization on code-level (peephole-Optimization),
   creation of compiled functional objects.
3. Pass of the Compiler:
   resolution of references between the functional objects.
|#

#| external representation of a Closure:
 #Y(name
    #lengthY(Byte in Hex ... Byte in Hex)
    further constants)
|#

;; The instruction list is in <doc/impbyte.xml>.

;; classification of instructions:
;; O = instruction without operand
;; K = numerical operand or
;;     short-operand (then the byte is = short-code-ops[x] + operand)
;; N = numerical operand
;; B = Byte-Operand
;; L = Label-Operand
;; NH = numerical Operand, that references a Hashtable
;; NC = numerical Operand, that references a Handler-Cons
;; LX = as many Label-Operands as specified by the preceding Operand

;; the position in the instruction-table delivers the actual code of the
;; instruction (>= 0, < short-code-base), codes >= short-code-base are
;; occupied by the K-instructions.
(defconstant instruction-table
  '#(;; (1) constants
     (NIL O) (PUSH-NIL N) (T O) (CONST K)
     ;; (2) static variables
     (LOAD K) (LOADI NNN) (LOADC NN) (LOADV NN) (LOADIC NNNN)
     (STORE K) (STOREI NNN) (STOREC NN) (STOREV NN) (STOREIC NNNN)
     ;; (3) dynamic variables
     (GETVALUE N) (SETVALUE N) (BIND N) (UNBIND1 O) (UNBIND N) (PROGV O)
     ;; (4) stack-operations
     (PUSH O) (POP O) (SKIP N) (SKIPI NNN) (SKIPSP NN)
     ;; (5) program flow and jumps
     (SKIP&RET N) (SKIP&RETGF N)
     (JMP L) (JMPIF L) (JMPIFNOT L) (JMPIF1 L) (JMPIFNOT1 L)
     (JMPIFATOM L) (JMPIFCONSP L) (JMPIFEQ L) (JMPIFNOTEQ L)
     (JMPIFEQTO NL) (JMPIFNOTEQTO NL) (JMPHASH NHL) (JMPHASHV NHL) (JSR L)
     (JMPTAIL NNL)
     ;; (6) environments and closures
     (VENV O) (MAKE-VECTOR1&PUSH N) (COPY-CLOSURE NN)
     ;; (7) function-calls
     (CALL NN) (CALL0 N) (CALL1 N) (CALL2 N)
     (CALLS1 B) (CALLS2 B) (CALLSR NB) (CALLC O) (CALLCKEY O)
     (FUNCALL N) (APPLY N)
     ;; (8) optional and keyword-arguments
     (PUSH-UNBOUND N) (UNLIST NN) (UNLIST* NN) (JMPIFBOUNDP NL) (BOUNDP N)
     (UNBOUND->NIL N)
     ;; (9) treatment of multiple values
     (VALUES0 O) (VALUES1 O) (STACK-TO-MV N) (MV-TO-STACK O) (NV-TO-STACK N)
     (MV-TO-LIST O) (LIST-TO-MV O) (MVCALLP O) (MVCALL O)
     ;; (10) BLOCK
     (BLOCK-OPEN NL) (BLOCK-CLOSE O) (RETURN-FROM N) (RETURN-FROM-I NNN)
     ;; (11) TAGBODY
     (TAGBODY-OPEN NLX) (TAGBODY-CLOSE-NIL O) (TAGBODY-CLOSE O) (GO NN)
     (GO-I NNNN)
     ;; (12) CATCH and THROW
     (CATCH-OPEN L) (CATCH-CLOSE O) (THROW O)
     ;; (13) UNWIND-PROTECT
     (UNWIND-PROTECT-OPEN L) (UNWIND-PROTECT-NORMAL-EXIT O)
     (UNWIND-PROTECT-CLOSE O) (UNWIND-PROTECT-CLEANUP O)
     ;; (14) HANDLER
     (HANDLER-OPEN NC) (HANDLER-BEGIN&PUSH O)
     ;; (15) some functions
     (NOT O) (EQ O) (CAR O) (CDR O) (CONS O) (SYMBOL-FUNCTION O) (SVREF O)
     (SVSET O) (LIST N) (LIST* N)
     ;; (16) combined operations
     (NIL&PUSH O) (T&PUSH O) (CONST&PUSH K)
     (LOAD&PUSH K) (LOADI&PUSH NNN) (LOADC&PUSH NN) (LOADV&PUSH NN)
     (POP&STORE N) (GETVALUE&PUSH N) (JSR&PUSH L)
     (COPY-CLOSURE&PUSH NN)
     (CALL&PUSH NN) (CALL1&PUSH N) (CALL2&PUSH N)
     (CALLS1&PUSH B) (CALLS2&PUSH B) (CALLSR&PUSH NB)
     (CALLC&PUSH O) (CALLCKEY&PUSH O)
     (FUNCALL&PUSH N) (APPLY&PUSH N)
     (CAR&PUSH O) (CDR&PUSH O) (CONS&PUSH O)
     (LIST&PUSH N) (LIST*&PUSH N)
     (NIL&STORE N) (T&STORE N) (LOAD&STOREC NNN)
     (CALLS1&STORE BN) (CALLS2&STORE BN) (CALLSR&STORE NBN)
     (LOAD&CDR&STORE N) (LOAD&CONS&STORE N) (LOAD&INC&STORE N)
     (LOAD&DEC&STORE N) (LOAD&CAR&STORE NN)
     (CALL1&JMPIF NL) (CALL1&JMPIFNOT NL)
     (CALL2&JMPIF NL) (CALL2&JMPIFNOT NL)
     (CALLS1&JMPIF BL) (CALLS1&JMPIFNOT BL)
     (CALLS2&JMPIF BL) (CALLS2&JMPIFNOT BL)
     (CALLSR&JMPIF NBL) (CALLSR&JMPIFNOT NBL)
     (LOAD&JMPIF NL) (LOAD&JMPIFNOT NL)
     (LOAD&CAR&PUSH N) (LOAD&CDR&PUSH N) (LOAD&INC&PUSH N) (LOAD&DEC&PUSH N)
     (CONST&SYMBOL-FUNCTION N) (CONST&SYMBOL-FUNCTION&PUSH N)
     (CONST&SYMBOL-FUNCTION&STORE NN)
     (APPLY&SKIP&RET NN) (FUNCALL&SKIP&RETGF NN)))
(dotimes (i (length instruction-table))
  (setf (get (first (svref instruction-table i)) 'INSTRUCTION) i))
(defconstant instruction-codes
  (let ((hashtable (make-hash-table :key-type 'symbol :value-type 'fixnum
                                    :test 'stablehash-eq :warn-if-needs-rehash-after-gc t)))
    (dotimes (i (length instruction-table))
      (setf (gethash (first (svref instruction-table i)) hashtable) i))
    hashtable))

;; K-instructions:
(defconstant instruction-table-K
  '#(LOAD LOAD&PUSH CONST CONST&PUSH STORE))
(defconstant short-code-base 157)
(defconstant short-code-opsize '#(15   25   21   30    8))
(defconstant short-code-ops '#(157  172  197  218  248));256


#|

intermediate language after the 1st pass:
=========================================

1. constants:

   (NIL)                      A0 := NIL, 1 value

   (PUSH-NIL n)               n-times: -(STACK) := NIL, undefined values

   (T)                        A0 := T, 1 value

   (CONST const)              A0 := 'const, 1 value

   (FCONST fnode)             A0 := the compilation result of an fnode, 1 value

   (BCONST block)             A0 := the Block-Cons of this block (a
                              constant from FUNC), 1 value

   (GCONST tagbody)           A0 := the Tagbody-Cons of this tagbody (a
                              constant from FUNC), 1 value

2.,3. variables:

   (GET var venvc stackz)     A0 := var, 1 value
                              (venvc is the current Closure-Venv,
                               stackz is the current stack-state)

   (SET var venvc stackz)     var := A0, 1 value
                              (venvc is the current Closure-Venv,
                               stackz is the current stack-state)

   (STORE n)                  (STACK+4*n) := A0, 1 value

   (GETVALUE symbol)          A0 := (symbol-value 'symbol), 1 value

   (SETVALUE symbol)          (setf (symbol-value 'symbol) A0), 1 value

   (BIND const)               binds const (a Symbol) dynamically to A0.
                              undefined values.

   (UNBIND1)                  unwinds a binding-frame

   (PROGV)                    binds the Symbols in the List (STACK)+
                              dynamically to the values in the List A0 and
                              thereby constructs exactly one binding-frame,
                              undefined values
4. Stack-Operations:

   (PUSH)                     -(STACK) := A0, undefined values

   (POP)                      A0 := (STACK)+, 1 values

   (UNWIND stackz1 stackz2 for-value) Executes an Unwind within a function:
                              cleans the Stack, in order to get from
                              Stack-State stackz1 to Stack-State stackz2.
                              Resolves Frames lying inbetween. for-value
                              specifies, if the values A0/... must be
                              saved thereby.
   (UNWINDSP stackz1 stackz2) modifies the SP, in order to get from
                              Stack-State stackz1 to Stack-State stackz2 .
                              STACK and the values A0/... remain unchanged.

5. Control Flow and Jumps:

   (RET)                      terminates the function with the values A0/...

   (RETGF)                    terminates the function with 1 value A0
                              and poss. calls A0 as function, with the same
                              Arguments as the current function

   (JMP label)                jump to label

   (JMPIF label)              if A0 /= NIL : jump to label.

   (JMPIFNOT label)           if A0 = NIL : jump to label.

   (JMPIF1 label)             if A0 /= NIL : 1 value, jump to label.

   (JMPIFNOT1 label)          if A0 = NIL : 1 value, jump to label.

   (JMPHASH test ((obj1 . label1) ... (objm . labelm)) label . labels)
                              jump to labeli, if A0 = obji (in terms of
                              the specified comparison), else to label.
                              Undefined values.

   (JSR m label)              calls the Code at label as subroutine,
                              with m Arguments on the Stack

   (BARRIER)                  is never reached, counts as leaving-jump

6. Environments and Closures:

   (VENV venvc stackz)        A0 := the Venv, that corresponds to venvc
                              (from the Stack, as Constant from
                               FUNC, or NIL, if not available in FUNC),
                              1 value
                              (stackz is the current Stack-State)
   (MAKE-VECTOR1&PUSH n)      creates a simple-vector with n+1 (n>=0)
                              Components and puts in A0 as Component 0.
                              -(STACK) := the new Vector.
                              Undefined values.
   (COPY-CLOSURE fnode n)     copies the Closure, that corresponds to fnode
                              and in the copy it replaces for i=0,...,n-1 (n>0)
                              the component (CONST i) by (STACK+4*(n-1-i)).
                              STACK := STACK+4*n. A0 := Closure-Copy, 1 value

7. Function-Calls:

   (CALLP)                    starts the construction of a Function-Call-Frame
                              (is discarded in the 2. Pass without replacement)

   (CALL k const)             calls the Function const with k Arguments
                              (STACK+4*(k-1)),...,(STACK+4*0) ,
                              STACK:=STACK+4*k, result is stored to A0/...
   (CALL0 const)              calls the Function const with 0 Arguments,
                              result is stored to A0/...
   (CALL1 const)              calls the Function const with 1 Argument A0,
                              result is stored to A0/...
   (CALL2 const)              calls the Function const with 2 Arguments (STACK)
                              and A0 , STACK:=STACK+4,
                              result is stored to A0/...
   (CALLS1 n)                 calls the Function (FUNTAB n)
   (CALLS2 n)                 resp. (FUNTAB 256+n)
                              (a SUBR without Rest-Parameter),
                              with the correct number of arguments on the STACK
                              STACK is cleaned, result is stored to A0/...
   (CALLSR m n)               calls the Function (FUNTABR n)
                              (a SUBR with Rest-Parameter) ,
                              with the correct number of arguments and
                              additional m remaining arguments on the STACK.
                              STACK is cleaned, result is stored to A0/...
   (CALLC)                    calls the Function A0 (a compiled Closure
                              without Keyword-Parameter). Arguments
                              are already in the right format on the STACK,
                              STACK is cleaned, result is stored to A0/...
   (CALLCKEY)                 calls the Function A0 (a compiled Closure
                              with Keyword-Parameter). Arguments
                              are already in the right format on the STACK,
                              STACK is cleaned, result is stored to A0/...
   (FUNCALLP)                 adds the structure of a FUNCALL-Frame,
                              Function to be called is in A0
   (FUNCALL n)                calls the specified Function with n (n>=0)
                              Arguments (all on the Stack),
                              removes the FUNCALL-Frame,
                              result is stored to A0/...
   (APPLYP)                   adds the structure of an APPLY-Frame,
                              Function to be called is in A0
   (APPLY n)                  calls the specified Function with n (n>=0)
                              Arguments (all on the Stack) and further
                              Arguments (list in A0),
                              removes the APPLY-Frame,
                              result is stored to A0/...

8. optional and Keyword-Arguments:

   (PUSH-UNBOUND n)           n-times: -(STACK) := #<UNBOUND>, undefined values

   (UNLIST n m)               shorten list A0 n times: -(STACK) := (car A0),
                              A0 := (cdr A0). At the last m times A0 may have
                              already reached the end,
                              then -(STACK) := #<UNBOUND> instead.
                              At the end A0 must be NIL.
                              undefined values. 0 <= m <= n.
   (UNLIST* n m)              shorten list A0 n times: -(STACK) := (car A0),
                              A0 := (cdr A0). At the last m times A0 may have
                              already reached the end,
                              then -(STACK) := #<UNBOUND> instead.
                              Then -(STACK) := (nthcdr n A0).
                              undefined values. 0 <= m <= n, n > 0.
   (JMPIFBOUNDP var venvc stackz label)
                              if Variable /= #<UNBOUND> :
                                jump to label, A0 := Variable, 1 value.
                              else undefined values.
                              (stackz is the current Stack-State)
   (BOUNDP var venvc stackz)  A0 := (NIL if Variable=#<UNBOUND>, else T),
                              1 value
                              (stackz is the current Stack-State)

9. Treatment of Multiple Values:

   (VALUES0)                  A0 := NIL, 0 values

   (VALUES1)                  A0 := A0, 1 value

   (STACK-TO-MV n)            fetches n values from (STACK)+ ,
                              STACK:=STACK+4*n, n>1

   (MV-TO-STACK)              Multiple Values A0/A1/... to -(STACK),
                              1. value atop, STACK:=STACK-4*D7.W,
                              after that undefined values

   (NV-TO-STACK n)            the first n values (n>=0) to -(STACK),
                              1. value atop, STACK:=STACK-4*n,
                              undefined values

   (MV-TO-LIST)               Multiple Values A0/... as List to A0,
                              1 value

   (LIST-TO-MV)               A0/... := (values-list A0)

   (MVCALLP)                  prepares a MULTIPLE-VALUE-CALL to the
                              Function in A0

   (MVCALL)                   executes a MULTIPLE-VALUE-CALL with the
                              Arguments lying in the Stack

10. BLOCK:

   (BLOCK-OPEN const label)   Stores a Block-Cons (with CAR=const and CDR=
                              Framepointer) to -(STACK), constructs a
                              Block-Frame. Undefined values.
                              On RETURN to this Frame --> jump to label.
   (BLOCK-CLOSE)              Leave the Block and thereby dismantle a Block-
                              Frame (including the Block-Cons-Variables)
   (RETURN-FROM const)        Leave the Block, whose Block-Cons is specified,
                              with the values A0/...
   (RETURN-FROM block)        Leave the specified Block (its Block-Cons
                              occurs among the BlockConsts of FUNC) with
                              the values A0/...
   (RETURN-FROM block stackz) Leave the specified Block (its Block-Cons
                              occurs in the Stack) with the values A0/...

11. TAGBODY:

   (TAGBODY-OPEN const label1 ... labelm)
                              Stores a Tagbody-Cons (with CAR=const
                              and CDR=Framepointer) on -(STACK), constructs a
                              Tagbody-Frame. Undefined values.
                              On GO with number l ---> jump to labell.
   (TAGBODY-CLOSE-NIL)        Leave the Tagbody and thereby dismantle a
                              Tagbody-Frame (including the Tagbody-Cons-
                              Variables). A0 := NIL, 1 value
   (TAGBODY-CLOSE)            Leave the Tagbody and thereby dismantle a
                              Tagbody-Frame (including the Tagbody-Cons-
                              Variables).
   (GO const l)               jump in Tagbody, whose Tagbody-Cons
                              is specified, to Tag (svref (car const) l)
   (GO tagbody l)             jump in the specified Tagbody to Tag Number
                              (cdr l) in (tagbody-used-far tagbody)
   (GO tagbody l stackz)      jump in the specified Tagbody to Tag Number
                              (cdr l) in (tagbody-used-far tagbody), its
                              Tagbody-Cons is located in the Stack

12. CATCH and THROW:

   (CATCH-OPEN label)         constructs a CATCH-Frame with A0 as Tag;
                              On THROW to this Tag ---> jump to label

   (CATCH-CLOSE)              unwinds a CATCH-Frame

   (THROW)                    executes a THROW to the Catch-Tag (STACK)+,
                              with the values A0/...

13. UNWIND-PROTECT:

   (UNWIND-PROTECT-OPEN label)  constructs a UNWIND-PROTECT-Frame; On
                              Unwind --> jump to label, saving the values

   (UNWIND-PROTECT-NORMAL-EXIT) unwinds an Unwind-Protect-Frame, writes a
                              Continuation-Address to SP, saves the
                              values and starts to execute the following
                              Cleanup-Code
   (UNWIND-PROTECT-CLOSE label) finishes the Cleanup-Code: writes back
                              the saved values, executes an RTS.
                              The Cleanup-Code starts at label.
   (UNWIND-PROTECT-CLEANUP)   unwinds an Unwind-Protect-Frame, writes a
                              Continuation-Address and the PC to SP,
                              saves the values and starts to execute the
                              Cleanup-Code

14. HANDLER:

   (HANDLER-OPEN const stackz label1 ... labelm)
                              constructs a HANDLER-Frame; const contains
                              the Condition-Types; die corresponding
                              Handlers start at labeli
   (HANDLER-BEGIN)            begins a Handler: produces the SP-State
                              as with HANDLER-OPEN,
                              A0 := Condition passed to the Handler, 1 value

15. Some Functions:

   (NOT)                      = (CALL1 #'NOT)

   (EQ)                       = (CALL2 #'EQ)

   (CAR denv)                 = (CALL1 #'CAR)

   (CDR denv)                 = (CALL1 #'CDR)

   (CONS)                     = (CALL2 #'CONS)

   (ATOM)                     = (CALL1 #'ATOM)

   (CONSP)                    = (CALL1 #'CONSP)

   (SYMBOL-FUNCTION denv)     = (CALL1 #'SYMBOL-FUNCTION)

   (SVREF denv)               = (CALL2 #'SVREF)

   (SVSET)                    (setf (svref (STACK) A0) (STACK+4)),
                              A0 := (STACK+4), 1 value, STACK:=STACK+8

   (LIST n)                   = (CALL n #'LIST), n>0

   (LIST* n)                  = (CALL n+1 #'LIST*), n>0


Some Definitions:

n, m, k     an Integer >=0

stackz      a Stack-State (see STACK-MANAGEMENT).
            The Stack-Layout stands firm after the 1. Pass.

venvc       the Environment of the Closure-Variables (see VARIABLE-MANAGEMENT).
            This also stands firm after the 1. Pass.

var         a Variable (see VARIABLE-MANAGEMENT). If it is
            special/constant/lexical, stands firm after the 1. Pass.

const       a Constant

symbol      a Symbol

fun         either (CONST const) a Constant, that is a Symbol,
            or (FUNTAB index) an indexing in the fixed Function-Table.

fnode       an fnode (see FUNCTION-MANAGEMENT)

label       a Label (uninterned Symbol)

block       a Block-Descriptor (see BLOCK-MANAGEMENT)

test        EQ or EQL or EQUAL

for-value   NIL or T

|#

(defconstant function-codes
  (let ((hashtable (make-hash-table :key-type 'symbol :value-type 'fixnum
                                    :test 'stablehash-eq :warn-if-needs-rehash-after-gc t)))
    (dotimes (i (* 3 256))
      (let ((sym (%funtabref i))) ; Name of the Function FUNTAB[i]
        (when sym (setf (gethash sym hashtable) i))))
    hashtable))
(defconstant funtabR-index ; Startindex of FUNTABR with reference to FUNTAB
  (dotimes (i (* 3 256))
    (let ((sym (%funtabref i)))
      (multiple-value-bind (name req opt rest-p) (subr-info sym)
        (declare (ignore name req opt))
        (when rest-p (return i))))))
(defun CALLS-code (funtab-index)
  (if (< funtab-index 256)
    `(CALLS1 ,funtab-index)
    `(CALLS2 ,(- funtab-index 256))))
(defmacro CALLS-code-fun (fun)
  `(load-time-value (CALLS-code (gethash ',fun function-codes))))

;; error message function
(defun compiler-error (caller &optional where)
  (error (TEXT "Compiler bug!! Occurred in ~A~@[ at ~A~].") caller where))


;;;;****                      STACK   MANAGEMENT

;; A Stack-State describes, what will be located in the two Stacks
;; at run-time.
;; Exact Structure:
;;  (item1 ... itemk . fun)
;; In memory this is really a tree-structure!
;; Definitions:
;;  fun = FNODE of the Function, in which the counting takes place.
;;  item = one of the following:
;;   n (Integer >=0) : n Lisp-Objects on the STACK
;;                     occupies n STACK-Entries
;;   (BIND n)        : one Binding-Frame for n Variables,
;;                     occupies 1+2*n STACK-Entries and 0 SP-Entries
;;                     Must be unwound on Unwind explicitely
;;   PROGV           : a Binding-Frame for arbitrary many Variables,
;;                     occupies ? STACK-Entries and 1 SP-Entry (Pointer above
;;                     the Frame = old STACK)
;;                     Must be unwound on Unwind explicitely
;;   CATCH           : a CATCH-Frame
;;                     occupies 3 STACK-Entries and 2+jmpbufsize SP-Entries
;;   UNWIND-PROTECT  : an Unwind-Protect-Frame
;;                     occupies 2 STACK-Entries and 2+jmpbufsize SP-Entries
;;                     Must be unwound on Unwind and Cleanup has to be executed
;
;;   CLEANUP         : during the Cleanup-Phase of an UNWIND-PROTECT
;;                     occupies ? STACK-Entries and 3 SP-Entries
;;                     (the lower one is Pointer above the Frame = old STACK)
;;   BLOCK           : a BLOCK-Frame
;;                     occupies 3 STACK-Entries and 2+jmpbufsize SP-Entries
;;                     Must be unwound on Unwind explicitely
;;   (TAGBODY n)     : a TAGBODY-Frame, that stores n Tags
;;                     occupies 3+n STACK-Entries and 1+jmpbufsize SP-Entries
;;                     Must be unwound on Unwind explicitely
;;   MVCALLP         : Preparation for MVCALL
;;                     occupies 1 STACK-Entry and 1 SP-Entry (Pointer above
;;                     FRAME = STACK)
;;   MVCALL          : many Lisp-Objects
;;                     occupies ? STACK-Entries and 1 SP-Entry (Pointer above
;;                     Frame = old STACK)
;;   ANYTHING        : many Lisp-Objects and Frames
;;                     occupies ? STACK-Entries and 1 SP-Entry (Pointer above
;;                     Frame = old STACK)

(defvar *stackz*)    ; the current Stack-State

;; A SP-Depth k is a cons (k1 . k2) and means k1+jmpbufsize*k2.
(defmacro spd (k1 k2) `(cons ,k1 ,k2))
(defun spd+ (k kd)
  (cons (+ (car k) (car kd))
        (+ (cdr k) (cdr kd))))
(defun spd- (k kd)
  (cons (- (car k) (car kd))
        (- (cdr k) (cdr kd))))
(defun spd<= (k kk)
  (and (<= (car k) (car kk))
       (<= (cdr k) (cdr kk))))
(defun spdmax (k kk)
  (cons (max (car k) (car kk))
        (max (cdr k) (cdr kk))))
#|
;; We cannot simply take the maximum of two depths, have to work with lists.
;; Is depth covered by some of the depths in the list?
 (defun some-spd<= (depth list-of-depths)
  (dolist (x list-of-depths nil)
    (when (spd<= depth x) (return t))))
|#

;; (stackz-fun stackz) extracts from a Stack-State the function, that is
;; currently processed.
#|
 (defun stackz-fun (stackz)
  (loop (when (atom stackz) (return)) (setq stackz (cdr stackz)))
  stackz)
|#
;; equivalent, but faster:
(defun stackz-fun (stackz)
  (if (atom stackz) stackz (cdr (last stackz))))

;; (access-in-stack stackz1 stackz2)
;; For the access to local variables in the Stack:
;; Outcome for two Stack-States stackz1 and stackz2, that lie both within
;; the same function and where stackz1 is "deeper" than stackz2:
;; 2 values: NIL and n, if (stackz2) = (STACK+4*n) starting from stackz1,
;;          k and n,    if (stackz2) = ((SP+4*k)+4*n) starting from stackz1.
;; (If stackz2 begins with BLOCK or TAGBODY, always the access to the
;;  consvar of a Block- resp. Tagbody-Frame is assumed.)
(defun access-in-stack (stackz1 stackz2 &aux (k nil) (n 0) (kd (spd 0 0)))
  (loop ;; looping the stacks upwards:
    ;; current STACK is STACK+4*n (for k=NIL) resp. (SP+4*k)+4*n,
    ;; current SP is SP+4*kd (for k=NIL) resp. SP+4*(k+kd).
    (when (eq stackz1 stackz2) (return))
    (when (atom stackz1) (compiler-error 'access-in-stack "STACKZ-END"))
    (let ((item (pop stackz1)))
      (cond ((integerp item) (setq n (+ n item)))
            ((consp item)
             (case (first item)
               (BIND    (setq n (+ n (+ 1 (* 2 (second item))))))
               (TAGBODY (setq kd (spd+ kd (spd 1 1))
                              n (+ n (+ 3 (second item)))))
               (t (compiler-error 'access-in-stack "STACKZ-LISTITEM"))))
            (t
             (case item
               (PROGV          (setq k (if k (spd+ k kd) kd) kd (spd 1 0) n 0))
               (CATCH          (setq kd (spd+ kd (spd 2 1)) n (+ n 3)))
               (UNWIND-PROTECT (setq kd (spd+ kd (spd 2 1)) n (+ n 2)))
               (CLEANUP        (setq k (if k (spd+ k kd) kd) kd (spd 3 0) n 0))
               (BLOCK          (setq kd (spd+ kd (spd 2 1)) n (+ n 3)))
               (MVCALLP        (setq kd (spd+ kd (spd 1 0)) n (+ n 1)))
               ((MVCALL ANYTHING)
                               (setq k (if k (spd+ k kd) kd) kd (spd 1 0) n 0))
               (t (compiler-error 'access-in-stack "STACKZ-ITEM")))))))
  (when (and (consp stackz2) ; on access to BLOCK- resp. TAGBODY-consvar:
             (or (eq (car stackz2) 'BLOCK)
                 (and (consp (car stackz2))
                      (eq (first (car stackz2)) 'TAGBODY))))
    (incf n 2)) ; consvar is located exactly 2 entries higher than frame start
  (values k n))

;; (may-UNWIND stackz1 stackz2)
;; determines, if (UNWIND stackz1 stackz2 for-value) is legal.
;; Therefore it is necessary, that the Compiler knows exactly about
;;  the Frames between stackz1 and stackz2.
(defun may-UNWIND (stackz1 stackz2)
  (loop
    (when (eq stackz1 stackz2) (return t))
    (when (atom stackz1) (compiler-error 'may-UNWIND "STACKZ-END"))
    (when (eq (car stackz1) 'ANYTHING) (return nil))
    (setq stackz1 (cdr stackz1))))

;; (expand-UNWIND stackz1 stackz2 for-value)
;; returns a piece of code equivalent to (UNWIND stackz1 stackz2 for-value),
;; consisting of
;; (SKIP n), (SKIPI k1 k2 n), (SKIPSP k1 k2), (VALUES0),
;; (UNWIND-PROTECT-CLEANUP), (UNBIND1), (BLOCK-CLOSE), (TAGBODY-CLOSE).
;; It must clean the stack - starting from stackz1 - , so that after it the
;; Stack-State stackz2 is there. If for-value=NIL the values can be
;; discarded thereby.
(defun expand-UNWIND (stackz1 stackz2 for-value
                      &aux (k nil) (n 0) (kd (spd 0 0)) (codelist nil))
  (flet ((here () ; up to here, first of all increment the Stacks
           (if k
             (progn
               (push `(SKIPI ,(car k) ,(cdr k) ,n) codelist)
               (unless (> (car kd) 0)
                 (compiler-error 'expand-UNWIND "SP-depth"))
               (when (or (> (car kd) 1) (> (cdr kd) 0))
                 (push `(SKIPSP ,(- (car kd) 1) ,(cdr kd)) codelist)))
             (progn
               (when (> n 0) (push `(SKIP ,n) codelist))
               (when (or (> (car kd) 0) (> (cdr kd) 0))
                 (push `(SKIPSP ,(car kd) ,(cdr kd)) codelist))))
           (setq k nil n 0 kd (spd 0 0))))
    (loop ;; looping the stacks upwards:
      ;; current STACK is STACK+4*n (for k=NIL) resp. (SP+4*k)+4*n,
      ;; current SP is SP+4*kd (for k=NIL) resp. SP+4*(k+kd).
      (when (eq stackz1 stackz2) (here) (return))
      (when (atom stackz1) (compiler-error 'expand-UNWIND "STACKZ-END"))
      (let ((item (car stackz1)))
        (cond ((integerp item) (setq n (+ n item)))
              ((consp item)
               (case (first item)
                 (BIND    (here) (push '(UNBIND1) codelist))
                 (TAGBODY (here) (push '(TAGBODY-CLOSE) codelist))
                 (t (compiler-error 'expand-UNWIND "STACKZ-LISTITEM"))))
              (t
               (case item
                 (PROGV (here) (push '(UNBIND1) codelist) (setq kd (spd 1 0)))
                 (CATCH (setq kd (spd+ kd (spd 2 1)) n (+ n 3)))
                 (UNWIND-PROTECT
                   (here)
                   (unless for-value
                     ;; When for-value=NIL at the first occurring
                     ;; UNWIND-PROTECT-Frame a '(VALUES0) is inserted.
                     (setq for-value t)
                     (push '(VALUES0) codelist))
                   (push '(UNWIND-PROTECT-CLEANUP) codelist))
                 (CLEANUP (setq k (if k (spd+ k kd) kd) kd (spd 3 0) n 0))
                 (BLOCK (here) (push '(BLOCK-CLOSE) codelist))
                 (MVCALLP (setq kd (spd+ kd (spd 1 0)) n (+ n 1)))
                 (MVCALL (setq k (if k (spd+ k kd) kd) kd (spd 1 0) n 0))
                 (t (compiler-error 'expand-UNWIND "STACKZ-ITEM"))))))
      (setq stackz1 (cdr stackz1)))
    (nreverse codelist)))

;; (spdepth-difference stackz1 stackz2)
;; returns the difference k of SP at stackz1 and SP at stackz2.
;; In order to increment the SP from stackz1 to stackz2,
;; (SKIPSP k1 k2) is sufficient.
(defun spdepth-difference (stackz1 stackz2 &aux (k (spd 0 0)))
  (loop
    (when (eq stackz1 stackz2) (return))
    (when (atom stackz1) (compiler-error 'spdepth-difference "STACKZ-END"))
    (let ((item (car stackz1)))
      (if (consp item)
        (case (first item)
          (TAGBODY (setq k (spd+ k (spd 1 1)))))
        (case item
          ((PROGV MVCALLP MVCALL ANYTHING) (setq k (spd+ k (spd 1 0))))
          ((CATCH UNWIND-PROTECT BLOCK) (setq k (spd+ k (spd 2 1))))
          (CLEANUP (setq k (spd+ k (spd 3 0)))))))
    (setq stackz1 (cdr stackz1)))
  k)



;;;;****        FUNCTION   ENVIRONMENT   MANAGEMENT

;; passed by the Interpreter: %fenv%

;; Interpreter-Function-Environment has the shape
;; %fenv% = NIL or #(f1 def1 ... fn defn NEXT-ENV), NEXT-ENV likewise
;;
;; So a mapping fi --> defi is established.
;; defi = Closure             implies, that defi is the local
;;                            function-definition of fi
;; defi = #<MACRO expander>   denotes a local Macro.
;; defi = #<FUNCTION-MACRO closure expander>
;;                            denotes a local function-definition
;;                            with alternative Macro-Expander
;; defi = NIL                 implies, that a local function-
;;                            definition is still to be added (cf. LABELS)

;; newly constructed:
(defvar *fenv*)
;; contains the new lexical function-bindings.
;; *fenv* has the same shape as %fenv% and ends with %fenv%:
;; #(f1 def1 ... fn defn NEXT-ENV), which establishes a
;;  a mapping fi --> defi.
;; defi = #<MACRO expander>         denotes a local Macro.
;; defi = (fdescr . var)            implies, that the local function-definition
;;           of fi is located at runtime in the lexical variable var.
;;           fnode is the fnode belonging to fi, still NIL at the beginning.
;; defi = (fdescr . const)          implies, that the local function-definition
;;           of fi is autonomously and is located in the constant const.
;;           fnode is the fnode belonging to fi, still NIL at the beginning.
;; fdescr is a Cons (fnode . lambdadescr),
;;           fnode is the fnode belonging to fi or NIL,
;;           lambdadescr = (LABELS . list of values of c-analyze-lambdalist)
;;           or lambdadescr = (GENERIC . Signature) or NIL.
;; defi = (#<MACRO expander> fdescr . {var|const})
;;                                    denotes a local function-definition
;;                                    with alternative Macro-Expander

;; Search the local function-definition of the symbol f in fenv:
;; result:
;; 1. value: T
;; 2. value: as Macro
;;    Macro-Expander                 if local Macrodefinition available
;;    NIL                            if not
;; 3. value and further values: as function
;;    GLOBAL, Vector, Index, NIL     if defi = (svref Vector Index)
;;                                   (so found in %fenv%)
;;    GLOBAL, Vector, Index, T       ditto as FUNCTION-MACRO
;;    LOCAL, def, fdescr             if def = {var|const} = (cdr (last defi))
;;                                   (so found in *fenv* without %fenv%)
;;    NIL                            if only Macro
;; Or:
;; 1. value: NIL                     if not defined locally.
(defun fenv-search (f &optional (fenv *fenv*))
  (let ((from-inside-macrolet nil))
    (loop
      (cond ((null fenv) (return-from fenv-search 'NIL))
            ((simple-vector-p fenv)
             (do ((l (1- (length fenv)))
                  (i 0 (+ i 2)))
                 ((= i l) (setq fenv (svref fenv i)))
               (if (equal f (svref fenv i))
                 (let ((def (svref fenv (1+ i))))
                   (if (and from-inside-macrolet (not (macrop def)))
                     (c-error (TEXT "Invalid access to the local function definition of ~S from within a ~S definition")
                              f 'macrolet)
                     (return-from fenv-search
                       (if (consp def)
                         (if (macrop (car def))
                           (values 'T
                                   (macro-expander (car def))
                                   'LOCAL (cddr def) (cadr def))
                           (values 'T
                                   'NIL
                                   'LOCAL (cdr def) (car def)))
                         (if (macrop def)
                           (values 'T (macro-expander def) 'NIL)
                           (if (function-macro-p def)
                             (values 'T
                                     (function-macro-expander def)
                                     'GLOBAL fenv (1+ i) 'T)
                             (values 'T
                                     'NIL
                                     'GLOBAL fenv (1+ i) 'NIL))))))))))
            ((and (consp fenv) (eq (car fenv) 'MACROLET))
             (setq from-inside-macrolet t)
             (setq fenv (cdr fenv)))
            (t (compiler-error 'fenv-search fenv))))))
;; Determines, if a function-name is not defined in the
;; Function-Environment fenv and hence refers to the global function.
(defun global-in-fenv-p (s fenv)
  (eq (fenv-search s fenv) 'NIL))

;; The Functions MACROEXPAND-1, MACROEXPAND work:
;; With a Vector consisting of
;; - such a Variable-Environment (concatenated Vectors, with
;;   defi = #<SYMBOL-MACRO expansion> for Symbol-Macro-Definitions),
;; - such a Function-Environment (concatenated Vectors, with
;;   defi = (SYSTEM::MACRO . expander) for Macro-Definitions for fi)

;; (MACROEXPAND-1 form env) expands the given Form in the Macroexpansion-
;; Environment env and returns the form expanded once and T
;; (or form and NIL, if not expandable).
;; (MACROEXPAND form env) expands the given Form in the Macroexpansions-
;; Environment env and returns the Form expanded as many times as possible
;; and T (or form and NIL, if not expandable).
;; (PARSE-BODY body docstring-allowed) analyzes the body and detaches
;; the Declarations and the Docstring (if allowed and if existing) .
;; 3 values: the remaining body-rest, a list of the found declspecs,
;; the Docstring (or NIL).

;;;;****           BLOCK   ENVIRONMENT   MANAGEMENT

;; passed by the Interpreter: %benv%

;; Interpreter-Block-Environment has the shape
;; %benv% = ((name1 . status1) ... (namen . statusn))
;; where namei is a Symbol and statusi is the state
;; of this lexically comprising
;;  Block: #<DISABLED> if the Block has already been left, else a
;;  Pointer in the Stack to the belonging Block-Frame.

;; newly constructed:
(defvar *benv*)

;; *benv* has the shape
;; ((name1 . block1) ... (namen . blockn) . %benv%)
;; where blocki is the Descriptor of the Block with Name namei:
(defstruct (block (:copier nil))
  fnode             ; Function, in which this Block is defined, an FNODE
  label             ; label, which finishes this Block
  stackz            ; Stack-State after the construction of the Block-Frame
  consvar           ; Variable, that lies in the Stack in the Block-Frame and
                    ; which contains the Block-Cons (whose CDR is set to
                    ; #<DISABLED>  on leaving the block)
  used-far          ; flag, indicates, if this Block is left out of a
                    ; different function with RETURN-FROM.
  for-value         ; specifies, if the whole block-construction has to
                    ; return values.
)
#-CLISP-DEBUG (remprop 'block 'clos::closclass)

;; Searches for a block with Name name and returns:
;; NIL                          if not found,
;; Block-Descriptor             if found in *benv* ,
;; Block-Cons (name . status)   if found in %benv% .
(defun benv-search (name &optional (benv *benv*))
  (loop
    (when (atom benv) (return nil))
    (when (eq (caar benv) name)
      (if (block-p (cdar benv))
        (return (cdar benv))
        (return (car benv))))
    (setq benv (cdr benv))))


;;;;****         TAGBODY   ENVIRONMENT   MANAGEMENT

;; passed by the Interpreter: %genv%

;; Interpreter-Tagbody-Environment has the shape
;; %genv% = ((Tagvektor1 . status1) ... (Tagvektorn . statusn))
;; where Tagvektori is a simple-vector, that contains the Tags that can
;; be jumped at, statusi is the state of this lexically comprising Tagbody:
;; #<DISABLED> if the Tagbody has already been left, else a
;; Pointer in the Stack to the belonging Tagbody-Frame.

;; newly constructed:
(defvar *genv*)

;; *genv* has the shape
;; ((Tagvektor1 . tagbody1) ... (Tagvektorn . tagbodyn) . %genv%)
;; where tagbodyi is the Descriptor of Tagbody i:
(defstruct (tagbody (:copier nil))
  fnode             ; Function, in which this Tagbody is defined, an FNODE
  labellist         ; list of Labels, parallel to the  tag-vector
  stackz            ; Stack-State after the construction of the Tagbody-Frame
  consvar           ; Variable, that lies in the Stack in the Tagbody-Frame and
                    ; which contains the Tagbody-Cons (whose CDR is set to
                    ; #<DISABLED> on leaving the Tagbody)
  used-far          ; list of all the Tags that are jumped at with a GO from
                    ; within another function.
)
#-CLISP-DEBUG (remprop 'tagbody 'clos::closclass)

;; Searches for a tag with Namen name and returns:
;; NIL                                         if not found,
;; Tagbody-Descriptor, Index                   if found in *genv* ,
;; Tagbody-Cons (Tagvektor . status), Index    if found in %genv% .
(defun genv-search (name &optional (genv *genv*))
  (loop
    (when (atom genv) (return nil))
    (do* ((v (caar genv))
          (l (length v))
          (i 0 (1+ i)))
         ((= i l))
      (when (eql (svref v i) name)
        (return-from genv-search
          (values (if (tagbody-p (cdar genv)) (cdar genv) (car genv)) i))))
    (setq genv (cdr genv))))


;;;;****       VARIABLE   ENVIRONMENT   MANAGEMENT

;; passed by the Interpreter: %venv%

;; Interpreter-Variablen-Environment has the shape
;; %venv% = NIL or #(v1 val1 ... vn valn NEXT-ENV),
;; NEXT-ENV of the same shape.
(defparameter specdecl
  (eval
   '(let ((*evalhook*
            #'(lambda (form env)
                (declare (ignore form))
                ;; The Evalhook-Mechanism passes the Environment.
                ;; (svref...0) thereof is the Variable-Environment,
                ;; (svref...1) thereof is the associated "value"
                ;; #<SPECIAL REFERENCE> from the *evalhook*-binding.
                (svref (svref env 0) 1))))
     0)))
;; determines, if the Symbol var represents a Special-Variable
(defun proclaimed-special-p (var)
  (or (sys::special-variable-p var)
      (not (null (memq var *known-special-vars*)))))

;; newly constructed:
(defvar *venv*)                  ; Variable-Environment, fine-grained
(defvar *venvc*)                 ; Variable-Environment, coarse-grained

;; *venv* has the same shape as %venv% and ends with %venv%:
;; #(v1 var1 ... vn varn NEXT_ENV), where vari are Variable-Constructs or
;; Symbolmacros or Interpreter-Values and NEXT-ENV has the same shape.

;; *venvc* simulates the Runtime-Variable-Environment at runtime, as far
;; as it involves Closure-Variables.
;; *venvc* has the shape
;; (item1 ... itemn)
;; each item is
;;   NIL :            a LET/LET*/MULTIPLE-VALUE-BIND/Function-Entry/
;;                    FLET/LABELS, that does not create a Closure
;;   fnode :          a new Function
;;   ((var1 ... vark) . stackz) : the variables Var1, ..., Vark get
;;                    into a closure by LET/LET*/MULTIPLE-VALUE-BIND/
;;                    Function-Entry/FLET/LABELS.
;;                    this Closure is located in the Stack; the Stack-State
;;                    is specified, where it is reachable.

;; A Variable is described by either being special or - if lexical -
;; by the Stack-Structure being determined after the creation of the Variable
;; in the Stack resp. the place in the Closure.
(defstruct (var (:copier nil))
  (name nil :read-only t)  ; Symbol
  (specialp nil :read-only t) ; declared special (or bound lexically) ?
  constantp                ; Constant ?
  constant                 ; if Constant: Value and Origin of the Constant
                           ;   (the value is known at Compile-Time)
  usedp                    ; if lexically:
                           ;   was the Variable ever used ?
                           ;   (A list of references to the variable
                           ;    terminated by NIL or T)
  for-value-usedp          ; if lexically:
                           ;   was the Variable ever used for-value ?
  really-usedp             ; if lexically:
                           ;   was the Variable ever really
                           ;   (in order to know the value) used ?
  (assignedp nil)          ; if lexically:
                           ;   was a value ever assigned to the Variable?
  (modified-list '())      ; if lexically: for each SET on the Variable:
                           ;   a List (value-anode set-anode . for-value)
  (replaceable-list '())   ; if lexically:
                           ;   for each movable-Variable, that has the same
                           ;   value during its entire Existence like this one
                           ;   and therefore is replaceable: a
                           ;   List (var init-anode . bind-anode)
  closurep                 ; if lexically:
                           ;   NIL if in the Stack, T if in the Closure
  (stackz nil :read-only t); if lexically:
                           ;   Stack-State after creation of the Variable
                           ;   (if Variable is in Stack: its location in Stack)
  (venvc nil :read-only t) ; if lexically and in the Closure:
                           ;   the *venvc*, in whose first Item this
                           ;   Variable occurs.
  (fnode nil :read-only t) ; function containing this variable, an FNODE
)

;; (venv-search v) searches in *venv* for a Variable with the Symbol v.
;; result:
;; NIL                   if not found
;; SPECIAL               if found as a special-declared variable
;; LOCAL, vector, index  if interpretatively lexically bound, value in vector
;; T, var                if lexically bound, in Stack or in the Closure
(defun venv-search (v &optional (venv *venv*))
  (when (or (constantp v) (proclaimed-special-p v))
    (return-from venv-search 'SPECIAL))
  (let ((from-inside-macrolet nil))
    (loop
      (cond ((null venv) (return-from venv-search 'NIL))
            ((simple-vector-p venv)
             (do ((l (1- (length venv)))
                  (i 0 (+ i 2)))
                 ((= i l) (setq venv (svref venv i)))
               (if (eq v (svref venv i))
                 (let ((val (svref venv (1+ i))))
                   (if (and from-inside-macrolet
                            (not (eq val specdecl))
                            (not (symbol-macro-p val)))
                     (c-error (TEXT "Invalid access to the value of the lexical variable ~S from within a ~S definition")
                              v 'macrolet)
                     (return-from venv-search
                       (if (and (var-p val) #| (eq (var-name val) v) |# )
                         (progn
                           (assert (not (var-specialp val)))
                           (values T val))
                         (if (eq val specdecl)
                           'SPECIAL
                           (values 'LOCAL venv (1+ i))))))))))
            ((and (consp venv) (eq (car venv) 'MACROLET))
             (setq from-inside-macrolet t)
             (setq venv (cdr venv)))
            (t (compiler-error 'venv-search venv))))))

;; (venv-search-macro v) searches in *venv* for a Variable with the Symbol v.
;; result:
;;   if v is a Symbol-Macro:  T, Expansion.
;;   else:                              NIL.
(defun venv-search-macro (v &optional (venv *venv*))
  (multiple-value-bind (a b c) (venv-search v venv)
    (case a
      ((NIL) (symbol-macro-expand v))
      ((LOCAL) (and (symbol-macro-p (svref b c))
                    (values t (sys::%record-ref (svref b c) 0))))
      (t nil))))

;; (push-*venv* var1 ... varn) extends *venv* by var1, ..., varn,
;; so to speak like (dolist (v (list var1 ... varn)) (push v *venv*)).
(defun push-*venv* (&rest varlist)
  (when varlist
    #|; the alternative definition conses less but is longer and thus slower
    (let* ((len (ash (length varlist) 1)) (idx -1)
           (ret (make-array (1+ len))))
      (setf (svref ret len) *venv* *venv* ret)
      (dolist (var varlist *venv*)
        (setf (aref ret (incf idx)) (var-name var)
              (aref ret (incf idx)) (if (var-specialp var) specdecl var))))
    |#
    (let ((l (list *venv*)))
      (dolist (var varlist)
        (setq l (list* (var-name var) (if (var-specialp var) specdecl var) l)))
      (setq *venv* (apply #'vector l)))))

;; (access-in-closure var venvc stackz)
;; returns for a Closure-Variable var, how one can access it
;; (from a location, where the Stack and the Closure-Environment
;;  are described by stackz and venvc):
;; 3 values k, n, m; the Variable is located in (svref ... 1+m)
;;     nil, n, m  : (STACK+4*n)
;;     k, nil, m  : (svref ... 0)^k VenvConst
;;     k, n,   m  : ((SP+4*k)+4*n)
(defun access-in-closure (var venvc stackz &aux (k nil) n)
  ;; coarse loop, determines the Closure-depth k at VenvConst:
  (loop
    (when (eq venvc (var-venvc var)) (return))
    (when (atom venvc)
      (compiler-error 'access-in-closure (list 'loop (var-name var))))
    (let ((item (pop venvc)))
      (if (null k)
        ;; start of count, (not (listp item)) == (fnode-p item)
        (when (not (listp item)) (setq k 0))
        (when (consp item) (incf k))))) ; count
  (if k
    (setq n nil)
    (multiple-value-setq (k n) (access-in-stack stackz (cdr (first venvc)))))
  (let ((m (do ((L (car (first venvc)) (cdr L))
                (i 0 (1+ i)))
               ((eq (car L) var) i)
             (when (null L)
               (compiler-error 'access-in-closure
                               (list 'do (var-name var)))))))
    (values k n m)))

;;;;****             CONSTANT   MANAGEMENT

;; A Constant is a Box with the value of the Constant:
(defstruct (const (:copier nil))
  value         ; value of the Constant
  form          ; form, that evaluates to value
  ltv-form      ; (LOAD-TIME-VALUE form) as it occurs in the source, or nil
  horizon       ; validity range of value and form:
                ; :VALUE  -  only value is valid
                ;            (then form is implicitly: form = `(QUOTE ,value))
                ; :ALL    -  value and form are both valid
                ; :FORM   -  only form is valid
  ;; For *compiling-from-file* = nil only :VALUE and :ALL are possible.
  ;; What is filled into the Fnode in the 3. Pass, is:
  ;;   For *compiling-from-file* = nil: only value.
  ;;   For *compiling-from-file* /= nil:
  ;;     If (eq horizon ':value), value, else form.
)
(defun const-value-safe (c)
  (if (eq (const-horizon c) :form)
    (compiler-error 'const-value c)
    (const-value c)))

;; In the 2nd Pass Variables with constantp=T are treated as Constants.


;;;;****           DECLARATION    MANAGEMENT

(defparameter *declaration-types*
  '(special ; Bindings
    type ftype function ; Types
    inline notinline ; Function-Compilation
    ignore optimize dynamic-extent ; Compiler-Hints
    declaration ; Additional Declarations
    ;; Types according to table 4-1 :
    array atom base-char base-string bignum bit bit-vector boolean character
    compiled-function complex cons double-float extended-char fixnum
    float function hash-table integer keyword list long-float nil null number
    package pathname random-state ratio rational readtable real sequence
    short-float simple-array simple-base-string simple-bit-vector
    simple-string simple-vector single-float standard-char stream string
    cs-cl:string string-char symbol t vector
    ;; Additional Declarations:
    compile ; statement, that the form resp. function is to be compiled
    sys::source ; the Source-Lambdabody (unexpanded) within a Lambdabody
    sys::in-defun ; indicates, which global function the Code belongs to
    ignorable ; marks variables as possibly ignorable
              ; (aside: Gensym-Variable are always automatically ignorable.)
    clos::dynamically-modifiable ; add/remove methods without a warning
    sys::read-only)) ; marks Variables as not assigned

;; passed by the Interpreter: %denv%

;; newly constructed:
(defvar *denv*)
;; *denv* has the same shape as %denv% and ends with %denv%.
;; *denv* has the shape (item1 ... itemn), with each item having the
;; construction type (declaration-type argument ...) .
;; special treatment of
;;   SPECIAL : is omitted, noted in *venv* instead.
;;   IGNORE, IGNORABLE : is omitted, worked up itself in the
;;                       processing form instead.
;; Additional Declaration (INLINING symbol) against recursive Inlining.

;; (declared-notinline fun denv) determines, if fun - a Symbol pointing to a
;; global function, which is not shadowed by a local function-definition -
;; is declared as NOTINLINE in denv.
;; How about local functions ??
(defun declared-notinline (fun &optional (denv *denv*))
  (when (member `(INLINING ,fun) *denv* :test #'equal)
    ;; never recursively expand a function inline!
    (return-from declared-notinline t))
  (loop
    (when (atom denv)
      (when *compiling-from-file*
        (when (member fun *notinline-functions* :test #'equal) (return t))
        (when (member fun *inline-functions* :test #'equal) (return nil)))
      (return (eq (get (get-funname-symbol fun) 'inlinable) 'notinline)))
    (let ((declspec (car denv)))
      (when (and (eq (car declspec) 'INLINE)
                 (member fun (cdr declspec) :test #'equal))
        (return nil))
      (when (and (eq (car declspec) 'NOTINLINE)
                 (member fun (cdr declspec) :test #'equal))
        (return t)))
    (setq denv (cdr denv))))

;; (declared-constant-notinline sym denv) determines,
;; if sym - a symbol pointing to a global constant,
;; that is not shadowed by a local variable-definition -
;; is declared as CONSTANT-NOTINLINE in denv.
(defun declared-constant-notinline (sym &optional (denv *denv*))
  (loop
    (when (atom denv)
      (when *compiling-from-file*
        (when (memq sym *notinline-constants*) (return t))
        (when (memq sym *inline-constants*) (return nil)))
      (return (eq (get sym 'constant-inlinable) 'constant-notinline)))
    (let ((declspec (car denv)))
      (when (and (eq (car declspec) 'CONSTANT-INLINE)
                 (memq sym (cdr declspec)))
        (return nil))
      (when (and (eq (car declspec) 'CONSTANT-NOTINLINE)
                 (memq sym (cdr declspec)))
        (return t)))
    (setq denv (cdr denv))))

;; (declared-declaration sym denv) determines whether sym is a valid
;; declaration specifier in denv.
(defun declared-declaration (sym &optional (denv *denv*))
  (loop
    (when (atom denv)
      (return nil))
    (let ((declspec (car denv)))
      (when (and (eq (first declspec) 'DECLARATION) (memq sym (rest declspec)))
        (return t)))
    (setq denv (cdr denv))))

;; top-level optimization settings
(defconstant *optimize* #.(make-hash-table :test 'stablehash-eq))

;; (declared-optimize quality) returns the optimization level for the given
;; quality, as an integer between 0 and 3 (inclusive).
;; quality - one of COMPILATION-SPEED, DEBUG, SAFETY, SPACE, SPEED.
;; Current/future assignments:
;; SAFETY >= 3 => keep function calls even to functions without side-effects
;;                (for ANSI CL 3.5)
;;        >= 2 =>
;;        >= 1 =>
;; DEBUG >= 3 =>
;;       >= 2 => every function has an exit restart [not implemented yet]
;;       >= 1 =>
;; SPACE >= 3 => discard arglist
;;       >= 2 => discard doc string
;;       >= 1 => never JIT compile
;; SPEED >= 3 =>
;;       >= 2 =>
;;       >= 1 =>
;; COMPILATION-SPEED >= 3 =>
;;                   >= 2 =>
;;                   >= 1 =>
(defun declared-optimize (quality &optional (denv *denv*))
  (loop
    (when (atom denv)
      (return-from declared-optimize (gethash quality *optimize* 1)))
    (let ((declspec (car denv)))
      (when (eq (car declspec) 'OPTIMIZE)
        ;; We cannot use ASSOC here (even though PROCESS-DECLARATIONS has
        ;; canonicalized the syntax to (quality value) in compiled code)
        ;; because a combination of interpreted and compiled code - e.g., via
        ;; the (COMPILE) declaration - will break.
        (dolist (spec (cdr declspec))
          (if (consp spec)
              (when (eq (first spec) quality)
                (return-from declared-optimize (second spec)))
              (when (eq spec quality)
                (return-from declared-optimize 3))))))
    (setq denv (cdr denv))))

;; return 2 values: the quality and the value
;; or issue a warning and return NIL
(defun parse-optimize-quality (spec)
  (let ((broken (if *compiling* #'c-warn 'warn))) ; WARN is not defined yet
    (let ((quality spec) (value 3))
      (if (or (symbolp spec)
              (and (consp spec) (symbolp (setq quality (car spec)))
                   (consp (cdr spec)) (realp (setq value (cadr spec)))
                   (null (cddr spec))))
        (if (memq quality '(COMPILATION-SPEED DEBUG SAFETY SPACE SPEED))
          (if (typep value '(INTEGER 0 3))
            (values quality value)
            (funcall broken (TEXT "Not a valid optimization level for ~S, should be one of 0, 1, 2, 3: ~S")
                     quality value))
          (funcall broken (TEXT "~S is not a valid ~S quality.") quality 'optimize))
        (funcall broken (TEXT "Not a valid ~S specifier: ~S") 'optimize spec)))))

;; check that X is either a SYMBOL or a (FUNCTION FUNCTION-NAME)
(defun symbol-or-function-p (x)
  (or (symbolp x)
      (and (consp x) (eq (car x) 'FUNCTION)
           (consp (cdr x))
           (function-name-p (cadr x))
           (null (cddr x)))))

;; (process-declarations declspeclist) analyzes the declarations (as they come
;; from PARSE-BODY) and returns:
;; a fresh list of the Special-declared symbols,
;; a fresh list of the Ignore-declared symbols,
;; a fresh list of the Ignorable-declared symbols,
;; a fresh list of the Read-Only-declared symbols,
;; a fresh list of other declaration specifiers.
(defun process-declarations (declspeclist)
  (setq declspeclist (nreverse declspeclist))
  (let ((specials '())
        (ignores '())
        (ignorables '())
        (readonlys '())
        (other '()))
    (dolist (declspec declspeclist)
      (if (or (atom declspec) (cdr (last declspec)))
        (c-warn (TEXT "Bad declaration syntax: ~S~%Will be ignored.")
                declspec)
        (let ((declspectype (car declspec)))
          (if (and (symbolp declspectype)
                   (or (memq declspectype *declaration-types*)
                       (declared-declaration declspectype)
                       (and *compiling-from-file*
                            (memq declspectype *user-declaration-types*))))
            (case declspectype
              ((SPECIAL)
               (dolist (x (cdr declspec))
                 (if (symbolp x)
                   (push x specials)
                   (c-warn (TEXT "Non-symbol ~S may not be declared ~S.")
                           x 'SPECIAL))))
              ((IGNORE)
               (dolist (x (cdr declspec))
                 (if (symbol-or-function-p x)
                   (push x ignores)
                   (c-warn (TEXT "Non-symbol ~S may not be declared ~S.")
                           x 'IGNORE))))
              ((IGNORABLE)
               (dolist (x (cdr declspec))
                 (if (symbol-or-function-p x)
                   (push x ignorables)
                   (c-warn (TEXT "Non-symbol ~S may not be declared ~S.")
                           x 'IGNORABLE))))
              ((SYS::READ-ONLY)
               (dolist (x (cdr declspec))
                 (if (symbolp x)
                   (push x readonlys)
                   (c-warn (TEXT "Non-symbol ~S may not be declared ~S.")
                           x 'READ-ONLY))))
              (t
               ;; Syntax check.
               (case declspectype
                 (TYPE
                  (setq declspec
                        (list* declspectype (second declspec)
                               (mapcan #'(lambda (x)
                                           (if (symbolp x)
                                             (list x)
                                             (progn
                                               (c-warn (TEXT "Non-symbol ~S may not be subject to a TYPE declaration.")
                                                       x)
                                               '())))
                                       (cddr declspec)))))
                 (FTYPE
                  (setq declspec
                        (list* declspectype (second declspec)
                               (mapcan #'(lambda (x)
                                           (if (function-name-p x)
                                             (list x)
                                             (progn
                                               (c-warn (TEXT "~S is not a function name and therefore may not be subject to a FTYPE declaration.")
                                                       x)
                                               '())))
                                       (cddr declspec)))))
                 ((INLINE NOTINLINE)
                  (setq declspec
                        (cons declspectype
                              (mapcan #'(lambda (x)
                                          (if (function-name-p x)
                                            (list x)
                                            (progn
                                              (c-warn (TEXT "~S is not a function name and therefore may not be declared ~S.")
                                                      x declspectype)
                                              '())))
                                      (cdr declspec)))))
                 (OPTIMIZE
                  (setq declspec
                        (cons declspectype
                              ;; Canonicalize, for easier search by quality.
                              (mapcan #'(lambda (x)
                                          (multiple-value-bind (q v)
                                              (parse-optimize-quality x)
                                            (and q `((,q ,v)))))
                                      (cdr declspec)))))
                 (DYNAMIC-EXTENT
                  (setq declspec
                        (cons declspectype
                              (mapcan #'(lambda (x)
                                          (if (symbol-or-function-p x)
                                            (list x)
                                            (progn
                                              (c-warn (TEXT "Not a valid ~S specifier: ~S")
                                                      'DYNAMIC-EXTENT x)
                                              '())))
                                      (cdr declspec)))))
                 (DECLARATION
                  (setq declspec
                        (list* declspectype (second declspec)
                               (mapcan #'(lambda (x)
                                           (if (symbolp x)
                                             (list x)
                                             (progn
                                               (c-warn (TEXT "Non-symbol ~S may not be subject to a DECLARATION declaration.")
                                                       x)
                                               '())))
                                       (cddr declspec)))))
                 (CLOS::DYNAMICALLY-MODIFIABLE
                  (when (cdr declspec)
                    (c-warn (TEXT "Arguments in ~S are not allowed") declspec)))
                 (COMPILE
                  (when (and (cdr declspec)
                             (not (and (consp (cdr declspec))
                                       (function-name-p (second declspec))
                                       (null (cddr declspec)))))
                    (c-warn (TEXT "The argument of a COMPILE declaration must be a function name: ~S")
                            declspec)
                    (setq declspec '(COMPILE)))))
               (push declspec other)))
            (c-warn (TEXT "Unknown declaration ~S.~%The whole declaration will be ignored.")
                    declspectype declspec)))))
    (values specials ignores ignorables readonlys other)))

;; (push-*denv* declspecs) extends *denv* by the declspecs.
;; declspecs must be a freshly consed list.
(defun push-*denv* (declspecs)
  (setq *denv* (nreconc declspecs *denv*)))

;;;;****             FUNCTION   MANAGEMENT

;; An FNODE contains the necessary Information for a Function:
(defstruct (fnode (:copier nil))
  name            ; Name, a Symbol or (SETF symbol)
  code            ; code of this function (first nothing, then an ANODE,
                  ; then a Closure)
  enclosing       ; function lexically containing this one, or NIL
  ;; Descriptions for the coming Closure:
  venvconst       ; Flag, if the Venv of this function has to be passed
                  ; explicitly on construction (or is always NIL)
  venvc           ; lookout of the Venv, that has to be passed to this function
                  ; on construction (if at all)
  Blocks-Offset   ; number of constants so far
  (Blocks nil)    ; List of Block-Constructs, that have to be passed
                  ; to this function on construction
  Tagbodys-Offset ; number of constants so far
  (Tags nil)      ; list of (tagbody . tag) defined in enclosing functions but
                  ; used by this function
  (Tagbodys nil)  ; List of Tagbody-Constructs, that have to be passed to this
                  ; function on construction
  Keyword-Offset  ; number of local constants so far
                  ; = start offset of the Keywords in FUNC
                  ; (equal to=0 if and only if the function is autonomously)
  (req-num 0)     ; number of required parameters
  (opt-num 0)     ; number of optional parameters
  (rest-flag nil) ; Flag, if &REST - Parameter is specified.
  (keyword-flag nil) ; Flag, if &KEY - Parameter is specified.
  (keywords nil)  ; List of Keyword-Constants (in the right order)
  allow-other-keys-flag         ; &ALLOW-OTHER-KEYS-Flag
  lambda-list     ; as passed to defun, discarded if SPACE >= 3
  documentation   ; discarded if SPACE >= 2
  (denv *denv*)   ; declaration environment at compilation time
  Consts-Offset   ; number of local constants so far
  (consts nil)    ; List of other constants of this function
                  ; this list is built up foremost in the second pass.
  (consts-forms nil) ; List of poss. Forms, that result in these constants
  (consts-ltv-forms nil) ; List of poss. (load-time-value ...) source forms
                  ; that correspond to these constants
  gf-p            ; Flag, if a generic function is produced
                  ; (implies Blocks-Offset = Tagbodys-Offset = Keyword-Offset
                  ;  = 0 or 1)
  ;; Notification of changes needed to be done in the enclosing function.
  far-used-vars     ; list of variables defined in enclosing functions but
                    ; used by this function
  far-assigned-vars ; list of variables defined in enclosing functions but
                    ; assigned by this function
  far-used-blocks   ; list of blocks defined in enclosing functions but
                    ; used by this function
  far-used-tagbodys ; list of (tagbody . tag) defined in enclosing
                    ; functions but used by this function
  ;; ignore declarations
  ignore                        ; declared (ignore #'name)
  ignorable                     ; declared (ignorable #'name)
  used                          ; actually used (not discarded)
)

;; the current function, an FNODE:
(defvar *func*)
;; the Label at the beginning of the Code of the current function:
(defvar *func-start-label*)

;; number of the so far occurred anonymous functions in the current function
;; (Lambda-Expressions):
(defvar *anonymous-count*)

;; *no-code* = T implies, that no Code is to be produced:
(defvar *no-code*)
;; this prevents, that Variables are put into the closure unnecessarily or
;; Optimizations are omitted unnecessarily.

;; Note that a variable is used by an inner fnode.
(defun note-far-used-var (var)
  (if (eq (var-fnode var) *func*)
    (setf (var-closurep var) t
          (var-really-usedp var) t)
    (pushnew var (fnode-far-used-vars *func*))))

;; Note that a variable is assigned by an inner fnode.
(defun note-far-assigned-var (var)
  (if (eq (var-fnode var) *func*)
    (setf (var-closurep var) t)
    (pushnew var (fnode-far-assigned-vars *func*))))

;; Note that a block is used by an inner fnode.
(defun note-far-used-block (block)
  (do ((fnode *func* (fnode-enclosing fnode)))
      ((eq fnode (block-fnode block)))
    (pushnew block (fnode-blocks fnode)))
  (setf (block-used-far block) t))

;; Note that a tag of a tagbody is used by an inner fnode.
(defun note-far-used-tagbody (tagbody+tag)
  (do* ((tagbody (car tagbody+tag)) (tb-fn (tagbody-fnode tagbody))
        (fnode *func* (fnode-enclosing fnode)))
       ((eq tb-fn fnode)
        (pushnew tagbody+tag (tagbody-used-far tagbody)))
    (pushnew tagbody+tag (fnode-Tags fnode))
    (pushnew tagbody (fnode-Tagbodys fnode))))

(defun propagate-far-used (fnode)
  ;; Propagate dependencies of fnode to the enclosing *func*.
  (mapc #'note-far-used-var (fnode-far-used-vars fnode))
  (mapc #'note-far-assigned-var (fnode-far-assigned-vars fnode))
  (mapc #'note-far-used-block (fnode-far-used-blocks fnode))
  (mapc #'note-far-used-tagbody (fnode-far-used-tagbodys fnode))
  ;; Nothing more to propagate, if propagate-far-used is called again.
  (setf (fnode-far-used-vars fnode) nil)
  (setf (fnode-far-assigned-vars fnode) nil)
  (setf (fnode-far-used-blocks fnode) nil)
  (setf (fnode-far-used-tagbodys fnode) nil))


;;;;****                 FORMS   MANAGEMENT

;; On each recursion the following variables are bound dynamically:
(defvar *form*)      ; the current form
(defvar *for-value*) ; if and which values of the Form are relevant:
                     ; NIL : values are irrelevant
                     ; ONE : only the first value is relevant
                     ; ALL : all values are relevant

;; An ANODE is the encoding of the information, that is needed for the
;; compilation of a form.
(defstruct (anode
             (:constructor mk-anode (#+CLISP-DEBUG source
                                     type
                                     #+CLISP-DEBUG sub-anodes
                                     seclass
                                     code
                                     #+CLISP-DEBUG stackz))
             (:copier nil))
  #+CLISP-DEBUG
  source        ; the source pertaining to this Form, mostly a Form
                ; (only needed for debugging purposes)
  type          ; Type of the ANODE (CALL, PRIMOP, VAR, LET, SETQ, ...)
  #+CLISP-DEBUG
  sub-anodes    ; all ANODEs of the sub-forms
  seclass       ; side effect classification
  code          ; generated LAP-Code, a List of LAP-statements and ANODEs
  #+CLISP-DEBUG
  stackz)       ; state of the Stacks on entry into the belonging LAP-Code
;; (make-anode ...) is the same as mk-anode, only that the arguments
;; are marked with keywords and unnecessary components
;; may stand there nevertheless because of #+CLISP-DEBUG.
(defmacro make-anode (&key
                      (source `*form*)
                      type
                      (sub-anodes `'())
                      seclass
                      code
                      (stackz `*stackz*))
  #-CLISP-DEBUG (declare (ignore source sub-anodes stackz))
  `(mk-anode #+CLISP-DEBUG ,source
             ,type
             #+CLISP-DEBUG ,sub-anodes
             ,seclass
             ,code
             #+CLISP-DEBUG ,stackz))

;; A Side-Effect-Class (SECLASS) is EITHER an Indicator
;;   (uses modifies uses-binding):
;; uses = NIL : this Anode can not be influenced by side-effects,
;;        List : this Anode depends on the value of the variables in the list,
;;        T : this Anode can possibly be influenced by every side-effect.
;; modifies = NIL : this Anode produces no side-effects
;;            list : ... produces side-effects only on the values of the
;;                    Variables in the list
;;            T : ... produces side-effects of unknown dimension.
;; uses-binding = NIL or list : this Anode depends on the fact that a binding
;;                              for the listed variables is in effect or not.
;;                              Only dynamic variables are in this list.
;;                T : ... can be influenced by binding any dynamic variable.
;; (Here, variables are VAR-Structures for lexical variables and symbols for
;; dynamic variables.)
;; Consequently:
;;   If the value is uninteresting, an ANODE with SECLASS-modifies=NIL
;;   can be omitted.
;;   For ANODEs with SECLASS, whose uses- and modifies-part are disjoint,
;;   the order of evaluation may be permuted.

;; FIXME1: foldability of compiled closures is not detected
;; FIXME2: RETURN-FROM, GO, HANDLER-BIND ==> *dirty-seclass*

;; SECLASS is a list, so that we can use MAPCAR in SECLASS-OR, SECLASS-WITHOUT.
;; If you modify SECLASS structure, you also need to update
;;  * the comment above
;;  * seclass_object() in lispbibl.d
;;  * parse_seclass() in record.d
(defstruct (seclass (:type list))
  (uses nil :read-only t)
  (modifies nil :read-only t)
  (uses-binding nil :read-only t))

(defconstant *seclass-pure* (make-seclass))
(defconstant *seclass-read* (make-seclass :uses 'T))
(defconstant *seclass-dirty*
  (make-seclass :uses 'T :uses-binding 'T :modifies 'T))

;; Side-Effect-Classes can also be attached to functions, not only to anodes.
;; The SECLASS of a function can also be:
;; NIL, which means that the function is constant-FOLDABLE
;;   (i.e. two calls with identical arguments give the same result,
;;    and calls with constant arguments can be evaluated at compile time;
;;    in particular, no side effects, does not depend on global variables or
;;    such, and does not even look "inside" its arguments).
(proclaim '(inline seclass-foldable-p))
(defun seclass-foldable-p (seclass) (null seclass))
(defconstant *seclass-foldable* NIL)

;; (seclass-or class1 class2) determines the total class of execution
(defun seclass-or (seclass1 seclass2)
  (if (seclass-foldable-p seclass1)
    (if (seclass-foldable-p seclass2)
      *seclass-foldable*
      seclass2)
    (if (seclass-foldable-p seclass2)
      seclass1
      (mapcar #'(lambda (l1 l2)
                  (if (or (eq l1 'T) (eq l2 'T))
                    'T
                    (union l1 l2)))
              seclass1 seclass2))))

;; So that the list of sub-anodes does not have to be calculated, however
;; the anode's side-effect-class belonging to this list can be calculated:
(defmacro anodes-seclass-or (&rest anodeforms)
  (reduce #'(lambda (form1 form2) `(SECLASS-OR ,form1 ,form2)) anodeforms
          :key #'(lambda (anodeform) `(ANODE-SECLASS ,anodeform))
          :initial-value *seclass-foldable*))
(define-modify-macro seclass-or-f (anode) seclass-or-anode)
(defmacro seclass-or-anode (seclass anode)
  `(SECLASS-OR ,seclass (ANODE-SECLASS ,anode)))
(defun anodelist-seclass-or (anodelist)
  (reduce #'seclass-or anodelist :key #'anode-seclass
          :initial-value *seclass-foldable*))

;; side-effects to lexical variables bound further inwards don't count
;; and are therefore eliminated:
(defun seclass-without (seclass varlist)
  ;; (dynamic variables are not eliminated; they are contained in varlist
  ;; as VAR-structures and in seclass as symbols.)
  (if (seclass-foldable-p seclass)
    *seclass-foldable*
    (mapcar #'(lambda (l)
                (if (eq l 'T)
                  'T
                  ;; same as (set-difference l varlist)
                  (remove-if #'(lambda (var) (memq var varlist)) l)))
            seclass)))

;; determines, if the order of evaluation of two anodes can be permuted -
;; so long as the stack-states permit this.
(defun anodes-commute (anode1 anode2)
  (seclasses-commute (anode-seclass anode1) (anode-seclass anode2)))
(defun seclasses-commute (seclass1 seclass2)
  (flet ((disjoint-p (uses modifies)
           (or (null uses) (null modifies)
               (and (not (eq uses 'T)) (not (eq modifies 'T))
                    (null (intersection uses modifies))))))
    (and (disjoint-p (seclass-uses seclass1) (seclass-modifies seclass2))
         (disjoint-p (seclass-uses seclass2) (seclass-modifies seclass1)))))

(proclaim '(inline anode-side-effect-free-p))
(defun anode-side-effect-free-p (anode)
  (null (seclass-modifies (anode-seclass anode))))

;;;;****            AUXILIARY   FUNCTIONS

;; disjoints a function name in Package and String.
(defun get-funname-string+pack (funname)
  (if (atom funname)
    (values (symbol-name funname) (symbol-package funname))
    (values (string-concat "(" (symbol-name (first funname)) " "
                               (symbol-name (second funname)) ")")
            (symbol-package (second funname)))))

;; returns a function name, that is composed by the package and the
;; printname of a given function name, a hyphen and a suffix.
(defun symbol-suffix (funname suffix)
  ;; We have 8 cases:
  ;;
  ;;        \ suffix   |  function name      number
  ;; funname \         |
  ;; --------------------------------------------------------------------
  ;; nil               |  suffix             suffix as uninterned symbol
  ;; #:symbol          |  suffix             concatenate
  ;; pack::symbol      |  concatenate        concatenate
  ;; list              |  concatenate        concatenate
  ;; --------------------------------------------------------------------
  (if (and (symbolp funname) (not (and funname (symbol-package funname)))
           (function-name-p suffix))
    suffix
    (progn
      ;; convert suffix to a string:
      (cond ((symbolp suffix) (setq suffix (symbol-name suffix)))
            ((not (stringp suffix))
             (setq suffix (write-to-string suffix :escape nil :base 10
                                           :radix nil :readably nil))))
      (if funname
        (multiple-value-bind (name pack) (get-funname-string+pack funname)
          ;; build new symbol:
          (let ((new-name (string-concat name "-" suffix)))
            (if pack
                (let ((lockp (package-lock pack)) sym)
                  (setf (package-lock pack) nil)
                  (setq sym (intern new-name pack))
                  (setf (package-lock pack) lockp)
                  sym)
                (make-symbol new-name))))
        (make-symbol suffix)))))

;; (C-COMMENT controlstring . args)
;; issue additional information from the compiler (via FORMAT).
(defun c-comment (cstring &rest args)
  (let ((dest (if *compile-verbose* *c-error-output* *c-listing-output*)))
    (when dest
      (fresh-line dest)
      (apply #'format dest cstring args)
      (elastic-newline dest))))

(defstruct c-source-point
  (lineno1 *compile-file-lineno1*)
  (lineno2 *compile-file-lineno2*)
  (file *compile-file-truename*))

;; (C-SOURCE-LOCATION)
;; returns a description of the location in the source.
(defun c-source-location (&optional (lineno1 *compile-file-lineno1*)
                          (lineno2 *compile-file-lineno2*)
                          (file *compile-file-truename*))
  (if (and file lineno1 lineno2)
    (string-concat
      ;; the first check is: "are we in the same file"?
      ;; we check for `*compile-file-pathname*' too since
      ;; `match-known-unknown-functions' binds `*compile-file-truename*'
      ;; (to pass the right value to this function!)
      (format nil (if (and *compile-file-pathname*
                           (equalp file *compile-file-truename*))
                    #1=""
                    (format nil (TEXT " in file ~S ") file)))
      (format nil (if (= lineno1 lineno2)
                    (TEXT " in line ~D ")
                    (TEXT " in lines ~D..~D "))
              lineno1 lineno2))
    #1#))

(defun c-source-point-location (point)
  (c-source-location (c-source-point-lineno1 point)
                     (c-source-point-lineno2 point)
                     (c-source-point-file point)))

(defun current-function ()
  (and (boundp '*func*) (fnode-p *func*) (fnode-name *func*)))
;; check whether we are now defining FUN (maybe defining some internals)
(defun defining-p (fun)
  (member `(SYS::IN-DEFUN ,fun) *denv* :test #'equal))
;; check whether we are now inside the DEFUN FUN
(defun in-defun-p (fun)
  (and (equal fun (current-function)) (defining-p fun)))

(defun c-current-location (&optional (in-function (current-function)))
  (let ((f (if in-function (format nil (TEXT "in ~S ") in-function) #1=""))
        (l (c-source-location)))
    (if (and (string= f #1#) (string= l #1#))
      #1#
      (string-concat f l ": "))))

(predefun c-warning (type cstring &rest args)
  (declare (ignore type))
  (apply #'c-comment
         (string-concat (TEXT "WARNING: ~A") "~%" cstring)
         (c-current-location) args))

;;; (C-WARN format-control-string . args)
;;; issue a compilation warning using FORMAT.
(defun c-warn (cstring &rest args)
  (apply 'c-warning 'sys::simple-warning cstring args))

; (C-STYLE-WARN controlstring . args)
; issue a style-warning (via FORMAT).
(defun c-style-warn (cstring &rest args)
  (apply 'c-warning 'sys::simple-style-warning cstring args))

;; continuable compiler error
(predefun c-cerror (location detail cstring &rest args)
  (declare (ignore detail))
  (fresh-line *c-error-output*)
  (format *c-error-output* (TEXT "ERROR: ~A") location)
  (terpri *c-error-output*)
  (apply #'format *c-error-output* cstring args)
  (elastic-newline *c-error-output*))

;; (C-ERROR controlstring . args)
;; issue a compiler error (via FORMAT) and terminate the current C-FORM.
(defun c-error (detail cstring &rest args)
  (incf *error-count*)
  (let ((in-function (current-function)))
    (when in-function
      (when *compiling-from-file*
        (pushnew in-function *functions-with-errors*)))
    (apply 'c-cerror (c-current-location in-function) detail cstring args))
  (throw 'c-error
    (make-anode :source NIL
                :type 'ERROR
                :sub-anodes '()
                :seclass *seclass-pure*
                :code '((NIL)))))

;; the 2nd return value of `compile' and `compile-file'
(defun compile-warnings-p ()
  (let ((count (+ *error-count* *warning-count*)))
    (if (zerop count) nil count)))

;; the 3rd return value of `compile' and `compile-file'
(defun compile-failure-p ()
  (let ((count (+ *error-count* (- *warning-count* *style-warning-count*))))
    (if (zerop count) nil count)))

;; caught c-error
(defmacro c-error-c (&rest args) `(catch 'c-error (c-error ,@args)))

;; (c-write-lib form) write the form to the lib-file
(defun c-write-lib (form)
  (when (and *compiling-from-file* *liboutput-stream*)
    ;; write form to the liboutput stream:
    (unless (eq (car form) 'progn)
      (compiler-error 'c-write-lib form))
    (dolist (fo (cdr form))
      (unless (constantp fo)
        (write fo :stream *liboutput-stream* :pretty t
                ; :closure t :circle t :array t :gensym t
                ; :escape t :level nil :length nil :radix t
                  :readably t :right-margin 79)
        (terpri *liboutput-stream*)))))
(defun c-eval-and-write-lib (form) (c-write-lib form) (eval form))
(defmacro eval-when-compile (&body body)
  `(eval-when (compile) (c-eval-and-write-lib '(progn ,@body))))

;; Test whether FORM - already known to be a cons - is of the form
;; (QUOTE object)
(defun quote-p (form)
  (and (eq (first form) 'QUOTE) (consp (cdr form)) (null (cddr form))))

;; (l-constantp form) determines, if form may be handled in the compiler
;; as load-time-constant.
(defun l-constantp (form)
  (if (atom form)
    (or (numberp form) (characterp form) (arrayp form) (hash-table-p form)
        (and (symbolp form)
             (cond ((keywordp form) t)
                   ((eq (symbol-package form) *lisp-package*)
                    (constantp form))
                   (t (not (null (assoc form *constant-special-vars*)))))))
    (quote-p form)))

;; (c-constantp form) determines, if form may be handled in the compiler
;; as compile-time-constant, and if the value is known and may be inserted
;; inline.
;; When *compiling-from-file* = nil , this is identical to (l-constantp form) .
(defun c-constantp (form)
  (if (atom form)
    (or (numberp form) (characterp form) (arrayp form) (hash-table-p form)
        (and (symbolp form)
             (cond ((keywordp form) t)
                   ((and *compiling-from-file*
                         (declared-constant-notinline form))
                    nil)
                   ((eq (symbol-package form) *lisp-package*)
                    (constantp form))
                   (t (not (null (assoc form *constant-special-vars*)))))))
    (quote-p form)))

;; (c-constant-value form) returns the value of a constant.
;; (c-constantp form) is required.
(defun c-constant-value (form)
  (if (atom form)
    (cond ((numberp form) form)
          ((characterp form) form)
          ((arrayp form) form)
          ((hash-table-p form) form)
          ((symbolp form)
           (cond ((keywordp form) form)
                 ((eq (symbol-package form) *lisp-package*)
                  (symbol-value form))
                 (t (cdr (assoc form *constant-special-vars*)))))
          (t (compiler-error 'c-constant-value form)))
    (second form)))

;; (anode-constantp anode) determines, if the Anode returns a constant
;; value (also known at compile-time).
(defun anode-constantp (anode)
  ;; Anode returns a constant value at all events, if its code consisted
  ;; (after TRAVERSE-ANODE) exactly of ((CONST ...)) .
  (let ((code (anode-code anode)))
    (and (consp code) (null (cdr code)) ; list of length 1
         (let ((item (car code)))
            (cond ((consp item)
                   (and (eq (first item) 'CONST)
                        (not (eq (const-horizon (second item)) ':form))))
                  ((anode-p item) (anode-constantp item)))))))

;; (anode-constant-value anode) returns the value of a constant Anode.
(defun anode-constant (anode)
  (let ((item (car (anode-code anode))))
    (cond ((consp item) (second item))
          (t #|(anode-p item)|# (anode-constant item)))))
(defun anode-constant-value (anode)
  (const-value-safe (anode-constant anode)))

;; (new-const value) returns a constant in *func* with the Value value
(defun new-const (value)
  (make-const :horizon ':value :value value))

;; (make-label for-value) returns a fresh label. for-value (NIL/ONE/ALL)
;; indicates, which of the values are needed after the label.
(defun make-label (for-value)
  (let ((label (gensym)))
    (setf (symbol-value label) '()) ; reference list for 2nd Pass := empty
    (setf (get label 'for-value) for-value)
    label))

;; returns a Special-Variable
(defun make-special-var (symbol)
  (make-var :name symbol :specialp t
            :constantp (l-constantp symbol)
            :constant (if (l-constantp symbol)
                        (if (c-constantp symbol)
                          (make-const :horizon ':all
                                      :value (c-constant-value symbol)
                                      :form symbol)
                          (make-const :horizon ':form
                                      :form symbol)))))


;;;;****                     FIRST   PASS

;; (test-list L) determines, if L is a real list, that ends with NIL
;; and has at least l1, but at most l2 elements. Else: Error.
(defun test-list (L &optional (l1 0) (l2 nil))
  (unless (and (listp L) (null (cdr (last L))))
    (c-error L (TEXT "Code contains dotted list ~S") L))
  (unless (>= (length L) l1)
    (c-error L (TEXT "Form too short, too few arguments: ~S") L))
  (when l2
    (unless (<= (length L) l2)
      (c-error L (TEXT "Form too long, too many arguments: ~S") L))))

;; c-form-table contains the handler function (to be called without arguments)
;; for all functions/specialforms/macros, that have to be treated specially.
(defconstant c-form-table
  (let ((hashtable (make-hash-table :key-type 'symbol :value-type '(or symbol function)
                                    :test 'stablehash-eq :warn-if-needs-rehash-after-gc t)))
    (mapc
     #'(lambda (acons) (setf (gethash (car acons) hashtable) (cdr acons)))
     `(;; Special forms:
       (QUOTE . c-QUOTE)
       (PROGN . c-PROGN)
       (LET . ,#'(lambda () (c-LET/LET* nil)))
       (LET* . ,#'(lambda () (c-LET/LET* t)))
       (IF . c-IF)
       (SETQ . c-SETQ)
       (BLOCK . c-BLOCK)
       (RETURN-FROM . c-RETURN-FROM)
       (TAGBODY . c-TAGBODY)
       (GO . c-GO)
       (FUNCTION . c-FUNCTION)
       (MULTIPLE-VALUE-BIND . c-MULTIPLE-VALUE-BIND)
       (MULTIPLE-VALUE-SETQ . c-MULTIPLE-VALUE-SETQ)
       (AND . c-AND)
       (OR . c-OR)
       (WHEN . c-WHEN)
       (UNLESS . c-UNLESS)
       (COND . c-COND)
       (CASE . c-CASE)
       (FCASE . c-CASE)
       (PSETQ . c-PSETQ)
       (MULTIPLE-VALUE-CALL . c-MULTIPLE-VALUE-CALL)
       (PROG1 . c-PROG1)
       (PROG2 . c-PROG2)
       (THE . c-THE)
       (CATCH . c-CATCH)
       (THROW . c-THROW)
       (UNWIND-PROTECT . c-UNWIND-PROTECT)
       (PROGV . c-PROGV)
       (MULTIPLE-VALUE-LIST . c-MULTIPLE-VALUE-LIST)
       (MULTIPLE-VALUE-PROG1 . c-MULTIPLE-VALUE-PROG1)
       (FLET . c-FLET)
       (LABELS . c-LABELS)
       (MACROLET . c-MACROLET)
       (SYSTEM::FUNCTION-MACRO-LET . c-FUNCTION-MACRO-LET)
       (SYMBOL-MACROLET . c-SYMBOL-MACROLET)
       (COMPILER-LET . c-COMPILER-LET)
       (EVAL-WHEN . c-EVAL-WHEN)
       (DECLARE . c-DECLARE)
       (LOAD-TIME-VALUE . c-LOAD-TIME-VALUE)
       (COMPILE-TIME-VALUE . c-COMPILE-TIME-VALUE)
       (LOCALLY . c-LOCALLY)
       ;; Macros:
       (%GENERIC-FUNCTION-LAMBDA . c-%GENERIC-FUNCTION-LAMBDA)
       (%OPTIMIZE-FUNCTION-LAMBDA . c-%OPTIMIZE-FUNCTION-LAMBDA)
       (CLOS:GENERIC-FLET . c-GENERIC-FLET)
       (CLOS:GENERIC-LABELS . c-GENERIC-LABELS)
       (HANDLER-BIND . c-HANDLER-BIND)
       (SYS::%HANDLER-BIND . c-%HANDLER-BIND)
       (SYS::CONSTANT-EQL . c-CONSTANT-EQL)
       (WITHOUT-PACKAGE-LOCK . c-WITHOUT-PACKAGE-LOCK)
       ;; Inline-compiled functions:
       (FUNCALL . c-FUNCALL)
       (APPLY . c-APPLY)
       (+ . c-PLUS)
       (* . c-STAR)
       (- . c-MINUS)
       (/ . c-SLASH)
       (= . c-COMPARE-NUMBERS)
       (/= . c-COMPARE-NUMBERS)
       (< . c-COMPARE-NUMBERS)
       (<= . c-COMPARE-NUMBERS)
       (> . c-COMPARE-NUMBERS)
       (>= . c-COMPARE-NUMBERS)
       (SYS::SVSTORE . c-SVSTORE)
       (EQ . c-EQ)
       (EQL . c-EQL)
       (EQUAL . c-EQUAL)
       (MAPCAR . c-MAPCAR)
       (MAPLIST . c-MAPLIST)
       (MAPC . c-MAPC)
       (MAPL . c-MAPL)
       (MAPCAN . c-MAPCAN)
       (MAPCON . c-MAPCON)
       (MAPCAP . c-MAPCAP)
       (MAPLAP . c-MAPLAP)
       (TYPEP . c-TYPEP)
       (FORMAT . c-FORMAT)
       (SORT . c-SORT)
       (STABLE-SORT . c-SORT)   ; => never occurs in compiled code!
       (NTH . c-NTH)
       (SYSTEM::%SETNTH . c-SETNTH)
       ;; Special case for LIST
       (MAP . c-MAP)
       (MAP-INTO . c-MAP-INTO)
       (SOME . c-SOME)
       (EVERY . c-EVERY)
       (NOTANY . c-NOTANY)
       (NOTEVERY . c-NOTEVERY)
       ;; Special case for LIST, and COMPLEMENT tricks
       (REMOVE-IF . c-REMOVE-IF)
       (REMOVE-IF-NOT . c-REMOVE-IF-NOT)
       (DELETE-IF . c-DELETE-IF)
       (DELETE-IF-NOT . c-DELETE-IF-NOT)
       (SUBSTITUTE-IF . c-SUBSTITUTE-IF)
       (SUBSTITUTE-IF-NOT . c-SUBSTITUTE-IF-NOT)
       (NSUBSTITUTE-IF . c-NSUBSTITUTE-IF)
       (NSUBSTITUTE-IF-NOT . c-NSUBSTITUTE-IF-NOT)
       (FIND-IF . c-FIND-IF)
       (FIND-IF-NOT . c-FIND-IF-NOT)
       (POSITION-IF . c-POSITION-IF)
       (POSITION-IF-NOT . c-POSITION-IF-NOT)
       (COUNT-IF . c-COUNT-IF)
       (COUNT-IF-NOT . c-COUNT-IF-NOT)
       ;; COMPLEMENT tricks
       (SUBST-IF . c-SUBST-IF)
       (SUBST-IF-NOT . c-SUBST-IF-NOT)
       (NSUBST-IF . c-NSUBST-IF)
       (NSUBST-IF-NOT . c-NSUBST-IF-NOT)
       (MEMBER-IF . c-MEMBER-IF)
       (MEMBER-IF-NOT . c-MEMBER-IF-NOT)
       (ASSOC-IF . c-ASSOC-IF)
       (ASSOC-IF-NOT . c-ASSOC-IF-NOT)
       (RASSOC-IF . c-RASSOC-IF)
       (RASSOC-IF-NOT . c-RASSOC-IF-NOT)
       (ADJOIN . c-TEST/TEST-NOT)
       (NSET-DIFFERENCE . c-TEST/TEST-NOT)
       (SEARCH . c-TEST/TEST-NOT)
       (ASSOC . c-TEST/TEST-NOT)
       (NSET-EXCLUSIVE-OR . c-TEST/TEST-NOT)
       (SET-DIFFERENCE . c-TEST/TEST-NOT)
       (COUNT . c-TEST/TEST-NOT)
       (NSUBLIS . c-TEST/TEST-NOT)
       (SET-EXCLUSIVE-OR . c-TEST/TEST-NOT)
       (DELETE . c-TEST/TEST-NOT)
       (NSUBST . c-TEST/TEST-NOT)
       (SUBLIS . c-TEST/TEST-NOT)
       (DELETE-DUPLICATES . c-TEST/TEST-NOT)
       (NSUBSTITUTE . c-TEST/TEST-NOT)
       (SUBSETP . c-TEST/TEST-NOT)
       (FIND . c-TEST/TEST-NOT)
       (NUNION . c-TEST/TEST-NOT)
       (SUBST . c-TEST/TEST-NOT)
       (INTERSECTION . c-TEST/TEST-NOT)
       (POSITION . c-TEST/TEST-NOT)
       (SUBSTITUTE . c-TEST/TEST-NOT)
       (MEMBER . c-TEST/TEST-NOT)
       (RASSOC . c-TEST/TEST-NOT)
       (TREE-EQUAL . c-TEST/TEST-NOT)
       (MISMATCH . c-TEST/TEST-NOT)
       (REMOVE . c-TEST/TEST-NOT)
       (UNION . c-TEST/TEST-NOT)
       (NINTERSECTION . c-TEST/TEST-NOT)
       (REMOVE-DUPLICATES . c-TEST/TEST-NOT)
       ;;
       (CONCATENATE . c-CONCATENATE)
       (LDB . c-LDB)
       (LDB-TEST . c-LDB-TEST)
       (MASK-FIELD . c-MASK-FIELD)
       (DPB . c-DPB)
       (DEPOSIT-FIELD . c-DEPOSIT-FIELD)))
    hashtable))
;; This table must contain all Special-Forms:
(do-all-symbols (sym)
  (when (and (special-operator-p sym) (not (gethash sym c-form-table)))
    (compiler-error 'c-form-table sym)))

;; Expand compiler macros at the outermost level of the given form.
;; Return the replacement form, and as second value a boolean indicating
;; whether some expansion was made.
(defun expand-compiler-macro (form)
  (let ((expanded-p nil))
    (tagbody
     reexpand
       (when (consp form)
         (let ((fun (car form)))
           (when (and (function-name-p fun) (not (declared-notinline fun)))
             (let* ((env (env))
                    (cmf (compiler-macro-function fun env)))
               (when cmf
                 (let ((cmf-result (funcall cmf form env)))
                   ;; ANSI CL, glossary of "compiler macro function", says
                   ;; that a result of NIL means no replacement.
                   (unless (or (eq cmf-result 'nil) (eq cmf-result form))
                     (setq form cmf-result
                           expanded-p t)
                     (go reexpand)))))))))
    (values form expanded-p)))

;; check whether the form is a '(LAMBDA ...)
(proclaim '(inline lambda-form-p))
(defun lambda-form-p (form)
  (and (consp form) (eq (car form) 'LAMBDA) (consp (cdr form))))

;; compiles a form.
;; No code is generated, if no values are needed and the form
;; does not produce side effects.
(defun c-form (*form* &optional (*for-value* *for-value*))
 (let
  ((anode
    (catch 'c-error
      (if (atom *form*)
        (if (symbolp *form*)
          (multiple-value-bind (macrop expansion)
              (venv-search-macro *form* *venv*)
            (if macrop ; Symbol-Macro ?
              (c-form expansion) ; -> expand
              (c-VAR *form*)))
          (c-CONST))
        (let ((fun (first *form*)))
          (if (function-name-p fun)
            (multiple-value-bind (a m f1 f2 f3 f4) (fenv-search fun)
              (declare (ignore f2 f4))
              (if (null a)
                ;; no local definition
                (multiple-value-bind (expansion expanded-p)
                    (expand-compiler-macro *form*)
                  (if expanded-p
                    (c-form expansion) ; -> expand
                    (let ((handler
                            (and (symbolp fun) (gethash fun c-form-table))))
                      (if handler ; found handler function?
                        ;; ==> (symbolp fun) = T
                        (if (or (and (special-operator-p fun)
                                     (not (macro-function fun)))
                                (not (declared-notinline fun)))
                          (funcall handler) ; yes -> call
                          (if (macro-function fun)
                            (c-form (mac-exp (macro-function fun) *form*))
                            ;; normal global function call
                            (c-GLOBAL-FUNCTION-CALL fun)))
                        ;; no -> not a special-form anyway
                        ;; (all those are in the c-form-table)
                        (if (and (symbolp fun) (macro-function fun))
                          ;; global macro
                          (c-form (mac-exp (macro-function fun) *form*))
                          ;; global function
                          (if (and (in-defun-p fun)
                                   (not (declared-notinline fun)))
                            ;; recursive call of the current global function
                            (c-LOCAL-FUNCTION-CALL fun (cons *func* nil)
                                                   (cdr *form*))
                            ;; normal call of the global function
                            (c-GLOBAL-FUNCTION-CALL fun)))))))
                (if (and m (not (and f1 (declared-notinline fun))))
                  (c-form (mac-exp m *form*))
                  (case f1
                    (GLOBAL ; found in the interpreter environment %fenv%
                     ; (c-form `(FUNCALL (FUNCTION ,fun) ,@(cdr *form*)))
                     (c-FUNCALL-NOTINLINE `(FUNCTION ,fun) (cdr *form*)))
                    (LOCAL  ; local function (found in *fenv*)
                     ; (c-form `(FUNCALL (FUNCTION ,fun) ,@(cdr *form*)))
                     (c-LOCAL-FUNCTION-CALL fun f3 (cdr *form*)))
                    (t (compiler-error 'c-form f1))))))
            (if (lambda-form-p fun)
              (c-form `(FUNCALL (FUNCTION ,fun) ,@(cdr *form*)))
              #| not: (c-LAMBDA-FUNCTION-CALL fun (cdr *form*)) |#
              (c-error fun (TEXT "Not the name of a function: ~S") fun))))))))
  #+CLISP-DEBUG (setf (anode-source anode) *form*)
  ;; If no values are needed and no side effects are produced,
  ;; the appendant code can be discarded completely:
  (when (and (null *for-value*) (anode-side-effect-free-p anode))
    (setf (anode-code anode) '())
    (setf (anode-seclass anode) *seclass-pure*))
  anode))

;;; Macroexpand a form.
;;; That is exactly what c-form does later anyway.
;;; (c-form (macroexpand-form form)) == (c-form form).
(defun macroexpand-form (form)
  ;; The difference from  (values (macroexpand form (env)))  is that here
  ;; 1. compiler macros expanders are preferred over normal macro expanders,
  ;; 2. the macros mentioned in 'c-form-table' are not expanded.
  (tagbody
   reexpand
    (setq form (expand-compiler-macro form))
    (if (atom form)
      (if (symbolp form)
        (multiple-value-bind (macrop expansion) (venv-search-macro form *venv*)
          (if macrop
            (progn (setq form expansion) (go reexpand))
            (go done)))
        (go done))
      (let ((fun (first form)))
        (if (function-name-p fun)
          (multiple-value-bind (a m f1 f2 f3 f4) (fenv-search fun)
            (declare (ignore f2 f3 f4))
            (if a               ; locally defined
              (when f1          ; local function?
                (setq m nil))
              ;; no local definition
              (when (and (symbolp fun) (macro-function fun) ; global macro?
                         (not (gethash fun c-form-table)))
                (setq m (macro-function fun))))
            (if m               ; macro?
              (progn
                (setq form (mac-exp m form)) ; -> expand
                (go reexpand))
              (go done)))
          (go done))))
    done
    (return-from macroexpand-form form)))

;; compile NIL (a kind of emergency exit)
(defun c-NIL ()
  (make-anode :type 'NIL
              :sub-anodes '()
              :seclass *seclass-foldable*
              :code '((NIL))))

;; constant as form:
(defun c-CONST ()
  (make-anode :type 'const
              :sub-anodes '()
              :seclass (if (c-constantp *form*) *seclass-foldable* *seclass-pure*)
              :code `((CONST ,(new-const *form*)))))

;; variable as Form:
(defun c-VAR (symbol)
  ;; search the variable in *venv* :
  (multiple-value-bind (a b c) (venv-search symbol)
    (when (eq a 'NIL)
      (c-warn (TEXT "~S is neither declared nor bound,~@
                     it will be treated as if it were declared SPECIAL.")
              symbol)
      (when *compiling-from-file*
        (pushnew symbol *unknown-free-vars* :test #'eq))
      (setq a 'SPECIAL))
    (case a
      (SPECIAL ; special variable
        (let ((var (make-special-var symbol)))
          (make-anode
            :type 'VAR
            :sub-anodes '()
            :seclass (if (var-constantp var) *seclass-foldable*
                         (make-seclass :uses (if *for-value*
                                                 (list symbol) 'NIL)))
            :code (if *for-value*
                    (if (var-constantp var)
                      `((CONST ,(make-const
                                 ;; Keywords are not needed in #. syntax
                                 :horizon (if (keywordp symbol) ':value ':all)
                                 :value (c-constant-value symbol)
                                 :form symbol)))
                      `((GETVALUE ,symbol)))
                    '()))))
      (LOCAL ; interpreted, lexical
        (make-anode
          :type 'VAR
          :sub-anodes '()
          :seclass (make-seclass :uses (if *for-value* 'T 'NIL))
          :code (if *for-value*
                  `((CONST ,(new-const b)) ; Vector
                    (PUSH)
                    (CONST ,(new-const c)) ; Index
                    (SVREF NIL))
                  '())))
      ((T) ; lexically in Stack or Closure
        (let* ((var b)
               (get-anode
                 (make-anode
                   :type 'VAR
                   :sub-anodes '()
                   :seclass (make-seclass
                             :uses (if *for-value* (list var) 'NIL))
                   :code (if *for-value*
                           `((GET ,var ,*venvc* ,*stackz*))
                           '()))))
          (push get-anode (var-usedp var))
          (when *for-value*
            (setf (var-for-value-usedp var) t)
            (unless *no-code*
              (unless (eq (stackz-fun (var-stackz var)) (var-fnode var))
                (compiler-error 'c-VAR "VAR-FNODE"))
              (if (eq (var-fnode var) *func*)
                (setf (var-really-usedp var) t)
                (note-far-used-var var))))
          get-anode))
      (t (compiler-error 'c-VAR 'venv-search)))))

;; variable assignment:
(defun c-VARSET (symbol value-anode for-value)
  ;; search the variable in *venv* :
  (multiple-value-bind (a b c) (venv-search symbol)
    (when (eq a 'NIL)
      (c-warn (TEXT "~S is neither declared nor bound,~@
                     it will be treated as if it were declared SPECIAL.")
              symbol)
      (setq a 'SPECIAL))
    (case a
      (SPECIAL ; special variable
        (let ((var (make-special-var symbol)))
          (make-anode :type 'VARSET
                      :sub-anodes '()
                      :seclass
                        (if (var-constantp var)
                          *seclass-pure*
                          (make-seclass :uses-binding (list symbol)
                                        :modifies (list symbol)))
                      :code (if (var-constantp var)
                              (progn
                                (c-warn
                                 (TEXT "The constant ~S may not be assigned to.~@
                                        The assignment will be ignored.")
                                        symbol)
                                '((VALUES1)))
                              `((SETVALUE , symbol))))))
      (LOCAL ; interpreted, lexical
        (make-anode :type 'VARSET
                    :sub-anodes '()
                    :seclass (make-seclass :modifies 'T)
                    :code `((PUSH)
                            (CONST ,(new-const b)) ; Vector
                            (PUSH)
                            (CONST ,(new-const c)) ; Index
                            (SVSET))))
      ((T) ; lexically in Stack or Closure
        (let* ((var b)
               (set-anode
                 (make-anode :type 'VARSET
                             :sub-anodes '()
                             :seclass (make-seclass :modifies (list var))
                             :code `((SET ,var ,*venvc* ,*stackz*)))))
          ;; assignment "uses" the Variable
          (unless (var-usedp var) (setf (var-usedp var) t))
          (setf (var-assignedp var) t)
          (unless *no-code*
            (setf (var-constantp var) nil) ; not constant anymore due to assignment
            (push (list* value-anode set-anode for-value)
                  (var-modified-list var))
            (unless (eq (stackz-fun (var-stackz var)) (var-fnode var))
              (compiler-error 'c-VARSET "VAR-FNODE"))
            (unless (eq (var-fnode var) *func*)
              (note-far-assigned-var var))
            ;; the replacement of a variable innervar by var is not
            ;; allowed, if during the existence of innervar
            ;; a value is assigned to var.
            (setf (var-replaceable-list var)
              (delete-if #'(lambda (innervar-info) ; innervar currently active?
                             (let ((innervar (first innervar-info)))
                               (tailp (var-stackz innervar) *stackz*)))
                         (var-replaceable-list var))))
          set-anode))
      (t (compiler-error 'c-VARSET 'venv-search)))))

;; function calls, for which the function is a Symbol or (SETF symbol) :

(defun make-funname-const (name)
  (if (atom name)
    (new-const name)
    (let ((symbol (second name)))
      (make-const :horizon ':all
                  :value (system::get-setf-symbol symbol)
                  :form `(SYSTEM::GET-SETF-SYMBOL ',symbol)))))

(defun proclaimed-inline-p (fun)
  (eq (get (get-funname-symbol fun) 'inlinable) 'inline))

;; we need to check *known-functions* to make sure that the side-effect
;; class is computed correctly
(defun f-side-effect (fun)
  ;; we start with FUNCTION-SIDE-EFFECT to ensure that FUN is indeed a function
  (multiple-value-bind (seclass fdef name) (function-side-effect fun)
    ;; If SAFETY = 3, ANSI CL 3.5 requires us to signal errors about
    ;; invalid arguments, and the simplest way to implement this
    ;; requirement is to not omit the call. We don't keep track of the
    ;; possibility of errors through the SECLASS currently.
    ;; Therefore pretend the function has arbitrary side-effects.
    (if (>= (declared-optimize 'SAFETY) 3)
      *seclass-dirty*
      ;; For NOTINLINE functions, side effects are unpredictable!
      (if (declared-notinline name)
        *seclass-dirty*
        (let ((kf (assoc name *known-functions* :test #'equal)))
          (if kf
            (fourth kf) ; defined in this compilation unit, use the seclass!
            (if (equal *seclass-dirty* seclass)
              *seclass-dirty*
              ;; seclass is not dirty ==> function is defined
              (if (or (proclaimed-inline-p name)     ; inlined
                      (subr-info fdef) ; SUBR
                      (null name)      ; anonymous
                      (let ((pack (symbol-package (get-funname-symbol name))))
                        (or (null pack) (package-lock pack))))
                seclass
                *seclass-dirty*))))))))

;; Constant-Folding: if fun is foldable (i.e.: subr-flag = T and
;; key-flag = NIL) and if codelist consists besides the (PUSH)s and the
;; Call-Code at the end only of Anodes with code = ((CONST ...)) ?
(defmacro return-if-foldable (seclass fun codelist caller)
  (let ((const-form (gensym "RETURN-IF-FOLDABLE-")))
    `(when (seclass-foldable-p ,seclass)
       (let ((,const-form (try-constant-fold ,codelist ,fun)))
         (when ,const-form
           (return-from ,caller (c-GLOBAL-FUNCTION-CALL-form ,const-form)))))))

;; compile arg and augment SECLASS, CODELIST, and *STACKZ*
;; NB: codelist should be a symbol, it is multiply evaluated
(defmacro collect-arg (seclass codelist arg)
  (let ((anode (gensym "COLLECT-ARG-")))
    `(let ((,anode (c-form ,arg 'ONE)))
       (seclass-or-f ,seclass ,anode)
       (push ,anode ,codelist)
       (push '(PUSH) ,codelist)
       (push 1 *stackz*))))

;; compile each argument in ARGS and return seclass and codelist
;; modifies *stackz*
(defun collect-args (seclass args &optional codelist)
  (dolist (arg args (values seclass codelist))
    (collect-arg seclass codelist arg)))

;; global function call, normal (notinline): (fun {form}*)
(defun c-NORMAL-FUNCTION-CALL (fun) ; fun is a symbol or (SETF symbol)
  (test-list *form* 1)
  (let* ((n (length (cdr *form*)))
         #+CLISP-DEBUG (oldstackz *stackz*)
         (*stackz* *stackz*))
    (multiple-value-bind (seclass codelist)
        (collect-args (f-side-effect fun) (cdr *form*) (list '(CALLP)))
      (setq codelist (nreconc codelist
                              `((,@(case n (0 `(CALL0)) (1 `(CALL1))
                                           (2 `(CALL2)) (t `(CALL ,n)))
                                 ,(make-funname-const fun)))))
      (return-if-foldable seclass fun codelist c-NORMAL-FUNCTION-CALL)
      (make-anode
       :type 'CALL
       :sub-anodes codelist
       :seclass seclass
       :code codelist
       :stackz oldstackz))))

;; Compute the signature of a function object:
;; 1. name
;; 2. req-num
;; 3. opt-num
;; 4. rest-p
;; 5. key-p
;; 6. keyword-list
;; 7. allow-other-keys-p
(defun function-signature (obj &optional no-error)
  ;; what if the function has been redefined in this file already?
  ;; if it has been redefined above, we must use the signature
  ;; from the above definition!
  (let ((kf (assoc obj *known-functions* :test #'equal)) known-sig)
    (when kf        ; use the signature from the above definition!
      (setq known-sig (third kf))
      (return-from function-signature
        (values (first kf)
                (sig-req-num  known-sig)
                (sig-opt-num  known-sig)
                (sig-rest-p   known-sig)
                (sig-keys-p   known-sig)
                (sig-keywords known-sig)
                (sig-allow-p  known-sig)))))
  (when (and (function-name-p obj) (fboundp obj))
    (setq obj (fdefinition obj)))
  (if (closurep obj)
    (if (sys::%compiled-function-p obj)
        ;; compiled closure
        (multiple-value-bind (req-num opt-num rest-p key-p keywords allow-p)
            (signature obj)
          (values (sys::closure-name obj)
                  req-num opt-num rest-p key-p keywords allow-p))
        ;; interpreted closure
        (let ((clos_keywords (sys::%record-ref obj 16)))
          (values (sys::closure-name obj)
                  (sys::%record-ref obj 12) ; req_num
                  (sys::%record-ref obj 13) ; opt_num
                  (sys::%record-ref obj 19) ; rest_flag
                  (not (numberp clos_keywords))
                  (if (not (numberp clos_keywords)) (copy-list clos_keywords))
                  (sys::%record-ref obj 18)))) ; allow_flag
    (cond #+FFI
          ((eq (type-of obj) 'FFI::FOREIGN-FUNCTION)
           (values (function-name obj)
                   (foreign-function-in-arg-count obj) 0 nil nil nil nil))
          (t
           (multiple-value-bind (name req-num opt-num rest-p keywords allow-p)
               (subr-info obj)
             (if name
               (values name req-num opt-num rest-p keywords keywords allow-p)
               (if no-error
                 (values)
                 (coerce obj 'function)))))))) ; error

(defun get-signature (obj)
  (multiple-value-bind (name req-num opt-num rest-p key-p keywords allow-p)
      (function-signature obj)
    (declare (ignore name))
    (make-signature :req-num req-num :opt-num opt-num :rest-p rest-p
                    :keys-p key-p :keywords keywords :allow-p allow-p)))

(defun signature-to-list (req-num opt-num rest-p key-p keywords allow-p)
  (let ((args '()) (count -1))
    (dotimes (i req-num)
      #1=(push (make-symbol (format nil "ARG~D" (incf count))) args))
    (when (plusp opt-num)
      (push '&OPTIONAL args)
      (dotimes (i opt-num) #1#))
    (when rest-p
      (push '&REST args)
      (push 'other-args args))
    (when key-p
      (push '&KEY args)
      (dolist (kw keywords) (push kw args))
      (when allow-p (push '&ALLOW-OTHER-KEYS args)))
    (nreverse args)))

(defun sig-to-list (sig)
  (signature-to-list (sig-req-num sig) (sig-opt-num sig) (sig-rest-p sig)
                     (sig-keys-p sig) (sig-keywords sig) (sig-allow-p sig)))

;; returns the signature of a function from fdescr
(defun fdescr-signature (fdescr)
  (if (cdr fdescr)
    (if (eq (cadr fdescr) 'LABELS)
      ;; defined with LABELS: from the lambda list information
      (multiple-value-bind (reqvar optvar optinit optsvar restvar
                            keyflag keyword keyvar keyinit keysvar
                            allow-other-keys auxvar auxinit)
          (values-list (cddr fdescr))
        (declare (ignore optinit optsvar keyvar keyinit
                         keysvar auxvar auxinit))
        (values (length reqvar) (length optvar)
                (not (eql restvar 0)) keyflag
                keyword allow-other-keys))
      ;; defined with GENERIC-FLET or GENERIC-LABELS: from the signature
      (values-list (cddr fdescr)))
    ;; defined with FLET or IN-DEFUN: from the fnode
    (let ((fnode (car fdescr)))
      (values (fnode-req-num fnode) (fnode-opt-num fnode)
              (fnode-rest-flag fnode) (fnode-keyword-flag fnode)
              (fnode-keywords fnode) (fnode-allow-other-keys-flag fnode)))))

;; (test-argument-syntax args applyargs fun
;;                       req opt rest-p key-p keylist allow-p)
;; check whether the arglist ARGS (and maybe additional arguments APPLYARGS)
;; is a valid arglist for the function FUN with the signature
;; (REQ OPT REST-P KEY-P KEYLIST ALLOW-P)
;; The appropriate warnings are printed as necessary
;; Returns:
;;   NO-KEYS           correct syntax, no keywords,
;;   STATIC-KEYS       correct syntax, constant keywords,
;;   DYNAMIC-KEYS      (probably) correct syntax, non-constant keywords
;;   NIL               incorrect syntax,
;; In the first two cases:
;; if (not applyargs):
;;   req <= (length args) <= (req+opt or, if rest-p or key-p, infinity)
;; or if applyargs:
;;   (length args) <= (req+opt or, if rest-p or key-p, infinity).
(defun test-argument-syntax (args applyargs fun req opt rest-p key-p keylist
                             allow-p)
  (unless (and (listp args) (null (cdr (last args))))
    (c-error args (TEXT "argument list to function ~S is dotted: ~S")
             fun args))
  (let ((n (length args))
        (reqopt (+ req opt)))
    (unless (and (or applyargs (<= req n)) (or rest-p key-p (<= n reqopt)))
      (c-warn (TEXT "~S was called with ~S~:[~; or more~] arguments, but it requires ~:[~:[from ~S to ~S~;~S~]~;at least ~*~S~] argument~:p.")
              fun n applyargs
              (or rest-p key-p) (eql req reqopt) req reqopt)
      (return-from test-argument-syntax 'NIL))
    (unless key-p (return-from test-argument-syntax 'NO-KEYS))
    ;; has keywords
    (when (<= n reqopt) (return-from test-argument-syntax 'STATIC-KEYS))
    (when rest-p (return-from test-argument-syntax 'DYNAMIC-KEYS))
    (setq n (- n reqopt) args (nthcdr reqopt args))
    (unless (or (evenp n) applyargs)
      (c-warn (TEXT "keyword arguments to function ~S should occur pairwise: ~S")
              fun args)
      (return-from test-argument-syntax 'NIL))
    (do ((keyargs args (cddr keyargs))
         (allow-other-keys-seen nil)
         (allow-flag allow-p)
         wrong-keys)
        ((null keyargs)
         (cond ((and wrong-keys (not allow-flag))
                (c-warn (TEXT "illegal keyword~P ~{~S~#[~; and ~S~:;, ~]~} for function ~S.~
                             ~%The only allowed keyword~[s are~; is~:;s are~] ~{~S~#[~; and ~S~:;, ~]~}.")
                        (length wrong-keys) wrong-keys fun
                        (length keylist) keylist)
                NIL)
               (t 'STATIC-KEYS)))
      (let ((key (first keyargs)))
        (unless (c-constantp key)
          (return-from test-argument-syntax 'DYNAMIC-KEYS))
        (setq key (c-constant-value key))
        (unless (symbolp key)
          (c-warn (TEXT "argument ~S to function ~S is not a symbol")
                  (first keyargs) fun)
          (return-from test-argument-syntax 'DYNAMIC-KEYS))
        (when (and (eq key ':ALLOW-OTHER-KEYS) (not allow-other-keys-seen))
          (setq allow-other-keys-seen t)
          (unless (c-constantp (second keyargs))
            (return-from test-argument-syntax 'DYNAMIC-KEYS))
          (when (c-constant-value (second keyargs)) (setq allow-flag t)))
        (unless (memq key keylist)
          (push key wrong-keys))))))

;; try to evaluate FORM for side effects
;; returns NIL on error and T on success
(defmacro try-eval (&body forms)
  `(block try-eval
     (let ((*error-handler*
             #'(lambda (&rest error-args)
                 ;; NB: the warning may be reported twice: if you compile
                 ;; (* 1d30 1d30), this will be called first from c-STAR
                 ;; (because this is a * form), and second from
                 ;; c-DIRECT-FUNCTION-CALL (because this is a constant form)
                 (apply #'c-warn (TEXT "Run time error expected: ~@?")
                        (cdr error-args))
                 (return-from try-eval nil))))
       ,@forms)
     t))

(defun try-constant-fold (codelist fun)
  (when (every (lambda (code) (or (not (anode-p code)) (anode-constantp code)))
               codelist)
    ;; try to call function:
    (let ((args (let ((L '())) ; list of (constant) arguments
                  (dolist (code codelist (nreverse L))
                    (when (anode-p code)
                      (push (anode-constant-value code) L)))))
          resulting-values)
      (when (try-eval (setq resulting-values
                            (multiple-value-list (apply fun args))))
        ;; function called successfully, perform constant folding:
        `(VALUES ,@(mapcar #'(lambda (x) `(QUOTE ,x)) resulting-values))))))

;; (c-DIRECT-FUNCTION-CALL args applyargs fun req opt rest-p key-p keylist
;;                         subr-flag call-code-producer)
;; compiles the processing of the arguments for the direct call of a
;; function (i.e. without argument-check at run-time).
;; (test-argument-syntax ...) must have checked the arguments already
;;             successfully (i.e. with result NO-KEYS or STATIC-KEYS) .
;; args      : list of argument-forms,
;; applyargs : if specified, list of a form for additional arguments,
;; fun       : name of the function to be called (Symbol) ,
;; req,opt,rest-p,key-p,keylist,allow-p
;;           : information about the lambda-list of fun
;; subr-flag : Flag, if fun is a SUBR or a compiled Closure,
;;             (attention: use applyargs only for compiled closures!),
;; call-code-producer : function, that returns the code, which is appended
;;                      at the end and which executes the call.
(defun c-DIRECT-FUNCTION-CALL (args applyargs fun req opt rest-p key-p keylist
                               subr-flag call-code-producer)
  (let ((seclass (f-side-effect fun)))
    (if (and (null *for-value*) (null (seclass-modifies seclass)))
      ;; Do not need to call the function, just evaluate the arguments.
      (progn
        (let ((*no-code* t) (*for-value* 'NIL))
          (funcall call-code-producer))
        (c-form `(PROGN ,@args ,@applyargs)))
      (let ((n (length args))
            (reqopt (+ req opt))
            (codelist '()))
        (let ((*stackz* *stackz*))
          ;; required and given optional parameters:
          (dotimes (i (min n reqopt))
            (collect-arg seclass codelist (pop args)))
          (if applyargs
            (progn
              (when subr-flag
                (compiler-error 'c-DIRECT-FUNCTION-CALL "APPLY-SUBR"))
              (when key-p (compiler-error 'c-DIRECT-FUNCTION-CALL "APPLY-KEY"))
              (if (>= reqopt n)
                ;; missing optional parameters are initialized from the list:
                (let* ((anz (- reqopt n))
                       (anode1 (c-form (first applyargs) 'ONE))
                       (anode2 (progn
                                 (push (if rest-p (+ anz 1) anz) *stackz*)
                                 (c-unlist rest-p anz (min opt anz)))))
                  (seclass-or-f seclass anode1)
                  (push anode1 codelist)
                  (seclass-or-f seclass anode2)
                  (push anode2 codelist))
                ;; n > reqopt, implies rest-p.
                ;; Passing of the remaining arguments to a compiled Closure:
                ;; as list.
                ;; List consisting of all additional arguments:
                (progn
                  (let ((*stackz* *stackz*))
                    (multiple-value-setq (seclass codelist)
                      (collect-args seclass args codelist))
                    (let ((anode (c-form (first applyargs) 'ONE)))
                      (seclass-or-f seclass anode)
                      (push anode codelist))
                    (push `(LIST* ,(- n reqopt)) codelist))
                  (push '(PUSH) codelist)
                  (push 1 *stackz*))))
            (progn
              ;; missing optional parameters are initialized with #<UNBOUND> :
              (when (> reqopt n)
                (let ((anz (- reqopt n)))
                  (push `(PUSH-UNBOUND ,anz) codelist)
                  (push anz *stackz*)))
              ;; &rest parameter:
              (when rest-p
                (if subr-flag
                  ;; Passing of remaining arguments to a SUBR: one by one
                  (multiple-value-setq (seclass codelist)
                    (collect-args seclass args codelist))
                  ;; passing of remaining arguments to a compiled closure:
                  ;; as list
                  (if (null args)
                    ;; empty list
                    (progn
                      (push '(NIL) codelist)
                      (push '(PUSH) codelist)
                      (push 1 *stackz*))
                    ;; list of all further arguments:
                    (progn
                      (let ((*stackz* *stackz*))
                        (multiple-value-setq (seclass codelist)
                          (collect-args seclass args codelist))
                        (push `(LIST ,(- n reqopt)) codelist))
                      (push '(PUSH) codelist)
                      (push 1 *stackz*)))))))
          ;; &key parameter:
          (when key-p
            ;; only if rest-p and key-p at the same time, if n <= reqopt,
            ;; because `test-argument-syntax' (which yielded STATIC-KEYS)
            ;; has excluded the other case already.
            (let ((keyanz (length keylist)))
              ;; First initialize all keys with #<UNBOUND> ,
              ;; then evaluate and assign the arguments in the specified order?
              ;; this is too simple for us. We transpose the arguments, so that
              ;; as many of the (STORE ...) as possible are replaced by (PUSH):
              ;; The arguments for the first Keys are evaluated at first,
              ;; if possible, the last Keys are evaluated at last.
              ;; However, we use only one single (PUSH-UNBOUND ...).
              (let* ((key-positions
                       ;; list of triples (key stack-depth free-p), where
                       ;; stack-depth = keyanz-1...0 and free-p states,
                       ;; if the Slot is already filled.
                       (let ((i keyanz))
                         (mapcar #'(lambda (key) (list key (decf i) t))
                                 keylist)))
                     (anodes
                       ;; list of quadruples (needed key-position anode stackz),
                       ;; where key-position is the stack-depth of the
                       ;; Keyword-Slots or NIL, anode is the Anode for
                       ;; this argument.  The list is kept in the same
                       ;; order, as is specified by the argument-list.
                       ;; exception: needed = NIL for anodes, whose
                       ;; calculation was brought forward or suspended.
                       (let ((L '()))
                         (loop
                           (when (null args) (return))
                           (let* ((key (c-constant-value (pop args)))
                                  (tripel (assoc key key-positions :test #'eq)) ; can be =NIL!
                                  (for-value (third tripel))
                                  (arg (pop args)))
                             ;; for-value /= NIL: Existing Keyword,
                             ;; and the Slot is still empty
                             ;; for-value = NIL: ALLOW-allowed Keyword
                             ;; or Slot already filled
                             (unless for-value
                               (if tripel
                                 (c-style-warn
                                   (TEXT "~S: ignored duplicate keyword ~S ~S")
                                   fun key arg)
                                 (unless (eq key ':ALLOW-OTHER-KEYS)
                                   (c-style-warn
                                     (TEXT "~S: ignored keyword ~S ~S")
                                     fun key arg))))
                             (let* ((*stackz* (cons 0 *stackz*)) ; 0 will be replaced later
                                    (anode (c-form arg (if for-value 'ONE 'NIL))))
                               (seclass-or-f seclass anode)
                               (push (list t
                                           (and for-value (second tripel))
                                           anode
                                           *stackz*)
                                     L))
                             (when tripel
                               (setf (third tripel) nil))))
                         (nreverse L))))
                (let ((depth1 0)
                      (depth2 0)
                      (codelist-from-end '()))
                  (flet ((commute-with-rest-p (anodeetc anodes anodesr)
                           (let ((anode (third anodeetc)))
                             (do ((anodesr2 anodes (cdr anodesr2)))
                                 ((eq anodesr2 anodesr) t)
                               (unless (anodes-commute
                                        anode (third (car anodesr2)))
                                 (return nil))))))
                    ;; bring forward as much as possible:
                    (do ((anodesr anodes (cdr anodesr)))
                        ((null anodesr))
                      (let ((anodeetc (car anodesr))) ; next Quadruple
                        (when (first anodeetc) ; something else to do?
                          (if (and
                                (or ; no Keyword, i.e. no (STORE ...) necessary?
                                  (null (second anodeetc))
                                  ;; topmost Keyword?
                                  (= (second anodeetc) (- keyanz depth1 1)))
                                ;; does anodeetc commute with previous anodes?
                                (commute-with-rest-p anodeetc anodes anodesr))
                            ;; bring forward:
                            (progn
                              (setf (first (fourth anodeetc))
                                    depth1) ; correct stack depth
                              (push (third anodeetc)
                                    codelist) ; into the code-list
                              (when (second anodeetc)
                                (push '(PUSH) codelist)
                                (incf depth1))
                              ;; we don't need this one anymore:
                              (setf (first anodeetc) nil))
                            ;; else we do nothing.
                            ))))
                    ;; bring backwards as much as possible:
                    (setq anodes (nreverse anodes))
                    (do ((anodesr anodes (cdr anodesr)))
                        ((null anodesr))
                      (let ((anodeetc (car anodesr))) ; next Quadruple
                        (when (first anodeetc) ; still sth. to do?
                          (if (and
                                (or ; no Keyword, i.e. no (STORE ...) necessary?
                                  (null (second anodeetc))
                                  ;; lowest Keyword?
                                  (= (second anodeetc) depth2))
                                ;; does anodeetc commute with all later anodes?
                                (commute-with-rest-p anodeetc anodes anodesr))
                            ;; push to the End:
                            (progn
                              (when (second anodeetc)
                                (push '(PUSH) codelist-from-end)
                                (incf depth2))
                              (setf (first (fourth anodeetc))
                                    (- keyanz depth2)) ; correct stack-depth
                              (push (third anodeetc)
                                    codelist-from-end) ; into the code-list
                              ;; we don't need this one anymore
                              (setf (first anodeetc) nil))
                            ;; else we do nothing.
                            ))))
                    (setq anodes (nreverse anodes))
                    (let ((depth-now (- keyanz depth2)))
                      ;; codelist-from-end decreases the Stack by depth2
                      (when (> depth-now depth1)
                        (push `(PUSH-UNBOUND ,(- depth-now depth1)) codelist))
                      ;; In code-list stack-depth is now depth-now.
                      (dolist (anodeetc anodes)
                        (when (first anodeetc)
                          ;; correct stack-depth
                          (setf (first (fourth anodeetc)) depth-now)
                          (push (third anodeetc) codelist)
                          (when (second anodeetc)
                            (push `(STORE ,(- (second anodeetc) depth2))
                                  codelist)))))
                    ;; now codelist-from-end:
                    (setq codelist (nreconc codelist-from-end codelist)))))
              ;; now all key argument are on the Stack.
              (push keyanz *stackz*)))
          (setq codelist (nreconc codelist (funcall call-code-producer))))
        (return-if-foldable seclass fun codelist c-DIRECT-FUNCTION-CALL)
        (make-anode
          :type `(DIRECT-CALL ,fun)
          :sub-anodes (remove-if-not #'anode-p codelist)
          :seclass seclass
          :code codelist)))))
(defun c-unlist (rest-p n m)
  (if rest-p
    (if (eql n 0)
      (make-anode :type 'UNLIST*
                  :sub-anodes '()
                  :seclass *seclass-pure*
                  :code '((PUSH)))
      (make-anode :type 'UNLIST*
                  :sub-anodes '()
                  :seclass *seclass-dirty* ; can report Error
                  :code `((UNLIST* ,n ,m))))
    (make-anode :type 'UNLIST
                :sub-anodes '()
                :seclass *seclass-dirty* ; can report Error
                :code `((UNLIST ,n ,m)))))
(defun cclosure-call-code-producer (fun fnode req opt rest-flag key-flag
                                    keylist)
  (if (eq fnode *func*) ; recursive call of the own function
    (let ((call-code
            `((JSR ,(+ req opt (if rest-flag 1 0) (length keylist)) ; number of stack-entries
                   ,*func-start-label*))))
      #'(lambda () call-code))
    ;; call another Cclosure
    #'(lambda ()
        (list
          (c-form `(FUNCTION ,fun) 'ONE)
          (if key-flag '(CALLCKEY) '(CALLC))))))

(defun function-code-list (fun arg-count)
  (case fun
    ((CAR FIRST) `((CAR ,*denv*)))
    ((CDR REST) `((CDR ,*denv*)))
    (CAAR `((CAR ,*denv*) (CAR ,*denv*)))
    ((CADR SECOND) `((CDR ,*denv*) (CAR ,*denv*)))
    (CDAR `((CAR ,*denv*) (CDR ,*denv*)))
    (CDDR `((CDR ,*denv*) (CDR ,*denv*)))
    (CAAAR `((CAR ,*denv*) (CAR ,*denv*) (CAR ,*denv*)))
    (CAADR `((CDR ,*denv*) (CAR ,*denv*) (CAR ,*denv*)))
    (CADAR `((CAR ,*denv*) (CDR ,*denv*) (CAR ,*denv*)))
    ((CADDR THIRD) `((CDR ,*denv*) (CDR ,*denv*) (CAR ,*denv*)))
    (CDAAR `((CAR ,*denv*) (CAR ,*denv*) (CDR ,*denv*)))
    (CDADR `((CDR ,*denv*) (CAR ,*denv*) (CDR ,*denv*)))
    (CDDAR `((CAR ,*denv*) (CDR ,*denv*) (CDR ,*denv*)))
    (CDDDR `((CDR ,*denv*) (CDR ,*denv*) (CDR ,*denv*)))
    (CAAAAR `((CAR ,*denv*) (CAR ,*denv*) (CAR ,*denv*) (CAR ,*denv*)))
    (CAAADR `((CDR ,*denv*) (CAR ,*denv*) (CAR ,*denv*) (CAR ,*denv*)))
    (CAADAR `((CAR ,*denv*) (CDR ,*denv*) (CAR ,*denv*) (CAR ,*denv*)))
    (CAADDR `((CDR ,*denv*) (CDR ,*denv*) (CAR ,*denv*) (CAR ,*denv*)))
    (CADAAR `((CAR ,*denv*) (CAR ,*denv*) (CDR ,*denv*) (CAR ,*denv*)))
    (CADADR `((CDR ,*denv*) (CAR ,*denv*) (CDR ,*denv*) (CAR ,*denv*)))
    (CADDAR `((CAR ,*denv*) (CDR ,*denv*) (CDR ,*denv*) (CAR ,*denv*)))
    ((CADDDR FOURTH) `((CDR ,*denv*) (CDR ,*denv*) (CDR ,*denv*) (CAR ,*denv*)))
    (CDAAAR `((CAR ,*denv*) (CAR ,*denv*) (CAR ,*denv*) (CDR ,*denv*)))
    (CDAADR `((CDR ,*denv*) (CAR ,*denv*) (CAR ,*denv*) (CDR ,*denv*)))
    (CDADAR `((CAR ,*denv*) (CDR ,*denv*) (CAR ,*denv*) (CDR ,*denv*)))
    (CDADDR `((CDR ,*denv*) (CDR ,*denv*) (CAR ,*denv*) (CDR ,*denv*)))
    (CDDAAR `((CAR ,*denv*) (CAR ,*denv*) (CDR ,*denv*) (CDR ,*denv*)))
    (CDDADR `((CDR ,*denv*) (CAR ,*denv*) (CDR ,*denv*) (CDR ,*denv*)))
    (CDDDAR `((CAR ,*denv*) (CDR ,*denv*) (CDR ,*denv*) (CDR ,*denv*)))
    (CDDDDR `((CDR ,*denv*) (CDR ,*denv*) (CDR ,*denv*) (CDR ,*denv*)))
    (ATOM '((ATOM)))
    (CONSP '((CONSP)))
    (SYS::%UNBOUND '((PUSH-UNBOUND 1) (POP)))
    ((NOT NULL) '((NOT)))
    (CONS '((CONS)))
    (SVREF `((SVREF ,*denv*)))
    (SYS::%SVSTORE '((SVSET)))
    (EQ '((EQ)))
    (VALUES (case arg-count
              (0 '((VALUES0)))
              (1 '((VALUES1)))
              (t `((PUSH) ; also push last argument to the Stack
                   (STACK-TO-MV ,arg-count)))))
    (VALUES-LIST '((LIST-TO-MV)))
    (SYMBOL-FUNCTION `((SYMBOL-FUNCTION ,*denv*)))
    (LIST (if (plusp arg-count)
              `((PUSH) (LIST ,arg-count))
              '((NIL))))
    (LIST* (case arg-count
             (1 '((VALUES1)))
             (t `((LIST* ,(1- arg-count))))))
    (t (compiler-error 'c-GLOBAL-FUNCTION-CALL fun))))

;; global function call: (fun {form}*)
(defun c-GLOBAL-FUNCTION-CALL-form (*form*)
  (c-GLOBAL-FUNCTION-CALL (first *form*)))
(defun c-GLOBAL-FUNCTION-CALL (fun) ; fun is a Symbol or (SETF symbol)
  (test-list *form* 1)
  (note-function-used fun (cdr *form*) nil)
  (when *compiling-from-file* ; called by COMPILE-FILE?
    ;; take note of PROCLAIM-declarations:
    (when (and (eq fun 'PROCLAIM) (= (length *form*) 2))
      (let ((h (second *form*)))
        (when (c-constantp h)
          (c-form
           `(eval-when-compile (c-PROCLAIM ',(c-constant-value h)))))))
    ;; take note of module requirements:
    (when (and (memq fun '(PROVIDE REQUIRE))
               (every #'c-constantp (rest *form*)))
      (c-form
        `(eval-when-compile
           (,(case fun
               (PROVIDE 'c-PROVIDE)  ; c-PROVIDE instead of PROVIDE
               (REQUIRE 'c-REQUIRE)) ; c-REQUIRE instead of REQUIRE
            ,@(mapcar           ; quote arguments
               #'(lambda (x) (list 'QUOTE (c-constant-value x)))
               (rest *form*))))))
    ;; take note of package-requirements:
    (when (and *package-tasks-treat-specially*
               (memq fun '(MAKE-PACKAGE SYSTEM::%IN-PACKAGE
                           SHADOW SHADOWING-IMPORT EXPORT UNEXPORT
                           USE-PACKAGE UNUSE-PACKAGE IMPORT))
               (every #'c-constantp (rest *form*)))
      (push
        `(,fun
          ,@(mapcar
              ;; Quote the arguments, but only when necessary, because
              ;; ANSI-CL IN-PACKAGE wants unquoted arguments.
              #'(lambda (x)
                  (let ((v (c-constant-value x)))
                    (if (or (numberp v) (characterp v) (arrayp v) (keywordp v))
                      v
                      (list 'QUOTE v))))
              (rest *form*)))
        *package-tasks*)))
  (let* ((args (cdr *form*))    ; arguments
         (n (length args)))     ; number of arguments
    (if (or (not (fboundp fun)) (declared-notinline fun))
      ;; the function arguments will not be checked
      (c-NORMAL-FUNCTION-CALL fun)
      (multiple-value-bind (name req opt rest-p key-p keylist allow-p check)
          (function-signature fun t)
        (setq check (and name (test-argument-syntax args nil fun req opt rest-p
                                                    key-p keylist allow-p)))
        (if (and name (equal fun name)) ; function is valid
          (case fun
            ((CAR CDR FIRST REST NOT NULL CONS SVREF VALUES
              CAAR CADR CDAR CDDR CAAAR CAADR CADAR CADDR CDAAR CDADR
              CDDAR CDDDR SECOND THIRD FOURTH CAAAAR CAAADR CAADAR CAADDR
              CADAAR CADADR CADDAR CADDDR CDAAAR CDAADR CDADAR CDADDR
              CDDAAR CDDADR CDDDAR CDDDDR ATOM CONSP SYS::%UNBOUND
              VALUES-LIST SYS::%SVSTORE EQ SYMBOL-FUNCTION LIST LIST*)
             ;; these here have keylist=NIL, allow-p=NIL and
             ;; (which is not used) opt=0.
             (if check ; (and (<= req n) (or rest-p (<= n (+ req opt))))
               ;; we make the call INLINE.
               (let ((sideeffects ; side-effect-class of the function-execution
                       (if (>= (declared-optimize 'SAFETY) 3)
                         *seclass-dirty* ; see comment in F-SIDE-EFFECT
                         (function-side-effect fun)))) ; no need for a check
                 (cond ((and (null *for-value*)
                             (null (seclass-modifies sideeffects)))
                        ;; don't have to call the function,
                        ;; only evaluate the arguments
                        (c-form `(PROGN ,@args)))
                       ((and (seclass-foldable-p sideeffects)
                             (every #'c-constantp args))
                        ;; call the function at compile time
                        (let ((*stackz* *stackz*))
                          (multiple-value-bind (seclass codelist)
                              (collect-args sideeffects args)
                            (return-if-foldable seclass fun codelist
                                                c-GLOBAL-FUNCTION-CALL)
                            (compiler-error 'c-GLOBAL-FUNCTION-CALL
                                            (list fun args seclass codelist)))))
                       ((and (eq fun 'VALUES) (eq *for-value* 'ONE))
                        (if (= n 0) (c-NIL) (c-form `(PROG1 ,@args))))
                       (t (let ((*stackz* *stackz*))
			    (multiple-value-bind (seclass codelist)
			        (collect-args sideeffects args)
                              ;; evaluate the arguments and push all to the
                              ;; stack except for the last (because the last
                              ;; one is expected in A0):
			      (pop codelist) (pop *stackz*)
                              (setq codelist
                                    (nreconc codelist
                                             (function-code-list fun n)))
                              (make-anode
                               :type `(PRIMOP ,fun)
                               :sub-anodes (remove-if-not #'anode-p codelist)
                               :seclass seclass
                               :code codelist))))))
               ;; check failed (wrong argument count) => not INLINE:
               (c-NORMAL-FUNCTION-CALL fun)))
            (t ; is the SUBR fun contained in the FUNTAB?
             (let ((index (gethash fun function-codes)))
               (case fun
                 ;; accept &KEY and an even number of &OPTIONAL
                 ((PARSE-NAMESTRING MERGE-PATHNAMES READ-FROM-STRING)
                  ;; (#:ARG0 &OPTIONAL #:ARG1 #:ARG2 &KEY ...)
                  ;; it just so happens that a keyword is a bad
                  ;; (or, in case of READ-FROM-STRING, an unusual)
                  ;; second (1st optional) argument for these functions,
                  ;; thus this keywordp test is good enough
                  (when (keywordp (second args))
                    (c-style-warn (TEXT "Apparently passing &KEY arguments without &OPTIONAL arguments in ~S") *form*))))
               (if index
                 (case check
                   ((NO-KEYS STATIC-KEYS)
                    ;; correct syntax, stack layout is known
                    ;; at compile time ==> INLINE
                    (c-DIRECT-FUNCTION-CALL
                      args nil fun req opt rest-p keylist keylist
                      t ; it is a SUBR
                      (let ((call-code ; call with help from the FUNTAB:
                              (cons
                                (if (not rest-p)
                                  (CALLS-code index)
                                  `(CALLSR ,(max 0 (- n req opt)) ; When n<req+opt another (PUSH-UNBOUND ...) still has to come
                                           ,(- index funtabR-index)))
                                (case fun
                                  (;; functions, that do not return:
                                   (;; control.d:
                                    SYS::DRIVER SYS::UNWIND-TO-DRIVER
                                    ;; debug.d:
                                    ;; SYS::REDO-EVAL-FRAME
                                    ;; SYS::RETURN-FROM-EVAL-FRAME
                                    ;; error.d:
                                    ERROR SYSTEM::ERROR-OF-TYPE
                                    INVOKE-DEBUGGER)
                                   '((BARRIER)))
                                  (t '())))))
                        #'(lambda () call-code))))
                   (t (c-NORMAL-FUNCTION-CALL fun)))
                 ;; not a SUBR
                 (let ((inline-lambdabody (inline-lambdabody fun)))
                   (if (inline-callable-lambdabody-p inline-lambdabody n)
                     ;; inline call of the global function is possible
                     (c-FUNCALL-INLINE fun args nil inline-lambdabody nil)
                     (c-NORMAL-FUNCTION-CALL fun)))))))
          (c-NORMAL-FUNCTION-CALL fun))))))

;; Alist mapping a function name to format string and arguments.
(defvar *deprecated-functions-alist*
  ;; The deprecated ANSI CL functions. More are added in deprecated.lisp.
  '((GENTEMP  "This function creates symbols that cannot be garbage-collected. Use ~S instead." gensym)
    (SET      "This function name is anachronistic. Use ~S ~S instead." setf symbol-value)))

;; note a global function call
;; NAME is function name, ARGS are arguments, APPLY-ARGS are APPLY arguments
;; ARGS == 0 means non-funcall context
;; this adds an unknown function to the `*unknown-functions*' list
;;  an unknown function is (NAME C-SOURCE-POINT . (ARGS . APPLY-ARGS))
;;  or (NAME C-SOURCE-POINT) if non-funcall context
(defun note-function-used (name args apply-args)
  (unless (fboundp name)
    (if *compiling-from-file*
      (let ((kf (assoc name *known-functions* :test #'equal))
            (uf (if (listp args)
                  (list* name (make-c-source-point) args apply-args)
                  (list name (make-c-source-point)))))
        (if kf
          (match-known-unknown-functions uf kf)
          (push uf *unknown-functions*)))
      (unless (defining-p name)
        (c-warn (TEXT "Function ~s is not defined") name))))
  (let ((deprecation-info (assoc name *deprecated-functions-alist* :test #'eq)))
    (when deprecation-info
      (if *compiling-from-file*
        (pushnew name *deprecated-functions* :test #'eq)
        ;; WARNING implies non-NIL 3rd return value (failure-p) from COMPILE
        (apply #'c-style-warn (string-concat
                               (TEXT "Function ~S is deprecated.") " ~@?")
               deprecation-info)))))

;; note global OPTIMIZE proclamations
;; used by c-PROCLAIM and PROCLAIM in control.d
(defun note-optimize (specs)
  (dolist (quality specs)
    (multiple-value-bind (quality value) (parse-optimize-quality quality)
      (when quality
        (setf (gethash quality *optimize*) value)))))

;; auxiliary function: PROCLAIM on file-compilation, cf. function PROCLAIM
(defun c-PROCLAIM (declspec)
  (when (consp declspec)
    (case (car declspec)
      (SPECIAL
        (dolist (var (cdr declspec))
          (when (symbolp var) (pushnew var *known-special-vars* :test #'eq))))
      (NOTSPECIAL
       (dolist (var (cdr declspec))
         (when (symbolp var) (delete var *known-special-vars* :test #'eq))))
      (INLINE
        (dolist (var (cdr declspec))
          (when (function-name-p var)
            (pushnew var *inline-functions* :test #'equal)
            (setq *notinline-functions* (delete var *notinline-functions*
                                                :test #'equal)))))
      (NOTINLINE
        (dolist (var (cdr declspec))
          (when (function-name-p var)
            (pushnew var *notinline-functions* :test #'equal)
            (setq *inline-functions* (delete var *inline-functions*
                                             :test #'equal)))))
      (CONSTANT-INLINE
        (dolist (var (cdr declspec))
          (when (symbolp var)
            (pushnew var *inline-constants*)
            (setq *notinline-constants* (delete var *notinline-constants*)))))
      (CONSTANT-NOTINLINE
        (dolist (var (cdr declspec))
          (when (symbolp var)
            (pushnew var *notinline-constants*)
            (setq *inline-constants* (delete var *inline-constants*)))))
      (OPTIMIZE (note-optimize (cdr declspec)))
      (DECLARATION
        (dolist (var (cdr declspec))
          (pushnew (sys::check-not-type var 'proclaim)
                   *user-declaration-types* :test #'eq))))))

;; DEFCONSTANT when compiling
(defun c-PROCLAIM-CONSTANT (symbol initial-value-form) ; ABI
  (when *compiling-from-file*
    (pushnew symbol *known-special-vars* :test #'eq)
    (when (c-constantp initial-value-form)
      (push (cons symbol (c-constant-value initial-value-form))
            *constant-special-vars*))))

;; DEFUN when compiling
(defun c-DEFUN (symbol signature &optional lambdabody (type 'defun)) ; ABI
  (when *compiling* ; c-DEFUN can also be called by the Expander!
    (when *compiling-from-file*
      (let ((kf (assoc symbol *known-functions* :test #'equal)))
        (when (and kf (eq type 'defun))
          ;; The check (eq type 'defun) cuts off
          ;; defmethod forms, which can appear many times in the
          ;; same file.  We could have made a special effort, like this:
          ;;  (let ((def (and (fboundp symbol) (fdefinition symbol))))
          ;;    (when (typep def clos::<standard-generic-function>)
          ;;      (clos::check-signature-congruence
          ;;        def symbol (clos::generic-function-signature def) signature)))
          ;; but it would be a waste of time since the signature
          ;; congruence check will be done at load time anyway and
          ;; - the above check catches only separate `defmethod' forms,
          ;;   but misses `:method's in `defgeneric' forms,
          ;; - the above check works only for already defined generic
          ;;   functions but not for generic functions defined in this file.
          (if (equalp signature (third kf))
              (c-style-warn (TEXT "Function ~s~% was already defined~a")
                            symbol (c-source-point-location (second kf)))
              (c-warn (TEXT "Function ~s~% was already defined~a~% with the signature~%~a~% it is being re-defined with a new signature~%~a")
                      symbol (c-source-point-location (second kf))
                      (sig-to-list (third kf))
                      (sig-to-list signature)))))
      (pushnew (list symbol (make-c-source-point) signature *seclass-dirty*)
               *known-functions* :test #'equal :key #'car)
      (when lambdabody
        ;; lambdabody given ==> function definition is in the
        ;; top-level environment and can be inlined
        (push (cons symbol lambdabody) *inline-definitions*)))))

;; auxiliary function: PROVIDE on file-compilation, cf. function PROVIDE
(defun c-PROVIDE (module-name)
  (pushnew (module-name module-name) *compiled-modules* :test #'string=))

;; load or compile
(defun load-or-compile (module-name file may-require)
  (with-augmented-load-path ((make-pathname :name nil :type nil
                                            :defaults *compile-file-pathname*))
    (let* ((present-files
            (search-file file (append *source-file-types* '("lib")) nil))
           (newest-file (first present-files)))
      ;; if the libfile occurs among the found Files
      ;; and if it is the newest:
      (if (and (consp present-files)
               (string= (pathname-type newest-file) "lib"))
        (load newest-file ; load libfile
              :verbose (and *load-verbose* *compile-verbose*)
              :print (and *load-print* *compile-print*))
        (if newest-file
            ;; found file in *load-paths*+*compile-file-pathname*
            (if *compile-file-directory*
              ;; `compile-file' was given :output-file,
              ;; so put the compiled file there
              (compile-file newest-file :output-file
                            (merge-pathnames *compile-file-directory*
                                             newest-file))
              ;; `compile-file' was called without an explicit
              ;; :output-file arg, so compile `in place'
              (compile-file newest-file))
            ;; file not found - call require
            (if may-require
              (require module-name)
              (c-error *form*
                       (TEXT "Cannot find file ~S required by feature ~S")
                       file module-name)))))))

;; auxiliary function: REQUIRE on file-compilation, cf. function REQUIRE
(defun c-REQUIRE (module-name &optional (pathname nil p-given))
  (setq module-name (module-name module-name))
  (unless (or (member module-name *modules* :test #'string=)
              (member module-name *compiled-modules* :test #'string=))
    (unless p-given (setq pathname (pathname module-name)))
    (if (atom pathname)
        (load-or-compile module-name pathname t)
        (mapcar (lambda (path) (load-or-compile module-name path nil))
                pathname))))

;;; auxiliary functions for
;;; LET/LET*/MULTIPLE-VALUE-BIND/Lambda-Expression/FLET/LABELS:

;; Syntax-Analysis:

(defun c-illegal-syntax (form caller)
  (c-error-c form (TEXT "Illegal syntax in ~A: ~S") caller form))

;; analyzes a parameter-list of LET/LET*, returns:
;; the List of Symbols,
;; the List of Forms.
(defun analyze-letlist (parameters)
  (do ((L parameters (cdr L))
       (symbols nil)
       (forms nil))
      ((null L) (values (nreverse symbols) (nreverse forms)))
    (cond ((symbolp (car L)) (push (car L) symbols) (push nil forms))
          ((and (consp (car L)) (symbolp (caar L))
                (or (null (cdar L))
                    (and (consp (cdar L)) (null (cddar L)))))
           (push (caar L) symbols) (push (cadar L) forms))
          (t (c-illegal-syntax (car L) "LET/LET*")))))

;; Analyzes a lambda-list of a function (CLtL2 p. 76, ANSI CL 3.4.1.).
;; Returns 13 values:
;; 1. list of required parameters
;; 2. list of optional parameters
;; 3. list of init-forms of the optional parameters
;; 4. list of supplied-vars for the optional parameters (0 for the missing)
;; 5. &rest parameter or 0
;; 6. flag, if keywords are allowed
;; 7. list of keywords
;; 8. list of keyword parameters
;; 9. list of init-forms of the keyword parameters
;; 10. list of supplied-vars for the keyword parameters (0 for the missing)
;; 11. flag, if other keywords are allowed
;; 12. list of &aux variables
;; 13. list of init-forms of the &aux variables
(defun c-analyze-lambdalist (lambdalist)
  (sys::analyze-lambdalist lambdalist
    #'(lambda (form detail errorstring &rest arguments)
        (declare (ignore form detail))
        (catch 'c-error
          (apply #'c-error lambdalist errorstring arguments)))))

(defun lambda-list-to-signature (lambda-list)
  (multiple-value-bind (req opt opt-i opt-p rest
                        key-p keywords key-v key-i key-v-p allow-p)
      (c-analyze-lambdalist lambda-list)
    (declare (ignore opt-i opt-p key-v key-i key-v-p))
    (make-signature :req-num (length req) :opt-num (length opt)
                    :rest-p (not (eql 0 rest)) :keys-p key-p
                    :keywords keywords :allow-p allow-p)))

;; return the inline lambdabody for the function FUN (if any)
(defun inline-lambdabody (fun)
  (or (and *compiling-from-file*
           (cdr (assoc fun *inline-definitions* :test #'equal)))
      (get (get-funname-symbol fun) 'sys::inline-expansion)))

;;; (inline-callable-function-lambda-p form n) or
;;; (inline-callable-function-p form n) check whether the FORM
;;; can be called inline with N (and maybe MORE) arguments
;;; (subject to syntax errors in the lambda list)
;;; form should be already macroexpanded.
(defun inline-callable-function-lambda-p (form n &optional (more nil))
  (and (function-form-p form)
       (let ((funname (second form)))
         ;; funname must be (LAMBDA lambdalist ...)
         (and (lambda-form-p funname)
              (let ((lambdalist (second funname)))
                ;; lambdalist must be a list, with no &KEYs
                ;; (functions with &KEYs cannot be expanded INLINE, since these
                ;; arguments are dynamically bound to the variables.
                ;; it is possible to speed up APPLY with GETF in assembler)
                (and (listp lambdalist)
                     (not (position '&KEY lambdalist))
                     (not (position '&ALLOW-OTHER-KEYS lambdalist))
                     (let ((&opt-pos (position '&OPTIONAL lambdalist))
                           (&rest-pos (position '&REST lambdalist))
                           (&aux-pos (or (position '&AUX lambdalist)
                                         (length lambdalist))))
                       (or (if &rest-pos
                             (or more (>= n (or &opt-pos &rest-pos)))
                             (if more
                               (<= n (if &opt-pos (- &aux-pos 1) &aux-pos))
                               (if &opt-pos
                                 (<= &opt-pos n (- &aux-pos 1))
                                 (= n &aux-pos))))
                           (c-warn (TEXT "Cannot call ~S on ~D~@[ or more~] argument~P")
                                   form n more (if more 0 n))))))))))
(defun inline-callable-lambdabody-p (inline-lambdabody n &optional (more nil))
  (and (consp inline-lambdabody)
       (inline-callable-function-lambda-p
        `(FUNCTION (LAMBDA ,@inline-lambdabody)) n more)))
(defun inline-callable-function-p (form n)
  (or (inline-callable-function-lambda-p form n)
      (and (function-form-p form)
           (let ((fun (second form)))
             ;; fun must be a function name with an inline-definition,
             ;; then (FUNCALL fun ...) is converted to (fun ...) compiled inline.
             ;; see c-FUNCALL, c-FUNCTION-CALL, c-GLOBAL-FUNCTION-CALL.
             (and (function-name-p fun) (null (fenv-search fun))
                  (not (and (symbolp fun)
                            (or (special-operator-p fun) (macro-function fun))))
                  (not (declared-notinline fun))
                  (or #| ;; probably not worth it
                      (and (in-defun fun)
                           (multiple-value-bind
                                (req opt rest-flag key-flag keylist allow-flag)
                             (fdescr-signature (cons *func* nil))
                             (declare (ignore keylist allow-flag))
                             (and (<= req n) (or rest-flag (<= n (+ req opt)))
                                  (not key-flag))))
                      |#
                      (inline-callable-lambdabody-p (inline-lambdabody fun) n)))))))

;; specially declared symbols:
(defvar *specials*)   ; list of all symbols recently declared special
(defvar *ignores*)    ; list of all symbols/fnames recently declared ignore
(defvar *ignorables*) ; list of all symbols/fnames recently declared ignorable
(defvar *readonlys*)  ; list of all symbols recently declared read-only

;; check whether (FUNCTION FNAME) is in LIST
(defun fname-ignored-p (fname list)
  (dolist (n list)
    (when (and (consp n) (equal fname (second n)))
      (return t))))

;; push all symbols for special variables into *venv* :
(defun push-specials ()
  (apply #'push-*venv* (mapcar #'make-special-var *specials*)))

;; checks if a variable is rightly ignore-declared...
(defun ignore-check (var)
  (let ((sym (var-name var)))
    (if (memq sym *ignores*) ; var ignore-declared
      (if (var-specialp var)
        (c-warn (TEXT "Binding variable ~S can cause side effects despite IGNORE declaration since it is declared SPECIAL.")
                sym)
        (when (var-for-value-usedp var)
          ;; style-warning as per 3.2.5, although
          ;; COMPILER-DIAGNOSTICS:USE-HANDLER calls it a warning
          (c-style-warn (TEXT "variable ~S is used despite IGNORE declaration.")
                        sym)))
      ;; var not ignore-declared
      (unless (or (memq sym *ignorables*) ; var also not ignorable-declared
                  ;; (symbols without Home-Package do not originate from the
                  ;; user, the warning would only cause confusion).
                  (null (symbol-package sym)) ; sym a (gensym) ?
                  (var-specialp var)) ; var is lexical
        (unless (var-usedp var) ; var is never used
          (c-style-warn (TEXT "variable ~S is not used.~%Misspelled or missing IGNORE declaration?") sym))
        (when (and (var-assignedp var) (not (var-for-value-usedp var)))
          (c-style-warn (TEXT "variable ~S is assigned but not read") sym))))
    (when (memq sym *readonlys*)
      (unless (var-specialp var)
        (when (var-assignedp var)
          (c-warn (TEXT "The variable ~S is assigned to, despite READ-ONLY declaration.")
                  sym))))))

;; returns the Code, that is necessary for the new construction of a
;; Closure and its placement in the Stack:
;; this Code extends the Venv described by (cdr venvc) with closurevars,
;; (cdr stackz) is the current stack-state.
;; After the construction of the Closure venvc resp.
;; stackz are the current states.
(defun c-MAKE-CLOSURE (closurevars venvc stackz)
  (if closurevars
    `((VENV ,(cdr venvc) ,(cdr stackz))
      (MAKE-VECTOR1&PUSH ,(length closurevars)))
    '()))

;;; There are two ways to bind variables:
;; 1. fixed-var: the variable has a position in the Stack, may not be optimized
;;               away. If the Variable is in the Closure, however, its value
;;               must be transfered there; if the Variable is dynamic, a
;;               binding-frame has to be opened up.
;;               occurrence: MULTIPLE-VALUE-BIND, Lambda-Expression (required,
;;               optional, rest, keyword - Parameter)
;; 2. movable-var: the Variable may be optimized away, if it is constant
;;                 (it is either dynamic and constant or lexical
;;                  and bound to a constant and never SETQ-ed). So
;;                 the init-value plays a role.
;;                 occurrence: LET, LET*, Lambda-Expression (optional-svar,
;;                 keyword-svar, aux-Variable)

;; 1. fixed-var

;; binding of a fixed-var:
;; symbol --> Variable
;; Leaves *stackz* unchanged.
(defun bind-fixed-var-1 (symbol)
  (if (or (constantp symbol)
          (proclaimed-special-p symbol)
          (memq symbol *specials*))
    ;; must bind symbol dynamically:
    (progn
      (when (l-constantp symbol)
        (c-error-c symbol (TEXT "Constant ~S cannot be bound.")
                   symbol))
      (make-special-var symbol))
    ;; must bind symbol lexically :
    (make-var :name symbol :specialp nil :constantp nil
              :usedp nil :for-value-usedp nil :really-usedp nil
              :closurep nil
              :stackz *stackz* :venvc *venvc* :fnode *func*)))

;; registers in *stackz*, that a fixed-var is being bound
(defun bind-fixed-var-2 (var)
  (when (and (var-specialp var) (not (var-constantp var)))
    (push '(BIND 1) *stackz*)))

;; returns the Code that binds the variable var to the content of stackdummyvar
;; stackz is the stack-state before the binding of this variable.
(defun c-bind-fixed-var (var stackdummyvar stackz)
  (if (var-specialp var)
    (if (var-constantp var)
      '() ; constant cannot be bound
      `((GET ,stackdummyvar ,*venvc* ,stackz)
        (BIND ,(new-const (var-name var)))))
    ; var lexical, not constant by definition
    (if (var-closurep var)
      `((GET ,stackdummyvar ,*venvc* ,stackz)
        (SET ,var ,*venvc* ,stackz))
      '()))) ; var and stackdummyvar identical

;; creates a Stack-Variable and a Fixed-Variable at a time for each
;; Symbol from the Variable-List symbols and returns both lists as values.
(defun process-fixed-var-list (symbols &optional optimflags)
  (do ((symbolsr symbols (cdr symbolsr))
       (optimflagsr optimflags (cdr optimflagsr))
       (varlist nil) ; list of Variables
       (stackvarlist nil)) ; list of Stackvariables (partly Dummys)
      ((null symbolsr) (values (nreverse varlist) (nreverse stackvarlist)))
    (push 1 *stackz*)
    ;; with constantp=nil and really-usedp=t,
    ;; in order to avoid optimizing it away
    (push (make-var :name (gensym) :specialp nil :constantp nil
                    :usedp nil :for-value-usedp nil
                    :really-usedp (null (car optimflagsr)) :closurep nil
                    :stackz *stackz* :venvc *venvc* :fnode *func*)
          stackvarlist)
    (push (bind-fixed-var-1 (car symbolsr)) varlist)))

;; Eliminates all assignments to an unused Variable.
(defun unmodify-unused-var (var)
  (dolist (modified (var-modified-list var))
    (if (cddr modified)
      ;; value of the assignment is needed
      (let ((set-anode (second modified))) ; Anode of the assignment itself
        (setf (anode-code set-anode) '((VALUES1)))) ; remove assignment
      ;; value of the assignment is not needed
      (progn
        (let ((value-anode (first modified))) ; Anode for assigned value
          (when (anode-side-effect-free-p value-anode)
            (setf (anode-code value-anode) '()))) ; poss. remove value-form
        (let ((set-anode (second modified))) ; Anode of the assignment itself
          (setf (anode-code set-anode) '())))))) ; remove assignment

;; checks and optimizes the variables
;; and returns the list of Closure-Variables (in the right order).
(defun checking-fixed-var-list (varlist &optional optimflaglist)
  (let ((closurevarlist '()))
    (dolist (var varlist (nreverse closurevarlist))
      ;; 1st step: write poss. warnings
      (ignore-check var)
      ;; 2nd step: finally determine variable-location (Stack or Closure),
      ;; poss. optimize
      (unless (var-specialp var)
        ;; only lexical Variables can lie in the Closure,
        ;; only lexical Variables can be optimized
        (if (not (var-really-usedp var))
          ;; Variable lexical and unused
          (progn ; eliminate variable
            (setf (var-closurep var) nil)
            (when (car optimflaglist) ; optimize-able fixed-var?
              (setf (first (var-stackz var)) 0) ; remove from stack
              (setf (car optimflaglist) 'GONE)) ; note as gone
            (unmodify-unused-var var)) ; eliminate assignments to var
          (when (var-closurep var)
            ; variable must lie in the closure
            (push var closurevarlist))))
      (setq optimflaglist (cdr optimflaglist)))))

;; 2. movable-var

;; At the Binding of a Variable var to an Anode anode:
;; Is the lexical Variable being bound to the value at a lexical
;; variable? If so, to which variable?
(defun bound-to-var-p (var anode)
  (if (var-specialp var)
    nil
    ;; var lexically
    (loop
      (unless (eql (length (anode-code anode)) 1) (return nil))
      (setq anode (first (anode-code anode)))
      (unless (anode-p anode)
        (if (and (consp anode) (eq (first anode) 'GET))
          ;; Code at the Anode consists exactly of ((GET outervar ...)).
          (return (second anode))
          (return nil))))))

;; Binding of a movable-var:
;; symbol form-anode --> Variable
;; extends *stackz* exactly by one entry
(defun bind-movable-var (symbol form-anode)
  (if (or (constantp symbol)
          (proclaimed-special-p symbol)
          (memq symbol *specials*))
    ;; must bind symbol dynamically:
    (progn
      (if (l-constantp symbol)
        (progn
          (c-error-c symbol (TEXT "Constant ~S cannot be bound.") symbol)
          (push 0 *stackz*))
        (push '(BIND 1) *stackz*))
      (make-special-var symbol))
    ;; must bind symbol lexically:
    (let ((var
            (progn
              (push 1 *stackz*) ; preliminary: 1 place on the Stack
              (make-var :name symbol :specialp nil
                :constantp (anode-constantp form-anode) ; is set to NIL for assignments
                :constant (if (anode-constantp form-anode)
                            (anode-constant form-anode))
                :usedp nil :for-value-usedp nil :really-usedp nil
                :closurep nil ; is possibly set to T
                :stackz *stackz* :venvc *venvc* :fnode *func*))))
      (let ((outervar (bound-to-var-p var form-anode)))
        (when outervar ; if var is bound to a variable outervar, later
                       ; poss. each reference to var may be converted
                       ; to a reference to outervar.
          (push (list var form-anode) (var-replaceable-list outervar))))
      var)))

;; returns the code, that binds the variable var to A0:
(defun c-bind-movable-var (var)
  (if (var-specialp var)
    (if (var-constantp var)
      '() ; dynamic constants cannot be bound
      `((BIND ,(new-const (var-name var)))))
    (if (var-closurep var)
      ;; write Closure-Variable:
      ;; (var-stackz var) = (0 . ...) is the current stack-state.
      `((SET ,var ,*venvc* ,(var-stackz var)))
      ;; lexical Variable: was poss. eliminated from the Stack
      (if (zerop (first (var-stackz var)))
        '()
        `((PUSH)))))) ; in the Stack: write to the next-lower stack-location

;; returns the code that binds the variable var to the result of the
;; ANODE anode
(defun c-bind-movable-var-anode (var anode)
  (let ((binding-anode
          (make-anode :type 'BIND-MOVABLE
                      :sub-anodes '()
                      :seclass *seclass-pure*
                      :code (c-bind-movable-var var))))
    (let ((outervar (bound-to-var-p var anode)))
      (when outervar ; if var is bound to a Variable outervar, later
                     ; poss. each reference to var may be converted to a
                     ; reference to outervar.
        (dolist (innervar-info (var-replaceable-list outervar))
          (when (eq (first innervar-info) var) ; additionally set binding-anode
            (setf (cddr innervar-info) binding-anode)))))
    (list anode binding-anode)))

;; (process-movable-var-list symbols initforms *-flag) compiles the initforms
;; (like for LET/LET*) and associates them with the variables to symbols.
;; changes *venv* (for *-flag : incrementally, else all at once).
;; returns three values:
;; 1. list of Variables,
;; 2. list of ANODEs for the initforms,
;; 3. list of stack-states after the binding of the variables.
(defun process-movable-var-list (symbols initforms *-flag)
  (do ((symbolsr symbols (cdr symbolsr))
       (initformsr initforms (cdr initformsr))
       (varlist '())
       (anodelist '())
       (stackzlist '()))
      ((null symbolsr)
       (unless *-flag (apply #'push-*venv* varlist)) ; binding at LET
       (values (nreverse varlist) (nreverse anodelist) (nreverse stackzlist)))
    (let* ((initform (car initformsr))
           (anode (c-form initform 'ONE)) ; compile initform
           (var (bind-movable-var (car symbolsr) anode)))
      (push anode anodelist)
      (push var varlist)
      (push *stackz* stackzlist)
      (when *-flag (push-*venv* var))))) ; binding at LET*

;; checks and optimizes the variables (like at LET/LET*)
;; and returns the list of Closure-Variables (in the right order).
(defun checking-movable-var-list (varlist anodelist)
  (do ((varlistr varlist (cdr varlistr))
       (anodelistr anodelist (cdr anodelistr))
       (closurevarlist '()))
      ((null varlistr) (nreverse closurevarlist))
    (let ((var (car varlistr)))
      (when var
        ;; 1st step: write poss. warnings
        (ignore-check var)
        ;; 2nd step: finally determine variable-location
        ;; (Stack or Closure or eliminated)
        (unless (var-specialp var)
          ;; can only be optimized for lexical variables
          (if (var-constantp var)
            ;; Variable lexical and constant
            (progn ; eliminate variable
              (setf (var-closurep var) nil)
              (setf (first (var-stackz var)) 0) ; remove from Stack
              (when (anode-side-effect-free-p (car anodelistr))
                ;; maybe remove initform
                (setf (anode-code (car anodelistr)) '())))
            (if (not (var-really-usedp var))
              ;; Variable lexical and unused
              (progn ; eliminate variable
                (setf (var-closurep var) nil)
                (setf (first (var-stackz var)) 0) ; remove from Stack
                (when (anode-side-effect-free-p (car anodelistr))
                  ;; maybe remove initform
                  (setf (anode-code (car anodelistr)) '()))
                (unmodify-unused-var var)) ; eliminate assignments to var
              (when (var-closurep var)
                ;; Variable must lie in the Closure
                (setf (first (var-stackz var)) 0) ; occupies 0 Stack-Entries
                (push var closurevarlist)))))))))

;; Optimizes a list of variables.
;; (The lexically inner variables have to occur at the end of the list.)
(defun optimize-var-list (vars)
  (unless *no-code*
    (dolist (var (reverse vars))
      (when var
        ;; Optimization (inner variables first):
        ;; If a Variable innervar is bound to the value of var, and if
        ;; during the life-time of innervar neither innervar nor var are
        ;; changed (in order to be able to assure this, both must be
        ;; lexical and in the Stack), innervar can be replaced by var.
        (unless (or (var-specialp var) (var-closurep var))
          ;; var is lexical and in the Stack
          (dolist (innervar-info (var-replaceable-list var))
            (let ((innervar (first innervar-info)))
              ;; innervar is a movable-var, that is initialized with var.
              ;; during the life-time of innervar nothing is assigned to var.
              (unless (or (var-specialp innervar) (var-closurep innervar))
                ;; innervar is lexical and in the Stack
                (when (null (var-modified-list innervar))
                  ;; during the life-time of innervar nothing
                  ;; is assigned to innervar, too.
                  (unless (eql (first (var-stackz innervar)) 0)
                    ;; innervar not yet optimized away?
                    (when (cddr innervar-info)
                      ;; innervar-info consists correctly of three parts?
                      ;; eliminate Variable innervar:
                      ;; remove from Stack:
                      (setf (first (var-stackz innervar)) 0)
                      ;; eliminate initialization and binding of innervar:
                      (setf (anode-code (second innervar-info)) '())
                      (setf (anode-code (cddr innervar-info)) '())
                      ;; the references to Variable innervar are transformed
                      ;; to references to Variable var:
                      (let ((using-var (var-usedp var)))
                        (do ((using-innervar (var-usedp innervar)
                                             (cdr using-innervar)))
                            ((atom using-innervar))
                          (let* ((anode (car using-innervar)) ; type VAR anode
                                 ;; its code, () or ((GET ...))
                                 (code (anode-code anode)))
                            (unless (null code)
                              ;; (anode-code anode) has the shape
                              ;; ((GET innervar ...))
                              (setf (second (car code)) var)
                              (push anode using-var))))
                        (setf (var-usedp var) using-var)))))))))))))

;; builds the code, that binds a list of variables, together with their svars
;; (the same as for Lambdabody- Optional/Key - variables).
(defun c-bind-with-svars (-vars -dummys s-vars -anodes s-anodes -stackzs)
  (do ((-varsr -vars (cdr -varsr)) ; fixed-vars
       (-dummysr -dummys (cdr -dummysr))
       (s-varsr s-vars (cdr s-varsr)) ; movable-vars
       (-anodesr -anodes (cdr -anodesr))
       (s-anodesr s-anodes (cdr s-anodesr))
       (-stackzsr -stackzs (cdr -stackzsr))
       (L '()))
      ((null -varsr) (nreverse L))
    (when (car s-varsr)
      (setq L
        (revappend
          (c-bind-movable-var-anode (car s-varsr) (car s-anodesr))
          L)))
    (setq L
      (revappend
        (let* ((var (car -varsr))
               (stackdummyvar (car -dummysr))
               (anode (car -anodesr))
               (stackz (car -stackzsr))
               (label (make-label 'ONE)))
          (if (var-specialp var)
            `((JMPIFBOUNDP ,stackdummyvar ,*venvc* ,stackz ,label)
              ,anode
              ,label
              ,@(if (var-constantp var)
                  '() ; constant cannot be bound
                  `((BIND ,(new-const (var-name var))))))
            ;; var lexical, not constant by definition
            (if (var-closurep var)
              `((JMPIFBOUNDP ,stackdummyvar ,*venvc* ,stackz ,label)
                ,anode
                ,label
                (SET ,var ,*venvc* ,stackz))
              (if (not (var-really-usedp var))
                ;; Variable was optimized away in checking-fixed-var-list
                (if (anode-side-effect-free-p anode)
                  '()
                  `((JMPIFBOUNDP ,stackdummyvar ,*venvc* ,stackz ,label)
                    ,anode
                    ,label))
                ;; variable available in stack
                `((JMPIFBOUNDP ,stackdummyvar ,*venvc* ,stackz ,label)
                  ,anode
                  (SET ,var ,*venvc* ,stackz)
                  ,label)))))
        L))))

;; add 1 stack slot for closure dummy
(proclaim '(inline closuredummy-add-stack-slot))
(defun closuredummy-add-stack-slot (closurevars closuredummy-stackz
                                    closuredummy-venvc)
  (when closurevars
    (setf (first closuredummy-venvc) (cons closurevars closuredummy-stackz)
          (first closuredummy-stackz) 1)))

;; compile (name lambdalist {declaration|docstring}* {form}*), return the FNODE
(defun c-LAMBDABODY (name lambdabody &optional fenv-cons gf-p reqoptimflags)
  (test-list lambdabody 1)
  (let* ((*func* (make-fnode :enclosing *func* :venvc *venvc*
                             :name (if (integerp name)
                                       (symbol-suffix (fnode-name *func*) name)
                                       name)))
         (*stackz* *func*) ; empty stack
         (*venvc* (cons *func* *venvc*))
         (*func-start-label* (make-label 'NIL))
         (*anonymous-count* 0)
         (lalist (car lambdabody))
         (type-decls '())
         (anode (catch 'c-error
    ;; here it starts to become complicated
    (multiple-value-bind (reqvar  optvar optinit optsvar  restvar
                          keyflag keyword keyvar keyinit keysvar
                          allow-other-keys auxvar auxinit)
        (if fenv-cons
          ;; c-analyze-lambdalist was already called at c-LABELS
          (values-list (cddar fenv-cons))
          (progn
            (when *defun-accept-specialized-lambda-list*
              (multiple-value-setq (lalist type-decls)
                (sys::specialized-lambda-list-to-ordinary
                 lalist 'compile)))
            (c-analyze-lambdalist lalist)))
      (when (and optvar keyvar)
        (c-style-warn (TEXT "Mixing ~S and ~S in lambda list ~S is bad design")
                      '&OPTIONAL '&KEY lalist))
      (setf (fnode-req-num *func*) (length reqvar)
            (fnode-opt-num *func*) (length optvar)
            (fnode-rest-flag *func*) (not (eql restvar 0))
            (fnode-keyword-flag *func*) keyflag
            (fnode-keywords *func*) keyword
            (fnode-lambda-list *func*) lalist
            (fnode-allow-other-keys-flag *func*) allow-other-keys)
      (when fenv-cons (setf (caar fenv-cons) *func*)) ; Fixup for c-LABELS
      (multiple-value-bind (body-rest declarations docstring)
          (parse-body (cdr lambdabody) t)
        (setf (fnode-documentation *func*) docstring)
        (setq declarations (nreconc type-decls declarations))
        (let ((oldstackz *stackz*)
              (*stackz* *stackz*)
              (*denv* *denv*)
              (*venv* *venv*)
              (*venvc* *venvc*)
              *specials* *ignores* *ignorables* *readonlys* other-decls
              req-vars req-dummys req-stackzs
              opt-vars opt-dummys opt-anodes opts-vars opts-anodes opt-stackzs
              rest-vars rest-dummys rest-stackzs
              key-vars key-dummys key-anodes keys-vars keys-anodes key-stackzs
              aux-vars aux-anodes
              closuredummy-stackz closuredummy-venvc)
          (multiple-value-setq
              (*specials* *ignores* *ignorables* *readonlys* other-decls)
            (process-declarations declarations))
          ;; visibility of Closure-Dummyvar:
          (push nil *venvc*)
          (setq closuredummy-venvc *venvc*)
          ;; build Stack-Dummy-Variable for reqvar, optvar, restvar, keyvar:
          (multiple-value-setq (req-vars req-dummys)
            (process-fixed-var-list reqvar reqoptimflags))
          (multiple-value-setq (opt-vars opt-dummys)
            (process-fixed-var-list optvar))
          (multiple-value-setq (rest-vars rest-dummys)
            (if (eql restvar 0)
              (values '() '())
              (process-fixed-var-list (list restvar))))
          (multiple-value-setq (key-vars key-dummys)
            (process-fixed-var-list keyvar))
          ;; room for the function itself (below the arguments):
          (push 1 *stackz*)
          ;; room for Closure-Dummyvar:
          (push 0 *stackz*)
          (setq closuredummy-stackz *stackz*)
          ;; activate the bindings of the required-parameters:
          (setq req-stackzs (bind-req-vars req-vars))
          ;; activate the bindings of the optional-parameters/svar:
          (multiple-value-setq (opt-anodes opt-stackzs opts-vars opts-anodes)
            (bind-opt-vars opt-vars opt-dummys optinit optsvar))
          ;; activate the bindings of the rest-parameters:
          (unless (eql restvar 0)
            (setq rest-stackzs (bind-rest-vars rest-vars)))
          ;; activate the bindings of the keyword-parameters/svar:
          (multiple-value-setq (key-anodes key-stackzs keys-vars keys-anodes)
            (bind-opt-vars key-vars key-dummys keyinit keysvar))
          ;; activate the bindings of the Aux-Variables:
          (multiple-value-setq (aux-vars aux-anodes)
            (bind-aux-vars auxvar auxinit))
          (push-specials)
          (push-*denv* other-decls)
          (setf (fnode-denv *func*) *denv*)
          (let* ((body-anode (c-form `(PROGN ,@body-rest) (if gf-p 'ONE 'ALL)))
                 ;; check the variables:
                 (closurevars
                   (append
                     (checking-fixed-var-list req-vars reqoptimflags)
                     (checking-fixed-var-list opt-vars)
                     (checking-movable-var-list opts-vars opts-anodes)
                     (checking-fixed-var-list rest-vars)
                     (checking-fixed-var-list key-vars)
                     (checking-movable-var-list keys-vars keys-anodes)
                     (checking-movable-var-list aux-vars aux-anodes)))
                 (codelist
                   `(,*func-start-label*
                     ,@(c-make-closure closurevars closuredummy-venvc
                                       closuredummy-stackz)
                     ,@(mapcap #'c-bind-fixed-var req-vars req-dummys
                               req-stackzs)
                     ,@(c-bind-with-svars opt-vars opt-dummys opts-vars
                                          opt-anodes opts-anodes opt-stackzs)
                     ,@(mapcap #'c-bind-fixed-var rest-vars rest-dummys
                               rest-stackzs)
                     ,@(c-bind-with-svars key-vars key-dummys keys-vars
                                          key-anodes keys-anodes key-stackzs)
                     ,@(mapcap #'c-bind-movable-var-anode aux-vars aux-anodes)
                     ,body-anode
                     (UNWIND ,*stackz* ,oldstackz t)
                     ,(if gf-p '(RETGF) '(RET))))
                 (anode-list `(,@opt-anodes ,@(remove nil opts-anodes)
                               ,@key-anodes ,@(remove nil keys-anodes)
                               ,@aux-anodes ,body-anode))
                 (anode
                   (make-anode
                     :type 'LAMBDABODY
                     :source lambdabody
                     :sub-anodes anode-list
                     :seclass *seclass-foldable*
                     :stackz oldstackz
                     :code codelist)))
            (closuredummy-add-stack-slot
             closurevars closuredummy-stackz closuredummy-venvc)
            (optimize-var-list (append req-vars opt-vars opts-vars rest-vars
                                       key-vars keys-vars aux-vars))
            (setf (anode-seclass anode) (anodelist-seclass-or anode-list))
            anode))))
    ;; this was the production of the Anode
    )))
    ;; anonymous functions are ignorable
    (unless (integerp name) (push *func* *fnode-list*))
    (setf (fnode-code *func*) anode)
    (when reqoptimflags
      (decf (fnode-req-num *func*) (count 'GONE reqoptimflags)))
    (when (eq (anode-type anode) 'ERROR)
      ;; turn it into a correct function, that does nothing
      (setf (fnode-req-num *func*) 0
            (fnode-opt-num *func*) 0
            (fnode-rest-flag *func*) t
            (fnode-keyword-flag *func*) nil
            (fnode-keywords *func*) '()
            (fnode-allow-other-keys-flag *func*) nil
            (anode-code (fnode-code *func*)) `((NIL) (SKIP 2) (RET))))
    (setf (fnode-gf-p *func*) gf-p)
    (setf (fnode-venvconst *func*)
          (not (and (null (fnode-far-used-vars *func*))
                    (null (fnode-far-assigned-vars *func*)))))
    (setf (fnode-Consts-Offset *func*)
      (+ (setf (fnode-Keyword-Offset *func*)
           (+ (setf (fnode-Tagbodys-Offset *func*)
                (+ (setf (fnode-Blocks-Offset *func*)
                     (if (fnode-venvconst *func*) 1 0))
                   (length (fnode-Blocks *func*))))
              (length (fnode-Tagbodys *func*))))
         (length (fnode-Keywords *func*))))
    (when gf-p
      ;; the dispatch of generic functions cannot refer to external blocks and
      ;; tagbodies. the keywords are indeed displaced perforce.
      (when (or (fnode-Blocks *func*) (fnode-Tagbodys *func*))
        (compiler-error 'c-LAMBDABODY "GF"))
      ;; Now (fnode-Keyword-Offset *func*) = (fnode-Tagbodys-Offset *func*) =
      ;;    = (fnode-Blocks-Offset *func*) = (if (fnode-venvconst *func*) 1 0)
    )
    ;; Set list of outer blocks that are needed by *func*.
    (setf (fnode-far-used-blocks *func*)
          (remove-if #'(lambda (block) (eq (block-fnode block) *func*))
                     (fnode-Blocks *func*)))
    ;; Set list of outer tagbodys and tags that are needed by *func*.
    (setf (fnode-far-used-tagbodys *func*)
          (remove-if #'(lambda (tagbody+tag)
                         (eq (tagbody-fnode (car tagbody+tag)) *func*))
                     (fnode-Tags *func*)))
    *func*))
(defun bind-req-vars (req-vars)
  (let ((req-stackzs '()))
    (dolist (var req-vars)
      (push-*venv* var)
      (push *stackz* req-stackzs)
      (bind-fixed-var-2 var))
    (nreverse req-stackzs)))
(defun bind-opt-vars (opt-vars opt-dummys optinit optsvar)
  (let ((opt-anodes '())
        (opt-stackzs '())
        (opts-vars '())
        (opts-anodes '()))
    (do ((opt-varsr opt-vars (cdr opt-varsr))
         (opt-dummysr opt-dummys (cdr opt-dummysr))
         (optinitr optinit (cdr optinitr))
         (optsvarr optsvar (cdr optsvarr)))
        ((null opt-varsr))
      (if (eql (car optsvarr) 0)
        (progn (push nil opts-vars) (push nil opts-anodes))
        (let* ((anode
                 (make-anode
                   :type 'OPTIONAL-SVAR
                   :sub-anodes '()
                   :seclass (make-seclass
                             :uses (list (car opt-dummysr)))
                   :code `((BOUNDP ,(car opt-dummysr) ,*venvc* ,*stackz*))))
               (var (bind-movable-var (car optsvarr) anode)))
          (push anode opts-anodes)
          (push var opts-vars)))
      (push (c-form (car optinitr) 'ONE) opt-anodes)
      (push-*venv* (car opt-varsr))
      (push *stackz* opt-stackzs) (bind-fixed-var-2 (car opt-varsr))
      (unless (eql (car optsvarr) 0) (push-*venv* (car opts-vars))))
    (values
      (nreverse opt-anodes) (nreverse opt-stackzs)
      (nreverse opts-vars) (nreverse opts-anodes))))
(defun bind-rest-vars (rest-vars)
  (let ((rest-stackzs '()))
    (push-*venv* (car rest-vars))
    (push *stackz* rest-stackzs)
    (bind-fixed-var-2 (car rest-vars))
    rest-stackzs)) ; (nreverse rest-stackzs) unnecessary
(defun bind-aux-vars (auxvar auxinit)
  (let ((aux-vars '())
        (aux-anodes '()))
    (do ((auxvarr auxvar (cdr auxvarr))
         (auxinitr auxinit (cdr auxinitr)))
        ((null auxvarr))
      (let* ((initform (car auxinitr))
             (anode (c-form initform 'ONE))
             (var (bind-movable-var (car auxvarr) anode)))
        (push anode aux-anodes)
        (push var aux-vars)
        (push-*venv* var)))
    (values (nreverse aux-vars) (nreverse aux-anodes))))

;; returns the ANODE, that itself returns (on a given current stack-state)
;; the function belonging to an FNODE as value.
(defun c-FNODE-FUNCTION (fnode &optional (*stackz* *stackz*))
  (make-anode
    :type 'FUNCTION
    :sub-anodes '()
    :seclass *seclass-pure*
    :code (if (zerop (fnode-keyword-offset fnode))
            `((FCONST ,fnode))
            `(,@(if (fnode-Venvconst fnode)
                  (prog1 ; Venv has to be passed on construction
                      `((VENV ,(fnode-venvc fnode) ,*stackz*)
                        (PUSH))
                    (push 1 *stackz*)))
              ,@(mapcap ; Block-Conses have to be passed on construction
                  #'(lambda (block)
                      (prog1
                        `(,(if (memq block (fnode-Blocks *func*))
                             `(BCONST ,block)
                             `(GET ,(block-consvar block) ,*venvc* ,*stackz*))
                           (PUSH))
                        (push 1 *stackz*)))
                  (fnode-Blocks fnode))
              ,@(mapcap ; Tagbody-Conses have to be passed on construction
                  #'(lambda (tagbody)
                      (prog1
                          `(,(if (memq tagbody (fnode-Tagbodys *func*))
                               `(GCONST ,tagbody)
                               `(GET ,(tagbody-consvar tagbody)
                                     ,*venvc* ,*stackz*))
                            (PUSH))
                        (push 1 *stackz*)))
                  (fnode-Tagbodys fnode))
              ,@(if (fnode-gf-p fnode)
                  (progn
                    (assert (= (fnode-keyword-offset fnode) 1))
                    `((FCONST ,fnode)
                      (PUSH)
                      ,(CALLS-code-fun SYSTEM::%COPY-GENERIC-FUNCTION)))
                  `((COPY-CLOSURE ,fnode ,(fnode-keyword-offset fnode))))))))


;;;;****        FIRST PASS :   SPECIAL   FORMS

;; compile (PROGN {form}*)
;; no forms -> NIL, exactly one form -> that form,
;; at least two forms -> all in order, only the last form's values
;; count.
(defun c-PROGN ()
  (test-list *form* 1)
  (let ((L (cdr *form*))) ; list of forms
    (cond ((null L) (c-NIL)) ; no form -> NIL
          ((null (cdr L)) (c-form (car L))) ; exactly one form
          (t (do (#+CLISP-DEBUG (anodelist '())
                  (seclass *seclass-foldable*)
                  (codelist '())
                  (Lr L)) ; remaining list of forms
                 ((null Lr)
                  (make-anode
                    :type 'PROGN
                    :sub-anodes (nreverse anodelist)
                    :seclass seclass
                    :code (nreverse codelist)))
               (let* ((formi (pop Lr)) ; i-th form
                      (anodei (c-form formi (if (null Lr) *for-value* 'NIL))))
                 #+CLISP-DEBUG (push anodei anodelist)
                 (seclass-or-f seclass anodei)
                 (push anodei codelist)))))))

;; compile (PROG1 form1 {form}*)
;; on *for-value* the value of form1 has to be saved in the stack
(defun c-PROG1 ()
  (test-list *form* 2)
  (if (or (null *for-value*) (and (eq *for-value* 'ONE) (null (cddr *form*))))
    (c-form `(PROGN ,@(cdr *form*)))
    (let ((anode1 (c-form (second *form*) 'ONE))
          (anode2 (let ((*stackz* (cons 1 *stackz*)))
                    (c-form `(PROGN ,@(cddr *form*)) 'NIL))))
      (make-anode
        :type 'PROG1
        :sub-anodes (list anode1 anode2)
        :seclass (anodes-seclass-or anode1 anode2)
        :code `(,anode1 (PUSH) ,anode2 (POP))))))

;; compile (PROG2 form1 form2 {form}*)
(defun c-PROG2 ()
  (test-list *form* 3)
  (c-form `(PROGN ,(second *form*) (PROG1 ,(third *form*) ,@(cdddr *form*)))))

;; compile (IF form1 form2 [form3])
;; if form1 is a constant, then the Compiler can make the fall differentiation.
(defun c-IF ()
  (test-list *form* 3 4)
  (let ((form1 (second *form*))
        (form2 (third *form*))
        (form3 (fourth *form*))) ; = NIL, if *form* only has length 3
    (let ((anode1 (c-form form1 'ONE)))
      (if (anode-constantp anode1)
        (if (anode-constant-value anode1)
          (prog1 (c-form form2) (let ((*no-code* t)) (c-form form3 'NIL)))
          (prog2 (let ((*no-code* t)) (c-form form2 'NIL)) (c-form form3)))
        (let ((anode2 (c-form form2))
              (label1 (make-label *for-value*)))
          (if form3
            (let ((anode3 (c-form form3))
                  (label2 (make-label 'NIL)))
              (make-anode
                :type 'IF
                :sub-anodes (list anode1 anode2 anode3)
                :seclass (anodes-seclass-or anode1 anode2 anode3)
                :code `(,anode1
                        (JMPIFNOT ,label2)
                        ,anode2
                        (JMP ,label1)
                        ,label2
                        ,anode3
                        ,label1)))
            ;; save one jump on if without else
            (make-anode
              :type 'IF
              :sub-anodes (list anode1 anode2)
              :seclass (anodes-seclass-or anode1 anode2)
              :code `(,anode1
                      (,(if *for-value* 'JMPIFNOT1 'JMPIFNOT) ,label1)
                      ,anode2
                      ,label1))))))))

;; compile (WHEN form1 {form}*)
(defun c-WHEN ()
  (test-list *form* 2)
  (c-form `(IF ,(second *form*) (PROGN ,@(cddr *form*)))))

;; compile (UNLESS form1 {form}*)
(defun c-UNLESS ()
  (test-list *form* 2)
  (c-form `(IF ,(second *form*) NIL (PROGN ,@(cddr *form*)))))

;; compile (AND {form}*)
(defun c-AND ()
  (test-list *form* 1)
  (cond ((null (cdr *form*)) ; no forms
         (make-anode
           :type 'AND
           :sub-anodes '()
           :seclass *seclass-foldable*
           :code '((T))))
        ((null (cddr *form*)) (c-form (second *form*))) ; exactly one form
        (t (do (#+CLISP-DEBUG (anodelist '())
                (seclass *seclass-foldable*)
                (codelist '())
                (Lr (cdr *form*))
                (label (make-label *for-value*))) ; Label at the end
               ((null Lr)
                (push label codelist)
                (make-anode
                  :type 'AND
                  :sub-anodes (nreverse anodelist)
                  :seclass seclass
                  :code (nreverse codelist)))
             (let* ((formi (pop Lr))
                    (anodei (c-form formi (if (null Lr) *for-value* 'ONE))))
               #+CLISP-DEBUG (push anodei anodelist)
               (seclass-or-f seclass anodei)
               (if (null Lr)
                 ;; last form -> take over directly
                 (push anodei codelist)
                 ;; not the last form -> create test
                 (if (anode-constantp anodei)
                   ;; constant /= NIL -> omit, constant NIL -> finished
                   (unless (anode-constant-value anodei)
                     (if *for-value* (push '(NIL) codelist))
                     (let ((*no-code* t))
                       (dolist (form Lr) (c-form form 'NIL)))
                     (setq Lr nil))
                   (progn ; normal test
                     (push anodei codelist)
                     (push `(,(if *for-value* 'JMPIFNOT1 'JMPIFNOT) ,label)
                           codelist)))))))))

;; compile (OR {form}*)
(defun c-OR ()
  (test-list *form* 1)
  (cond ((null (cdr *form*)) ; no forms
         (make-anode
           :type 'OR
           :sub-anodes '()
           :seclass *seclass-foldable*
           :code '((NIL))))
        ((null (cddr *form*)) (c-form (second *form*))) ; exactly one form
        (t (do (#+CLISP-DEBUG (anodelist '())
                (seclass *seclass-foldable*)
                (codelist '())
                (Lr (cdr *form*))
                (label (make-label *for-value*))) ; Label at the end
               ((null Lr)
                ;; If the last anode is known to be side-effect-free and to
                ;; evaluate to NIL, drop it, and turn the jump before it to
                ;; (VALUES1).
                (let ((last-anode (car codelist)))
                  (when (and last-anode (anode-constantp last-anode)
                             (null (anode-constant-value last-anode))
                             (cdr codelist))
                    (pop codelist)
                    (setf (car codelist) '(VALUES1))))
                (push label codelist)
                (make-anode
                  :type 'OR
                  :sub-anodes (nreverse anodelist)
                  :seclass seclass
                  :code (nreverse codelist)))
             (let* ((formi (pop Lr))
                    (anodei (c-form formi (if (null Lr) *for-value* 'ONE))))
               #+CLISP-DEBUG (push anodei anodelist)
               (seclass-or-f seclass anodei)
               (if (null Lr)
                 ;; last form -> take over directly
                 (push anodei codelist)
                 ;; not the last form -> create test
                 (if (anode-constantp anodei)
                   ;; constant NIL -> omit, constant /= NIL -> finished
                   (when (anode-constant-value anodei)
                     (if *for-value* (push anodei codelist))
                     (let ((*no-code* t))
                       (dolist (form Lr) (c-form form 'NIL)))
                     (setq Lr nil))
                   (progn ; normal test
                     (push anodei codelist)
                     (push `(,(if *for-value* 'JMPIF1 'JMPIF) ,label)
                           codelist)))))))))

;; compile (QUOTE object)
(defun c-QUOTE ()
  (test-list *form* 2 2)
  (let ((value (second *form*)))
    (make-anode :type 'QUOTE
                :sub-anodes '()
                :seclass *seclass-foldable*
                :code (if *for-value* `((CONST ,(new-const value))) '()))))

;; compile (THE type form)
(defun c-THE ()
  (test-list *form* 3 3)
  (c-form (third *form*))) ; simply ignore the type-declaration

;; compile (DECLARE {declspec}*)
(defun c-DECLARE ()
  (test-list *form* 1)
  (c-error *form* (TEXT "Misplaced declaration: ~S") *form*))

;; compile (LOAD-TIME-VALUE form [read-only-p])
(defun c-LOAD-TIME-VALUE ()
  (test-list *form* 2 3)
  (let ((form (second *form*))) ; ignore read-only-p
    (make-anode
     :type 'LOAD-TIME-VALUE
     :sub-anodes '()
     :seclass *seclass-pure*
     :code (if *for-value*
             `((CONST ,(if *fasoutput-stream* ; not called right away
                         (if (and (symbolp form) (c-constantp form))
                           (make-const :horizon ':all
                                       :form form
                                       :ltv-form *form*
                                       :value (c-constant-value form))
                           (make-const :horizon ':form
                                       :form form
                                       :ltv-form *form*))
                         (make-const :horizon ':all
                                     :value (eval form)
                                     :form form
                                     :ltv-form *form*))))
             '()))))


;; compile (COMPILE-TIME-VALUE form)
(defun c-COMPILE-TIME-VALUE ()
  (test-list *form* 2 2)
  (make-anode :type 'CONST
              :sub-anodes '()
              :seclass *seclass-foldable*
              :code `((CONST ,(new-const (eval (second *form*)))))))

;; compile (CATCH tag {form}*)
(defun c-CATCH ()
  (test-list *form* 2)
  (let* ((anode1 (c-form (second *form*) 'ONE))
         (anode2 (let ((*stackz* (cons 'CATCH *stackz*)))
                   (c-form `(PROGN ,@(cddr *form*)))))
         (label (make-label *for-value*)))
    (make-anode :type 'CATCH
                :sub-anodes (list anode1 anode2)
                :seclass (anodes-seclass-or anode1 anode2)
                :code `(,anode1
                        (CATCH-OPEN ,label)
                        ,anode2
                        (CATCH-CLOSE)
                        ,label))))

;; compile (THROW tag form)
(defun c-THROW ()
  (test-list *form* 3 3)
  (let* ((anode1 (c-form (second *form*) 'ONE))
         (anode2 (let ((*stackz* (cons 1 *stackz*)))
                   (c-form (third *form*) 'ALL))))
    (make-anode :type 'THROW
                :sub-anodes (list anode1 anode2)
                :seclass
                  (let ((seclass12 (anodes-seclass-or anode1 anode2)))
                    (make-seclass
                      :uses (seclass-uses seclass12)
                      :uses-binding (seclass-uses-binding seclass12)
                      :modifies 'T))
                :code `(,anode1 (PUSH) ,anode2 (THROW)))))

;; compile (UNWIND-PROTECT form1 {form}*)
(defun c-UNWIND-PROTECT ()
  (test-list *form* 2)
  (let ((anode2 (let ((*stackz* (cons 'CLEANUP *stackz*)) (*for-value* nil))
                  (c-form `(PROGN ,@(cddr *form*)) 'NIL))))
    (if (anode-side-effect-free-p anode2)
      ;; cleanup forms are side-effect free ==> ignore them
      (c-form (second *form*))
      ;; cleanup forms have side effects
      (let ((anode1 (let ((*stackz* (cons 'UNWIND-PROTECT *stackz*)))
                      (c-form (second *form*))))
            (label (make-label 'NIL)))
        (make-anode :type 'UNWIND-PROTECT
                    :sub-anodes (list anode1 anode2)
                    :seclass (anodes-seclass-or anode1 anode2)
                    :code `((UNWIND-PROTECT-OPEN ,label)
                            ,anode1
                            ,@(case *for-value*
                                ((NIL) '((VALUES0)))
                                (ONE '((VALUES1)))
                                ((T) '()))
                            (UNWIND-PROTECT-NORMAL-EXIT)
                            ,label
                            ,anode2
                            (UNWIND-PROTECT-CLOSE ,label)))))))

;; compile (PROGV form1 form2 {form}*)
(defun c-PROGV ()
  (test-list *form* 3)
  (let ((anode1 (c-form (second *form*) 'ONE)))
    ;; if form1 is constant=NIL, one can spare the binding:
    (if (and (anode-constantp anode1) (null (anode-constant-value anode1)))
      (c-form `(PROGN ,(third *form*) (PROGN ,@(cdddr *form*))))
      (let* ((stackz2 (cons 1 *stackz*))
             (anode2 (let ((*stackz* stackz2))
                       (c-form (third *form*) 'ONE)))
             (stackz3 (cons 'PROGV *stackz*))
             (anode3 (let ((*stackz* stackz3))
                       (c-form `(PROGN ,@(cdddr *form*)))))
             (seclass3 (anode-seclass anode3))
             (flag t))
        ;; if anode3 does not depend on any side-effects,
        ;; one can spare the binding:
        (when (and (null (seclass-uses seclass3))
                   (null (seclass-uses-binding seclass3)))
          (setf (first stackz2) 0)
          (setf (first stackz3) 0)
          (setq flag nil))
        (make-anode :type 'PROGV
                    :sub-anodes (list anode1 anode2 anode3)
                    :seclass (anodes-seclass-or anode1 anode2 anode3)
                    :code `(,anode1
                            ,@(if flag '((PUSH)))
                            ,anode2
                            ,@(if flag '((PROGV)))
                            ,anode3
                            ,@(if flag
                                `((UNWIND ,stackz3 ,*stackz* ,*for-value*))
                                ;; is expanded to '((UNBIND1) (SKIPSP 1 0))
                                )))))))

;; compile (MULTIPLE-VALUE-PROG1 form1 {form}*)
;; if values are not needed: simple PROGN. else: if {form}*
;; is free from side-effects, only form1, else: push values of form1
;; on the stack and gather them with function VALUES afterwards.
(defun c-MULTIPLE-VALUE-PROG1 ()
  (test-list *form* 2)
  (case *for-value*
    (ALL
     (let* ((stackz1 (cons 'MVCALLP *stackz*))
            (anode1 (let ((*stackz* stackz1))
                      (c-form (second *form*))))
            (anode2 (let ((*stackz* (cons 'MVCALL *stackz*)))
                      (c-form `(PROGN ,@(cddr *form*)) 'NIL))))
       (make-anode :type 'MULTIPLE-VALUE-PROG1
                   :sub-anodes (list anode1 anode2)
                   :seclass (anodes-seclass-or anode1 anode2)
                   :code
                   (if (anode-side-effect-free-p anode2)
                     (prog2 (setf (first stackz1) 0) `(,anode1))
                     `((CONST ,(make-const :horizon ':all
                                           :value #'values
                                           :form '(function values)))
                       (MVCALLP)
                       ,anode1
                       (MV-TO-STACK)
                       ,anode2
                       (MVCALL))))))
    (ONE (c-form `(PROG1 ,@(cdr *form*))))
    ((NIL) (c-form `(PROGN ,@(cdr *form*))))))

;; compile (MULTIPLE-VALUE-CALL form1 {form}*)
(defun c-MULTIPLE-VALUE-CALL ()
  (test-list *form* 2)
  (if (null (cddr *form*))
    ;; (c-form `(FUNCALL ,(second *form*))) ; 0 Arguments for form1
    (c-FUNCTION-CALL (second *form*) '())
    (let* ((anode1 (c-form (second *form*) 'ONE))
           (seclass (f-side-effect (second *form*)))
           #+CLISP-DEBUG (anodelist (list anode1))
           (codelist '()))
      (push anode1 codelist)
      (push '(MVCALLP) codelist)
      (do ((Lr (cddr *form*))
           (i 0 (1+ i)))
          ((null Lr))
        (let* ((formi (pop Lr))
               (anodei
                 (let ((*stackz* (cons (if (zerop i) 'MVCALLP 'MVCALL)
                                       *stackz*)))
                   (c-form formi 'ALL))))
          #+CLISP-DEBUG (push anodei anodelist)
          (seclass-or-f seclass anodei)
          (push anodei codelist)
          (push '(MV-TO-STACK) codelist)))
      (push '(MVCALL) codelist)
      (make-anode :type 'MULTIPLE-VALUE-CALL
                  :sub-anodes (nreverse anodelist)
                  :seclass seclass
                  :code (nreverse codelist)))))

;; compile (MULTIPLE-VALUE-LIST form)
(defun c-MULTIPLE-VALUE-LIST ()
  (test-list *form* 2 2)
  (if *for-value*
    (let ((anode1 (c-form (second *form*) 'ALL)))
      (make-anode :type 'MULTIPLE-VALUE-LIST
                  :sub-anodes (list anode1)
                  :seclass (anodes-seclass-or anode1)
                  :code `(,anode1 (MV-TO-LIST))))
    (c-form (second *form*))))

;; determines, if a setq-argument-list assigns Symbol-Macros.
(defun setqlist-macrop (l)
  (do ((l l (cddr l)))
      ((null l) nil)
    (let ((s (car l)))
      (when (and (symbolp s) (venv-search-macro s)) (return t)))))

(defvar *compiler-unlocked-packages* nil)
(defun set-check-lock (caller symbol)
  (when (and (not (memq (symbol-package symbol) *compiler-unlocked-packages*))
             (symbol-value-lock symbol))
    (c-warn (TEXT "~S: assignment to the internal special variable ~S")
            caller symbol)))

;; compile (SETQ {symbol form}*)
;; execute all assignments one after the other
(defun c-SETQ ()
  (test-list *form* 1)
  (when (evenp (length *form*))
    (c-error *form* (TEXT "Odd number of arguments to SETQ: ~S") *form*))
  (if (null (cdr *form*))
    (c-NIL) ; (SETQ) == (PROGN) == NIL
    (if (setqlist-macrop (cdr *form*))
      (c-form ; (SETF ...) instead of (SETQ ...), macro-expand
        (funcall (macro-function 'SETF) (cons 'SETF (cdr *form*)) (env)))
      (do ((L (cdr *form*) (cddr L))
           #+CLISP-DEBUG (anodelist '())
           (seclass *seclass-foldable*)
           (codelist '()))
          ((null L)
           (make-anode
             :type 'SETQ
             :sub-anodes (nreverse anodelist)
             :seclass seclass
             :code (nreverse codelist)))
        (let* ((symboli (first L))
               (formi (second L))
               (anodei (c-form formi 'ONE)))
          #+CLISP-DEBUG (push anodei anodelist)
          (if (symbolp symboli)
            (progn
              (set-check-lock 'setq symboli)
              (push anodei codelist)
              (seclass-or-f seclass anodei)
              (let ((setteri (c-VARSET symboli anodei
                                       (and *for-value* (null (cddr L))))))
                (push setteri codelist)
                (seclass-or-f seclass setteri)))
            (progn
              (c-error-c symboli (TEXT "Cannot assign to non-symbol ~S.")
                         symboli)
              (push '(VALUES1) codelist))))))))

;; compile (PSETQ {symbol form}*)
;; save all temporary values on the stack, only then assign them
(defun c-PSETQ ()
  (test-list *form* 1)
  (when (evenp (length *form*))
    (c-error *form* (TEXT "Odd number of arguments to PSETQ: ~S") *form*))
  (if (null (cdr *form*))
    (c-NIL) ; (PSETQ) == (PROGN) == NIL
    (if (setqlist-macrop (cdr *form*))
      (c-form ; (PSETF ...) instead of (PSETQ ...), macro-expand
        (funcall (macro-function 'PSETF) (cons 'PSETF (cdr *form*)) (env)))
      (let ((anodelist '())
            (setterlist '()))
        ;; compile forms and assignments:
        (do ((L (cdr *form*)))
            ((null L))
          (let* ((symboli (pop L))
                 (formi (pop L))
                 (anodei (c-form formi 'ONE)))
            (if (symbolp symboli)
              (progn
                (set-check-lock 'psetq symboli)
                (push anodei anodelist)
                (push (c-VARSET symboli anodei nil) setterlist)
                (push 0 *stackz*))
              (c-error-c symboli (TEXT "Cannot assign to non-symbol ~S.")
                         symboli))))
        ;; try to reorganize them in a fashion, that as few  (PUSH)'s and
        ;; (POP)'s as possible are necessary:
        (let ((codelist1 '())
              (codelist2 '())
              ;; build codelist = (nconc codelist1 (nreverse codelist2))
              (seclass *seclass-foldable*)) ; total side-effect-class of codelist
          (do ((anodelistr anodelist (cdr anodelistr))
               (setterlistr setterlist (cdr setterlistr)))
              ((null anodelistr))
            (let ((anode (car anodelistr))
                  (setter (car setterlistr)))
              ;; Normally, we would have to prepend the anode and a (PUSH)
              ;; in front of codelist; a (POP) and the setter would have
              ;; to be appended after codelist. We try to simplify this:
              (cond ((seclasses-commute (anode-seclass setter) seclass)
                     ;; move the setter in front:
                     (push setter codelist1)
                     (push anode codelist1))
                    ((seclasses-commute (anode-seclass anode) seclass)
                     ;; move the anode to the end:
                     (push anode codelist2)
                     (push setter codelist2))
                    (t ; no simplification possible
                     (push '(PUSH) codelist1)
                     (push anode codelist1)
                     (push '(POP) codelist2)
                     (push setter codelist2)
                     (setf (car *stackz*) 1))) ; need a variable in the stack
              (setq seclass
                (seclass-or seclass
                  (seclass-or (anode-seclass anode) (anode-seclass setter))))
              (setf *stackz* (cdr *stackz*))))
          ;; now *stackz* is again on the old level.
          (when *for-value* (push '(NIL) codelist2))
          (make-anode
            :type 'PSETQ
            :sub-anodes (nreverse anodelist)
            :seclass seclass
            :code (nconc codelist1 (nreverse codelist2))))))))

;; compile (MULTIPLE-VALUE-SETQ ({symbol}*) form)
;; all desired values on the the stack, then pop them ony by one and
;; assign.
(defun c-MULTIPLE-VALUE-SETQ ()
  (test-list *form* 3 3)
  (test-list (second *form*) 0)
  (if (dolist (s (second *form*) nil)
        (when (and (symbolp s) (venv-search-macro s)) (return t)))
    (c-form `(SYSTEM::MULTIPLE-VALUE-SETF ,@(cdr *form*)))
    (let* ((n (length (second *form*)))
           (anode1 (c-form (third *form*) 'ALL))
           (*stackz* *stackz*))
      (if (zerop n)
        (make-anode :type 'MULTIPLE-VALUE-SETQ
                    :sub-anodes (list anode1)
                    :seclass (anodes-seclass-or anode1)
                    :code `(,anode1
                            ,@(if (eq *for-value* 'ALL) '((VALUES1)) '())))
        ;; Here we generate the assignments in reverse order, using (POP)
        ;; instructions, because they are faster than the (LOAD i) instructions
        ;; that would be needed if we did the assignments in left-to-right
        ;; order. However, ANSI CL says the assignments are (conceptually)
        ;; performed in left-to-right order. The only case when this might
        ;; matter is when the symbol list contains duplicates. In this case,
        ;; we have to eliminate some assignments.
        (do ((L (second *form*) (cdr L))
             #+CLISP-DEBUG (anodelist (list anode1))
             (seclass (anode-seclass anode1))
             (codelist '()))
            ((null L)
             (if (= n 1)
               (setq codelist (cdr codelist)) ; discard last (POP)
               (setq codelist (cons `(NV-TO-STACK ,n) codelist)))
             (make-anode
               :type 'MULTIPLE-VALUE-SETQ
               :sub-anodes (nreverse anodelist)
               :seclass seclass
               :code (cons anode1 codelist)))
          (let ((symbol (car L)))
            (if (symbolp symbol)
              (unless (memq symbol (cdr L))
                (let ((setter (c-VARSET symbol
                                (make-anode :type 'NOP
                                            :sub-anodes '()
                                            :seclass *seclass-foldable*
                                            :code '())
                                (and *for-value* (null codelist)))))
                  (set-check-lock 'multiple-value-setq symbol)
                  (push setter codelist)
                  (seclass-or-f seclass setter)))
              (c-error-c symbol (TEXT "Cannot assign to non-symbol ~S.")
                         symbol)))
          (push '(POP) codelist)
          (push 1 *stackz*))))))

;; returns the code for the parallel binding of variables.
;; (car *stackz*) should be = 0, (cdr *stackz*) is poss. extended.
(defun c-parallel-bind-movable-var-anode (varlist anodelist stackzlist
                                          &optional (other-anodes '()))
  ;; Variable may be bound foremost at the end, if it is SPECIAL
  ;; and sequencing Anodes can depend on its value.
  (let ((bind-afterwards nil))
    (append
      (maplap
        #'(lambda (varlistr anodelistr stackzlistr)
            (let ((var (car varlistr))
                  (anode (car anodelistr)))
              (if (and (var-specialp var)
                       (let ((symbol (var-name var)))
                         (some
                           #'(lambda (other-anode)
                               ;; does the value of other-anode possibly depend
                               ;; on the value of var?
                               (let* ((se (anode-seclass other-anode))
                                      (uses (seclass-uses se))
                                      (u-bi (seclass-uses-binding se)))
                                 (or (eq uses 'T) (memq symbol uses)
                                     (eq u-bi 'T) (memq symbol u-bi))))
                           (cdr anodelistr))))
                (let* ((stackz (car stackzlistr))
                       (dummyvar ; auxiliary variable in Stack
                         (make-var :name (gensym) :specialp nil
                                   :closurep nil :stackz stackz)))
                  (push (list dummyvar var (cdr *stackz*)) bind-afterwards)
                  ;; room for 1 more closing binding:
                  (push (car stackz) (cdr *stackz*))
                  ;; memorize room for auxiliary variable in stack:
                  (setf (car stackz) 1)
                  (c-bind-movable-var-anode dummyvar anode))
                (c-bind-movable-var-anode var anode))))
        varlist (append anodelist other-anodes) stackzlist)
      other-anodes
      (mapcap
        #'(lambda (bind)
            (let ((dummyvar (first bind)) ; auxiliary variable in Stack
                  (var (second bind)) ; SPECIAL-Variable
                  ;; stack-state before the construction of closing-binding:
                  (stackz (third bind)))
              `((GET ,dummyvar ,*venvc* ,stackz)
                ,@(c-bind-movable-var var))))
        (nreverse bind-afterwards)))))

;; compile (LET/LET* ({var|(var value)}*) {declaration}* {form}*)
(defun c-LET/LET* (*-flag)
  (test-list *form* 2)
  (test-list (second *form*) 0)
  (multiple-value-bind (body-rest declarations) (parse-body (cddr *form*))
    (let ((oldstackz *stackz*)
          (*stackz* *stackz*)
          (*denv* *denv*)
          (*venv* *venv*)
          (*venvc* *venvc*))
      (multiple-value-bind (*specials* *ignores* *ignorables* *readonlys* other-decls)
          (process-declarations declarations)
        ;; syntax-test of the parameter-list:
        (multiple-value-bind (symbols initforms)
            (analyze-letlist (second *form*))
          (push 0 *stackz*) (push nil *venvc*) ; room for Closure-Dummyvar
          (let ((closuredummy-stackz *stackz*)
                (closuredummy-venvc *venvc*))
            (multiple-value-bind (varlist anodelist stackzlist)
                (process-movable-var-list symbols initforms *-flag)
              (unless *-flag (push 0 *stackz*)) ; room for closing-bindings
              (push-specials)
              (push-*denv* other-decls)
              (let ((body-anode (c-form `(PROGN ,@body-rest)))) ; compile Body
                ;; check the variables:
                (let* ((closurevars
                         (checking-movable-var-list varlist anodelist))
                       (codelist
                         `(,@(c-make-closure closurevars closuredummy-venvc
                                             closuredummy-stackz)
                           ,@(if *-flag
                               ;; sequential binding of variables
                               (mapcap #'c-bind-movable-var-anode
                                       varlist anodelist)
                               ;; parallel binding of variables
                               (c-parallel-bind-movable-var-anode
                                varlist anodelist stackzlist))
                           ,body-anode
                           (UNWIND ,*stackz* ,oldstackz ,*for-value*)))
                       (anode
                         (make-anode
                           :type (if *-flag 'LET* 'LET)
                           :sub-anodes `(,@anodelist ,body-anode)
                           :seclass (seclass-without
                                      (anodelist-seclass-or
                                       `(,@anodelist ,body-anode))
                                      varlist)
                           :stackz oldstackz
                           :code codelist)))
                  (closuredummy-add-stack-slot
                   closurevars closuredummy-stackz closuredummy-venvc)
                  (optimize-var-list varlist)
                  anode)))))))))

;; compile (LOCALLY {declaration}* {form}*)
(defun c-LOCALLY (&optional (c #'c-form)) ; cf. c-LET/LET*
  (test-list *form* 1)
  (multiple-value-bind (body-rest declarations) (parse-body (cdr *form*))
    (let ((*venv* *venv*))
      (multiple-value-bind (*specials* ignores ignorables readonlys other-decls)
          (process-declarations declarations)
        (declare (ignore ignores ignorables readonlys))
        (push-specials)
        (push-*denv* other-decls)
        (funcall c `(PROGN ,@body-rest))))))

;; compile (MULTIPLE-VALUE-BIND ({var}*) form1 {declaration}* {form}*)
(defun c-MULTIPLE-VALUE-BIND ()
  (test-list *form* 3)
  (test-list (second *form*) 0)
  (let ((symbols (second *form*)))
    (dolist (sym symbols)
      (unless (symbolp sym)
        (c-error sym (TEXT "Only symbols may be used as variables, not ~S")
                 sym)))
    (if (= (length symbols) 1)
      (c-form `(LET ((,(first symbols) ,(third *form*))) ,@(cdddr *form*)))
      (multiple-value-bind (body-rest declarations) (parse-body (cdddr *form*))
        (let ((oldstackz *stackz*)
              (*stackz* *stackz*)
              (*denv* *denv*)
              (*venv* *venv*)
              (*venvc* *venvc*))
          (multiple-value-bind (*specials* *ignores* *ignorables* *readonlys* other-decls)
              (process-declarations declarations)
            (if (null symbols) ; empty variable-list -> bind nothing
              (let ((anode1 (c-form (third *form*) 'NIL)))
                (push-specials)
                (push-*denv* other-decls)
                (let ((anode2 (c-form `(PROGN ,@(cdddr *form*)))))
                  (make-anode :type 'MULTIPLE-VALUE-BIND
                    :sub-anodes (list anode1 anode2)
                    :seclass (anodes-seclass-or anode1 anode2)
                    :code `(,anode1 ,anode2))))
              (let ((anode1 (c-form (third *form*) 'ALL)))
                (push nil *venvc*) ; visibility of Closure-Dummyvar
                (multiple-value-bind (varlist stackvarlist)
                    (process-fixed-var-list symbols)
                  (push 0 *stackz*) ; room for Closure-Dummyvar
                  (let* ((closuredummy-stackz *stackz*)
                         (closuredummy-venvc *venvc*)
                         (stackzlist
                           (do* ((varlistr varlist (cdr varlistr))
                                 (L '()))
                                ((null varlistr) (nreverse L))
                             (let ((var (car varlistr)))
                               (push-*venv* var)
                               (push *stackz* L) (bind-fixed-var-2 var)))))
                    (push-specials)
                    (push-*denv* other-decls)
                    (let* ((body-anode ; compile Body
                             (c-form `(PROGN ,@body-rest)))
                           ; check the variables:
                           (closurevars (checking-fixed-var-list varlist))
                           (codelist ; generate Code
                             `(,anode1
                               (NV-TO-STACK ,(length symbols))
                               ,@(c-make-closure closurevars closuredummy-venvc
                                                 closuredummy-stackz)
                               ,@ ; bind special- or Closure-variables:
                                 (do ((stackvarlistr stackvarlist
                                                     (cdr stackvarlistr))
                                      (stackzlistr stackzlist (cdr stackzlistr))
                                      (varlistr varlist (cdr varlistr))
                                      (L '()))
                                     ((null varlistr) (nreverse L))
                                   (setq L (revappend
                                             (c-bind-fixed-var
                                               (car varlistr)
                                               (car stackvarlistr)
                                               (car stackzlistr))
                                             L)))
                               ,body-anode
                               (UNWIND ,*stackz* ,oldstackz ,*for-value*)))
                           (anode
                             (make-anode
                               :type 'MULTIPLE-VALUE-BIND
                               :sub-anodes (list anode1 body-anode)
                               :seclass (seclass-without
                                          (anodes-seclass-or anode1 body-anode)
                                          varlist)
                               :stackz oldstackz
                               :code codelist)))
                      (closuredummy-add-stack-slot
                        closurevars closuredummy-stackz closuredummy-venvc)
                      (optimize-var-list varlist)
                      anode)))))))))))

;; compile (COMPILER-LET ({var|(var value)}*) {form}*)
(defun c-COMPILER-LET (&optional (c #'c-form))
  (test-list *form* 2)
  (test-list (second *form*) 0)
  (do ((L (second *form*) (cdr L))
       (varlist '())
       (valueslist '()))
      ((null L)
       (progv (nreverse varlist) (nreverse valueslist)
         (funcall c `(PROGN ,@(cddr *form*)))))
    (cond ((symbolp (car L)) (push (car L) varlist) (push nil valueslist))
          ((and (consp (car L)) (symbolp (caar L))
                (or (null (cdar L))
                    (and (consp (cdar L)) (null (cddar L)))))
           (push (caar L) varlist) (push (eval (cadar L)) valueslist))
          (t (c-illegal-syntax (car L) 'COMPILER-LET)))))

(macrolet ((check-blockname (name)
             `(unless (symbolp ,name)
                (c-error-c ,name (TEXT "Block name must be a symbol, not ~S")
                           ,name)
                (setq ,name NIL)))) ; Default-Blockname

;; compile (BLOCK name {form}*)
(defun c-BLOCK ()
  (test-list *form* 2)
  (let ((name (second *form*)))
    (check-blockname name)
    (let* ((*stackz* (cons 'BLOCK *stackz*)) ; Block-Frame
           (label (make-label *for-value*))
           (block (make-block :fnode *func* :label label
                    :consvar (make-var :name (gensym) :specialp nil
                                       :closurep nil :stackz *stackz*)
                    :stackz *stackz* :used-far nil :for-value *for-value*))
           (*benv* (cons (cons name block) *benv*)) ; activate Block
           (anode (c-form `(PROGN ,@(cddr *form*)))))
      (if (block-used-far block)
        (make-anode :type 'BLOCK
                    :sub-anodes (list anode)
                    :seclass (anodes-seclass-or anode)
                    :code `((BLOCK-OPEN
                             ;; set (gensym) to nil
                             ,(new-const (and (symbol-package name) name))
                             ,label)
                            ,anode
                            (BLOCK-CLOSE)
                            ,label))
        (progn
          (setf (first *stackz*) 0) ; need no Blockframe
          (make-anode :type 'BLOCK
                      :sub-anodes (list anode)
                      :seclass (anodes-seclass-or anode)
                      :code `(,anode ,label)))))))

;; compile (RETURN-FROM name [form])
(defun c-RETURN-FROM ()
  (test-list *form* 2 3)
  (let ((name (second *form*)))
    (check-blockname name)
    (let ((a (benv-search name)))
      (cond ((null a) ; this Blockname is invisible
             (c-error name
                      (TEXT "RETURN-FROM block ~S is impossible from here.")
                      name))
            ((block-p a) ; visible in *benv* without %benv%
             (let ((anode (c-form (third *form*) (block-for-value a))))
               (if (and (eq (block-fnode a) *func*)
                        (may-UNWIND *stackz* (cdr (block-stackz a))))
                 ;; same functions
                 (make-anode
                   :type 'RETURN-FROM
                   :sub-anodes (list anode)
                   :seclass *seclass-dirty*
                   :code `(,anode
                           (UNWIND ,*stackz* ,(cdr (block-stackz a))
                                   ,(block-for-value a))
                           (JMP ,(block-label a))))
                 ;; different functions or unknown frames onto the stack
                 (progn
                   (unless *no-code*
                     (note-far-used-block a))
                   (make-anode
                     :type 'RETURN-FROM
                     :sub-anodes (list anode)
                     :seclass *seclass-dirty*
                     :code `(,anode
                             ,@(if (not (block-for-value a)) '((VALUES0)))
                             (RETURN-FROM ,a
                              ,@(if (eq (block-fnode a) *func*)
                                    `(,*stackz*) '()))))))))
            ((consp a) ; visible in %benv%
             (let ((anode (c-form (third *form*) 'ALL)))
               (make-anode
                 :type 'RETURN-FROM
                 :sub-anodes (list anode)
                 :seclass *seclass-dirty*
                 :code `(,anode (RETURN-FROM ,(new-const a))))))
            (t (compiler-error 'c-RETURN-FROM a))))))

) ; macrolet

;; compile (TAGBODY {tag|form}*)
(defun c-TAGBODY ()
  (test-list *form* 1)
  (multiple-value-bind (taglist labellist)
    (do ((L (cdr *form*) (cdr L))
         (taglist '())
         (labellist '()))
        ((null L) (values (nreverse taglist) (nreverse labellist)))
      (let ((item (car L)))
        (if (atom item)
          (if (or (symbolp item) (numberp item))
            ;; Symbol NIL is permitted, because in ANSI CL it is not
            ;; ambiguous anymore.
            ;; Other numbers are permitted, so that - just as 3.3.2 -
            ;; 3.3 is a admissible jump-destination.
            (progn
              (push item taglist)
              (push (make-label 'NIL) labellist))
            (c-error-c
             item (TEXT "Only numbers and symbols are valid tags, not ~S")
             item)))))
    (let* ((*stackz* (cons 0 *stackz*)) ; poss. TAGBODY-Frame
           (tagbody (make-tagbody :fnode *func* :labellist labellist
                      :consvar (make-var :name (gensym) :specialp nil
                                         :closurep nil :stackz *stackz*)
                      :stackz *stackz* :used-far nil))
           (*genv* (cons (cons (apply #'vector taglist) tagbody) *genv*))
           ;; activate Tagbody
           (codelist '())
           #+CLISP-DEBUG (anodelist '())
           (seclass *seclass-foldable*))
      ;; compile interior of Tagbody:
      (do ((formlistr (cdr *form*) (cdr formlistr))
           (taglistr taglist)
           (labellistr labellist))
          ((null formlistr)
           #+CLISP-DEBUG (setq anodelist (nreverse anodelist))
           (setq codelist (nreverse codelist)))
        (let ((formi (car formlistr)))
          (if (atom formi)
            (when (and (consp taglistr) (eql formi (car taglistr)))
              ;; retrieve Tag
              (pop taglistr) (push (pop labellistr) codelist))
            (let ((anodei (c-form formi 'NIL)))
              #+CLISP-DEBUG (push anodei anodelist)
              (seclass-or-f seclass anodei)
              (push anodei codelist)))))
      (if (tagbody-used-far tagbody)
        (let ((used-tags (make-array (length taglist) :fill-pointer 0)))
          ;; Collect the used tags and assign indices.
          (dolist (tagbody+tag (tagbody-used-far tagbody))
            (let* ((tag (cdr tagbody+tag))
                   (index (or (position tag used-tags :test #'eql)
                              (vector-push tag used-tags)
                              (compiler-error 'c-TAGBODY tag))))
              (setf (cdr tagbody+tag) index)))
          (setf (tagbody-used-far tagbody) nil)
          (let* ((l (length used-tags))
                 (used-label-list
                   (do ((i 0 (1+ i))
                        (l1 '()))
                       ((= i l) (nreverse l1))
                     (push
                       (elt labellist (position (aref used-tags i) taglist
                                                :test #'eql))
                       l1))))
            (setf (first *stackz*) `(TAGBODY ,l))
            (setq codelist
              `((TAGBODY-OPEN
                  ,(new-const (map 'simple-vector
                                   #'(lambda (tag)
                                       (if (numberp tag)
                                         tag
                                         ;; GENSYM --> NIL so that
                                         ;; *.fas will not contain GENSYMs
                                         (and (symbol-package tag) tag)))
                                   used-tags))
                  ,@used-label-list)
                ,@codelist
                (TAGBODY-CLOSE-NIL)))))
        (when *for-value* (setq codelist `(,@codelist (NIL)))))
      (make-anode :type 'TAGBODY
                  :sub-anodes anodelist
                  :seclass seclass
                  :code codelist))))

;; compile (GO tag)
(defun c-GO ()
  (test-list *form* 2 2)
  (let ((tag (second *form*)))
    (unless (or (symbolp tag) (numberp tag))
      (c-error tag (TEXT "Tag must be a symbol or a number, not ~S") tag))
    (multiple-value-bind (a b) (genv-search tag)
      (cond ((null a) ; this Tag is invisible
             (c-error tag (TEXT "GO to tag ~S is impossible from here.") tag))
            ((tagbody-p a) ; visible in *genv* without %genv%
             (if (and (eq (tagbody-fnode a) *func*)
                      (may-UNWIND *stackz* (tagbody-stackz a)))
               ;; same functions
               (make-anode
                 :type 'GO
                 :sub-anodes '()
                 :seclass *seclass-dirty*
                 :code `((UNWIND ,*stackz* ,(tagbody-stackz a) nil)
                         (JMP ,(nth b (tagbody-labellist a)))))
               ;; different functions or unknown frames onto the stack
               (let ((tagbody+tag (cons a tag)))
                 (unless *no-code*
                   (note-far-used-tagbody tagbody+tag))
                 (make-anode
                   :type 'GO
                   :sub-anodes '()
                   :seclass *seclass-dirty*
                   :code `((VALUES0)
                           (GO ,a ,tagbody+tag
                            ,@(if (eq (tagbody-fnode a) *func*)
                                  `(,*stackz*) '())))))))
            ((consp a) ; visible in %genv%
             (make-anode
               :type 'GO
               :sub-anodes '()
               :seclass *seclass-dirty*
               :code `((GO ,(new-const a) ,b))))
            (t (compiler-error 'c-GO a))))))

;; compile (FUNCTION funname)
(defun c-FUNCTION ()
  (test-list *form* 2 3)
  (let* ((longp (cddr *form*)) ; flag, if explicit form (FUNCTION name funname)
         (name (second *form*)))
    (if (and (not longp) (function-name-p name))
      (multiple-value-bind (a m f1 f2 f3 f4) (fenv-search name)
        (if (null a)
          (progn
            (note-function-used name 0 nil)
            (make-anode
              :type 'FUNCTION
              :sub-anodes '()
              :seclass *seclass-read*
              :code (if (and (subr-info name) (not (declared-notinline name)))
                      `((CONST ,(make-const :horizon ':all
                                            :value (symbol-function name)
                                            :form `(FUNCTION ,name))))
                      `((CONST ,(make-funname-const name))
                        (SYMBOL-FUNCTION NIL)))))
          (case f1
            (GLOBAL ; found in %fenv%
             (make-anode
               :type 'FUNCTION
               :sub-anodes '()
               :seclass *seclass-read*
               :code `((CONST ,(new-const f2))
                       (PUSH)
                       (CONST ,(new-const f3))
                       (SVREF NIL)
                       ,@(if f4
                           `((PUSH) ,(CALLS-code-fun FUNCTION-MACRO-FUNCTION))
                           '()))))
            (LOCAL ; found in *fenv* without %fenv%
             (if (const-p f2)
               (make-anode
                 :type 'FUNCTION
                 :sub-anodes '()
                 :seclass *seclass-pure*
                 :code `((FCONST ,(const-value-safe f2))))
               (c-VAR (var-name f2))))
            (t (if (and (null f1) m)
                 (c-error
                  name
                  (TEXT "~S is not a function. It is a locally defined macro.")
                  name)
                 (compiler-error 'c-FUNCTION name))))))
      (let ((funname (car (last *form*))))
        (if (lambda-form-p funname)
          (let* ((*no-code* (or *no-code* (null *for-value*)))
                 (fnode
                   (c-lambdabody
                     (if (and longp (function-name-p name))
                       name ; specified function-name
                       (incf *anonymous-count*))
                     (cdr funname))))
            (unless *no-code* (propagate-far-used fnode))
            (c-fnode-function fnode))
          (c-error funname (TEXT "Only symbols and lambda expressions are function names, not ~S")
                   funname))))))

;; compile (%GENERIC-FUNCTION-LAMBDA . lambdabody)
(defun c-%GENERIC-FUNCTION-LAMBDA ()
  (test-list *form* 1)
  (let* ((*no-code* (or *no-code* (null *for-value*)))
         (fnode
           (c-lambdabody
             (incf *anonymous-count*)
             (cdr *form*)
             nil
             t))) ; gf-p = T, build Code for generic function
    (unless *no-code* (propagate-far-used fnode))
    (c-fnode-function fnode)))

;; compile (%OPTIMIZE-FUNCTION-LAMBDA reqoptimflags . lambdabody)
;; reqoptimflags is a list of flags that states, which Required-Parameter
;; of the lambdabody can be optimized away. For each Required-Parameter:
;; NIL: normal,
;; T: Can be optimized away, then it is turned into GONE.
;; NILs at the end of the list can be omitted.
;; The output contains the list of the omitted parameters
;; in addition to the function.
(defmacro %OPTIMIZE-FUNCTION-LAMBDA (reqoptimflags &rest lambdabody)
  (declare (ignore reqoptimflags))
  ;; without compiler: do not optimize
  `(CONS (FUNCTION (LAMBDA ,@lambdabody)) NIL))
(defun c-%OPTIMIZE-FUNCTION-LAMBDA ()
  (test-list *form* 2)
  (let* ((*no-code* (or *no-code* (null *for-value*)))
         (reqoptimflags (copy-list (second *form*)))
         (fnode
           (c-lambdabody
             (incf *anonymous-count*)
             (cddr *form*)
             nil nil reqoptimflags)))
    (unless *no-code* (propagate-far-used fnode))
    (let* ((anode1 (c-fnode-function fnode))
           (resultflags (mapcar #'(lambda (x) (eq x 'GONE)) reqoptimflags))
           (anode2 (let ((*stackz* (cons 1 *stackz*))
                         (*form* `(QUOTE ,resultflags)))
                     (c-QUOTE))))
      (make-anode :type '%OPTIMIZE-FUNCTION-LAMBDA
                  :sub-anodes (list anode1 anode2)
                  :seclass (anodes-seclass-or anode1 anode2)
                  :code `(,anode1 (PUSH) ,anode2 (CONS))))))

(macrolet ((err-syntax (specform fdef)
             `(c-error-c
               ,fdef (TEXT "Illegal function definition syntax in ~S: ~S")
               ,specform ,fdef))
           (add-fenv (namelist fenvconslist)
             `(do ((namelistr ,namelist (cdr namelistr))
                   (fenvconslistr ,fenvconslist (cdr fenvconslistr))
                   (L nil))
                  ((null namelistr)
                   (sys::cons-*fenv* L))
                (push (car namelistr) L)
                (push (car fenvconslistr) L)))
           (mk-var ()
             '(make-var :name (gensym) :specialp nil :constantp nil
               :usedp t :for-value-usedp t :really-usedp nil
               :closurep nil ; later poss. set to T
               :stackz *stackz* :venvc *venvc* :fnode *func*))
           (c-declarations (c declarations body-rest
                              &optional namelist fnodelist)
             `(multiple-value-bind
                    (*specials* *ignores* *ignorables* *readonlys* other-decls)
                  (process-declarations ,declarations)
                (push-specials) (push-*denv* other-decls)
                ,@(when (and namelist fnodelist)
                    `((mapc #'(lambda (name fnode)
                                (setf (fnode-ignore fnode)
                                      (fname-ignored-p name *ignores*)
                                      (fnode-ignorable fnode)
                                      (fname-ignored-p name *ignorables*)))
                            ,namelist ,fnodelist)))
                ;; compile the remaining forms:
                (funcall ,c `(PROGN ,@body-rest))))
           (with-bindings ((body body-rest declarations mvb-var)
                           mvb-form &body forms)
             `(multiple-value-bind (,body-rest ,declarations)
                  (parse-body ,body)
                (let ((oldstackz *stackz*)
                      (*stackz* *stackz*)
                      (*denv* *denv*)
                      (*venvc* *venvc*)
                      (*venv* *venv*))
                  (push 0 *stackz*) (push nil *venvc*) ; for Closure-Dummyvar
                  (let ((closuredummy-stackz *stackz*)
                        (closuredummy-venvc *venvc*))
                    (multiple-value-bind ,mvb-var ,mvb-form
                      ,@forms)))))
           (get-anode (type)
             `(let* ((closurevars (checking-movable-var-list varlist anodelist))
                     (anode
                      (make-anode
                       :type ',type
                       :sub-anodes `(,@anodelist ,body-anode)
                       :seclass (seclass-without
                                 (anodelist-seclass-or
                                  `(,@anodelist ,body-anode))
                                 varlist)
                       :code `(,@(c-make-closure closurevars closuredummy-venvc
                                                 closuredummy-stackz)
                               ,@(mapcap #'c-bind-movable-var-anode
                                         varlist anodelist)
                               ,body-anode
                               (UNWIND ,*stackz* ,oldstackz ,*for-value*)))))
                (closuredummy-add-stack-slot closurevars closuredummy-stackz
                                             closuredummy-venvc)
                (optimize-var-list varlist)
                anode)))
  (macrolet ((check-fdef-name (caller fdef)
               `(unless (and (consp ,fdef) (function-name-p (car ,fdef))
                             (consp (cdr ,fdef)))
                  (err-syntax ',caller ,fdef))))

;; compile (FLET ({fundef}*) {form}*)
(defun c-FLET ()
  (test-list *form* 2)
  (test-list (second *form*) 0)
  ;; namelist = list of names, fnodelist = list of fnodes of the functions
  (with-bindings ((cddr *form*) body-rest declarations (namelist fnodelist))
    (do ((fdefsr (second *form*) (cdr fdefsr))
         (L1 '())               ; namelist
         (L2 '()))              ; fnodelist
        ((null fdefsr) (values (nreverse L1) (nreverse L2)))
      (let ((fdef (car fdefsr)))
        (check-fdef-name FLET fdef)
        (let* ((name (car fdef))
               (fnode (c-lambdabody
                       (symbol-suffix (fnode-name *func*) name)
                       (add-implicit-block name (cdr fdef)))))
          (push name L1)
          (push fnode L2))))
    (multiple-value-bind (vfnodelist varlist anodelist *fenv*)
        (do ((namelistr namelist (cdr namelistr))
             (fnodelistr fnodelist (cdr fnodelistr))
             (vfnodelist '())
             (varlist '())
             (anodelist '())
             (fenv '()))
            ((null namelistr)
             (values (nreverse vfnodelist) (nreverse varlist)
                     (nreverse anodelist)
                     (sys::cons-*fenv* fenv)))
          (push (car namelistr) fenv)
          (let ((fnode (car fnodelistr)))
            (if (zerop (fnode-keyword-offset fnode))
              ;; function-definition is autonomous
              (push (cons (list fnode) (new-const fnode)) fenv)
              (progn
                (push fnode vfnodelist)
                (push (c-fnode-function fnode) anodelist)
                (push 1 *stackz*)
                (let ((var (mk-var)))
                  (push (cons (list fnode) var) fenv)
                  (push var varlist))))))
      (apply #'push-*venv* varlist) ; activate auxiliary variables
      (let ((body-anode (c-declarations #'c-form declarations body-rest
                                        namelist fnodelist)))
        (unless *no-code*
          (mapc #'(lambda (var fnode)
                    (when (var-really-usedp var)
                      (propagate-far-used fnode)))
                varlist vfnodelist))
        (get-anode FLET)))))

;; compile (LABELS ({fundef}*) {form}*)
(defun c-LABELS ()
  (test-list *form* 2)
  (test-list (second *form*) 0)
  (with-bindings ((cddr *form*) body-rest declarations
                  (namelist varlist lambdanamelist lambdabodylist fenvconslist))
    (do ((fdefsr (second *form*) (cdr fdefsr))
         (L1 '())               ; namelist
         (L2 '())               ; varlist
         (L3 '())               ; lambdanamelist
         (L4 '())               ; lambdabodylist
         (L5 '()))              ; fenvconslist
        ((null fdefsr)
         (values (nreverse L1) (nreverse L2) (nreverse L3)
                 (nreverse L4) (nreverse L5)))
      (let ((fdef (car fdefsr)))
        (check-fdef-name LABELS fdef)
        (let ((name (car fdef)))
          (push name L1)
          (push 1 *stackz*)
          (push (mk-var) L2)
          (push (symbol-suffix (fnode-name *func*) name) L3)
          (push (cdr fdef) L4)
          (push
           (cons
            ;; fdescr, consisting of:
            (cons nil ; room for the FNODE
              (cons 'LABELS
                (multiple-value-list ; values from c-analyze-lambdalist
                 (c-analyze-lambdalist
                  (if *defun-accept-specialized-lambda-list*
                      (sys::specialized-lambda-list-to-ordinary
                       (cadr fdef) 'compile)
                      (cadr fdef))))))
            ;; Variable
            (car L2))
           L5))))
    ;; namelist = list of names, varlist = list of variables,
    ;; lambdanamelist = list of Dummy-names of the functions,
    ;; lambdabodylist = list of Lambda-bodies of the functions,
    ;; fenvconslist = list of Conses (fdescr . var) for *fenv*
    ;; (fdescr still without fnode, which is inserted later).
    (let ((*fenv* ; activate function-name
           (add-fenv namelist fenvconslist)))
      (apply #'push-*venv* varlist) ; activate auxiliary variables
      (let* ((fnodelist ; compile functions
              (mapcar #'(lambda (name lambdaname lambdabody fenvcons)
                          (c-lambdabody
                           lambdaname
                           (add-implicit-block name lambdabody)
                           fenvcons))
                      namelist lambdanamelist lambdabodylist
                      fenvconslist))
             (anodelist
              (mapcar #'(lambda (fnode var)
                          (c-fnode-function fnode (cdr (var-stackz var))))
                      fnodelist varlist))
             (body-anode (c-declarations #'c-form declarations body-rest
                                         namelist fnodelist)))
        ;; the variables, for which the function was autonomous, are
        ;; additionally declared as constants:
        (do ((varlistr varlist (cdr varlistr))
             (fnodelistr fnodelist (cdr fnodelistr)))
            ((null varlistr))
          (let ((var (car varlistr))
                (fnode (car fnodelistr)))
            (when (zerop (fnode-keyword-offset fnode))
              ;; function-definition is autonomous
              (setf (var-constantp var) t)
              (setf (var-constant var) (new-const fnode)))))
        ;; Determine the functions which are really used.
        ;; Functions with closure variables can pull in other functions.
        (unless *no-code*
          (let ((last-count 0))
            (loop
              ;; Iterate as long as at least one function has been pulled in.
              (when (eql last-count
                         (setq last-count (count-if #'var-really-usedp
                                                    varlist)))
                (return))
              (do ((varlistr varlist (cdr varlistr))
                   (fnodelistr fnodelist (cdr fnodelistr)))
                  ((null varlistr))
                (let ((var (car varlistr))
                      (fnode (car fnodelistr)))
                  (unless (zerop (fnode-keyword-offset fnode))
                    ;; function with closure variables
                    (when (var-really-usedp var)
                      (propagate-far-used fnode))))))))
        (get-anode LABELS)))))

;; compile
;; (SYS::FUNCTION-MACRO-LET ({(name fun-lambdabody macro-lambdabody)}) {form})
(defun c-FUNCTION-MACRO-LET ()
  (test-list *form* 2)
  (test-list (second *form*) 0)
  (multiple-value-bind (namelist fnodelist macrolist)
      (do ((funmacdefsr (second *form*) (cdr funmacdefsr))
           (L1 '())
           (L2 '())
           (L3 '()))
          ((null funmacdefsr)
           (values (nreverse L1) (nreverse L2) (nreverse L3)))
        (let ((funmacdef (car funmacdefsr)))
          (unless (and (consp funmacdef)
                       (symbolp (car funmacdef))
                       (consp (cdr funmacdef)) (consp (second funmacdef))
                       (consp (cddr funmacdef)) (consp (third funmacdef))
                       (null (cdddr funmacdef)))
            (err-syntax 'SYSTEM::FUNCTION-MACRO-LET funmacdef))
          (let* ((name (car funmacdef))
                 (fnode (c-lambdabody
                         (symbol-suffix (fnode-name *func*) name)
                         (second funmacdef)))
                 (macro (make-funmacro-expander name (third funmacdef))))
            (push name L1)
            (push fnode L2)
            (push macro L3))))
    ;; namelist  = list of names,
    ;; fnodelist = list of fnodes of the functions,
    ;; macrolist = list of Macro-Objects of the functions.
    (let ((oldstackz *stackz*)
          (*stackz* *stackz*)
          (*venvc* *venvc*)
          (*venv* *venv*))
      (push 0 *stackz*) (push nil *venvc*) ; room for Closure-Dummyvar
      (let ((closuredummy-stackz *stackz*)
            (closuredummy-venvc *venvc*))
        (multiple-value-bind (vfnodelist varlist anodelist *fenv*)
            (do ((namelistr namelist (cdr namelistr))
                 (fnodelistr fnodelist (cdr fnodelistr))
                 (macrolistr macrolist (cdr macrolistr))
                 (vfnodelist '())
                 (varlist '())
                 (anodelist '())
                 (fenv '()))
                ((null namelistr)
                 (values (nreverse vfnodelist) (nreverse varlist)
                         (nreverse anodelist)
                         (sys::cons-*fenv* fenv)))
              (push (car namelistr) fenv)
              (let ((fnode (car fnodelistr))
                    (macro (car macrolistr)))
                (setf (fnode-ignorable fnode) t)
                (if (zerop (fnode-keyword-offset fnode))
                  ;; function-definition is autonomous
                  (push (list* macro (list fnode) (new-const fnode)) fenv)
                  (progn
                    (push fnode vfnodelist)
                    (push (c-fnode-function fnode) anodelist)
                    (push 1 *stackz*)
                    (let ((var (mk-var)))
                      (push (cons macro (cons (list fnode) var)) fenv)
                      (push var varlist))))))
          (apply #'push-*venv* varlist) ; activate auxiliary variables
          (let ((body-anode ; compile remaining forms
                  (c-form `(PROGN ,@(cddr *form*)))))
            (unless *no-code*
              (mapc #'(lambda (var fnode)
                        (when (var-really-usedp var)
                          (propagate-far-used fnode)))
                    varlist vfnodelist))
            (get-anode FUNCTION-MACRO-LET)))))))

;; compile (CLOS:GENERIC-FLET ({genfundefs}*) {form}*)
(defun c-GENERIC-FLET ()
  (test-list *form* 2)
  (test-list (second *form*) 0)
  (multiple-value-bind (namelist signlist formlist)
      (do ((fdefsr (second *form*) (cdr fdefsr))
           (L1 '())
           (L2 '())
           (L3 '()))
          ((null fdefsr) (values (nreverse L1) (nreverse L2) (nreverse L3)))
        (let ((fdef (car fdefsr)))
          (check-fdef-name CLOS:GENERIC-FLET fdef)
          (let ((name (first fdef)))
            (push name L1)
            (push (clos::defgeneric-lambdalist-callinfo 'clos:generic-flet
                      *form* name (second fdef))
                  L2)
            (push (clos::make-generic-function-form
                   'clos:generic-flet *form* name (second fdef) (cddr fdef))
                  L3))))
    ;; namelist = list of Names,
    ;; signlist = list of Signatures of the generic functions,
    ;; formlist = list of Constructor-forms of the generic functions.
    (let ((oldstackz *stackz*)
          (*stackz* *stackz*)
          (*venvc* *venvc*)
          (*venv* *venv*))
      (push 0 *stackz*) (push nil *venvc*) ; room for Closure-Dummyvar
      (let ((closuredummy-stackz *stackz*)
            (closuredummy-venvc *venvc*))
        (multiple-value-bind (varlist anodelist *fenv*)
            (do ((namelistr namelist (cdr namelistr))
                 (signlistr signlist (cdr signlistr))
                 (formlistr formlist (cdr formlistr))
                 (varlist '())
                 (anodelist '())
                 (fenv '()))
                ((null namelistr)
                 (values (nreverse varlist) (nreverse anodelist)
                         (sys::cons-*fenv* fenv)))
              (push (car namelistr) fenv)
              (push (c-form (car formlistr) 'ONE) anodelist)
              (push 1 *stackz*)
              (let ((var (mk-var)))
                (push (cons (list* nil 'GENERIC (car signlistr)) var) fenv)
                (push var varlist)))
          (apply #'push-*venv* varlist) ; activate auxiliary variables
          (let ((body-anode ; compile remaining forms
                  (c-form `(PROGN ,@(cddr *form*)))))
            (get-anode CLOS:GENERIC-FLET)))))))

;; compile (CLOS:GENERIC-LABELS ({genfundefs}*) {form}*)
(defun c-GENERIC-LABELS ()
  (test-list *form* 2)
  (test-list (second *form*) 0)
  (let ((oldstackz *stackz*)
        (*stackz* *stackz*)
        (*venvc* *venvc*)
        (*venv* *venv*))
    (push 0 *stackz*) (push nil *venvc*) ; room for Closure-Dummyvar
    (let ((closuredummy-stackz *stackz*)
          (closuredummy-venvc *venvc*))
      (multiple-value-bind (namelist varlist fenvconslist formlist)
          (do ((fdefsr (second *form*) (cdr fdefsr))
               (L1 '())
               (L2 '())
               (L3 '())
               (L4 '()))
              ((null fdefsr)
               (values (nreverse L1) (nreverse L2) (nreverse L3)
                       (nreverse L4)))
            (let ((fdef (car fdefsr)))
              (check-fdef-name CLOS:GENERIC-LABELS fdef)
              (let ((name (first fdef)))
                (push name L1)
                (push 1 *stackz*)
                (push (mk-var) L2)
                (push (cons
                        ;; fdescr
                        (list* nil 'GENERIC
                               (clos::defgeneric-lambdalist-callinfo
                                 'clos:generic-labels *form* name (second fdef)))
                        ;; Variable
                        (car L2))
                      L3)
                (push (clos::make-generic-function-form
                       'clos:generic-labels *form* name (second fdef)
                       (cddr fdef))
                      L4))))
        ;; namelist = liste of Names, varlist = list of Variables,
        ;; fenvconslist = list of Conses (fdescr . var) for *fenv*,
        ;; formlist = list of Constructor-Forms of the generic functions.
        (let ((*fenv* ; activate function-names
                (add-fenv namelist fenvconslist)))
          (apply #'push-*venv* varlist) ; activate auxiliary variables
          (let* ((anodelist
                   (mapcar #'(lambda (form) (c-form form 'ONE)) formlist))
                 (body-anode ; compile remaining forms
                   (c-form `(PROGN ,@(cddr *form*)))))
            (get-anode CLOS:GENERIC-LABELS)))))))

;; compile (MACROLET ({macrodef}*) {form}*)
(defun c-MACROLET (&optional (c #'c-form))
  (test-list *form* 2)
  (test-list (second *form*) 0)
  (do ((L1 (second *form*) (cdr L1))
       (L2 '()))
      ((null L1)
       (multiple-value-bind (body-rest declarations) (parse-body (cddr *form*))
         (let ((*denv* *denv*) (*venv* *venv*)
               (*fenv* (sys::cons-*fenv* L2)))
           (c-declarations c declarations body-rest))))
    (let* ((macrodef (car L1))
           (name (car macrodef)))
      (push name L2)
      (push (make-macro-expander macrodef *form*) L2))))

)) ; macrolet

;; compile (SYMBOL-MACROLET ({symdef}*) {declaration}* {form}*)
(defun c-SYMBOL-MACROLET (&optional (c #'c-form))
  (test-list *form* 2)
  (test-list (second *form*) 0)
  ;; check the syntax of the parameter list:
  (multiple-value-bind (symbols expansions)
      (do ((L (second *form*) (cdr L))
           (symbols nil)
           (expansions nil))
          ((null L) (values (nreverse symbols) (nreverse expansions)))
        (let ((symdef (car L)))
          (if (and (consp symdef) (symbolp (car symdef))
                   (consp (cdr symdef)) (null (cddr symdef)))
            (progn
              (push (first symdef) symbols)
              (push (second symdef) expansions))
            (c-error-c symdef (TEXT "~S: Illegal syntax: ~S")
                       'symbol-macrolet symdef))))
    (let ((*denv* *denv*)
          (*venv*
            (apply #'vector
                   (nconc (mapcan #'(lambda (sym exp)
                                      (list sym (make-symbol-macro exp)))
                                  symbols expansions)
                          (list *venv*)))))
      (multiple-value-bind (body-rest declarations) (parse-body (cddr *form*))
        (multiple-value-bind (*specials* *ignores* *ignorables* *readonlys* other-decls)
            (process-declarations declarations)
          (push-specials)
          (push-*denv* other-decls)
          (dolist (symbol symbols)
            (if (or (constantp symbol) (proclaimed-special-p symbol))
              (c-error-c symbol (TEXT "~S: symbol ~S is declared SPECIAL and must not be declared a macro")
                         'symbol-macrolet symbol)
              (when (memq symbol *specials*)
                (c-error-c symbol (TEXT "~S: symbol ~S must not be declared SPECIAL and a macro at the same time")
                           'symbol-macrolet symbol))))
          (funcall c `(PROGN ,@body-rest)))))))

;; compile (EVAL-WHEN ({situation}*) {form}*)
(defun c-EVAL-WHEN (&optional (c #'c-form))
  (test-list *form* 2)
  (test-list (second *form*) 0)
  (let ((load-p nil) (compile-p nil) (execute-p nil) ; (eval-p nil)
        (top-level-p (eq c #'compile-toplevel-form)))
    (dolist (situation (second *form*))
      (fcase equal situation
        ((LOAD) (setq load-p t))
        ((:LOAD-TOPLEVEL) (when top-level-p (setq load-p t)))
        ((COMPILE) (setq compile-p t))
        ((:COMPILE-TOPLEVEL) (when top-level-p (setq compile-p t)))
        ((EVAL)  ) ; (setq eval-p t)
        ((:EXECUTE) (setq execute-p t))
        (((NOT EVAL) (NOT :EXECUTE)) (setq load-p t compile-p t))
        (((NOT COMPILE)) (setq load-p t)) ; eval-p t
        (((NOT :COMPILE-TOPLEVEL)) (setq load-p t execute-p t))
        (t (c-error 'situation
                    (TEXT "~S situation must be ~S, ~S or ~S, but not ~S")
                    'eval-when :load-toplevel :compile-toplevel :execute
                    situation))))
    (let ((form `(PROGN ,@(cddr *form*))))
      (when (and compile-p load-p) (c-write-lib form))
      (when compile-p (eval form))
      (funcall c (and (or load-p (and execute-p (not top-level-p))) form)))))

;; compile (COND {clause}*)
(defun c-COND ()
  (test-list *form* 1)
  (c-form
    (let ((clauses (cdr *form*))) ; macroexpand (COND . clauses)
      (if (null clauses)
        'NIL
        (let ((clause (car clauses)))
          (if (atom clause)
            (c-error clause (TEXT "COND clause without test: ~S")
                     clause)
            (let ((test (car clause)))
              (if (cdr clause)
                `(IF ,test (PROGN ,@(cdr clause)) (COND ,@(cdr clauses)))
                `(OR ,test (COND ,@(cdr clauses)))))))))))

;; compile (CASE keyform {clause}*) and (FCASE test keyform {clause}*)
(defun c-CASE ()
  (test-list *form* 1)
  (let* ((head (first *form*))
         (clauses (rest *form*))
         (test (if (eq head 'case) 'eql (pop clauses)))
         (keyform (pop clauses))
         ;; simplify clauses:
         (newclauses '())
         (allkeys '()))
    (let ((default-passed nil))
      (do ((clauses clauses))
          ((endp clauses))
        (let ((clause (pop clauses)))
          (if (atom clause)
            (c-error clause (TEXT "CASE clause without objects: ~S")
                     clause)
            (let ((keys (car clause)))
              (if default-passed ; was the Default already there?
                (setq keys nil)
                (if (or (eq keys 'T) (eq keys 'OTHERWISE))
                  (progn
                    (when clauses
                      (c-error-c
                       keys (TEXT "~S: the ~S clause must be the last one: ~S")
                       'case keys *form*))
                    (setq keys 'T)
                    (setq default-passed t))
                  (let ((newkeys '()))
                    (dolist (key (if (listp keys) keys (list keys)))
                      (if (not (member key allkeys :test test)) ; remove-duplicates
                        (progn (push key allkeys) (push key newkeys))
                        (c-style-warn (TEXT "Duplicate ~S label ~S : ~S")
                                      'case key *form*)))
                    (setq keys (nreverse newkeys)))))
              (push (cons keys (cdr clause)) newclauses)))))
      (unless default-passed (push '(T NIL) newclauses))
      (setq newclauses (nreverse newclauses))
      (setq allkeys (nreverse allkeys)))
    ;; newclauses now contains no double keys, T as keys exactly once,
    ;; and allkeys is the set of all Keys.
    (if (or (<= (length allkeys) 2) ; few Keys -> use TEST directly
            (not (memq test '(eq eql equal equalp)))) ; valid hash tests
      (let ((keyvar (gensym)))
        (labels ((ifify (clauses)
                   (if (null clauses)
                     'NIL
                     `(IF ,(let ((keys (caar clauses)))
                             (if (listp keys)
                               `(OR ,@(mapcar
                                       #'(lambda (key) `(,test ,keyvar ',key))
                                       keys))
                               'T)) ; keys = T, the Default-Case
                        (PROGN ,@(cdar clauses))
                        ,(ifify (cdr clauses))))))
          (c-form
            `(LET ((,keyvar ,keyform)) (PROGN ,keyvar ,(ifify newclauses))))))
      (let ((keyform-anode (c-form keyform 'ONE))
            (default-anode nil)
            (cases '())) ; list of Triples (keylist label anode)
        (dolist (clause newclauses)
          (if (car clause)
            (let ((anode (c-form `(PROGN ,@(cdr clause)))))
              (if (atom (car clause))
                (setq default-anode anode)
                (push (list (car clause) (make-label 'NIL) anode) cases)))
            (let ((*no-code* t)) (c-form `(PROGN ,@(cdr clause)) 'NIL))))
        (setq cases (nreverse cases))
        (if (anode-constantp keyform-anode)
          (let ((value (anode-constant-value keyform-anode)))
            (dolist (case cases default-anode)
              (when (member value (first case) :test test)
                (return (third case)))))
          (let ((default-label (make-label 'NIL))
                (end-label (make-label *for-value*)))
            (when (and (eq test 'EQL) (every #'EQL=EQ allkeys))
              (setq test 'EQ))
            (cond ((eq test 'EQ)
                   (if (every #'(lambda (x)
                                  (or (symbolp x)
                                      (and (integerp x) (<= (integer-length x) 24))
                                      (sys::short-float-p x)
                                      (characterp x)))
                              allkeys)
                     (setq test 'STABLEHASH-EQ)
                     (setq test 'FASTHASH-EQ)))
                  ((eq test 'EQL)
                   (if (every #'(lambda (x)
                                  (or (symbolp x)
                                      (numberp x)
                                      (characterp x)))
                              allkeys)
                     (setq test 'STABLEHASH-EQL)
                     (setq test 'FASTHASH-EQL)))
                  ((eq test 'EQUAL)
                   (if (every #'(lambda (x)
                                  (labels ((stablep (x depth)
                                             (if (atom x)
                                               (or (symbolp x)
                                                   (numberp x)
                                                   (characterp x))
                                               (if (= depth 0)
                                                 t
                                                 (and (stablep (car x) (1- depth))
                                                      (stablep (cdr x) (1- depth)))))))
                                    (stablep x 4)))
                              allkeys)
                     (setq test 'STABLEHASH-EQUAL)
                     (setq test 'FASTHASH-EQUAL))))
            (make-anode
              :type 'CASE
              :sub-anodes `(,keyform-anode ,@(mapcar #'third cases)
                            ,default-anode)
              :seclass
                (anodelist-seclass-or
                  `(,keyform-anode ,@(mapcar #'third cases) ,default-anode))
              :code
                `(,keyform-anode
                  (JMPHASH
                    ,test
                    ,(mapcap ; alist (obji -> labeli)
                       #'(lambda (case)
                           (let ((label (second case)))
                             (mapcar #'(lambda (obj) (cons obj label))
                                     (first case))))
                       cases)
                    ,default-label
                    ,@(mapcar #'second cases)) ; all Labels, without doubles
                  ,@(mapcap
                      #'(lambda (case)
                          `(,(second case) ; Label
                            ,(third case) ; Anode
                            (JMP ,end-label)))
                      cases)
                  ,default-label
                  ,default-anode
                  ,end-label))))))))


;;;;****             FIRST PASS :    MACROS

;; helpers for c-HANDLER-BIND & c-%HANDLER-BIND
(defun c-handler-bind-handler-anode (label handler)
  ;; the handler is a function with dynamic extent.
  (let* ((*stackz* (cons 'ANYTHING *stackz*))
         (oldstackz *stackz*)
         (*venv* *venv*))
    ;; work place for the function:
    (push 1 *stackz*)
    (let* ((condition-sym (gensym))
           (condition-anode
            (make-anode :type 'CONDITION
                        :sub-anodes '()
                        :seclass *seclass-read*
                        :code '())) ; first comes (HANDLER-BEGIN)
           (condition-var (bind-movable-var condition-sym condition-anode)))
      (push-*venv* condition-var)
      (let ((body-anode (c-form `(FUNCALL ,handler ,condition-sym) 'NIL)))
        ;; Check the variables (must not happen in the closure):
        (checking-movable-var-list (list condition-var) (list condition-anode))
        (let* ((codelist
                `(,label
                  (HANDLER-BEGIN)
                  ,@(c-bind-movable-var-anode condition-var condition-anode)
                  ,body-anode
                  (UNWINDSP ,*stackz* ,*func*) ; (SKIPSP k1 k2)
                  (UNWIND ,*stackz* ,oldstackz NIL) ; (SKIP 2)
                  (RET)))
               (anode (make-anode
                       :type 'HANDLER
                       :sub-anodes `(,body-anode)
                       :seclass *seclass-dirty* ; actually irrelevant
                       :stackz oldstackz
                       :code codelist)))
          (optimize-var-list (list condition-var))
          anode)))))

(defun c-handler-bind-anode (body-form types handler-labels handler-anodes)
  (if types
    (let* ((label (make-label 'NIL))
           (oldstackz *stackz*)
           (*stackz* (cons 4 *stackz*)) ; HANDLER-Frame
           (body-anode (c-form body-form)))
      (make-anode
       :type 'HANDLER-BIND
       :sub-anodes `(,body-anode ,@handler-anodes)
       :seclass (anodelist-seclass-or `(,body-anode ,@handler-anodes))
       :stackz oldstackz
       :code `((HANDLER-OPEN ,(new-const (coerce types 'vector))
                             ,*stackz* ,@handler-labels)
               (JMP ,label)
               ,@handler-anodes
               ,label
               ,body-anode
               (UNWIND ,*stackz* ,oldstackz ,*for-value*))))
    (c-form body-form)))

;; Making HANDLER-BIND a special form is a preformance optimization to avoid
;; consing at run time in IGNORE-ERRORS,
;; see https://sourceforge.net/p/clisp/bugs/582/ & conditions.tst.
;; %HANDLER-BIND + macro in condition.lisp work correctly.
;; NB: even though HANDLER-BIND is a special form, it does not need a special
;;  treatment in init.lisp:EXPAND-FORM because it expands to %HANDLER-BIND
;;  which looks like a regular function (for evaluation).

;;; (HANDLER-BIND ({(typespec handler)}*) {form}*)
(defun c-HANDLER-BIND ()
  (test-list *form* 2)
  (test-list (second *form*) 0)
  (let ((body (cddr *form*))
        (types '())
        (handler-labels '())
        (handler-anodes '()))
    (dolist (clause (second *form*))
      (test-list clause 2 2)
      (let ((type (first clause)) (handler (second clause))
            (label (make-label 'ONE)))
        (push type types)
        (push label handler-labels)
        (push (c-handler-bind-handler-anode label handler) handler-anodes)))
    (c-handler-bind-anode `(PROGN ,@body)
                          (nreverse types) (nreverse handler-labels)
                          (nreverse handler-anodes))))

;;; (SYS::%HANDLER-BIND body-function 'typespec1 handler1 ...)
(defun c-%HANDLER-BIND ()
  (test-list *form* 1)
  (let ((body-f (second *form*))
        (types '())
        (handler-labels '())
        (handler-anodes '()))
    (do ((tail (cddr *form*))) ((endp tail))
      (let ((type (pop tail)) (handler (pop tail)) (label (make-label 'ONE)))
        (unless (quote-p type) (compiler-error 'c-%HANDLER-BIND type))
        (push (second type) types)
        (push label handler-labels)
        (push (c-handler-bind-handler-anode label handler) handler-anodes)))
    (c-handler-bind-anode `(FUNCALL ,body-f)
                          (nreverse types) (nreverse handler-labels)
                          (nreverse handler-anodes))))

;; compile (SYS::CONSTANT-EQL form1 form2 form3)
(defun c-CONSTANT-EQL ()
  (test-list *form* 4 4)
  (let ((form1 (second *form*))
        (form23 (cddr *form*)))
    (if (and *compiling-from-file*
             (c-constantp form1)
             (let ((value (c-constant-value form1)))
               (or (stringp value) (bit-vector-p value))))
      (c-form `(SYS::LOOSE-CONSTANT-EQL ,@form23))
      (c-form `(EQL ,@form23)))))

;; compile (without-package-lock (packages) ...)
(defun c-WITHOUT-PACKAGE-LOCK (&optional (c #'c-form))
  (test-list *form* 1)
  (let* ((pack-list (second *form*))
         (*compiler-unlocked-packages*
           (nconc (mapcar #'find-package (or pack-list *system-package-list*))
                  *compiler-unlocked-packages*)))
    ;; Unlock the packages temporarily in the compilation environment.
    (with-no-package-lock-internal pack-list
      ;; Process the form as if this handler would not exist. We cannot use
      ;; macroexpand-form here, because macroexpand-form leaves this form
      ;; invariant - we would get into an endless recursion.
      (funcall c (macroexpand-1 *form*)))))


;;;;****   FIRST PASS :   INLINE   FUNCTIONS   (PRIMOPS)

;; function-calls, that are treated like special forms:

;; First FUNCALL

;; (c-FUNCALL-NOTINLINE funform args) compiles a function-call
;; (FUNCALL funform . args),
;; for which the STACK-Layout of the arguments cannot be determined
;; at compile-time.
(defun c-FUNCALL-NOTINLINE (funform args)
  (test-list args 0)
  (let* ((anode1 (c-form funform 'ONE))
         (*stackz* (cons 1 *stackz*)))
    (do ((formlistr args (cdr formlistr))
         (seclass (f-side-effect funform))
         #+CLISP-DEBUG (anodelist (list anode1))
         (codelist (list '(FUNCALLP) anode1)))
        ((null formlistr)
         (push `(FUNCALL ,(length args)) codelist)
         (make-anode
           :type 'FUNCALL
           :sub-anodes (nreverse anodelist)
           :seclass seclass
           :code (nreverse codelist)))
      (let ((anode (c-form (car formlistr) 'ONE)))
        #+CLISP-DEBUG (push anode anodelist)
        (seclass-or-f seclass anode)
        (push anode codelist))
      (push '(PUSH) codelist)
      (push 1 *stackz*))))

;; (c-FUNCALL-INLINE funform args applyargs lambdabody sameenv) compiles a
;; function-call (FUNCALL funform . args) resp.
;; (APPLY funform . args applyargs) [applyargs a list out of a form],
;; for which the STACK-Layout of the arguments can be determined at
;; compile-time.  sameenv specifies, if lambdabody is to be viewed in
;; the same environment or in the top-level-environment.
(defun c-FUNCALL-INLINE (funform arglist applyarglist lambdabody sameenv)
  (test-list lambdabody 1)
  (multiple-value-bind (reqvar  optvar optinit optsvar  restvar
                        keyflag keyword keyvar keyinit keysvar allow-other-keys
                        auxvar auxinit)
      (let ((lalist (pop lambdabody)) (declarations '()))
        (when *defun-accept-specialized-lambda-list*
          (multiple-value-setq (lalist declarations)
            (sys::specialized-lambda-list-to-ordinary lalist 'compile))
          (push (cons 'DECLARE (nreverse declarations)) lambdabody))
        (c-analyze-lambdalist lalist))
    (when (or keyflag keyword keyvar keyinit keysvar allow-other-keys)
      (compiler-error 'c-FUNCALL-INLINE funform))
    (let ((r (length reqvar)) ; number of required-arguments
          (s (length optvar)) ; number of optional arguments
          (|t| (length arglist))) ; number of specified arguments
      (when (and (null restvar) (> |t| (+ r s)))
        ;; too many arguments specified. Is redressed by introduction
        ;; of several additional optional arguments:
        (c-error-c funform (TEXT "Too many arguments to ~S") funform)
        (dotimes (i (- |t| (+ r s)))
          (let ((var (gensym)))
            (setq optvar (append optvar (list var)))
            (setq optinit (append optinit (list nil)))
            (setq optsvar (append optsvar (list nil)))
            (incf s)
            (push `(DECLARE (IGNORE ,var)) lambdabody))))
      (when (and (null applyarglist) (< |t| r))
        ;; too few arguments specified. Is redressed by introduction
        ;; of additional arguments:
        (c-error-c funform (TEXT "Too few arguments to ~S") funform)
        (setq arglist (append arglist
                              (make-list (- r |t|) :initial-element nil)))
        (setq |t| r))
      ;; Now (t>=r or apply-arg is there)
      ;; and (t<=r+s or &rest-Parameter is there).
      (let ((oldstackz *stackz*)
            (oldvenv *venv*)
            (oldfenv *fenv*)
            (oldbenv *benv*)
            (oldgenv *genv*)
            (olddenv *denv*)
            (*stackz* *stackz*)
            (*venv* (and sameenv *venv*))
            (*venvc* *venvc*)
            (*fenv* (and sameenv *fenv*))
            (*benv* (and sameenv *benv*))
            (*genv* (and sameenv *genv*))
            (*denv* (if sameenv
                      *denv*
                      (cons `(INLINING ,funform)
                            (remove-if-not
                             #'(lambda (declspec)
                                 (case (car declspec)
                                   ((DECLARATION SYS::IN-DEFUN INLINING) t)
                                   (t nil)))
                             *denv*)))))
        (multiple-value-bind (body-rest declarations)
            (parse-body lambdabody t)
          (let (*specials* *ignores* *ignorables* *readonlys* other-decls
                req-vars req-anodes req-stackzs
                opt-vars opt-anodes opt-stackzs ; optional and svar together!
                optdefaulted-vars optdefaulted-anodes optdefaulted-stackzs
                rest-vars rest-anodes rest-stackzs
                fixed-anodes fixed-stackz
                reqfixed-vars reqfixed-dummys reqfixed-stackzs
                optfixed-vars optfixed-dummys optfixed-anodes
                optsfixed-vars optsfixed-anodes optfixed-stackzs
                restfixed-vars restfixed-dummys restfixed-stackzs
                aux-vars aux-anodes
                closuredummy-stackz closuredummy-venvc)
            (multiple-value-setq (*specials* *ignores* *ignorables* *readonlys* other-decls)
              (process-declarations declarations))
            (push 0 *stackz*) (push nil *venvc*) ; room for Closure-Dummyvar
            (setq closuredummy-stackz *stackz* closuredummy-venvc *venvc*)
            (flet ((finish-using-applyarg
                       (reqvar optvar optinit optsvar restvar)
                     ;; reqvar and optvar/optinit/optsvar as well as
                     ;; arglist are already partially shortened.
                     ;; Disassembly of the remaining argument-list by
                     ;; means of UNLIST resp. UNLIST*. Hence a
                     ;; stack-layout with fixed look, cf. c-LAMBDABODY.
                     (setq fixed-anodes
                           (list
                             (let ((anode1 (let ((*venv* oldvenv)
                                                 (*fenv* oldfenv)
                                                 (*benv* oldbenv)
                                                 (*genv* oldgenv)
                                                 (*denv* olddenv))
                                             (c-form (first applyarglist)
                                                     'ONE)))
                                   (anode2 (c-unlist (not (eql restvar 0))
                                                     (+ (length reqvar)
                                                        (length optvar))
                                                     (length optvar))))
                               (make-anode
                                 :type 'APPLY-UNLIST
                                 :sub-anodes (list anode1 anode2)
                                 :seclass (anodes-seclass-or anode1 anode2)
                                 :code `(,anode1 ,anode2)))))
                     ;; build Stack-Dummy-Variable for the
                     ;; reqvar,optvar,restvar:
                     (multiple-value-setq (reqfixed-vars reqfixed-dummys)
                       (process-fixed-var-list reqvar))
                     (multiple-value-setq (optfixed-vars optfixed-dummys)
                       (process-fixed-var-list optvar))
                     (multiple-value-setq (restfixed-vars restfixed-dummys)
                       (if (eql restvar 0)
                         (values '() '())
                         (process-fixed-var-list (list restvar))))
                     (push 0 *stackz*) (setq fixed-stackz *stackz*)
                     ;; activate the bindings of the required-parameters:
                     (setq reqfixed-stackzs (bind-req-vars reqfixed-vars))
                     ;; activate the bindings of the optional-parameters/svar:
                     (multiple-value-setq (optfixed-anodes optfixed-stackzs
                                           optsfixed-vars optsfixed-anodes)
                       (bind-opt-vars optfixed-vars optfixed-dummys
                                      optinit optsvar))
                     ;; activate the binding of the rest-parameter:
                     (unless (eql restvar 0)
                       (setq restfixed-stackzs
                             (bind-rest-vars restfixed-vars)))))
              (block main-args
                ;; bind required-parameter:
                (do ((reqvarr reqvar (cdr reqvarr)))
                    ((null reqvarr))
                  (if (null arglist) ; implies, that apply-arg is there
                    (return-from main-args
                      (finish-using-applyarg reqvarr optvar optinit optsvar
                                             restvar))
                    (let* ((form (pop arglist))
                           (anode (let ((*venv* oldvenv)
                                        (*fenv* oldfenv)
                                        (*benv* oldbenv)
                                        (*genv* oldgenv)
                                        (*denv* olddenv))
                                    (c-form form 'ONE)))
                           (var (bind-movable-var (car reqvarr) anode)))
                      (push anode req-anodes)
                      (push var req-vars)
                      (push *stackz* req-stackzs)
                      (push-*venv* var))))
                ;; bind optional parameters and Svars:
                (do ((optvarr optvar (cdr optvarr))
                     (optinitr optinit (cdr optinitr))
                     (optsvarr optsvar (cdr optsvarr)))
                    ((null optvarr))
                  (if (and applyarglist (null arglist))
                    (return-from main-args
                      (finish-using-applyarg '() optvarr optinitr
                                             optsvarr restvar))
                    (let ((svar-init (not (null arglist)))) ; = NIL or T
                      (if svar-init
                        (progn
                          (let ((*no-code* t))
                            (c-form (car optinitr) 'NIL))
                          (let* ((anode
                                   (let ((*venv* oldvenv)
                                         (*fenv* oldfenv)
                                         (*benv* oldbenv)
                                         (*genv* oldgenv)
                                         (*denv* olddenv))
                                     (c-form (pop arglist) 'ONE)))
                                 (var (bind-movable-var (car optvarr) anode)))
                            (push anode opt-anodes)
                            (push var opt-vars)
                            (push *stackz* opt-stackzs)
                            (push-*venv* var)
                            (unless (eql (car optsvarr) 0)
                              (let* ((anode (c-form svar-init 'ONE))
                                     (var (bind-movable-var (car optsvarr) anode)))
                                (push anode opt-anodes)
                                (push var opt-vars)
                                (push *stackz* opt-stackzs)
                                (push-*venv* var)))))
                        (let* ((anode (c-form (car optinitr) 'ONE))
                               (var (bind-movable-var (car optvarr) anode)))
                          (push anode optdefaulted-anodes)
                          (push var optdefaulted-vars)
                          (push *stackz* optdefaulted-stackzs)
                          (push-*venv* var)
                          (unless (eql (car optsvarr) 0)
                            (let* ((anode (c-form svar-init 'ONE))
                                   (var (bind-movable-var (car optsvarr) anode)))
                              (push anode optdefaulted-anodes)
                              (push var optdefaulted-vars)
                              (push *stackz* optdefaulted-stackzs)
                              (push-*venv* var))))))))
                (if (eql restvar 0)
                  ;; consume further arguments:
                  (when applyarglist
                    (return-from main-args
                      (finish-using-applyarg '() '() '() '() restvar)))
                  ;; bind rest-parameter:
                  (let* ((form (if applyarglist
                                 (if arglist
                                   `(LIST* ,@arglist ,@applyarglist)
                                   (first applyarglist))
                                 (if arglist `(LIST ,@arglist) 'NIL)))
                         (anode (let ((*venv* oldvenv)
                                      (*fenv* oldfenv)
                                      (*benv* oldbenv)
                                      (*genv* oldgenv)
                                      (*denv* olddenv))
                                  (c-form form 'ONE)))
                         (var (bind-movable-var restvar anode)))
                    (push anode rest-anodes)
                    (push var rest-vars)
                    (push *stackz* rest-stackzs)
                    (push-*venv* var)))
                (push 0 *stackz*) (setq fixed-stackz *stackz*)))
            (setq req-vars (nreverse req-vars))
            (setq req-anodes (nreverse req-anodes))
            (setq req-stackzs (nreverse req-stackzs))
            (setq opt-vars (nreverse opt-vars))
            (setq opt-anodes (nreverse opt-anodes))
            (setq opt-stackzs (nreverse opt-stackzs))
            (setq optdefaulted-vars (nreverse optdefaulted-vars))
            (setq optdefaulted-anodes (nreverse optdefaulted-anodes))
            (setq optdefaulted-stackzs (nreverse optdefaulted-stackzs))
            ;; activate the bindings of the Aux-Variables:
            (multiple-value-setq (aux-vars aux-anodes)
              (bind-aux-vars auxvar auxinit))
            (push-specials)
            (push-*denv* other-decls)
            (let* ((body-anode (c-form `(PROGN ,@body-rest)))
                   ;; check the variables:
                   (varlist
                     (append req-vars opt-vars optdefaulted-vars rest-vars
                             reqfixed-vars optfixed-vars optsfixed-vars
                             restfixed-vars aux-vars))
                   (closurevars
                     (append
                       (checking-movable-var-list req-vars req-anodes)
                       (checking-movable-var-list opt-vars opt-anodes)
                       (checking-movable-var-list optdefaulted-vars optdefaulted-anodes)
                       (checking-movable-var-list rest-vars rest-anodes)
                       (checking-fixed-var-list reqfixed-vars)
                       (checking-fixed-var-list optfixed-vars)
                       (checking-movable-var-list optsfixed-vars
                                                  optsfixed-anodes)
                       (checking-fixed-var-list restfixed-vars)
                       (checking-movable-var-list aux-vars aux-anodes)))
                   (codelist
                     `(,@(c-make-closure closurevars closuredummy-venvc
                                         closuredummy-stackz)
                       ,@(let ((*stackz* fixed-stackz))
                           (c-parallel-bind-movable-var-anode
                             (append req-vars    opt-vars    rest-vars   )
                             (append req-anodes  opt-anodes  rest-anodes )
                             (append req-stackzs opt-stackzs rest-stackzs)
                             fixed-anodes))
                       ,@(mapcap #'c-bind-movable-var-anode
                                 optdefaulted-vars optdefaulted-anodes)
                       ,@(mapcap #'c-bind-fixed-var reqfixed-vars
                                 reqfixed-dummys reqfixed-stackzs)
                       ,@(c-bind-with-svars optfixed-vars optfixed-dummys
                                            optsfixed-vars optfixed-anodes
                                            optsfixed-anodes optfixed-stackzs)
                       ,@(mapcap #'c-bind-fixed-var restfixed-vars
                                 restfixed-dummys restfixed-stackzs)
                       ,@(mapcap #'c-bind-movable-var-anode aux-vars
                                 aux-anodes)
                       ,body-anode
                       (UNWIND ,*stackz* ,oldstackz ,*for-value*)))
                   (anode
                     (make-anode
                       :type 'FUNCALL
                       :sub-anodes
                         `(,@req-anodes ,@opt-anodes ,@optdefaulted-anodes ,@rest-anodes
                           ,@fixed-anodes ,@optfixed-anodes
                           ,@(remove nil optsfixed-anodes)
                           ,@aux-anodes ,body-anode)
                       :seclass
                         (seclass-without
                           (anodelist-seclass-or
                             `(,@req-anodes ,@opt-anodes ,@optdefaulted-anodes ,@rest-anodes
                               ,@fixed-anodes ,@optfixed-anodes
                               ,@(remove nil optsfixed-anodes)
                               ,@aux-anodes ,body-anode))
                           varlist)
                       :stackz oldstackz
                       :code codelist)))
              (closuredummy-add-stack-slot
               closurevars closuredummy-stackz closuredummy-venvc)
              (optimize-var-list varlist)
              anode)))))))

;; compiles (fun {form}*), whereas fun is a local function.
;; fdescr is the associated information from *fenv*.
(defun c-LOCAL-FUNCTION-CALL (fun fdescr args)
  ;; (test-list args 0) ; that manages in a moment (test-argument-syntax ...)
  ;; fetch Call-Specification:
  (multiple-value-bind (req opt rest-flag key-flag keylist allow-flag)
      (fdescr-signature fdescr)
    (case (test-argument-syntax
           args nil fun req opt rest-flag key-flag keylist allow-flag)
      ((NO-KEYS STATIC-KEYS)
       ;; call INLINE
       (c-DIRECT-FUNCTION-CALL
         args nil fun req opt rest-flag key-flag keylist
         nil ; no SUBR-, but Cclosure-call
         (cclosure-call-code-producer fun (car fdescr) req opt rest-flag
                                      key-flag keylist)))
      (t (c-FUNCALL-NOTINLINE `(FUNCTION ,fun) args)))))

;; check whether (FUNC FORM) can be inlined
;; useful for (CONSTANTLY ...) and (COMPLEMENT ...)
(defun inlinable-function-operation-form-p (form func)
  (and (consp form) (eq (first form) func)
       (consp (rest form)) (null (cddr form))
       (not (fenv-search func))
       (not (declared-notinline func))))

;; (c-FUNCTION-CALL funform arglist) compiles a function call
;; (FUNCALL funform . arglist).
(defun c-FUNCTION-CALL (funform arglist)
  (setq funform (macroexpand-form funform))
  (when (inline-callable-function-lambda-p funform (length arglist))
    ;; call of a Lambda-expression is possible INLINE
    (return-from c-FUNCTION-CALL
      (c-FUNCALL-INLINE funform arglist nil (cdr (second funform)) t)))
  (when (and (inlinable-function-operation-form-p funform 'COMPLEMENT)
             (not (fenv-search 'NOT)))
    ;; (complement fn) -->
    ;; (let ((f fn)) ... #'(lambda (&rest args) (not (apply f args))) ...)
    (return-from c-FUNCTION-CALL
      (c-form `(NOT (FUNCALL ,(second funform) ,@arglist)))))
  (when (inlinable-function-operation-form-p funform 'CONSTANTLY)
    ;; (constantly obj) -->
    ;; (let ((o obj)) ... #'(lambda (&rest a) (declare (ignore a)) o) ...)
    (return-from c-FUNCTION-CALL
      (c-form `(PROG1 ,(second funform) ,@arglist))))
  (when (simple-function-form-p funform) ; #'symbol
    (return-from c-FUNCTION-CALL
      (progn
        (test-list funform 2 2)
        ;; list in more detail, cf. c-FUNCTION ??
        (c-form `(,(second funform) ,@arglist)))))
  ;; call of NOTINLINE
  (c-FUNCALL-NOTINLINE funform arglist))

(defun c-FUNCALL ()
  (test-list *form* 2)
  (c-FUNCTION-CALL (second *form*) (cddr *form*)))

(defun c-APPLY ()
  (test-list *form* 3)
  (let* ((funform (second *form*))
         (arglist (cddr *form*))
         (args (butlast arglist))
         (apply-args (last arglist))
         (n (1- (length arglist)))) ; the minimum number of arguments
    (setq funform (macroexpand-form funform))
    (when (inline-callable-function-lambda-p funform n t)
      (return-from c-APPLY
        (c-FUNCALL-INLINE funform args apply-args (cdr (second funform)) t)))
    (when (and (inlinable-function-operation-form-p funform 'COMPLEMENT)
               (not (fenv-search 'NOT)))
      ;; (complement fn) -->
      ;; (let ((f fn)) ... #'(lambda (&rest args) (not (apply f args))) ...)
      (return-from c-APPLY
        (c-form `(NOT (APPLY ,(second funform) ,@arglist)))))
    (when (inlinable-function-operation-form-p funform 'CONSTANTLY)
      ;; (constantly obj) -->
      ;; (let ((o obj)) ... #'(lambda (&rest a) (declare (ignore a)) o) ...)
      (return-from c-APPLY
        (c-form `(PROG1 ,(second funform) ,@arglist))))
    (when (simple-function-form-p funform) ; #'symbol
      (let ((fun (second funform)))
        (test-list funform 2 2)
        (let (name req opt rest-p key-p keylist allow-p)
          (multiple-value-bind (a m f1 f2 f3) (fenv-search fun)
            (declare (ignore m f1 f2))
            (if a           ; fun is local
              (let ((fnode (car f3)))
                (if fnode       ; valid entry
                  (setq name fun
                        req (fnode-req-num fnode)
                        opt (fnode-opt-num fnode)
                        rest-p (fnode-rest-flag fnode)
                        key-p (fnode-keyword-flag fnode)
                        keylist (fnode-keywords fnode)
                        allow-p (fnode-allow-other-keys-flag fnode))
                  (setq name fun ; labels: no fnode yet
                        ;; (cddr f3) are the return values of
                        ;; C-ANALYZE-LAMBDALIST, see c-LABELS
                        req (length (third f3))
                        opt (length (fourth f3))
                        rest-p (symbolp (seventh f3))
                        key-p (eighth f3)
                        keylist (ninth f3)
                        allow-p (nth 12 f3))))
              (multiple-value-setq (name req opt rest-p key-p keylist allow-p)
                (function-signature fun t))) ; global functions only
            (if (and name (equal fun name))
              (test-argument-syntax args apply-args fun req opt rest-p
                                    key-p keylist allow-p)
              (note-function-used fun args apply-args))))
        (unless (declared-notinline fun) ; can fun be taken INLINE?
          (flet ((c-LOCAL-APPLY (fdescr)
                   (multiple-value-bind
                         (req opt rest-flag key-flag keylist allow-flag)
                       (fdescr-signature fdescr)
                     (unless key-flag
                       ;; without Keyword-Arguments
                       (when (eq 'NO-KEYS
                                 (test-argument-syntax
                                  args apply-args
                                  fun req opt rest-flag key-flag keylist
                                  allow-flag))
                         ;; Syntax correct -> call INLINE
                         (return-from c-APPLY
                           (c-DIRECT-FUNCTION-CALL args apply-args
                             fun req opt rest-flag key-flag keylist
                             nil ; no SUBR-, but Cclosure-Aufruf
                             (cclosure-call-code-producer
                              fun (car fdescr) req opt rest-flag
                              key-flag keylist))))))))
            (multiple-value-bind (a m f1 f2 f3 f4) (fenv-search fun)
              (declare (ignore m f2 f4))
              ;; (APPLY #'fun . args) maybe possible to simplify
              (if (null a)
                ;; global function
                (unless (and (symbolp fun) ; special form or global macro?
                             (or (special-operator-p fun)
                                 (macro-function fun)))
                  (when (in-defun-p fun)
                    ;; recursive call of the current global function
                    (c-LOCAL-APPLY (cons *func* nil)))
                  (let ((inline-lambdabody (inline-lambdabody fun)))
                    (when (inline-callable-lambdabody-p inline-lambdabody n t)
                      ;; inline call of the global function is possible
                      (return-from c-APPLY
                        (c-FUNCALL-INLINE fun args apply-args
                                          inline-lambdabody nil)))))
                (when (eq f1 'LOCAL) ; local function
                  (c-LOCAL-APPLY f3))))))))
    ;; if none of the optimizations was possible:
    (let* ((anode1 (c-form funform 'ONE))
           (seclass (f-side-effect funform))
           (*stackz* (cons 1 *stackz*)))
      (do ((formlistr arglist (cdr formlistr))
           #+CLISP-DEBUG (anodelist (list anode1))
           (codelist (list '(APPLYP) anode1)))
          ((null formlistr)
           (push `(APPLY ,n) codelist)
           (make-anode
             :type 'APPLY
             :sub-anodes (nreverse anodelist)
             :seclass seclass
             :code (nreverse codelist)))
        (let ((anode (c-form (car formlistr) 'ONE)))
          #+CLISP-DEBUG (push anode anodelist)
          (seclass-or-f seclass anode)
          (push anode codelist)
          (when (cdr formlistr)
            (push 1 *stackz*) (push '(PUSH) codelist)))))))

;; macroexpand form and check for it being a constant number
;; signal an error when it is not an number
;; returns 2 values - value and constant-p
(defun c-constant-number (form)
  (let ((expanded (macroexpand-form form)))
    (when (c-constantp expanded)
      (let ((val (c-constant-value expanded)))
        (if (numberp val)
          (return-from c-constant-number (values val t))
          (c-warn
            (TEXT "Arithmetic operand ~s must evaluate to a number, not ~s")
            form val))))
    (values expanded nil)))

;; return two values: the list of numeric constants
;; and the list of other forms
;; This optimization makes compiled code behave differently than interpreted
;; code, but is allowed by CLHS section 12.1.1.1.
(defun c-collect-numeric-constants (forms)
  (let ((consts nil) (others nil))
    (dolist (form forms)
      (multiple-value-bind (val const-p) (c-constant-number form)
        (if const-p (push val consts) (push val others))))
    (values (nreverse consts)   ; not really necessary to nreverse consts
            (nreverse others))))

(defun c-PLUS ()
  (test-list *form* 1)
  (multiple-value-bind (const-sum other-parts)
      (c-collect-numeric-constants (cdr *form*))
    (unless (try-eval (setq const-sum (reduce #'+ const-sum)))
      (return-from c-PLUS (c-GLOBAL-FUNCTION-CALL-form *form*)))
    (cond ((null other-parts)   ; constant addends only
           (c-form const-sum))  ; ==> constant result
          ((eql const-sum 0)    ; const-sum == 0 ==> skip it
           ;; this is a bad optimization: THE is slower than #'+
           ;;(if (cdr other-parts) (c-form `(the number ,@other-parts)) ...)
           (c-GLOBAL-FUNCTION-CALL-form `(+ ,@other-parts)))
          ((null (cdr other-parts)) ; just one non-constant summand
           (case const-sum
             (+1 (c-form `(1+ ,@other-parts)))
             (-1 (c-form `(1- ,@other-parts)))
             (t (c-GLOBAL-FUNCTION-CALL-form `(+ ,const-sum ,@other-parts)))))
          (t (c-GLOBAL-FUNCTION-CALL-form `(+ ,const-sum ,@other-parts))))))

(defun c-STAR ()
  (test-list *form* 1)
  (multiple-value-bind (const-prod other-parts)
      (c-collect-numeric-constants (cdr *form*))
    (unless (try-eval (setq const-prod (reduce #'* const-prod)))
      (return-from c-STAR (c-GLOBAL-FUNCTION-CALL-form *form*)))
    (cond ((null other-parts)     ; constant multiples only
           (c-form const-prod))   ; ==> constant result
          ;; this is a bad optimization: one call to #'* is cheaper than PROGN
          ;;((eql const-prod 0)   ; const-prod == 0 ==> result == 0
          ;; (c-form `(progn ,@(mapcar (lambda (form) `(the number ,form))
          ;;                           other-parts)
          ((eql const-prod 1)   ; const-prod == 1 ==> skip it
           ;; this is a bad optimization: THE is slower than #'*
           ;;(if (cdr other-parts) (c-form `(the number ,@other-parts)) ...)
           (c-GLOBAL-FUNCTION-CALL-form `(* ,@other-parts)))
          ((and (eql const-prod -1) (null (cdr other-parts)))
           (c-GLOBAL-FUNCTION-CALL-form `(- ,@other-parts)))
          (t (c-GLOBAL-FUNCTION-CALL-form `(* ,const-prod ,@other-parts))))))

(defun c-MINUS ()
  (test-list *form* 2)
  (let ((unary-p (= (length *form*) 2))
        (const-sum 0)           ; the constant sum in the tail
        (first-part 0) (other-parts '()))
    (unless unary-p
      (multiple-value-bind (val const-p) (c-constant-number (second *form*))
        (if const-p
          (setq const-sum val)
          (setq first-part val))))
    (multiple-value-bind (consts others)
        (c-collect-numeric-constants (if unary-p (cdr *form*) (cddr *form*)))
      (unless (try-eval (setq const-sum (reduce #'- consts
                                                :initial-value const-sum)))
        (return-from c-MINUS (c-GLOBAL-FUNCTION-CALL-form *form*)))
      (setq other-parts others))
    (if (null other-parts)      ; nothing to subtract
      (let ((*form* `(+ ,const-sum ,first-part))) (c-PLUS))
      (c-GLOBAL-FUNCTION-CALL-form
       `(- ,@(if (eql first-part 0)
               (if (and (eql const-sum 0) (null (cdr other-parts)))
                 '()
                 `(,const-sum))
               (if (eql const-sum 0)
                 `(,first-part)
                 `(,first-part ,(- const-sum))))
           ,@other-parts)))))

(defun c-SLASH ()
  (test-list *form* 2)
  (let ((unary-p (= (length *form*) 2))
        (const-prod 1)          ; the constant product in the tail
        (first-part 1) (other-parts '()))
    (unless unary-p
      (multiple-value-bind (val const-p) (c-constant-number (second *form*))
        (if const-p
          (setq const-prod val)
          (setq first-part val))))
    (multiple-value-bind (consts others)
        (c-collect-numeric-constants (if unary-p (cdr *form*) (cddr *form*)))
      (unless (try-eval (setq const-prod (reduce #'/ consts
                                                 :initial-value const-prod)))
        (return-from c-SLASH (c-GLOBAL-FUNCTION-CALL-form *form*)))
      (setq other-parts others))
    (cond ((null other-parts)      ; no divisors
           (let ((*form* `(* ,const-prod ,first-part))) (c-STAR)))
          ;; this is a bad optimization: one call to #'/ is cheaper than PROGN
          ;;((eql first-part 0)
          ;; (c-form `(progn ,@(mapcar (lambda (form) `(the number ,form))
          ;;                           other-parts)
          ;;                 0)))
          (t (c-GLOBAL-FUNCTION-CALL-form
              `(/ ,@(if (eql first-part 1)
                      (if (and (eql const-prod 1) (null (cdr other-parts)))
                        '()
                        `(,const-prod))
                      (if (eql const-prod 1)
                        `(,first-part)
                        `(,first-part ,(/ const-prod))))
                  ,@other-parts))))))

(defun c-COMPARE-NUMBERS ()
  (test-list *form* 2)
  (if (= (length *form*) 3)
    ;; Optimize (cmp arg1 arg2) by looking whether arg1 or arg2 is known to be
    ;; zero. (Which kind of zero, doesn't matter.)
    (multiple-value-bind (arg-1 const1-p) (c-constant-number (second *form*))
      (if (and const1-p (zerop arg-1))
        (c-GLOBAL-FUNCTION-CALL-form
          (ecase (first *form*)
            (= `(ZEROP ,(third *form*)))
            (/= `(NOT (ZEROP ,(third *form*))))
            (< `(PLUSP ,(third *form*)))
            (<= `(NOT (MINUSP ,(third *form*))))
            (> `(MINUSP ,(third *form*)))
            (>= `(NOT (PLUSP ,(third *form*))))))
        (multiple-value-bind (arg-2 const2-p)
            (c-constant-number (third *form*))
          (c-GLOBAL-FUNCTION-CALL-form
            (if (and const2-p (zerop arg-2))
              (ecase (first *form*)
                (= `(ZEROP ,arg-1))
                (/= `(NOT (ZEROP ,arg-1)))
                (< `(MINUSP ,arg-1))
                (<= `(NOT (PLUSP ,arg-1)))
                (> `(PLUSP ,arg-1))
                (>= `(NOT (MINUSP ,arg-1))))
             ;; Use arg-1 and arg-2 instead of (second *form*), (third *form*),
             ;; to avoid expanding these subforms a second time.
             `(,(first *form*) ,arg-1 ,arg-2))))))
    (c-GLOBAL-FUNCTION-CALL (first *form*))))

(defun c-SVSTORE ()
  (test-list *form* 4 4)
  ;; (sys::svstore arg1 arg2 arg3) -> (sys::%svstore arg3 arg1 arg2)
  (let ((arg1 (second *form*)) (arg2 (third *form*)) (arg3 (fourth *form*))
        (argvar1 (gensym)) (argvar2 (gensym)))
    (c-form
      `(LET* ((,argvar1 ,arg1) (,argvar2 ,arg2))
         (SYS::%SVSTORE ,arg3 ,argvar1 ,argvar2)))))

(defun c-EQ ()
  (test-list *form* 3 3)
  (let ((arg1 (macroexpand-form (second *form*)))
        (arg2 (macroexpand-form (third *form*))))
    (if (and (c-constantp arg1) (c-constantp arg2))
      (c-form `(QUOTE ,(eq (c-constant-value arg1) (c-constant-value arg2))))
      (progn
        (when (c-constantp arg1)
          ;; arg2 being constant is better, so that JMPIFEQTO is possible
          (rotatef arg1 arg2))
        (if (and (c-constantp arg2) (eq (c-constant-value arg2) 'NIL))
          (c-GLOBAL-FUNCTION-CALL-form `(NULL ,arg1))
          (c-GLOBAL-FUNCTION-CALL-form `(EQ ,arg1 ,arg2)))))))

;; EQL is the same as EQ for symbols, fixnums and characters
(defun EQL=EQ (x)
  (or (symbolp x)
      (and (integerp x) (<= (integer-length x) 24))
      ;; Note: Using (fixnump x) here would not generate portable code.
      ;; The minimum fixnum length across architectures in CLISP is 24 bits.
      (sys::short-float-p x)
      (characterp x)))

(defun c-EQL ()
  (test-list *form* 3 3)
  (let ((arg1 (macroexpand-form (second *form*)))
        (arg2 (macroexpand-form (third *form*))))
    (cond ((and (c-constantp arg1) (c-constantp arg2))
           (c-form `(QUOTE ,(eql (c-constant-value arg1)
                                 (c-constant-value arg2)))))
          ((or (and (c-constantp arg1) (EQL=EQ (c-constant-value arg1)))
               (and (c-constantp arg2) (EQL=EQ (c-constant-value arg2))))
           (let ((*form* `(EQ ,arg1 ,arg2))) (c-EQ)))
          (t (c-GLOBAL-FUNCTION-CALL-form `(EQL ,arg1 ,arg2))))))

;; EQUAL is the same as EQL for symbols, numbers and characters
(defun EQUAL=EQL (x) (or (symbolp x) (numberp x) (characterp x)))

(defun c-EQUAL ()
  (test-list *form* 3 3)
  (let ((arg1 (macroexpand-form (second *form*)))
        (arg2 (macroexpand-form (third *form*))))
    (cond ((or (and (c-constantp arg1) (EQUAL=EQL (c-constant-value arg1)))
               (and (c-constantp arg2) (EQUAL=EQL (c-constant-value arg2))))
           (let ((*form* `(EQL ,arg1 ,arg2))) (c-EQL)))
          (t (c-GLOBAL-FUNCTION-CALL-form `(EQUAL ,arg1 ,arg2))))))

;; Forms the inner part of a MAPCAR/MAPC/MAPCAN/MAPCAP-Expansion
(defun c-MAP-on-CARs-inner (innerst-fun blockname endp-value restvars
                            &optional (itemvars '()))
  (if (null restvars)
    (funcall innerst-fun (nreverse itemvars))
    (let ((restvar (car restvars))
          (itemvar (gensym)))
      `(IF (ENDP ,restvar)
         (RETURN-FROM ,blockname ,endp-value)
         (LET ((,itemvar (CAR ,restvar)))
           ,(c-MAP-on-CARs-inner innerst-fun blockname endp-value
                                 (cdr restvars) (cons itemvar itemvars)))))))

;; make shift forms for variables: (a b c) --> (a (cdr a) b (cdr b) c (cdr c))
(defun shift-vars (restvars)
  (mapcap #'(lambda (restvar) `(,restvar (CDR ,restvar))) restvars))

(proclaim '(inline copy-list-lax))
(defun copy-list-lax (obj) ; ABI
  "Like COPY-LIST, but return the argument when it is not a LIST."
  (if (consp obj) (copy-list obj) obj))

;; Forms a MAPCAR/MAPCAN/MAPCAP-Expansion
(defun c-MAP-on-CARs (adjoin-fun funform forms)
  (let ((erg (gensym)) (tail (gensym))
        (blockname (gensym))
        (restvars (gensym-list forms))
        (tag (gensym)) (tmp (gensym)))
    `(LET ((,erg NIL)
           ,@(case adjoin-fun ((CONS)) ((NCONC APPEND) `((,tail nil)))))
       (BLOCK ,blockname
         (LET* ,(mapcar #'list restvars forms)
           (TAGBODY
             ,tag
             ,(c-MAP-on-CARs-inner
               (case adjoin-fun
                 ((CONS)
                  #'(lambda (itemvars)
                      `(SETQ ,erg (,adjoin-fun (FUNCALL ,funform ,@itemvars)
                                               ,erg))))
                 ((NCONC)
                  #'(lambda (itemvars)
                      `(LET ((,tmp (FUNCALL ,funform ,@itemvars)))
                         (IF (CONSP ,erg)
                           (SETF ,tail (LAST ,tail) (CDR ,tail) ,tmp)
                           (SETQ ,erg ,tmp ,tail ,erg)))))
                 ((APPEND)
                  #'(lambda (itemvars)
                      `(LET ((,tmp (COPY-LIST-LAX (FUNCALL ,funform ,@itemvars))))
                         (IF (CONSP ,erg)
                           (SETF ,tail (LAST ,tail) (CDR ,tail) ,tmp)
                           (SETQ ,erg ,tmp ,tail ,erg))))))
               blockname
               'NIL
               restvars)
             (SETQ ,@(shift-vars restvars))
             (GO ,tag))))
       ,(case adjoin-fun
          ((CONS) `(SYS::LIST-NREVERSE ,erg))
          (t erg)))))

;; Forms a MAPLIST/MAPCON/MAPLAP-Expansion
(defun c-MAP-on-LISTs (adjoin-fun funform forms)
  (let ((erg (gensym)) (tail (gensym))
        (blockname (gensym))
        (restvars (gensym-list forms))
        (tag (gensym)) (tmp (gensym)))
    `(LET ((,erg NIL)
           ,@(case adjoin-fun ((CONS)) ((NCONC APPEND) `((,tail nil)))))
       (BLOCK ,blockname
         (LET* ,(mapcar #'list restvars forms)
           (TAGBODY
             ,tag
             (IF (OR ,@(mapcar #'(lambda (restvar) `(ENDP ,restvar)) restvars))
               (RETURN-FROM ,blockname))
             ,(case adjoin-fun
               ((CONS)
                `(SETQ ,erg (,adjoin-fun (FUNCALL ,funform ,@restvars) ,erg)))
               ((NCONC)
                `(LET ((,tmp (FUNCALL ,funform ,@restvars)))
                   (IF (CONSP ,erg)
                     (SETF ,tail (LAST ,tail) (CDR ,tail) ,tmp)
                     (SETQ ,erg ,tmp ,tail ,erg))))
               ((APPEND)
                `(LET ((,tmp (COPY-LIST-LAX (FUNCALL ,funform ,@restvars))))
                   (IF (CONSP ,erg)
                     (SETF ,tail (LAST ,tail) (CDR ,tail) ,tmp)
                     (SETQ ,erg ,tmp ,tail ,erg)))))
             (SETQ ,@(shift-vars restvars))
             (GO ,tag))))
       ,(case adjoin-fun
          ((CONS) `(SYS::LIST-NREVERSE ,erg))
          (t erg)))))

(defun c-MAPC ()
  (test-list *form* 3)
  (let ((funform (macroexpand-form (second *form*))))
    (if (inline-callable-function-p funform (length (cddr *form*)))
      (c-form
        (let* ((tempvar (gensym))
               (forms (cons tempvar (cdddr *form*)))
               (blockname (gensym))
               (restvars (gensym-list forms))
               (tag (gensym)))
          `(LET ((,tempvar ,(third *form*)))
             (BLOCK ,blockname
               (LET* ,(mapcar #'list restvars forms)
                 (TAGBODY
                   ,tag
                   ,(c-MAP-on-CARs-inner
                     #'(lambda (itemvars) `(FUNCALL ,funform ,@itemvars))
                     blockname
                     'NIL
                     restvars)
                   (SETQ ,@(shift-vars restvars))
                   (GO ,tag))))
             ,tempvar)))
      (c-GLOBAL-FUNCTION-CALL-form `(MAPC ,funform ,@(cddr *form*))))))

(defun c-MAPL ()
  (test-list *form* 3)
  (let ((funform (macroexpand-form (second *form*))))
    (if (inline-callable-function-p funform (length (cddr *form*)))
      (c-form
        (let* ((tempvar (gensym))
               (forms (cons tempvar (cdddr *form*)))
               (blockname (gensym))
               (restvars (gensym-list forms))
               (tag (gensym)))
          `(LET ((,tempvar ,(third *form*)))
             (BLOCK ,blockname
               (LET* ,(mapcar #'list restvars forms)
                 (TAGBODY
                   ,tag
                   (IF (OR ,@(mapcar #'(lambda (restvar) `(ENDP ,restvar))
                                     restvars))
                     (RETURN-FROM ,blockname))
                   (FUNCALL ,funform ,@restvars)
                   (SETQ ,@(shift-vars restvars))
                   (GO ,tag))))
             ,tempvar)))
      (c-GLOBAL-FUNCTION-CALL-form `(MAPL ,funform ,@(cddr *form*))))))

(defun c-MAPCAR ()
  (test-list *form* 3)
  (if (null *for-value*)
    (let ((*form* `(MAPC ,@(cdr *form*)))) (c-MAPC))
    (let ((funform (macroexpand-form (second *form*)))
          (forms (cddr *form*)))
      (if (inline-callable-function-p funform (length forms))
        (c-form (c-MAP-on-CARs 'CONS funform forms))
        (c-GLOBAL-FUNCTION-CALL-form `(MAPCAR ,funform ,@forms))))))

(defun c-MAPLIST ()
  (test-list *form* 3)
  (if (null *for-value*)
    (let ((*form* `(MAPL ,@(cdr *form*)))) (c-MAPL))
    (let ((funform (macroexpand-form (second *form*)))
          (forms (cddr *form*)))
      (if (inline-callable-function-p funform (length forms))
        (c-form (c-MAP-on-LISTs 'CONS funform forms))
        (c-GLOBAL-FUNCTION-CALL-form `(MAPLIST ,funform ,@forms))))))

(defun c-MAPCAN ()
  (test-list *form* 3)
  (let ((funform (macroexpand-form (second *form*)))
        (forms (cddr *form*)))
    (if (inline-callable-function-p funform (length forms))
      (c-form (c-MAP-on-CARs 'NCONC funform forms))
      (c-GLOBAL-FUNCTION-CALL-form `(MAPCAN ,funform ,@forms)))))

(defun c-MAPCON ()
  (test-list *form* 3)
  (let ((funform (macroexpand-form (second *form*)))
        (forms (cddr *form*)))
    (if (inline-callable-function-p funform (length forms))
      (c-form (c-MAP-on-LISTs 'NCONC funform forms))
      (c-GLOBAL-FUNCTION-CALL-form `(MAPCON ,funform ,@forms)))))

(defun c-MAPCAP ()
  (test-list *form* 3)
  (if (null *for-value*)
    (let ((*form* `(MAPC ,@(cdr *form*)))) (c-MAPC))
    (let ((funform (macroexpand-form (second *form*)))
          (forms (cddr *form*)))
      (if (inline-callable-function-p funform (length forms))
        (c-form (c-MAP-on-CARs 'APPEND funform forms))
        (c-GLOBAL-FUNCTION-CALL-form `(MAPCAP ,funform ,@forms))))))

(defun c-MAPLAP ()
  (test-list *form* 3)
  (if (null *for-value*)
    (let ((*form* `(MAPL ,@(cdr *form*)))) (c-MAPL))
    (let ((funform (macroexpand-form (second *form*)))
          (forms (cddr *form*)))
      (if (inline-callable-function-p funform (length forms))
        (c-form (c-MAP-on-LISTs 'APPEND funform forms))
        (c-GLOBAL-FUNCTION-CALL-form `(MAPLAP ,funform ,@forms))))))

;; c-TYPEP cf. TYPEP in type.lisp
(defun c-TYPEP () ; cf. TYPEP in type.lisp
  (test-list *form* 3 4)
  (let ((objform (second *form*))
        (typeform (macroexpand-form (third *form*))))
    (when (c-constantp typeform)
      (let ((type (c-constant-value typeform)) h)
        (cond ((symbolp type)
                (cond ; Test for Property TYPE-SYMBOL:
                      ((setq h (assoc type c-typep-alist1))
                        (setq h (cdr h))
                        (return-from c-TYPEP
                          (c-GLOBAL-FUNCTION-CALL-form `(,h ,objform))))
                      ((setq h (assoc type c-typep-alist2))
                        (setq h (cdr h))
                        (return-from c-TYPEP
                          (let ((*form* `(,h ,objform)))
                            (c-FUNCALL-INLINE
                              (symbol-suffix '#:TYPEP (symbol-name type))
                              (list objform)
                              nil
                              h
                              nil))))
                      ; Test for Property TYPE-LIST:
                      ((setq h (assoc type c-typep-alist3))
                        (setq h (cdr h))
                        (let* ((objvar (gensym))
                               (testform (funcall h objvar))
                               (lambdabody `((,objvar) ,testform)))
                          (return-from c-TYPEP
                            (let ((*form* `((lambda ,@lambdabody) ,objform)))
                              (c-FUNCALL-INLINE
                                (symbol-suffix '#:TYPEP (symbol-name type))
                                (list objform)
                                nil
                                lambdabody
                                nil)))))
                      ((setq h (get type 'SYS::DEFTYPE-EXPANDER))
                        (return-from c-TYPEP
                          (c-form `(TYPEP ,objform
                                    ',(funcall h (list type))))))
                      ((setq h (get type 'SYS::DEFSTRUCT-DESCRIPTION))
                        (return-from c-TYPEP
                          (c-form (sys::ds-typep-expansion objform type h))))
                      ((and (setq h (get type 'CLOS::CLOSCLASS))
                            (clos::defined-class-p h)
                            (eq (clos:class-name h) type))
                        (return-from c-TYPEP
                          (c-form
                            (if (clos::structure-class-p h)
                              ;; %STRUCTURE-TYPE-P is a little more efficient
                              ;; than CLOS::TYPEP-CLASS, so prefer it.
                              `(%STRUCTURE-TYPE-P ',type ,objform)
                              `(CLOS::TYPEP-CLASS ,objform
                                 (LOAD-TIME-VALUE (CLOS:FIND-CLASS ',type)))))))))
              ((and (consp type) (symbolp (first type)))
                (catch 'c-TYPEP
                  (cond ((and (eq (first type) 'SATISFIES)
                              (eql (length type) 2))
                         (let ((fun (second type)))
                           (unless (symbolp (second type))
                             (c-warn (TEXT "~S: argument to SATISFIES must be a symbol: ~S")
                                     'typep (second type))
                              (throw 'c-TYPEP nil))
                            (return-from c-TYPEP
                              (c-GLOBAL-FUNCTION-CALL-form `(,fun ,objform)))))
                        ((eq (first type) 'MEMBER)
                          (return-from c-TYPEP
                            (let ((*form* `(CASE ,objform
                                             (,(rest type) T) (t NIL))))
                              (c-CASE))))
                        ((and (eq (first type) 'EQL) (eql (length type) 2))
                          (return-from c-TYPEP
                            (let ((*form* `(EQL ,objform ',(second type))))
                              (c-EQL))))
                        ((and (eq (first type) 'NOT) (eql (length type) 2))
                          (return-from c-TYPEP
                            (c-GLOBAL-FUNCTION-CALL-form
                              `(NOT (TYPEP ,objform ',(second type))))))
                        ((or (eq (first type) 'AND) (eq (first type) 'OR))
                          (return-from c-TYPEP
                            (c-form
                              (let ((objvar (gensym)))
                                `(LET ((,objvar ,objform))
                                   (,(first type) ; AND or OR
                                    ,@(mapcar #'(lambda (typei)
                                                  `(TYPEP ,objvar ',typei))
                                              (rest type))))))))
                        ((setq h (assoc (first type) c-typep-alist3))
                          (setq h (cdr h))
                          (let* ((objvar (gensym))
                                 (testform (apply h objvar (rest type)))
                                 (lambdabody `((,objvar) ,testform)))
                            (return-from c-TYPEP
                              (let ((*form* `((lambda ,@lambdabody) ,objform)))
                                (c-FUNCALL-INLINE
                                  (symbol-suffix '#:TYPEP
                                                 (symbol-name (first type)))
                                  (list objform)
                                  nil
                                  lambdabody
                                  nil))))))))
              ((clos::defined-class-p type)
               (return-from c-TYPEP
                 (c-form `(CLOS::TYPEP-CLASS ,objform
                            ,(if (eq (get (clos:class-name type) 'CLOS::CLOSCLASS) type)
                               `(LOAD-TIME-VALUE (CLOS:FIND-CLASS ',(clos:class-name type)))
                               typeform)))))
              ((clos::eql-specializer-p type)
               (return-from c-TYPEP
                 (let ((*form* `(EQL ,objform ',(clos::eql-specializer-singleton type))))
                   (c-EQL))))
              ;; ((sys::encodingp type) ...) ; not worth optimizing
              )))
    (c-GLOBAL-FUNCTION-CALL-form
      `(TYPEP ,objform ,typeform ,@(cdddr *form*)))))

;; c-FORMAT cf. FORMAT in format.lisp
(defun c-FORMAT ()
  (test-list *form* 3)
  ;; Give a warning for the common error of forgotten destination.
  (let ((destination (second *form*)))
    (when (c-constantp destination)
      (setq destination (c-constant-value destination))
      (unless (or (null destination) (eq destination 'T)
                  (streamp destination)
                  (and (stringp destination)
                       (array-has-fill-pointer-p destination)))
        (c-warn (TEXT "The ~S destination is invalid (not NIL or T or a stream or a string with fill-pointer): ~S")
                (car *form*) destination)))
    (if (and (stringp (third *form*)) (not (fenv-search 'FORMATTER)))
      ;; precompile the format-string at compile-time.
      (cond ((eq destination t) ; avoid calling FORMAT altogether
             (c-GLOBAL-FUNCTION-CALL-form
              `(funcall (FORMATTER ,(third *form*)) *standard-output*
                        ,@(cdddr *form*))))
            ((eq destination nil) ; avoid calling FORMAT altogether
             (c-form ; we do not need full WITH-OUTPUT-TO-STRING here
              `(let ((<format-stream> (make-string-output-stream)))
                 (funcall (FORMATTER ,(third *form*)) <format-stream>
                          ,@(cdddr *form*))
                 (get-output-stream-string <format-stream>))))
            ((c-GLOBAL-FUNCTION-CALL-form
              `(FORMAT ,(second *form*) (FORMATTER ,(third *form*))
                       ,@(cdddr *form*)))))
      (c-GLOBAL-FUNCTION-CALL 'FORMAT))))

(defun c-SORT ()
  (test-list *form* 3)
  ;; Give a warning for the common error of transposed predicate and sequence
  (let ((sequence-form (second *form*)))
    (when (or (function-form-p sequence-form) (lambda-form-p sequence-form))
      (c-warn (TEXT "First argument to ~S should be sequence, not ~S")
              (car *form*) sequence-form))
    (when (and (consp sequence-form) (quote-p sequence-form))
      (c-warn (TEXT "~S is destructive, should not be called on a constant ~S")
              (car *form*) sequence-form))
    (c-GLOBAL-FUNCTION-CALL 'SORT)))

;; c-NTH for NTH; c-SETNTH for (SETF NTH)==SYSTEM::%SETNTH
;; mostly for (defstruct (foo (:type list))) accessors
(macrolet ((simple-index-p (ival func)
             `(and ,ival (or (integerp ,ival)
                             (c-warn
                              (TEXT "~S: index should be an integer, not ~S")
                              ,func ,ival))
                   (<= 0 ,ival 9))))
(defun c-NTH ()
  (test-list *form* 3 3)
  (let* ((index (macroexpand-form (second *form*)))
         (list (macroexpand-form (third *form*)))
         (i-val (and (c-constantp index) (c-constant-value index))))
    (if (simple-index-p i-val 'NTH)
      (c-GLOBAL-FUNCTION-CALL-form
        `(,(svref #(FIRST SECOND THIRD FOURTH FIFTH SIXTH SEVENTH EIGHTH
                    NINTH TENTH) i-val)
          ,list))
      (c-GLOBAL-FUNCTION-CALL-form `(NTH ,index ,list)))))
(defun c-SETNTH ()
  (test-list *form* 4 4)
  (let* ((index (macroexpand-form (second *form*)))
         (list (macroexpand-form (third *form*)))
         (value (macroexpand-form (fourth *form*)))
         (i-val (and (c-constantp index) (c-constant-value index))))
    (if (simple-index-p i-val '(SETF NTH))
      (c-form
        `(SETF (,(svref #(FIRST SECOND THIRD FOURTH FIFTH SIXTH SEVENTH
                          EIGHTH NINTH TENTH) i-val) ,list) ,value))
      (c-GLOBAL-FUNCTION-CALL-form `(SYSTEM::%SETNTH ,index ,list ,value)))))
)

;; Tests whether a form is declared to return a list.
(defun declared-list-form-p (form)
  ; For the moment, we don't propagate types, therefore the user has to
  ; write THE explicitly.
  (and (consp form) (eq (first form) 'THE)
       (consp (rest form)) (memq (second form) '(LIST CONS))
       (consp (cddr form)) (null (cdddr form))))

(defun c-MAP ()
  (test-list *form* 4)
  (let ((restype-form (second *form*))
        (fun-form (macroexpand-form (third *form*)))
        (forms (cdddr *form*)))
    (if (and (c-constantp restype-form)
             (memq (c-constant-value restype-form) '(NIL LIST)) ; restype is NIL or LIST
             (every #'declared-list-form-p forms) ; all sequences are lists
             (inline-callable-function-p fun-form (length forms)))
      (ecase (c-constant-value restype-form)
        ((NIL) ; like MAPC
         (c-form
           (let ((blockname (gensym))
                 (restvars (gensym-list forms))
                 (tag (gensym)))
             `(BLOCK ,blockname
                (LET* ,(mapcar #'list restvars forms)
                  (TAGBODY
                    ,tag
                    ,(c-MAP-on-CARs-inner
                      #'(lambda (itemvars) `(FUNCALL ,fun-form ,@itemvars))
                      blockname
                      'NIL
                      restvars)
                    (SETQ ,@(shift-vars restvars))
                    (GO ,tag)))))))
         ((LIST) ; like MAPCAR
          (c-form (c-MAP-on-CARs 'CONS fun-form forms))))
      (c-GLOBAL-FUNCTION-CALL-form `(MAP ,restype-form ,fun-form ,@forms)))))

(defun c-MAP-INTO ()
  (test-list *form* 3)
  (let ((res-form (second *form*))
        (fun-form (macroexpand-form (third *form*)))
        (forms (cdddr *form*)))
    (if (and (declared-list-form-p res-form)
             (every #'declared-list-form-p forms) ; all sequences are lists
             (inline-callable-function-p fun-form (length forms)))
      (c-form
        (let ((blockname (gensym))
              (resultvar (gensym))
              (resrestvar (gensym))
              (restvars (gensym-list forms))
              (tag (gensym)))
          `(LET* ((,resultvar ,res-form)
                  (,resrestvar ,resultvar))
             (BLOCK ,blockname
               (LET* ,(mapcar #'list restvars forms)
                 (TAGBODY
                   ,tag
                   (IF (ENDP ,resrestvar)
                     (RETURN-FROM ,blockname NIL)
                     ,(c-MAP-on-CARs-inner
                       #'(lambda (itemvars)
                           `(SETF (CAR ,resrestvar) (FUNCALL ,fun-form ,@itemvars)))
                       blockname
                       'NIL
                       restvars))
                    (SETQ ,@(shift-vars (cons resrestvar restvars)))
                    (GO ,tag))))
             ,resultvar)))
      (c-GLOBAL-FUNCTION-CALL-form `(MAP-INTO ,res-form ,fun-form ,@forms)))))

(defun c-SOME ()
  (test-list *form* 3)
  (let ((pred-form (macroexpand-form (second *form*)))
        (forms (cddr *form*)))
    (if (inlinable-function-operation-form-p pred-form 'COMPLEMENT)
      ;; (SOME (COMPLEMENT fn) ...) --> (NOTEVERY fn ...)
      (c-form `(NOTEVERY ,(second pred-form) ,@forms))
      (if (and (every #'declared-list-form-p forms) ; all sequences are lists
               (inline-callable-function-p pred-form (length forms)))
        (c-form
          (let ((restvars (gensym-list forms))
                (blockname (gensym))
                (tag (gensym))
                (tmp (gensym)))
            `(LET* ,(mapcar #'list restvars forms)
               (BLOCK ,blockname
                 (TAGBODY
                   ,tag
                   ,(c-MAP-on-CARs-inner
                     #'(lambda (itemvars)
                         `(LET ((,tmp (FUNCALL ,pred-form ,@itemvars)))
                            (IF ,tmp (RETURN-FROM ,blockname ,tmp))))
                     blockname
                     'NIL
                     restvars)
                   (SETQ ,@(shift-vars restvars))
                   (GO ,tag))))))
        (c-GLOBAL-FUNCTION-CALL-form (list* 'SOME pred-form forms))))))

(defun c-EVERY ()
  (test-list *form* 3)
  (let ((pred-form (macroexpand-form (second *form*)))
        (forms (cddr *form*)))
    (if (inlinable-function-operation-form-p pred-form 'COMPLEMENT)
      ;; (EVERY (COMPLEMENT fn) ...) --> (NOTANY fn ...)
      (c-form `(NOTANY ,(second pred-form) ,@forms))
      (if (and (every #'declared-list-form-p forms) ; all sequences are lists
               (inline-callable-function-p pred-form (length forms)))
        (c-form
          (let ((restvars (gensym-list forms))
                (blockname (gensym))
                (tag (gensym)))
            `(LET* ,(mapcar #'list restvars forms)
               (BLOCK ,blockname
                 (TAGBODY
                   ,tag
                   ,(c-MAP-on-CARs-inner
                     #'(lambda (itemvars)
                         `(IF (NOT (FUNCALL ,pred-form ,@itemvars))
                            (RETURN-FROM ,blockname NIL)))
                     blockname
                     'T
                     restvars)
                   (SETQ ,@(shift-vars restvars))
                   (GO ,tag))))))
        (c-GLOBAL-FUNCTION-CALL-form (list* 'EVERY pred-form forms))))))

(defun c-NOTANY ()
  (test-list *form* 3)
  (let ((pred-form (macroexpand-form (second *form*)))
        (forms (cddr *form*)))
    (if (inlinable-function-operation-form-p pred-form 'COMPLEMENT)
      ;; (NOTANY (COMPLEMENT fn) ...) --> (EVERY fn ...)
      (c-form `(EVERY ,(second pred-form) ,@forms))
      (if (and (every #'declared-list-form-p forms) ; all sequences are lists
               (inline-callable-function-p pred-form (length forms)))
        (c-form
          (let ((restvars (gensym-list forms))
                (blockname (gensym))
                (tag (gensym)))
            `(LET* ,(mapcar #'list restvars forms)
               (BLOCK ,blockname
                 (TAGBODY
                   ,tag
                   ,(c-MAP-on-CARs-inner
                     #'(lambda (itemvars)
                         `(IF (FUNCALL ,pred-form ,@itemvars)
                            (RETURN-FROM ,blockname NIL)))
                     blockname
                     'T
                     restvars)
                   (SETQ ,@(shift-vars restvars))
                   (GO ,tag))))))
        (c-GLOBAL-FUNCTION-CALL-form (list* 'NOTANY pred-form forms))))))

(defun c-NOTEVERY ()
  (test-list *form* 3)
  (let ((pred-form (macroexpand-form (second *form*)))
        (forms (cddr *form*)))
    (if (inlinable-function-operation-form-p pred-form 'COMPLEMENT)
      ;; (NOTEVERY (COMPLEMENT fn) ...) --> (AND (SOME fn ...) T)
      (c-form `(AND (SOME ,(second pred-form) ,@forms) 'T))
      (if (and (every #'declared-list-form-p forms) ; all sequences are lists
               (inline-callable-function-p pred-form (length forms)))
        (c-form
          (let ((restvars (gensym-list forms))
                (blockname (gensym))
                (tag (gensym)))
            `(LET* ,(mapcar #'list restvars forms)
               (BLOCK ,blockname
                 (TAGBODY
                   ,tag
                   ,(c-MAP-on-CARs-inner
                     #'(lambda (itemvars)
                         `(IF (NOT (FUNCALL ,pred-form ,@itemvars))
                            (RETURN-FROM ,blockname T)))
                     blockname
                     'NIL
                     restvars)
                   (SETQ ,@(shift-vars restvars))
                   (GO ,tag))))))
        (c-GLOBAL-FUNCTION-CALL-form (list* 'NOTEVERY pred-form forms))))))

(defun c-REMOVE-IF (&optional inverted)
  (test-list *form* 3)
  (let ((pred-form (macroexpand-form (second *form*))))
    (if (inlinable-function-operation-form-p pred-form 'COMPLEMENT)
      ;; (REMOVE-IF (COMPLEMENT fn) ...) --> (REMOVE-IF-NOT fn ...)
      ;; (REMOVE-IF-NOT (COMPLEMENT fn) ...) --> (REMOVE-IF fn ...)
      (c-form (list* (if inverted 'REMOVE-IF 'REMOVE-IF-NOT) (second pred-form)
                     (cddr *form*)))
      (if (and (null (cdddr *form*)) ; no keyword arguments
               (declared-list-form-p (third *form*)) ; sequence a list
               (inline-callable-function-p pred-form 1))
        (c-form
          (let ((result1var (gensym))
                (result2var (gensym))
                (listvar (gensym))
                (starttag (gensym))
                (endtag (gensym)))
            `(LET* ((,result1var NIL)
                    (,result2var ,(third *form*))
                    (,listvar ,result2var))
               (DECLARE (LIST ,listvar))
               (TAGBODY
                 ,starttag
                 (IF (ENDP ,listvar) (GO ,endtag))
                 (IF ,(let ((test `(FUNCALL ,pred-form (CAR ,listvar))))
                        (when inverted (setq test `(NOT ,test)))
                        test)
                   (PROGN
                     (SETQ ,result1var (NRECONC (LDIFF ,result2var ,listvar) ,result1var))
                     (SETQ ,result2var (SETQ ,listvar (CDR ,listvar))))
                   (SETQ ,listvar (CDR ,listvar)))
                 (GO ,starttag)
                 ,endtag)
               (NRECONC ,result1var ,result2var))))
        (c-GLOBAL-FUNCTION-CALL-form
          (list* (if inverted 'REMOVE-IF-NOT 'REMOVE-IF) pred-form
                 (cddr *form*)))))))
(defun c-REMOVE-IF-NOT ()
  (c-REMOVE-IF t))

(defun c-DELETE-IF (&optional inverted)
  (test-list *form* 3)
  (let ((pred-form (macroexpand-form (second *form*))))
    (if (inlinable-function-operation-form-p pred-form 'COMPLEMENT)
      ;; (DELETE-IF (COMPLEMENT fn) ...) --> (DELETE-IF-NOT fn ...)
      ;; (DELETE-IF-NOT (COMPLEMENT fn) ...) --> (DELETE-IF fn ...)
      (c-form (list* (if inverted 'DELETE-IF 'DELETE-IF-NOT) (second pred-form)
                     (cddr *form*)))
      (if (and (null (cdddr *form*)) ; no keyword arguments
               (declared-list-form-p (third *form*)) ; sequence a list
               (inline-callable-function-p pred-form 1))
        (c-form
          (let ((resultvar (gensym))
                (lastvar (gensym))
                (listvar (gensym))
                (starttag (gensym))
                (endtag (gensym)))
            `(LET* ((,resultvar ,(third *form*))
                    (,lastvar NIL)
                    (,listvar ,resultvar))
               (DECLARE (LIST ,listvar))
               (TAGBODY
                 ,starttag
                 (IF (ENDP ,listvar) (GO ,endtag))
                 (IF ,(let ((test `(FUNCALL ,pred-form (CAR ,listvar))))
                        (when inverted (setq test `(NOT ,test)))
                        test)
                   (IF ,lastvar
                     (SETF (CDR ,lastvar) (SETQ ,listvar (CDR ,listvar)))
                     (SETQ ,resultvar (SETQ ,listvar (CDR ,listvar))))
                   (PROGN
                     (SETQ ,lastvar ,listvar)
                     (SETQ ,listvar (CDR ,listvar))))
                 (GO ,starttag)
                 ,endtag)
               ,resultvar)))
        (c-GLOBAL-FUNCTION-CALL-form
          (list* (if inverted 'DELETE-IF-NOT 'DELETE-IF) pred-form
                 (cddr *form*)))))))
(defun c-DELETE-IF-NOT ()
  (c-DELETE-IF t))

(defun c-SUBSTITUTE-IF (&optional inverted)
  (test-list *form* 4)
  (let ((pred-form (macroexpand-form (third *form*))))
    (if (inlinable-function-operation-form-p pred-form 'COMPLEMENT)
      ;; (SUBSTITUTE-IF y (COMPLEMENT fn) ...) --> (SUBSTITUTE-IF-NOT y fn ...)
      ;; (SUBSTITUTE-IF-NOT y (COMPLEMENT fn) ...) --> (SUBSTITUTE-IF y fn ...)
      (c-form (list* (if inverted 'SUBSTITUTE-IF 'SUBSTITUTE-IF-NOT)
                     (second *form*) (second pred-form) (cdddr *form*)))
      (if (and (null (cddddr *form*)) ; no keyword arguments
               (declared-list-form-p (fourth *form*)) ; sequence a list
               (inline-callable-function-p pred-form 1))
        (c-form
          (let ((newitemvar (gensym))
                (result1var (gensym))
                (result2var (gensym))
                (listvar (gensym))
                (starttag (gensym))
                (endtag (gensym)))
            `(LET* ((,newitemvar ,(second *form*))
                    (,result1var NIL)
                    (,result2var ,(fourth *form*))
                    (,listvar ,result2var))
               (DECLARE (LIST ,listvar))
               (TAGBODY
                 ,starttag
                 (IF (ENDP ,listvar) (GO ,endtag))
                 (IF ,(let ((test `(FUNCALL ,pred-form (CAR ,listvar))))
                        (when inverted (setq test `(NOT ,test)))
                        test)
                   (PROGN
                     (SETQ ,result1var (CONS ,newitemvar (NRECONC (LDIFF ,result2var ,listvar) ,result1var)))
                     (SETQ ,result2var (SETQ ,listvar (CDR ,listvar))))
                   (SETQ ,listvar (CDR ,listvar)))
                 (GO ,starttag)
                 ,endtag)
               (NRECONC ,result1var ,result2var))))
        (c-GLOBAL-FUNCTION-CALL-form
          (list* (if inverted 'SUBSTITUTE-IF-NOT 'SUBSTITUTE-IF)
                 (second *form*) pred-form (cdddr *form*)))))))
(defun c-SUBSTITUTE-IF-NOT ()
  (c-SUBSTITUTE-IF t))

(defun c-NSUBSTITUTE-IF (&optional inverted)
  (test-list *form* 4)
  (let ((pred-form (macroexpand-form (third *form*))))
    (if (inlinable-function-operation-form-p pred-form 'COMPLEMENT)
      ;; (NSUBSTITUTE-IF y (COMPLEMENT fn) ...) --> (NSUBSTITUTE-IF-NOT y fn ...)
      ;; (NSUBSTITUTE-IF-NOT y (COMPLEMENT fn) ...) --> (NSUBSTITUTE-IF y fn ...)
      (c-form (list* (if inverted 'NSUBSTITUTE-IF 'NSUBSTITUTE-IF-NOT)
                     (second *form*) (second pred-form) (cdddr *form*)))
      (if (and (null (cddddr *form*)) ; no keyword arguments
               (declared-list-form-p (fourth *form*)) ; sequence a list
               (inline-callable-function-p pred-form 1))
        (c-form
          (let ((newitemvar (gensym))
                (wholevar (gensym))
                (listvar (gensym))
                (starttag (gensym))
                (endtag (gensym)))
            `(LET* ((,newitemvar ,(second *form*))
                    (,wholevar ,(fourth *form*))
                    (,listvar ,wholevar))
               (DECLARE (LIST ,listvar))
               (TAGBODY
                 ,starttag
                 (IF (ENDP ,listvar) (GO ,endtag))
                 (IF ,(let ((test `(FUNCALL ,pred-form (CAR ,listvar))))
                        (when inverted (setq test `(NOT ,test)))
                        test)
                   (SETF (CAR ,listvar) ,newitemvar))
                 (SETQ ,listvar (CDR ,listvar))
                 (GO ,starttag)
                 ,endtag)
               ,wholevar)))
        (c-GLOBAL-FUNCTION-CALL-form
          (list* (if inverted 'NSUBSTITUTE-IF-NOT 'NSUBSTITUTE-IF)
                 (second *form*) pred-form (cdddr *form*)))))))
(defun c-NSUBSTITUTE-IF-NOT ()
  (c-NSUBSTITUTE-IF t))

(defun c-FIND-IF (&optional inverted)
  (test-list *form* 3)
  (let ((pred-form (macroexpand-form (second *form*))))
    (if (inlinable-function-operation-form-p pred-form 'COMPLEMENT)
      ;; (FIND-IF (COMPLEMENT fn) ...) --> (FIND-IF-NOT fn ...)
      ;; (FIND-IF-NOT (COMPLEMENT fn) ...) --> (FIND-IF fn ...)
      (c-form (list* (if inverted 'FIND-IF 'FIND-IF-NOT) (second pred-form)
                     (cddr *form*)))
      (if (and (null (cdddr *form*)) ; no keyword arguments
               (declared-list-form-p (third *form*)) ; sequence a list
               (inline-callable-function-p pred-form 1))
        (c-form
          (let ((listvar (gensym))
                (blockname (gensym))
                (starttag (gensym))
                (elementvar (gensym)))
            `(LET ((,listvar ,(third *form*)))
               (DECLARE (LIST ,listvar))
               (BLOCK ,blockname
                 (TAGBODY
                   ,starttag
                   (IF (ENDP ,listvar) (RETURN-FROM ,blockname NIL))
                   (LET ((,elementvar (CAR ,listvar)))
                     (IF ,(let ((test `(FUNCALL ,pred-form ,elementvar)))
                            (when inverted (setq test `(NOT ,test)))
                            test)
                       (RETURN-FROM ,blockname ,elementvar)))
                   (SETQ ,listvar (CDR ,listvar))
                   (GO ,starttag))))))
        (c-GLOBAL-FUNCTION-CALL-form
          (list* (if inverted 'FIND-IF-NOT 'FIND-IF) pred-form
                 (cddr *form*)))))))
(defun c-FIND-IF-NOT ()
  (c-FIND-IF t))

(defun c-POSITION-IF (&optional inverted)
  (test-list *form* 3)
  (let ((pred-form (macroexpand-form (second *form*))))
    (if (inlinable-function-operation-form-p pred-form 'COMPLEMENT)
      ;; (POSITION-IF (COMPLEMENT fn) ...) --> (POSITION-IF-NOT fn ...)
      ;; (POSITION-IF-NOT (COMPLEMENT fn) ...) --> (POSITION-IF fn ...)
      (c-form (list* (if inverted 'POSITION-IF 'POSITION-IF-NOT)
                     (second pred-form) (cddr *form*)))
      (if (and (null (cdddr *form*)) ; no keyword arguments
               (declared-list-form-p (third *form*)) ; sequence a list
               (inline-callable-function-p pred-form 1))
        (c-form
          (let ((indexvar (gensym))
                (listvar (gensym))
                (blockname (gensym))
                (starttag (gensym)))
            `(LET* ((,indexvar 0) (,listvar ,(third *form*)))
               (DECLARE (INTEGER ,indexvar) (LIST ,listvar))
               (BLOCK ,blockname
                 (TAGBODY
                   ,starttag
                   (IF (ENDP ,listvar) (RETURN-FROM ,blockname NIL))
                   (IF ,(let ((test `(FUNCALL ,pred-form (CAR ,listvar))))
                          (when inverted (setq test `(NOT ,test)))
                          test)
                     (RETURN-FROM ,blockname ,indexvar))
                   (SETQ ,indexvar (+ ,indexvar 1))
                   (SETQ ,listvar (CDR ,listvar))
                   (GO ,starttag))))))
        (c-GLOBAL-FUNCTION-CALL-form
          (list* (if inverted 'POSITION-IF-NOT 'POSITION-IF) pred-form
                 (cddr *form*)))))))
(defun c-POSITION-IF-NOT ()
  (c-POSITION-IF t))

(defun c-COUNT-IF (&optional inverted)
  (test-list *form* 3)
  (let ((pred-form (macroexpand-form (second *form*))))
    (if (inlinable-function-operation-form-p pred-form 'COMPLEMENT)
      ;; (COUNT-IF (COMPLEMENT fn) ...) --> (COUNT-IF-NOT fn ...)
      ;; (COUNT-IF-NOT (COMPLEMENT fn) ...) --> (COUNT-IF fn ...)
      (c-form (list* (if inverted 'COUNT-IF 'COUNT-IF-NOT) (second pred-form)
                     (cddr *form*)))
      (if (and (null (cdddr *form*)) ; no keyword arguments
               (declared-list-form-p (third *form*)) ; sequence a list
               (inline-callable-function-p pred-form 1))
        (c-form
          (let ((countervar (gensym))
                (listvar (gensym))
                (starttag (gensym))
                (endtag (gensym)))
            `(LET* ((,countervar 0) (,listvar ,(third *form*)))
               (DECLARE (INTEGER ,countervar) (LIST ,listvar))
               (TAGBODY
                 ,starttag
                 (IF (ENDP ,listvar) (GO ,endtag))
                 (IF ,(let ((test `(FUNCALL ,pred-form (CAR ,listvar))))
                        (when inverted (setq test `(NOT ,test)))
                        test)
                   (SETQ ,countervar (+ ,countervar 1)))
                 (SETQ ,listvar (CDR ,listvar))
                 (GO ,starttag)
                 ,endtag)
               ,countervar)))
        (c-GLOBAL-FUNCTION-CALL-form
          (list* (if inverted 'COUNT-IF-NOT 'COUNT-IF) pred-form
                 (cddr *form*)))))))
(defun c-COUNT-IF-NOT ()
  (c-COUNT-IF t))

;; c-SUBST-IF, c-SUBST-IF-NOT etc.
(macrolet ((c-seqop (op n)
             (let ((op-if (intern (string-concat (string op) "-IF")
                                  *lisp-package*))
                   (op-if-not (intern (string-concat (string op) "-IF-NOT")
                                      *lisp-package*))
                   (c-op-if (intern (string-concat "C-" (string op) "-IF")))
                   (c-op-if-not (intern (string-concat "C-" (string op)
                                                       "-IF-NOT"))))
               `(progn
                  (defun ,c-op-if ()
                    (test-list *form* ,(+ 1 n))
                    (let ((pred-form (macroexpand-form
                                       ,(case n (2 `(second *form*))
                                                (3 `(third *form*))))))
                      (if (inlinable-function-operation-form-p pred-form
                                                               'COMPLEMENT)
                        ;; (op-if (complement fn) ...) --> (op-if-not fn ...)
                        (c-form ,(case n (2 `(list* ',op-if-not
                                              (second pred-form) (cddr *form*)))
                                         (3 `(list* ',op-if-not (second *form*)
                                              (second pred-form)
                                              (cdddr *form*)))))
                        (c-GLOBAL-FUNCTION-CALL-form
                          ,(case n (2 `(list* ',op-if pred-form (cddr *form*)))
                                   (3 `(list* ',op-if (second *form*) pred-form (cdddr *form*))))))))
                  (defun ,c-op-if-not ()
                    (test-list *form* ,(+ 1 n))
                    (let ((pred-form (macroexpand-form
                                       ,(case n (2 `(second *form*))
                                                (3 `(third *form*))))))
                      (if (inlinable-function-operation-form-p pred-form
                                                               'COMPLEMENT)
                        ;; (op-if-not (complement fn) ...) --> (op-if fn ...)
                        (c-form ,(case n (2 `(list* ',op-if (second pred-form)
                                              (cddr *form*)))
                                         (3 `(list* ',op-if (second *form*)
                                              (second pred-form)
                                              (cdddr *form*)))))
                        (c-GLOBAL-FUNCTION-CALL-form
                          ,(case n (2 `(list* ',op-if-not pred-form (cddr *form*)))
                                   (3 `(list* ',op-if-not (second *form*) pred-form (cdddr *form*))))))))))))

  (c-seqop SUBST 3)
  (c-seqop NSUBST 3)
  (c-seqop MEMBER 2)
  (c-seqop ASSOC 2)
  (c-seqop RASSOC 2)
)

;; :TEST (COMPLEMENT foo) ==> :TEST-NOT foo
;; :TEST-NOT (COMPLEMENT foo) ==> :TEST foo
(defun c-TEST/TEST-NOT ()
  (let ((fun (first *form*)))
    (multiple-value-bind (name req-num opt-num rest-p key-p keywords allow-p)
        (function-signature fun)
      (declare (ignore name rest-p key-p allow-p))
      ;; This optimization assumes opt-num = 0.
      (assert (and (= opt-num 0) (memq ':TEST keywords) (memq ':TEST-NOT keywords)))
      ;; Replace the first occurrence of a (:TEST testform) or
      ;; (:TEST-NOT testform), respectively.
      ;; Do nothing if the call will produce errors at runtime, such as if
      ;; :TEST and :TEST-NOT are both specified.
      ;; Do nothing if the optimization would modify the semantics, such as if
      ;; :TEST or :TEST-NOT is specified more than once.
      (let ((*form* *form*))
        (when (and (>= (length *form*) (+ 1 req-num))
                   (evenp (- (length *form*) (+ 1 req-num))))
          (let ((pos-TEST nil)
                (pos-TEST-NOT nil))
            (do* ((pos (+ 1 req-num) (+ pos 2))
                  (rest (nthcdr pos *form*) (cddr rest)))
                 ((endp rest))
              (let ((key-form (first rest)))
                (when (c-constantp key-form)
                  (let ((key (c-constant-value key-form)))
                    (case key
                      (:TEST (setq pos-TEST (if pos-TEST -1 pos)))
                      (:TEST-NOT (setq pos-TEST-NOT (if pos-TEST-NOT -1 pos))))))))
            (when (and (or pos-TEST pos-TEST-NOT)
                       (not (and pos-TEST pos-TEST-NOT)) ; both specified?
                       (not (eql pos-TEST -1)) ; duplicate :TEST?
                       (not (eql pos-TEST-NOT -1))) ; duplicate :TEST-NOT?
              (let* ((pos (or pos-TEST pos-TEST-NOT))
                     (testform (nth (+ pos 1) *form*)))
                (when (inlinable-function-operation-form-p testform 'COMPLEMENT)
                  (setq *form* (append (subseq *form* 0 pos)
                                       (list* (if pos-TEST ':TEST-NOT ':TEST)
                                              (second testform)
                                              (nthcdr (+ pos 2) *form*)))))))))
        (c-GLOBAL-FUNCTION-CALL fun)))))

;; (concatenate 'string ...) ==> (string-concat ...)
;; this happens mostly in macros, so it is not clear how valuable this is:
;; mcclim/Apps/Listener/file-types.lisp:define-mime-type
;;   (concatenate 'string (symbol-name media-type) "/" (symbol-name subtype))
(defconstant functions-returning-string
  '(string symbol-name char-name namestring enough-namestring
    princ-to-string prin1-to-string write-to-string with-output-to-string
    get-output-stream-string))
(defun c-CONCATENATE ()
  (if (and (equal (second *form*) '(QUOTE STRING))
           (every (lambda (f)
                    (or (and (c-constantp f)
                             (stringp (c-constant-value f)))
                        (and (consp f)
                             (memq (car f) functions-returning-string))))
                  (cddr *form*)))
      (c-GLOBAL-FUNCTION-CALL-form (cons 'EXT:STRING-CONCAT (cddr *form*)))
      (c-GLOBAL-FUNCTION-CALL-form *form*)))

;; Recognizes a constant byte specifier and returns it, or NIL.
(defun c-constant-byte-p (form)
  (cond ((c-constantp form)
         (setq form (c-constant-value form))
         (if (eq (type-of form) 'BYTE) form nil))
        ((and (consp form)
              (eq (first form) 'BYTE)
              (consp (cdr form))
              (typep (second form) '(AND (INTEGER 0 *) FIXNUM))
              (consp (cddr form))
              (typep (third form) '(AND (INTEGER 0 *) FIXNUM))
              (null (cdddr form))
              (not (fenv-search 'BYTE))
              (not (declared-notinline 'BYTE)))
         ;; no need to ignore errors, we have checked the arguments
         (byte (second form) (third form)))
        (t nil)))

(defun c-LDB ()
  (test-list *form* 3 3)
  (let* ((arg1-form (macroexpand-form (second *form*)))
         (arg1 (c-constant-byte-p arg1-form)))
    (if arg1
      ;; We optimize (ldb (byte size position) integer) only when position = 0,
      ;; because when position > 0, the expression
      ;; `(logand ,(1- (ash 1 size)) (ash integer ,(- position)))
      ;; is not better and causes more heap allocations than the original
      ;; expression. The expression
      ;; `(ash (logand ,(ash (1- (ash 1 size)) position) integer)
      ;;       ,(- position))
      ;; is even worse.
      ;; The "24" below is an arbitrary limit, to avoid huge integers in
      ;; the code [e.g. for (ldb (byte 30000 0) x)]. In particular, we
      ;; know that for size <= 24, (1- (ash 1 size)) is a posfixnum,
      ;; which makes the LOGAND operation particularly efficient.
      (if (and (= (byte-position arg1) 0) (<= (byte-size arg1) 24))
        (c-GLOBAL-FUNCTION-CALL-form
          `(LOGAND ,(1- (ash 1 (byte-size arg1))) ,(third *form*)))
        (c-GLOBAL-FUNCTION-CALL-form
          `(LDB (QUOTE ,arg1) ,(third *form*))))
      (c-GLOBAL-FUNCTION-CALL-form `(LDB ,arg1-form ,@(cddr *form*))))))

(defun c-LDB-TEST ()
  (test-list *form* 3 3)
  (let* ((arg1-form (macroexpand-form (second *form*)))
         (arg1 (c-constant-byte-p arg1-form)))
    (if arg1
      ;; The "24" below is an arbitrary limit, to avoid huge integers in
      ;; the code [e.g. for (ldb-test (byte 30000 0) x)].
      (if (<= (+ (byte-size arg1) (byte-position arg1)) 24)
        (c-GLOBAL-FUNCTION-CALL-form
         `(LOGTEST ,(ash (1- (ash 1 (byte-size arg1))) (byte-position arg1))
           ,(third *form*)))
        (c-GLOBAL-FUNCTION-CALL-form
          `(LDB-TEST (QUOTE ,arg1) ,(third *form*))))
      (c-GLOBAL-FUNCTION-CALL-form `(LDB-TEST ,arg1-form ,@(cddr *form*))))))

(defun c-MASK-FIELD ()
  (test-list *form* 3 3)
  (let* ((arg1-form (macroexpand-form (second *form*)))
         (arg1 (c-constant-byte-p arg1-form)))
    (if arg1
      ;; We know that for size+position <= 24, (ash (1- (ash 1 size)) position)
      ;; is a posfixnum, which makes the LOGAND operation more efficient than
      ;; the MASK-FIELD operation.
      (if (<= (+ (byte-size arg1) (byte-position arg1)) 24)
        (c-GLOBAL-FUNCTION-CALL-form
          `(LOGAND ,(ash (1- (ash 1 (byte-size arg1))) (byte-position arg1))
            ,(third *form*)))
        (c-GLOBAL-FUNCTION-CALL-form
          `(MASK-FIELD (QUOTE ,arg1) ,(third *form*))))
      (c-GLOBAL-FUNCTION-CALL-form `(MASK-FIELD ,arg1-form ,@(cddr *form*))))))

(defun c-DPB ()
  (test-list *form* 4 4)
  (let* ((arg2-form (macroexpand-form (third *form*)))
         (arg2 (c-constant-byte-p arg2-form)))
    (if arg2
      (c-GLOBAL-FUNCTION-CALL-form
        `(DPB ,(second *form*) (QUOTE ,arg2) ,(fourth *form*)))
      (c-GLOBAL-FUNCTION-CALL-form `(DPB ,(second *form*) ,arg2-form ,@(cdddr *form*))))))

(defun c-DEPOSIT-FIELD ()
  (test-list *form* 4 4)
  (let* ((arg2-form (macroexpand-form (third *form*)))
         (arg2 (c-constant-byte-p arg2-form)))
    (if arg2
      (c-GLOBAL-FUNCTION-CALL-form
        `(DEPOSIT-FIELD ,(second *form*) (QUOTE ,arg2) ,(fourth *form*)))
      (c-GLOBAL-FUNCTION-CALL-form `(DEPOSIT-FIELD ,(second *form*) ,arg2-form ,@(cdddr *form*))))))



;;;;****                     SECOND   PASS

;;; a table of pairs (fnode n).
;;; Each pair indicates, that in the 3rd Pass in Constant Nr. n of the
;;; functional Object of fnode the belonging fnode is to be replaced by the
;;; functional Object that was created by the fnode.
(defvar *fnode-fixup-table*)


;;; turns the ANODE-tree of fnode *func* into a functional object:
(defun pass2 (*func*)
  (when (anode-p (fnode-code *func*))
    ;; if Pass2 has not been executed yet,
    ;; only flatten, optimize and assemble the code
    (let ((code-list (compile-to-LAP)))
      ;; flatten code, split into pieces, optimize, turn into a list
      (when (fnode-gf-p *func*) ; convert CONSTs
        (setq code-list (CONST-to-LOADV code-list)))
      (let ((SPdepth (SP-depth code-list))) ; determine stack requirements
        (setq code-list (insert-combined-LAPs code-list))
        (create-fun-obj *func* (assemble-LAP code-list) SPdepth)))
    ;; do Pass2 on the sub-functions
    (dolist (x (fnode-Consts *func*)) (if (fnode-p x) (pass2 x)))))

#|
pass2 calls the 1st step.

After the 1. step the Code is divided into small part, with each part
stretching from a label to a jump (away from this part) (JMP, JMPCASE,
JMPCASE1-TRUE, JMPCASE1-FALSE, JMPHASH, RETURN-FROM, GO, RET, RETGF,
THROW, BARRIER). The parts are located (as a list in reversed order,
with the label as the last CDR) in vector *code-parts*.

  (symbol-value label) contains a list of the references of the label,
in the form:
 - Index in *code-parts*, if the reference is the corresponding jump
   (away from the part);
 - else opcode, where opcode is the command, in which the label occurs.
After the 1st step the code only contains Tags (Symbols) and Lists made of
Symbols and Numbers. Hence it is OK to work with SUBST and EQUAL.

The 1st step calls the 2nd step as soon as one part is completed.

Then, pass2 calls the 3rd step.  The 3rd step involves optimizations
that call further optimizations on success.

|#

#|
                             1st Step:
          Expansion of Code-Parts, Division of the Code in parts

changed:

 before                           after

 (CONST const)                    (CONST n const)
 (FCONST fnode)                   (CONST n), memorize Fixup for 3. Pass
 (BCONST block)                   (CONST n)
 (GCONST tagbody)                 (CONST n)
 (GET var venvc stackz)           (LOAD n) or (LOADI k1 k2 n)
                                  or (LOADC n m) or (LOADIC k1 k2 n m)
                                  or (LOADV k m) or (GETVALUE n)
                                  or (CONST n) or (CONST n const)
 (SET var venvc stackz)           (STORE n) or (STOREI k1 k2 n)
                                  or (STOREC n m) or (STOREIC k1 k2 n m)
                                  or (STOREV k m) or (SETVALUE n)
 (SETVALUE symbol)                (SETVALUE n)
 (GETVALUE symbol)                (GETVALUE n)
 (BIND const)                     (BIND n)
 (UNWIND stackz1 stackz2 for-value) a sequence of
                                  (SKIP n), (SKIPI k1 k2 n), (SKIPSP k1 k2),
                                  (VALUES0), (UNWIND-PROTECT-CLEANUP),
                                  (UNBIND1), (BLOCK-CLOSE), (TAGBODY-CLOSE)
 (UNWINDSP stackz1 stackz2)       a sequence of (SKIPSP k1 k2)
 (JMPIF label)                    (JMPCASE label new-label) new-label
 (JMPIFNOT label)                 (JMPCASE new-label label) new-label
 (JMPIF1 label)                   (JMPCASE1-TRUE label new-label) new-label
 (JMPIFNOT1 label)                (JMPCASE1-FALSE new-label label) new-label
 (JMPHASH test ((obj1 . label1) ... (objm . labelm)) label . labels)
                                  (JMPHASH n ht label . labels)
                                  with ht = Hash-Tabelle (obji -> labeli)
 (VENV venvc stackz)              (VENV) or (NIL)
                                  or (LOAD n) or (LOADI k1 k2 n)
 (COPY-CLOSURE fnode n)           (COPY-CLOSURE m n), memorize Fixup for Pass3
 (CALLP)                          discarded
 (CALL k fun)                     (CALL k n)
 (CALL0 fun)                      (CALL0 n)
 (CALL1 fun)                      (CALL1 n)
 (CALL2 fun)                      (CALL2 n)
 (FUNCALLP)                       (PUSH)
 (APPLYP)                         (PUSH)
 (JMPIFBOUNDP var venvc stackz label)
                                  (JMPIFBOUNDP n label)
 (BOUNDP var venvc stackz)        (BOUNDP n)
 (BLOCK-OPEN const label)         (BLOCK-OPEN n label)
 (RETURN-FROM const)              (RETURN-FROM n)
 (RETURN-FROM block)              (RETURN-FROM n)
 (RETURN-FROM block stackz)       (RETURN-FROM-I k1 k2 n)
 (TAGBODY-OPEN const label1 ... labelm)
                                  (TAGBODY-OPEN n label1 ... labelm)
 (GO const l)                     (GO n l)
 (GO tagbody (x . l))             (GO n l)
 (GO tagbody (x . l) stackz)      (GO-I k1 k2 n l)
 (HANDLER-OPEN const stackz label1 ... labelm)
                                  (HANDLER-OPEN n v k label1 ... labelm)
 unchanged:
 (NIL)
 (PUSH-NIL n)
 (T)
 (STORE n)
 (UNBIND1)
 (PROGV)
 (PUSH)
 (POP)
 (RET)
 (RETGF)
 (JMP label)
 (JSR m label)
 (BARRIER)
 (MAKE-VECTOR1&PUSH n)
 (CALLS1 n)
 (CALLS2 n)
 (CALLSR m n)
 (CALLC)
 (CALLCKEY)
 (FUNCALL n)
 (APPLY n)
 (PUSH-UNBOUND n)
 (UNLIST n m)
 (UNLIST* n m)
 (VALUES0)
 (VALUES1)
 (STACK-TO-MV n)
 (MV-TO-STACK)
 (NV-TO-STACK n)
 (MV-TO-LIST)
 (LIST-TO-MV)
 (MVCALLP)
 (MVCALL)
 (BLOCK-CLOSE)
 (TAGBODY-CLOSE-NIL)
 (TAGBODY-CLOSE)
 (CATCH-OPEN label)
 (CATCH-CLOSE)
 (THROW)
 (UNWIND-PROTECT-OPEN label)
 (UNWIND-PROTECT-NORMAL-EXIT)
 (UNWIND-PROTECT-CLOSE label)
 (UNWIND-PROTECT-CLEANUP)
 (HANDLER-BEGIN)
 (NOT)
 (EQ)
 (CAR denv)
 (CDR denv)
 (CONS)
 (ATOM)
 (CONSP)
 (SYMBOL-FUNCTION denv)
 (SVREF denv)
 (SVSET)
 (LIST n)
 (LIST* n)

New Operations:

 (JMP label boolvalue)            jump to label, boolvalue describes the 1.
                                  value: FALSE if =NIL, TRUE if /=NIL,
                                  NIL if unknown.

 (JMPCASE label1 label2)          jump to label1, if A0 /= NIL,
                                  resp. to label2, if A0 = NIL.

 (JMPCASE1-TRUE label1 label2)    if A0 /= NIL: jump to label1, 1 value.
                                  if A0 = NIL: jump to label2.

 (JMPCASE1-FALSE label1 label2)   if A0 /= NIL: jump to label1.
                                  if A0 = NIL: jump to label2, 1 value.

 (JMPTAIL m n label)              reduction of the Stack-Frame from n to m,
                                  then jump to label with undefined values.

|#

;; A Vector with Fill-Pointer that contains the code-parts:
(defvar *code-parts*)

;; A Vector of the same length with Fill-Pointer, that contains for each
;; code-part a "Position", where the part should be located finally (0 =
;; right at the beginning, higher values mean: shift further behind).
(defvar *code-positions*)

;; Registers a constant in (fnode-consts *func*) and returns its Index n.
;; value is the Value of the constant,
;; form is a Form with this value or NIL,
;; horizon = :value (then form = NIL) or :all or :form.
(defun value-form-index (value form ltv-form horizon &optional (func *func*))
  (when (fnode-p value)
    (setf (fnode-used value) t)
    (when (fnode-ignore value)
      ;; style-warning as per 3.2.5, although
      ;; COMPILER-DIAGNOSTICS:USE-HANDLER calls it a warning
      (c-style-warn (TEXT "function ~S is used despite IGNORE declaration.")
                    (fnode-name value))))
  (let ((const-list (fnode-consts func))
        (forms-list (fnode-consts-forms func))
        (ltv-forms-list (fnode-consts-ltv-forms func))
        (n (fnode-Consts-Offset func)))
    (if (null const-list)
      (progn
        (setf (fnode-consts func) (list value))
        (setf (fnode-consts-forms func) (list form))
        (setf (fnode-consts-ltv-forms func) (list ltv-form))
        n)
      (loop
        (when (if (eq horizon ':form)
                (and (eql (car forms-list) form)
                     (let ((ltv1 (car ltv-forms-list)) (ltv2 ltv-form))
                       (or (null ltv1) (null ltv2) (eq ltv1 ltv2))))
                ;; When horizon = :value or :all, we will compare only value.
                (eql (car const-list) value))
          (return n))
        (incf n)
        (when (null (cdr const-list))
          (setf (cdr const-list) (list value))
          (setf (cdr forms-list) (list form))
          (setf (cdr ltv-forms-list) (list ltv-form))
          (return n))
        (setq const-list (cdr const-list))
        (setq forms-list (cdr forms-list))
        (setq ltv-forms-list (cdr ltv-forms-list))))))
(defun constvalue-index (value)
  (value-form-index value nil nil ':value))

;; searches a constant in (fnode-Keywords *func*) and in (fnode-Consts *func*),
;; possibly registers it in (fnode-Consts *func*) . Returns its Index n.
(defun kvalue-form-index (value form ltv-form horizon &optional (func *func*))
  (when (and (not (eq horizon ':form)) (symbolp value))
    ;; the search only pays off for Symbols (formerly: Keywords)
    (do ((n (fnode-Keyword-Offset func) (1+ n))
         (L (fnode-Keywords func) (cdr L)))
        ((null L))
      (if (eq (car L) value) (return-from kvalue-form-index n))))
  (value-form-index value form ltv-form horizon func))
(defun kconstvalue-index (value)
  (kvalue-form-index value nil nil ':value))
(defun const-index (const)
  (if (and *compiling-from-file* (not (eq (const-horizon const) ':value)))
    (kvalue-form-index (const-value const) (const-form const)
                       (const-ltv-form const) (const-horizon const))
    (kvalue-form-index (const-value const) nil nil ':value)))

;; (make-const-code const) returns the Code, that moves the value of the
;; constant as 1 value to A0 .
(defun make-const-code (const)
  (unless (eq (const-horizon const) ':form)
    (let ((value (const-value const)))
      (cond ((eq value 'nil) (return-from make-const-code '(NIL)))
            ((eq value 't) (return-from make-const-code '(T))))))
  `(CONST ,(const-index const) ,const))

;; (bconst-index block) returns the Index in FUNC,
;; where this Block is located.
(defun bconst-index (block &optional (func *func*))
  ;; (+ (fnode-Blocks-Offset func)
  ;;    (position block (fnode-Blocks func) :test #'eq))
  (do ((n (fnode-Blocks-Offset func) (1+ n))
       (L (fnode-Blocks func) (cdr L)))
      ((eq (car L) block) n)))

;; (gconst-index tagbody) returns the Index in FUNC,
;; where this Tagbody is located.
(defun gconst-index (tagbody &optional (func *func*))
  ;; (+ (fnode-Tagbodys-Offset func)
  ;;    (position tagbody (fnode-Tagbodys func) :test #'eq))
  (do ((n (fnode-Tagbodys-Offset func) (1+ n))
       (L (fnode-Tagbodys func) (cdr L)))
      ((eq (car L) tagbody) n)))

;;; (fconst-index fnode) returns the Index in FUNC, where this fnode is
;;; located in the constants. If necessary, it is inserted and noted in
;;; *fnode-fixup-table* .
(defun fconst-index (fnode &optional (func *func*))
  (if (member fnode (fnode-Consts func))
    (constvalue-index fnode)
    (let ((n (constvalue-index fnode)))
      (push (list func n) *fnode-fixup-table*)
      n)))

;; Auxiliary Variables for recursive call of traverse-anode:

;; the current code-part, a reversed list of instructions, that
;; ends with the Start-Label as last nthcdr.
(defvar *code-part*)

;; and its number (Index in *code-parts*)
(defvar *code-index*)

;; Flag, if "dead Code" (i.e. Code, that is not reachable)
(defvar *dead-code*)

;; For jump-optimization in traverse-anode: List of all already
;; executed Label-Substitutions ((old-label . new-label) ...)
(defvar *label-subst*)

;; The current value, interpreted as boolean value:
;; FALSE if =NIL, TRUE if /=NIL, NIL if unknown.
;; (no restriction on the number of values!)
(defvar *current-value*)

;; List of Variables/Constants, whose values match the current
;; (lexical Variables as VARIABLE-Structures, dynamic Variables as
;; Symbols, Constants as CONST-Structures with horizon = :value or :all).
;; If this list is non-empty, there is exactly 1 value.
(defvar *current-vars*)

;; Each Label (a Gensym-Symbol) has as value a list of all References
;; to label, either as Index i in *code-parts*, if it is
;; the jump (the end) of (aref *code-parts* i) , or
;; as instruction (of a list) in all other cases. If the Label
;; starts a code-part, at (get label 'code-part) the Index in
;; *code-part* of the code-part is written, that starts with this Label. At
;; (get label 'for-value) is specified, how many values have a meaning
;; for a possible jump to the Label (NIL/ONE/ALL).
;; An exception is the "Label" NIL , which represents the entry-point.

;; Substitutes all references to old-label with references to new-label.
(defun label-subst (old-label new-label)
  ;; change all references to old-label:
  (dolist (ref (symbol-value old-label))
    (nsubst new-label old-label
            (rest (if (integerp ref) (first (aref *code-parts* ref)) ref))))
  ;; and register as references to new-label:
  (setf (symbol-value new-label)
        (nconc (symbol-value old-label) (symbol-value new-label)))
  (setf (symbol-value old-label) '())
  ;; no code-part starts with old-label:
  (remprop old-label 'code-part))

;; end current code-part and start a new code-part:
(defun finish-code-part ()
  ;; simplify the current code-part:
  (simplify *code-part*)
  ;; store *code-part* in *code-parts* :
  (vector-push-extend *code-part* *code-parts*)
  (vector-push-extend (incf *code-index*) *code-positions*))

;; emit a jump to Label label.
;; Thus a new code-part is started.
(defun emit-jmp (label)
  ;; with a jump:
  (push `(JMP ,label ,*current-value*) *code-part*)
  (push *code-index* (symbol-value label))
  (finish-code-part))

;; traverses through the Code of an Anode, expands the Code and
;; continues building *code-part* . Adjusts the Variables
;; *current-value* etc. accordingly.
(defun traverse-anode (code)
  (dolist (item code)
    (if (atom item)
      (cond ((symbolp item) ; Label
             (if *dead-code*
               ;; Code can be reached, so it is from now on not dead anymore
               (setq *dead-code* nil)
               (if (symbolp *code-part*)
                 ;; move Label item immediately to Label *code-part*
                 ;; -> can be identified
                 (let ((old-label *code-part*) (new-label item))
                   ;; substitute *code-parts* -> item
                   (label-subst old-label new-label)
                   (setq *label-subst*
                     (acons old-label new-label
                       (nsubst new-label old-label *label-subst*))))
                 ;; Label amid the code-part -> finish current code-part
                 (emit-jmp item)))
             ;; now the current code-part really starts,
             ;; with the label item:
             (setq *code-part* item)
             (setf (get item 'code-part) (fill-pointer *code-parts*))
             ;; jumps to this Label can still occur, so we do not know,
             ;; what A0 contains:
             (setq *current-value* nil *current-vars* '()))
            ((anode-p item)     ; Anode -> recursive
             (traverse-anode (anode-code item)))
            (t (compiler-error 'traverse-anode "ITEM")))
      ;; item is a normal instruction
      (unless *dead-code* ; only reachable code has to be processed
        (nsublis *label-subst* (rest item)) ; perform substitutions so far
        (case (first item)
          (CONST
           (let ((const (second item)))
             (if (eq (const-horizon const) ':form)
               (progn
                 (push (make-const-code const) *code-part*)
                 (setq *current-value* nil *current-vars* '()))
               (let ((cv (const-value const)))
                 (unless ; is (CONST cv) already contained in *current-vars*?
                     (dolist (v *current-vars* nil)
                       (when (and (const-p v) (eq (const-value-safe v) cv))
                         (return t)))
                   (push (make-const-code const) *code-part*)
                   (setq *current-value* (if (null cv) 'FALSE 'TRUE)
                         *current-vars* (list const)))))))
          (FCONST
           (push `(CONST ,(fconst-index (second item))) *code-part*)
           (setq *current-value* 'TRUE *current-vars* '()))
          (BCONST
           (push `(CONST ,(bconst-index (second item))) *code-part*)
           (setq *current-value* 'TRUE *current-vars* '()))
          (GCONST
           (push `(CONST ,(gconst-index (second item))) *code-part*)
           (setq *current-value* 'TRUE *current-vars* '()))
          (GET
           (let ((var (second item))
                 (venvc (third item))
                 (stackz (fourth item)))
             (unless (memq var *current-vars*)
               ;; already the current value = var ?
               (push
                (if (var-constantp var)
                  (let* ((const (var-constant var))
                         (val (const-value-safe const)))
                    (setq *current-value* (if (null val) 'FALSE 'TRUE))
                    (if (fnode-p val)
                      ;; FNODEs as values can (almost) solely
                      ;; originate from LABELS
                      `(CONST ,(fconst-index val))
                      (make-const-code const)))
                  (progn
                    (setq *current-value* nil)
                    (if (var-specialp var)
                      `(GETVALUE ,(kconstvalue-index
                                   (setq var (var-name var))))
                      (if (var-closurep var)
                        (multiple-value-bind (k n m)
                            (access-in-closure var venvc stackz)
                          (if n
                            (if k
                              `(LOADIC ,(car k) ,(cdr k) ,n ,m)
                              `(LOADC ,n ,m))
                            `(LOADV ,k ,(1+ m))))
                        ;; lexical and in Stack, so in the same function
                        (multiple-value-bind (k n)
                            (access-in-stack stackz (var-stackz var))
                          (if k
                            `(LOADI ,(car k) ,(cdr k) ,n)
                            `(LOAD ,n)))))))
                *code-part*)
               (setq *current-vars* (list var)))))
          (SET
           (let ((var (second item))
                 (venvc (third item))
                 (stackz (fourth item)))
             (unless (memq var *current-vars*)
               ;; already the current value = var ?
               (push
                (if (var-specialp var)
                  `(SETVALUE ,(kconstvalue-index (setq var (var-name var))))
                  (if (var-closurep var)
                    (multiple-value-bind (k n m)
                        (access-in-closure var venvc stackz)
                      (if n
                        (if k
                          `(STOREIC ,(car k) ,(cdr k) ,n ,m)
                          `(STOREC ,n ,m))
                        `(STOREV ,k ,(1+ m))))
                    ;; lexical and in Stack, so in the same function
                    (multiple-value-bind (k n)
                        (access-in-stack stackz (var-stackz var))
                      (if k `(STOREI ,(car k) ,(cdr k) ,n) `(STORE ,n)))))
                *code-part*)
               (push var *current-vars*)))) ; *current-value* is unchanged
          (GETVALUE
           (let ((symbol (second item)))
             (unless (memq symbol *current-vars*)
               (push `(GETVALUE ,(kconstvalue-index symbol)) *code-part*)
               (setq *current-value* nil *current-vars* (list symbol)))))
          (SETVALUE
           (let ((symbol (second item)))
             (unless (memq symbol *current-vars*)
               (push `(SETVALUE ,(kconstvalue-index symbol)) *code-part*)
               (push symbol *current-vars*)))) ; *current-value* is unchanged
          (BIND
           (push `(BIND ,(const-index (second item))) *code-part*)
           (setq *current-value* nil *current-vars* '())) ; undefined values
          (UNWIND ; multi-line conversion
           (traverse-anode
            (expand-UNWIND (second item) (third item) (fourth item))))
          (UNWINDSP ; multi-line conversion
           (let ((k (spdepth-difference (second item) (third item))))
             (when (or (> (car k) 0) (> (cdr k) 0))
               (push `(SKIPSP ,(car k) ,(cdr k)) *code-part*))))
          ((JMPIF JMPIFNOT JMPIF1 JMPIFNOT1)
           (if (null *current-value*)
             (let ((label (second item))
                   (new-label (make-label 'NIL)))
               (push
                (case (first item)
                  (JMPIF `(JMPCASE ,label ,new-label))
                  (JMPIFNOT `(JMPCASE ,new-label ,label))
                  (JMPIF1 `(JMPCASE1-TRUE ,label ,new-label))
                  (JMPIFNOT1 `(JMPCASE1-FALSE ,new-label ,label)))
                *code-part*)
               (push *code-index* (symbol-value (second item)))
               (push *code-index* (symbol-value new-label))
               (finish-code-part)
               (setf (get new-label 'code-part) (fill-pointer *code-parts*))
               (setq *code-part* new-label)
               ;; *current-value* and *current-vars* remain unchanged.
               )
             ;; boolean value known at jump
             (if (if (eq *current-value* 'FALSE)
                   ;; value=NIL -> omit JMPIF
                   (memq (first item) '(JMPIF JMPIF1))
                   ;; value/=NIL -> omit JMPIFNOT
                   (memq (first item) '(JMPIFNOT JMPIFNOT1)))
               ;; omit jump
               nil
               ;; convert to JMP:
               (progn
                 (when (memq (first item) '(JMPIF1 JMPIFNOT1))
                   (push '(VALUES1) *code-part*)) ; coerce exactly 1 value
                 (emit-jmp (second item))
                 (setq *dead-code* t)))))
          (JMPHASH
           (let ((hashtable (make-hash-table :key-type 't :value-type 'fixnum
                                             :test (second item)))
                 (labels (cddddr item)))
             (dolist (acons (third item))
               (setf (gethash (car acons) hashtable)
                     (position (cdr acons) labels)))
             (push `(JMPHASH ,(constvalue-index hashtable) ,hashtable
                     ,@(cdddr item))
                   *code-part*))
           ;; note down references:
           (dolist (label (cdddr item))
             (push *code-index* (symbol-value label)))
           (finish-code-part)
           (setq *dead-code* t))
          (VENV
           (let ((venvc (second item))
                 (stackz (third item)))
             (loop ; in venvc pass the NILs
              (when (car venvc) (return))
              (setq venvc (cdr venvc)))
             (push
              (if (consp (car venvc)) ; fetch from Stack
                (multiple-value-bind (k n)
                    (access-in-stack stackz (cdr (car venvc)))
                  (if k `(LOADI ,(car k) ,(cdr k) ,n) `(LOAD ,n)))
                (if (eq (car venvc) *func*)
                  (if (fnode-Venvconst *func*) '(VENV) '(NIL))
                  (compiler-error 'traverse-anode 'VENV)))
              *code-part*)
             (if (equal (car *code-part*) '(NIL))
               (setq *current-value* 'FALSE
                     *current-vars* (list (new-const 'NIL)))
               (setq *current-value* nil *current-vars* '()))))
          (COPY-CLOSURE
           (push `(COPY-CLOSURE ,(fconst-index (second item)) ,(third item))
                 *code-part*)
           (setq *current-value* 'TRUE *current-vars* '()))
          (CALLP) ; is canceled
          (CALL
           (push `(CALL ,(second item) ,(const-index (third item)))
                 *code-part*)
           (setq *current-value* nil *current-vars* '()))
          ((CALL0 CALL1 CALL2)
           (push `(,(first item) ,(const-index (second item)))
                 *code-part*)
           (setq *current-value* nil *current-vars* '()))
          ((FUNCALLP APPLYP)
           (push '(PUSH) *code-part*)
           (setq *current-value* nil *current-vars* '()))
          ((JMPIFBOUNDP BOUNDP)
           (let ((var (second item))
                 (stackz (fourth item)))
             (when (var-closurep var)
               (compiler-error 'traverse-anode 'var-closurep))
             (multiple-value-bind (k n)
                 (access-in-stack stackz (var-stackz var))
               (when k (compiler-error 'traverse-anode 'var-stackz))
               (push `(,(first item) ,n ,@(cddddr item)) *code-part*)
               (when (eq (first item) 'JMPIFBOUNDP)
                 (push (first *code-part*) (symbol-value (fifth item))))
               ;; undefined values
               (setq *current-value* nil *current-vars* '()))))
          (BLOCK-OPEN
           (let ((label (third item)))
             (push `(BLOCK-OPEN ,(const-index (second item)) ,label)
                   *code-part*)
             (push (first *code-part*) (symbol-value label))
             ;; undefined values
             (setq *current-value* nil *current-vars* '())))
          (RETURN-FROM
           (push
            (if (cddr item)
              (multiple-value-bind (k n)
                  (access-in-stack (third item) (block-stackz (second item)))
                `(RETURN-FROM-I ,(car k) ,(cdr k) ,n))
              (if (block-p (second item))
                `(RETURN-FROM ,(bconst-index (second item)))
                `(RETURN-FROM ,(const-index (second item)))))
            *code-part*)
            (finish-code-part)
            (setq *dead-code* t))
          (TAGBODY-OPEN
           (push `(TAGBODY-OPEN ,(const-index (second item)) ,@(cddr item))
                 *code-part*)
           (dolist (label (cddr item)) (push item (symbol-value label)))
           ;; undefined values
           (setq *current-value* nil *current-vars* '()))
          (GO
           (push
            (if (cdddr item)
              (multiple-value-bind (k n)
                  (access-in-stack (fourth item)
                                   (tagbody-stackz (second item)))
                `(GO-I ,(car k) ,(cdr k) ,n ,(cdr (third item))))
              (if (tagbody-p (second item))
                `(GO ,(gconst-index (second item)) ,(cdr (third item)))
                `(GO ,(const-index (second item)) ,(third item))))
            *code-part*)
           (finish-code-part)
           (setq *dead-code* t))
          ((NIL TAGBODY-CLOSE-NIL)
           (push item *code-part*)
           (setq *current-value* 'FALSE
                 *current-vars* (list (new-const 'NIL))))
          (HANDLER-OPEN
           (setq item
                 (let* ((v (const-value-safe (second item)))
                        (k (spdepth-difference (third item) *func*))
                        (l (length v)) (r (make-array (ash l 1)))) ; 2*l
                   ;; Out of v = #(type1 ... typem)
                   ;; make   v = #(type1 nil ... typem nil)
                   (dotimes (i l) (setf (aref r (ash i 1)) (aref v i)))
                   `(HANDLER-OPEN ,(constvalue-index (cons r k)) ,r ,k
                     ,@(cdddr item))))
           (push item *code-part*)
           (dolist (label (cddddr item)) (push item (symbol-value label))))
          (VALUES0
           (push item *code-part*)
           (setq *current-value* 'FALSE *current-vars* '()))
          ((SKIP SKIPI SKIPSP VALUES1 MVCALLP BLOCK-CLOSE TAGBODY-CLOSE
            CATCH-CLOSE UNWIND-PROTECT-NORMAL-EXIT HANDLER-BEGIN
            ;; STORE only on function-arguments within a
            ;; function-call, cf. c-DIRECT-FUNCTION-CALL
            STORE)
           (push item *code-part*))
          ((T)
           (push item *code-part*)
           (setq *current-value* 'TRUE
                 *current-vars* (list (new-const 'T))))
          ((RET RETGF BARRIER THROW)
           (push item *code-part*)
           (finish-code-part)
           (setq *dead-code* t))
          (JMP
           (emit-jmp (second item))
           (setq *dead-code* t))
          (JSR
           (push item *code-part*)
           (push item (symbol-value (third item)))
           (setq *current-value* nil *current-vars* '()))
          (CATCH-OPEN
           (push item *code-part*)
           (push item (symbol-value (second item))))
          ((UNWIND-PROTECT-OPEN UNWIND-PROTECT-CLOSE)
           (push item *code-part*)
           (push item (symbol-value (second item)))
           ;; values are thrown away
           (setq *current-value* nil *current-vars* '()))
          ((PUSH-NIL PROGV PUSH POP MAKE-VECTOR1&PUSH CALLS1 CALLS2 CALLSR
            CALLC CALLCKEY FUNCALL APPLY PUSH-UNBOUND UNLIST UNLIST*
            STACK-TO-MV MV-TO-STACK NV-TO-STACK MV-TO-LIST LIST-TO-MV MVCALL
            NOT EQ CAR CDR ATOM CONSP SYMBOL-FUNCTION SVREF SVSET)
           (push item *code-part*)
           (setq *current-value* nil *current-vars* '()))
          ((CONS LIST LIST*)
           (push item *code-part*)
           (setq *current-value* 'TRUE *current-vars* '()))
          ((UNWIND-PROTECT-CLEANUP)
           (push item *code-part*)
           (setq *current-vars* '())) ; can destroy variable-values
          ((UNBIND1)
           (push item *code-part*)
           ;; can destroy values of dynamic variables
           (setq *current-vars* (delete-if #'symbolp *current-vars*)))
          (t (compiler-error 'traverse-anode "LISTITEM")))))))

;; Auxiliary Functions after the 1st step:

;; if an instruction item is added, that perhaps contains Label-References,
;; then note-references has to be called. This notes the Label-References in
;; item. item belongs to (aref *code-parts* index).
;; if an instruction item is removed, that perhaps contains Label-References,
;; then remove-references has to be called. This notes the cancellation of the
;; Label-References in item. item belongs to (aref *code-parts* index).
;; Also returns the list of the Labels contained in item.
(macrolet ((references ()
             `(case (first item)
                (JMP (end-ref (second item)))
                ((JMPCASE JMPCASE1-TRUE JMPCASE1-FALSE)
                 (end-ref (second item)) (end-ref (third item)))
                (JMPHASH (dolist (label (cdddr item)) (end-ref label)))
                ((CATCH-OPEN UNWIND-PROTECT-OPEN UNWIND-PROTECT-CLOSE)
                 (mid-ref (second item)))
                ((JMPIFBOUNDP BLOCK-OPEN JSR) (mid-ref (third item)))
                (JMPTAIL (mid-ref (fourth item)))
                (TAGBODY-OPEN (dolist (label (cddr item)) (mid-ref label)))
                (HANDLER-OPEN
                 (dolist (label (cddddr item)) (mid-ref label))))))
  (defun note-references (item &optional index)
    (macrolet ((end-ref (label) `(push index (symbol-value ,label)))
               (mid-ref (label) `(push item (symbol-value ,label))))
      (references)))
  (defun remove-references (item &optional index &aux (labellist '()))
    (macrolet ((end-ref (label)
                 (let ((labelvar (gensym)))
                   `(let ((,labelvar ,label))
                      (setf (symbol-value ,labelvar)
                            (delete index (symbol-value ,labelvar)))
                      (pushnew ,labelvar labellist))))
               (mid-ref (label)
                 (let ((labelvar (gensym)))
                   `(let ((,labelvar ,label))
                      (setf (symbol-value ,labelvar)
                            (delete item (symbol-value ,labelvar)))
                      (pushnew ,labelvar labellist)))))
      (references)
      labellist))
)

#|
                              2nd Step
                Simplification of Sequences of Operations

This takes place on the reversed code-parts; they are changed
destructively, withal.

Simplification-Rules for Operations:

1. (VALUES1) can be dropped after all instructions, that produce only
   one value in any case, and above all, that use only one value in any case.

2. (SKIP n1) (SKIP n2)                   --> (SKIP n1+n2)
   (SKIPI k1 k2 n1) (SKIP n2)            --> (SKIPI k1 k2 n1+n2)
   (SKIP n1) (SKIPI k1 k2 n2)            --> (SKIPI k1 k2 n2)
   (SKIPI k11 k21 n1) (SKIPI k21 k22 n2) --> (SKIPI k11+k12+1 k21+k22 n2)
   (SKIPSP k11 k21) (SKIPI k21 k22 n)    --> (SKIPI k11+k12 k21+k22 n)
   (SKIPSP k11 k21) (SKIPSP k21 k22)     --> (SKIPSP k11+k12 k21+k22)

3. (NOT) (NOT) (NOT)                 --> (NOT)
   (ATOM) (NOT)                      --> (CONSP)
   (CONSP) (NOT)                     --> (ATOM)

4. (LOAD 0) (SKIP n)                 --> (POP) (SKIP n-1)  for n>1
   (LOAD 0) (SKIP 1)                 --> (POP)             for n=1
   (PUSH) (SKIP n)                   --> (SKIP n-1)  for n>1
   (PUSH) (SKIP 1)                   -->             for n=1
   (NV-TO-STACK n) (SKIP n)          -->
   (NV-TO-STACK n+m) (SKIP n)        --> (NV-TO-STACK m)
   (NV-TO-STACK n) (SKIP n+m)        --> (SKIP m)
   (STORE m) (SKIP n)                --> (VALUES1) (SKIP n) for n>m
   (STORE 0) (POP)                   --> (VALUES1) (SKIP 1)
   (PUSH) (POP)                      --> (VALUES1)
   (POP) (PUSH)                      -->
   (SKIP n) (PUSH)                   --> (SKIP n-1) (STORE 0) for n>1
   (SKIP 1) (PUSH)                   --> (STORE 0)            for n=1

5. (VALUES1)/... (MV-TO-STACK)       --> (VALUES1)/... (PUSH)
   (VALUES0) (MV-TO-STACK)           -->
   (STACK-TO-MV n) (MV-TO-STACK)     -->
   (STACK-TO-MV m) (NV-TO-STACK n)   --> (PUSH-NIL n-m)  for m<n
                                     -->                 for m=n
                                     --> (SKIP m-n)      for m>n
   (NIL)/(VALUES0) (NV-TO-STACK n)   --> (PUSH-NIL n)
   (VALUES1)/... (NV-TO-STACK n)     --> (VALUES1)/... (PUSH) (PUSH-NIL n-1)

6. (PUSH-UNBOUND n) (PUSH-UNBOUND m) --> (PUSH-UNBOUND n+m)

7. (LIST* 1)                         --> (CONS)

|#

;; The Hash-Table one-value-ops contains those instructions,
;; that create exactly one value.
(defconstant one-value-ops
  (let ((ht (make-hash-table :key-type 'symbol :value-type '(eql t)
                             :test 'stablehash-eq :warn-if-needs-rehash-after-gc t)))
    (dolist (op '(NIL T CONST LOAD LOADI LOADC LOADV LOADIC STORE STOREI
                  STOREC STOREV STOREIC GETVALUE SETVALUE POP VENV
                  COPY-CLOSURE BOUNDP VALUES1 MV-TO-LIST TAGBODY-CLOSE-NIL
                  NOT EQ CAR CDR CONS ATOM CONSP SYMBOL-FUNCTION SVREF SVSET
                  LIST LIST*))
      (setf (gethash op ht) t))
    ht))

;; The value for a Key in this Hash-Table indicates, how many values
;; are needed for the execution of the corresponding Operation
;; (cf. *for-value*):
;; NIL : values are discarded.
;; ONE : One value is used, the remaining values are discarded.
;; ALL : All values are used.
;; Operations, that do not change their values, are not
;; listed here.
(defconstant for-value-table
  (let ((ht (make-hash-table :key-type 'symbol :value-type '(member NIL ONE ALL)
                             :test 'stablehash-eq :warn-if-needs-rehash-after-gc t)))
    (dolist (op '(NIL PUSH-NIL T CONST LOAD LOADI LOADC LOADV LOADIC
                  GETVALUE POP JSR JMPTAIL BARRIER VENV COPY-CLOSURE CALL
                  CALL0 CALLS1 CALLS2 CALLSR FUNCALL PUSH-UNBOUND JMPIFBOUNDP
                  BOUNDP VALUES0 STACK-TO-MV MVCALL
                  BLOCK-OPEN TAGBODY-OPEN TAGBODY-CLOSE-NIL GO GO-I
                  UNWIND-PROTECT-OPEN UNWIND-PROTECT-CLOSE
                  HANDLER-OPEN HANDLER-BEGIN
                  LIST))
      (setf (gethash op ht) 'NIL))
    (dolist (op '(STORE STOREI STOREC STOREV STOREIC SETVALUE BIND PROGV PUSH
                  MAKE-VECTOR1&PUSH CALL1 CALL2 CALLC CALLCKEY APPLY UNLIST
                  UNLIST* VALUES1 LIST-TO-MV MVCALLP CATCH-OPEN
                  NOT EQ CAR CDR CONS ATOM CONSP SYMBOL-FUNCTION SVREF SVSET
                  LIST*))
      (setf (gethash op ht) 'ONE))
    (dolist (op '(MV-TO-STACK NV-TO-STACK MV-TO-LIST RETURN-FROM RETURN-FROM-I
                  THROW UNWIND-PROTECT-NORMAL-EXIT))
      (setf (gethash op ht) 'ALL))
    ;; Not in the Table, because they leave the values unchanged:
    ;;           '(UNBIND1 SKIP SKIPI SKIPSP BLOCK-CLOSE TAGBODY-CLOSE
    ;;             CATCH-CLOSE UNWIND-PROTECT-CLEANUP)
    ;; Not in the Table, because they are jumps:
    ;;   ONE:    '(RETGF JMPHASH)
    ;;   ALL:    '(RET JMP JMPCASE JMPCASE1-TRUE JMPCASE1-FALSE)
    ht))

;; Simplifies a code-part (in reversed order!).
;; The simplification-rules above are processed as long as possible.
;; Result is mostly NIL, or the start-label instead (in order to indicate,
;; that further optimizations are possible), if its Property for-value
;; has been weakened.
(defun simplify (codelist)
  (unless codelist (return-from simplify nil))
  (let ((for-value-at-end
          (let ((item (car codelist)))
            (case (first item)
              (JMP (get (second item) 'for-value))
              ((JMPCASE JMPCASE1-TRUE JMPCASE1-FALSE)
                (if (or (and (not (eq (first item) 'JMPCASE1-TRUE))
                             (eq (get (second item) 'for-value) 'ALL))
                        (and (not (eq (first item) 'JMPCASE1-FALSE))
                             (eq (get (third item) 'for-value) 'ALL)))
                  'ALL
                  'ONE))
              ((RETGF JMPHASH) 'ONE)
              ((BARRIER GO GO-I JMPTAIL) 'NIL)
              ((RETURN-FROM RETURN-FROM-I RET THROW) 'ALL)
              (t (compiler-error 'simplify codelist)))))
        (result nil)) ; poss. the start-label
    ;; for-value-at-end indicates, which values are needed before the jump.
    (loop
      (let ((modified nil))
        (let* ((left codelist) (middle (cdr left)) right
               (for-value for-value-at-end))
          ;; Three Pointers traverse through the code-list:
          ;;  ...left.middle.right...
          ;; for-value indicates, which values are needed after
          ;; execution of (car middle), before execution of (car left) .
          (tagbody start
            (when (atom middle) (go end))
            (setq right (cdr middle))
            (macrolet ((replace1 (new) ; replace (car middle) with new
                         `(progn
                            (setf (car middle) ,new)
                            (setq modified t) (go start)))
                       (replace2 (new)
                         ;; replace (car middle) and (car right) with new
                         `(progn
                            ,@(unless (equal new '(car middle))
                                `((setf (car middle) ,new)))
                            (setf (cdr middle) (cdr right))
                            (setq modified t) (go start)))
                       (discard1 () ; discard (car middle)
                         `(progn
                            (setf (cdr left) (setq middle right))
                            (setq modified t) (go start)))
                       (discard2 () ; discard (car middle) and (car right)
                         `(progn
                            (setf (cdr left) (setq middle (cdr right)))
                            (setq modified t) (go start)))
                       (extend2 (new1 new2)
                         ;; replace (car middle) with new1 and new2
                         `(progn
                            (setf (car middle) ,new1)
                            (setf (cdr middle) (cons ,new2 right))
                            (setq modified t) (go start))))
              (when (eq for-value 'NIL)
                ;; before an operation, that needs no values:
                (case (first (car middle))
                  ((NIL T CONST LOAD LOADI LOADC LOADV LOADIC GETVALUE VENV
                    BOUNDP VALUES0 VALUES1 MV-TO-LIST LIST-TO-MV NOT ATOM
                    CONSP)
                    (discard1))
                  ((CAR CDR SYMBOL-FUNCTION)
                   ; CAR, CDR, SYMBOL-FUNCTION cannot always be discarded,
                   ; because it may need to signal an error if SAFETY = 3.
                   (when (< (declared-optimize 'SAFETY (second (car middle))) 3)
                     (discard1)))
                  ((LIST LIST* STACK-TO-MV) ; (LIST n) --> (SKIP n), n>0
                                            ; (LIST* n) --> (SKIP n), n>0
                                            ; (STACK-TO-MV n) --> (SKIP n), n>0
                    (replace1 `(SKIP ,(second (car middle)))))
                  ((POP EQ CONS) (replace1 '(SKIP 1)))
                  ((SVREF)
                   ; SVREF cannot always be discarded, because it may need to
                   ; signal an error if SAFETY = 3.
                   (when (< (declared-optimize 'SAFETY (second (car middle))) 3)
                     (replace1 '(SKIP 1))))))
              (when (eq for-value 'ONE)
                ;; before an operation, that needs only one value:
                (case (first (car middle))
                  (VALUES1 (discard1))
                  (VALUES0 (replace1 '(NIL)))
                  (LIST-TO-MV (replace1 `(CAR NIL)))
                  (STACK-TO-MV ; (STACK-TO-MV n) --> (SKIP n-1) (POP) for n>1
                    (let ((n (second (car middle))))
                      (extend2 '(POP) `(SKIP ,(- n 1)))))))
              (when (consp right)
                ;; peephole comprises (car middle) and (car right), poss. more.
                (case (first (car middle))
                  (VALUES1 ; rule 1
                   (when (gethash (first (car right)) one-value-ops nil)
                     ;; (op ...) (VALUES1) --> (op ...)
                     (discard1)))
                  (NOT ; rule 3
                   (case (first (car right))
                     (NOT
                      (when (and (consp (cdr right))
                                 (equal (cadr right) '(NOT)))
                        ;; (NOT) (NOT) (NOT) --> (NOT)
                        (discard2)))
                     (ATOM (replace2 '(CONSP)))   ; (ATOM) (NOT) --> (CONSP)
                     (CONSP (replace2 '(ATOM))))) ; (CONSP) (NOT) --> (ATOM)
                  (SKIP
                    (let ((n2 (second (car middle)))) ; n2 > 0
                      (case (first (car right))
                        ;; rule 2
                        (SKIP ; (SKIP n1) (SKIP n2) --> (SKIP n1+n2)
                         (let ((n1 (second (car right))))
                           (replace2 `(SKIP ,(+ n1 n2)))))
                        (SKIPI
                         ;; (SKIPI k1 k2 n1) (SKIP n2) --> (SKIPI k1 k2 n1+n2)
                         (let ((k1 (second (car right)))
                               (k2 (third (car right)))
                               (n1 (fourth (car right))))
                           (replace2 `(SKIPI ,k1 ,k2 ,(+ n1 n2)))))
                        ;; rule 4
                        (LOAD ; (LOAD 0) (SKIP n) --> (POP) [(SKIP n-1)]
                         (when (eql (second (car right)) 0)
                           (if (eql n2 1)
                             (replace2 '(POP))
                             (progn (setf (car right) '(POP))
                                    (replace1 `(SKIP ,(- n2 1)))))))
                        (PUSH ; (PUSH) (SKIP n) --> [(SKIP n-1)]
                         (if (eql n2 1)
                           (discard2)
                           (replace2 `(SKIP ,(- n2 1)))))
                        (NV-TO-STACK
                         (let ((n1 (second (car right))))
                           (cond ((> n1 n2)
                                  (replace2 `(NV-TO-STACK ,(- n1 n2))))
                                 ((< n1 n2) (replace2 `(SKIP ,(- n2 n1))))
                                 (t (discard2)))))
                        (STORE
                         ;; (STORE m) (SKIP n) --> (VALUES1) (SKIP n) for n>m
                         (let ((m (second (car right))))
                           (when (> n2 m)
                             (setf (car right) '(VALUES1))
                             (setq modified t) (go start)))))))
                  (SKIPI ; rule 2
                   (case (first (car right))
                     (SKIP ; (SKIP n1) (SKIPI k1 k2 n2) --> (SKIPI k1 k2 n2)
                      (replace2 (car middle)))
                     (SKIPI
                      ;; (SKIPI k11 k21 n1) (SKIPI k21 k22 n2)
                      ;; --> (SKIPI k11+k12+1 k21+k22 n2)
                      (let ((k11 (second (car right)))
                            (k21 (third (car right)))
                            (k12 (second (car middle)))
                            (k22 (third (car middle)))
                            (n2 (third (car middle))))
                        (replace2 `(SKIPI ,(+ k11 k12 1) ,(+ k21 k22) ,n2))))
                     (SKIPSP
                      ;; (SKIPSP k11 k21) (SKIPI k21 k22 n)
                      ;; --> (SKIPI k11+k12 k21+k22 n)
                      (let ((k11 (second (car right)))
                            (k21 (third (car right)))
                            (k12 (second (car middle)))
                            (k22 (third (car middle)))
                            (n2 (fourth (car middle))))
                        (replace2 `(SKIPI ,(+ k11 k12) ,(+ k21 k22) ,n2))))))
                  (SKIPSP ; rule 2
                   (case (first (car right))
                     (SKIPSP
                      ;; (SKIPSP k11 k21) (SKIPSP k21 k22)
                      ;; --> (SKIPSP k11+k12 k21+k22)
                      (let ((k11 (second (car right)))
                            (k21 (third (car right)))
                            (k12 (second (car middle)))
                            (k22 (third (car middle))))
                        (replace2 `(SKIPSP ,(+ k11 k12) ,(+ k21 k22)))))))
                  (POP ; rule 4
                   (cond ((equal (car right) '(STORE 0))
                          ;; (STORE 0) (POP) --> (VALUES1) (SKIP 1)
                          (setf (car right) '(VALUES1))
                          (replace1 '(SKIP 1)))
                         ((equal (car right) '(PUSH))
                          ;; (PUSH) (POP) --> (VALUES1)
                          (replace2 '(VALUES1)))))
                  (PUSH ; rule 4
                   (case (first (car right))
                     (POP (discard2)) ; discard (POP) (PUSH)
                     (SKIP ; (SKIP n) (PUSH) --> [(SKIP n-1)] (STORE 0)
                      (let ((n (second (car right))))
                        (if (eql n 1)
                          (unless (and (consp (cdr right))
                                       (equal (cadr right) '(LOAD 0)))
                            ;; (LOAD 0) (SKIP 1) (PUSH) is treated differently
                            (replace2 '(STORE 0)))
                          (progn (setf (car right) `(SKIP ,(- n 1)))
                                 (replace1 '(STORE 0))))))))
                  (MV-TO-STACK ; rule 5
                   (when (gethash (first (car right)) one-value-ops nil)
                     ;; (car right) returns only one value -->
                     ;; replace (MV-TO-STACK) with (PUSH) :
                     (replace1 '(PUSH)))
                   (case (first (car right))
                     ((VALUES0 STACK-TO-MV) (discard2))))
                  (NV-TO-STACK ; rule 5
                   (let ((n (second (car middle))))
                     (case (first (car right))
                       (STACK-TO-MV
                        (let ((m (second (car right))))
                          (cond ((> n m) (replace2 `(PUSH-NIL ,(- n m))))
                                ((< n m) (replace2 `(SKIP ,(- m n))))
                                (t (discard2)))))
                       ((VALUES0 NIL) (replace2 `(PUSH-NIL ,n)))
                       (t (when (gethash (first (car right)) one-value-ops nil)
                            (extend2 `(PUSH-NIL ,(- n 1)) `(PUSH)))))))
                  (PUSH-UNBOUND ; rule 6
                   (case (first (car right))
                     (PUSH-UNBOUND
                      ;; (PUSH-UNBOUND n) (PUSH-UNBOUND m)
                      ;; --> (PUSH-UNBOUND n+m)
                      (let ((n (second (car right)))
                            (m (second (car middle))))
                        (replace2 `(PUSH-UNBOUND ,(+ n m)))))))
                  (LIST* ; rule 7
                   (when (equal (rest (car middle)) '(1))
                     (replace1 '(CONS)))))))
            (when (atom middle) (go end))
            ;; calculate new for-value, depending on (car middle):
            (setq for-value
                  (gethash (first (car middle)) for-value-table for-value))
            ;; advance:
            (setq left middle middle right)
            (go start)
           end)
          ;; code-part finished: (atom middle)
          (when middle
            ;; middle is the start-label
            (let ((old-for-value (get middle 'for-value)))
              ;; is for-value better than old-for-value ?
              (when (and (not (eq for-value old-for-value))
                         (or (eq old-for-value 'ALL) (eq for-value 'NIL)))
                ;; yes -> return start-label as result hereafter:
                (setf (get middle 'for-value) for-value result middle))))
          ) ; end let*
        (unless modified (return))
        )) ; end let, loop
    (let (codelistr)
      (when (and (eq (first (first codelist)) 'RET)
                 (consp (setq codelistr (cdr codelist)))
                 (or (eq (first (first codelistr)) 'JSR)
                     (and (eq (first (second codelist)) 'SKIP)
                          (consp (setq codelistr (cddr codelist)))
                          (eq (first (first codelistr)) 'JSR))))
        ;; (JSR n label) [(SKIP m)] (RET) --> (JMPTAIL n n+m label)
        (let ((n (second (first codelistr)))
              (label (third (first codelistr)))
              (m (if (eq codelistr (cdr codelist))
                   0
                   (second (second codelist)))))
          (setf (first codelist) `(JMPTAIL ,n ,(+ n m) ,label)))
        (remove-references (first codelistr)) ; (JSR ...) is discarded
        (note-references (first codelist)) ; (JMPTAIL ...) is inserted
        (setf (cdr codelist) (cdr codelistr)) ; discard 1 resp. 2 list-elements
        (setq for-value-at-end 'NIL))) ; JMPTAIL needs no values
    result))

#|
                            3rd Step:
                      General Optimizations

If an Optimization is performed successfully, all the
Optimizations that might apply after this one are retried.

 optimize-part
   - calls the 2nd step: Peephole-Optimization of normal Operations.

 optimize-label
   - code-parts for labels, that are not referenced (anymore), are removed.
   - if a label is referenced by only one single JMP, that does not
     spring from the same code-part, both affected pieces can be concatenated.
 optimize-short
   - if there is a code-part, where the start-label label1 is
     immediately followed by a (JMP label2), then all references of
     label1 are replaced by label2 and the code-part is removed.
   - if there is a code-part, where the start-label label is immediately
     followed by a
        (JMPCASE/JMPCASE1-TRUE/JMPCASE1-FALSE label_true label_false),
     then references (JMPCASE1-TRUE label l) and
     (JMPCASE1-FALSE l label) can be simplified.
   - a short code-part is directly attached to corresponding JMPs to its
     start-label. (A code-part is called "short", if it comprises at
     most 2 instructions and if it is not concluded with a
     JMPHASH (which should not be duplicated).
     HANDLER-OPEN also should not be duplicated.)
 optimize-jmpcase
   - (JMPCASE label label) is simplified to (JMP label).
   - (NOT) [...] (JMPCASE label_true label_false) is simplified to
     [...] (JMPCASE label_false label_true), whereas [...] may only
     contain instructions, that do not change the 1. value, and no
     values are needed at label_true and label_false.
 optimize-value
   - A jump JMPCASE1-TRUE/JMPCASE1-FALSE can be replaced by JMPCASE, if the
     value is not needed at the target-label or only the 1. value is needed.
   - A jump JMPCASE/JMPCASE1-TRUE/JMPCASE1-FALSE can be replaced by a
     JMP, if the current value at this location can be proven to be
     eiter =NIL or /=NIL .
   - A JMP can carry forward the information describing the current
     value to its target-label.

 coalesce
   - coalesce code-parts with the same end (at least 3 instructions).

|#

(defun optimize-part (code)
  (let ((label (simplify code)))
    (when label
      ;; The Property for-value of label was improved.
      (dolist (ref (symbol-value label))
        (when (integerp ref) (optimize-value ref))))))

(defun optimize-label (label &optional (index (get label 'code-part))
                                       (code (aref *code-parts* index))
                                       (lastc (last code)))
  (unless (or code (symbol-value label)) (return-from optimize-label))
  (unless (eq label (cdr lastc)) (compiler-error 'optimize-label label))
  (when label
    ;; label is a Label, it starts the Code
    ;; code = (aref *code-parts* index), and lastc = (last code).
    (let ((refs (symbol-value label))) ; List of References to it
      (cond ((null refs)
             ;; non-referenced Label: remove code-part,
             ;; eliminate references out of this code-part.
             (let ((labellist '())) ; list of labels that have lost references
               (loop
                 (when (atom code) (return))
                 (setq labellist
                       (nreconc labellist
                                (remove-references (pop code) index))))
               (setf (aref *code-parts* index) nil) ; remove code-part
               ;; At Labels with fewer references continue optimization:
               ;; (Caution: This can change *code-parts*.)
               (dolist (olabel labellist)
                 (let* ((oindex (get olabel 'code-part))
                        (ocode (aref *code-parts* oindex)))
                   (when (and ocode (eq (cdr (last ocode)) olabel))
                     (optimize-label olabel oindex ocode))))))
            ((null (cdr refs)) ; Label with only one Reference, by JMP ?
             (let ((ref (first refs)))
               (when (and (integerp ref) ; A JMP is a leaving-jump
                          (eq (first (car (aref *code-parts* ref))) 'JMP)
                          (not (eql index ref))) ; from another code-part
                 ;; append:
                 ;; (aref *code-parts* ref) is put into the "drawer"
                 ;; (aref *code-parts* index) .
                 (setf (cdr lastc) (rest (aref *code-parts* ref)))
                 (setf (aref *code-parts* ref) nil)
                 (let ((new-startlabel (cdr (last lastc))))
                   ;; new Startlabel of (aref *code-parts* index)
                   (when new-startlabel
                     (setf (get new-startlabel 'code-part) index)))
                 ;; deactivate old Startlabel of (aref *code-parts* index):
                 (setf (symbol-value label) '())
                 ;; simplify new code-part:
                 (optimize-part code))))))))

(defun optimize-short (index &optional (code (aref *code-parts* index))
                             &aux      (lastc (last code))
                                       (label (cdr lastc)))
  (when label
    ;; label is a Label, it starts the Code
    ;; code = (aref *code-parts* index), and lastc = (last code).
    (when (eq code lastc)
      ;; One single Operation after the Label.
      (let ((item (car code)))
        (case (first item)
          (JMP ; (JMP ...) immediately behind the Label
           (let ((to-label (second item)))
             (unless (symbol-value to-label)
               (compiler-error 'optimize-short (cons label to-label)))
             (unless (eq label to-label)
               (label-subst label to-label) ; adjust References
               (setf (aref *code-parts* index) nil) ; remove code-piece
               (setf (symbol-value to-label) ; reference is dropped
                     (delete index (symbol-value to-label)))
               (optimize-label to-label) ; possible optimization
               (dolist (refindex (symbol-value to-label))
                 (when (integerp refindex)
                   (let* ((refcode (aref *code-parts* refindex))
                          (ref (car refcode)))
                     (when (and (eq (first ref) 'JMPCASE)
                                (eq (second ref) to-label)
                                (eq (third ref) to-label))
                       ;; save optimization
                       (optimize-jmpcase refindex refcode)))))))
           (return-from optimize-short))
          ((JMPCASE JMPCASE1-TRUE JMPCASE1-FALSE)
           (let ((true-label (second item))
                 (false-label (third item)))
             (unless (or (eq label true-label) (eq label false-label))
               ;; simplifly JMPCASE1-references to label:
               (let ((modified-indices '())) ; Indices of modified code-parts
                 (dolist (refindex (symbol-value label))
                   (when (integerp refindex)
                     (let* ((refcode (aref *code-parts* refindex))
                            (ref (car refcode)))
                       (case (first ref)
                         (JMP
                          ;; (JMP label) -->
                          ;; (JMPCASE/... true-label false-label)
                          (setf (car refcode) item)
                          ;; new references to true-label and false-label:
                          (push refindex (symbol-value true-label))
                          (push refindex (symbol-value false-label))
                          (push refindex modified-indices))
                         ((JMPCASE JMPCASE1-TRUE JMPCASE1-FALSE)
                          ;; (JMPCASE/... label1 label2)
                          (let (;; TRUE-case: where to jump
                                (label1 (second ref))
                                ;; FALSE-case: where to jump
                                (label2 (third ref))
                                ;; TRUE-case: with (VALUES1) ?
                                (1-true (eq (first ref) 'JMPCASE1-TRUE))
                                ;; FALSE-case: with (VALUES1) ?
                                (1-false (eq (first ref) 'JMPCASE1-FALSE)))
                            (when (eq label label1)
                              ;; the (JMPCASE/... label ...) is simplified
                              ;; to (JMPCASE/... true-label ...).
                              (setq label1 true-label)
                              ;; new reference to true-label:
                              (push refindex (symbol-value true-label))
                              (push refindex modified-indices)
                              (when (eq (first item) 'JMPCASE1-TRUE)
                                (setq 1-true t)))
                            (when (eq label label2)
                              ;; the (JMPCASE/... ... label) is simplified
                              ;; to (JMPCASE/... ... false-label).
                              (setq label2 false-label)
                              ;; new reference to false-label:
                              (push refindex (symbol-value false-label))
                              (push refindex modified-indices)
                              (when (eq (first item) 'JMPCASE1-FALSE)
                                (setq 1-false t)))
                            (unless (eq (get label1 'for-value) 'ALL)
                              (setq 1-true nil))
                            (unless (eq (get label2 'for-value) 'ALL)
                              (setq 1-false nil))
                            (when (and 1-true 1-false)
                              (push '(VALUES1) (cdr refcode))
                              (setq 1-true nil 1-false nil))
                            (setf (car refcode)
                                  `(,(cond (1-true 'JMPCASE1-TRUE)
                                           (1-false 'JMPCASE1-FALSE)
                                           (t 'JMPCASE))
                                     ,label1
                                     ,label2))))
                         (JMPHASH ; JMPHASH has undefined values
                          (compiler-error 'optimize-short ref))))
                     ;; later:
                     ;; (setf (symbol-value label)
                     ;;       (delete refindex (symbol-value label)))
                     ))
                 (setf (symbol-value label)
                       (delete-if #'integerp (symbol-value label)))
                 ;; more optimization feasible because of reduced references:
                 (optimize-label label)
                 ;; poss. further optimization in changed code-parts:
                 (dolist (refindex modified-indices)
                   (simplify (aref *code-parts* refindex))
                   (optimize-value refindex)
                   (optimize-jmpcase refindex
                                     (aref *code-parts* refindex))))))))))
    ;; further "short" code-parts, at most 2 instructions long:
    (when (and (or (eq code lastc) (eq (cdr code) lastc))
               (not (eq (first (car code)) 'JMPHASH))
               (or (eq code lastc)
                   (not (eq (first (cadr code)) 'HANDLER-OPEN))))
      (let ((indices '())) ; we append code to those code-parts, whose indices are in this list.
        (setf (cdr lastc) '()) ; code preliminarily without the label to the end
        (dolist (refindex (symbol-value label))
          (when (and (integerp refindex) (not (eql refindex index))
                     (not (member refindex indices)))
            (let ((refcode (aref *code-parts* refindex)))
              (when (eq (first (car refcode)) 'JMP)
                ;; append:
                (let ((new-code (mapcar #'copy-list code)))
                  (dolist (op new-code) (note-references op refindex))
                  (setf (aref *code-parts* refindex)
                        (nconc new-code (cdr refcode))))
                (setf (symbol-value label) (delete refindex (symbol-value label)))
                (push refindex indices)))))
        (setf (cdr lastc) label) ; set the label to the list-end again
        (when indices
          ;; further possible optimizations:
          (dolist (refindex indices)
            (optimize-part (aref *code-parts* refindex)))
          (optimize-label label)))))) ; label has fewer references -> optimize
;; get-boolean-value tries to determine for a given starting piece of a
;; code-part (an (nthcdr n codelist) with n>=1) , which boolean value is
;; there after its execution:
;; FALSE     surely A0 = NIL,
;; TRUE      surely A0 /= NIL,
;; NIL       can say nothing.
(defun get-boolean-value (code)
  (let ((invert nil)) ; if the boolean value is inverted from here to the end
    ((lambda (value)
       (if invert
         (case value (TRUE 'FALSE) (FALSE 'TRUE) (t NIL))
         value))
     (block value
       (loop ; traverse code-list
         (when (atom code) (return))
         (case (first (car code))
           ((NIL VALUES0 TAGBODY-CLOSE-NIL) ; produce value NIL
            (return-from value 'FALSE)) ; thus we can terminate the loop
           ((T CONS LIST LIST*) ; produce value /= NIL
            ;; (LIST n) and (LIST* n) because of n>0.
            (return-from value 'TRUE)) ; thus we can terminate the loop
           (CONST
            (unless (and (cddr (car code))
                         (eq (const-horizon (third (car code))) ':form))
              ;; (CONST n) produces value /= NIL, because the value
              ;; is already known at Compile-Time and the constant
              ;; NIL in make-const-code has already been treated.
              (return-from value 'TRUE)) ; thus we can terminate the loop
            (return-from value nil))
           (NOT (setq invert (not invert))) ; invert the boolean value later
           ((UNBIND1 SKIP SKIPI SKIPSP STORE STOREI STOREV STOREC STOREIC
             SETVALUE VALUES1 BLOCK-CLOSE TAGBODY-CLOSE CATCH-CLOSE
             UNWIND-PROTECT-CLEANUP)
            ;; no modification of the first value ->
            ;; continue in the code-list
            )
           (t (return-from value nil)))
         (setq code (cdr code)))
       (when code
         ;; code is the start-label.
         ;; Inspect all jumps to the Label code:
         (let ((so-far nil))
           ;; = FALSE, if all jumps so far bring along FALSE,
           ;; = TRUE,  if all jumps so far bring along TRUE,
           ;; = NIL at the beginning.
           ;; If a jump brings along an unknown boolean value,
           ;; the loop can be left instantly.
           (flet ((new (value)
                    (cond ((null so-far) (setq so-far value))
                          ((not (eq value so-far))
                           (return-from value nil)))))
             (dolist (ref (symbol-value code))
               (if (integerp ref)
                 (let ((refcode (first (aref *code-parts* ref)))) ; the jump hither
                   ;; this cannot be a leaving-jump with undefined values.
                   (case (first refcode)
                     (JMP
                      (if (third refcode)
                        ;; value known before the jump
                        (new (third refcode))
                        ;; value unknown before the jump
                        (return-from value nil)))
                     ((JMPCASE JMPCASE1-TRUE JMPCASE1-FALSE)
                      (when (eq code (second refcode)) (new 'TRUE))
                      (when (eq code (third refcode)) (new 'FALSE)))
                     (t ;; JMPHASH has undefined values, and the
                        ;; other leaving-jumps contain no Labels.
                      (compiler-error 'get-boolean-value refcode))))
                 (case (first ref)
                   ((JMPIFBOUNDP BLOCK-OPEN CATCH-OPEN)
                    (return-from value nil)) ; can say nothing
                   (t ;; There are undefined values at the Labels in
                      ;; TAGBODY-OPEN, JSR, UNWIND-PROTECT-OPEN,
                      ;; UNWIND-PROTECT-CLOSE.
                    (compiler-error 'get-boolean-value ref))))))))
       nil)))) ; Default: can say nothing

(defun optimize-jmpcase (index code)
  (when (eq (first (car code)) 'JMPCASE)
    ;; Code ends with (JMPCASE ...)
    (let ((true-label (second (car code)))
          (false-label (third (car code))))
      (if (eq true-label false-label)
        ;; (JMPCASE label label) --> (JMP label ..)
        (progn
          (setf (car code) `(JMP ,true-label ,(get-boolean-value (cdr code))))
          ;; double reference becomes a single reference:
          (setf (symbol-value true-label)
                (delete index (symbol-value true-label) :count 1))
          ;; continue optimization:
          (optimize-part code)
          (optimize-short (get true-label 'code-part)))
        (when (and (null (get true-label 'for-value))
                   (null (get false-label 'for-value)))
          ;; try to eliminate NOTs:
          (let ((invert 0)
                (cr1 code)
                (cr2 (cdr code))) ; always cr2 = (cdr cr1)
            (loop
              (when (atom cr2) (return))
              (case (first (car cr2))
                ((UNBIND1 SKIP SKIPI SKIPSP VALUES1 BLOCK-CLOSE TAGBODY-CLOSE
                  CATCH-CLOSE UNWIND-PROTECT-CLEANUP)
                 ;; these operations do not need values and leave
                 ;; the 1. value unmodified
                 (shiftf cr1 cr2 (cdr cr2)))
                (NOT
                 (setf (cdr cr1) (setq cr2 (cdr cr2))) ; discard (NOT)
                 (incf invert))
                (t (return))))
            ;; invert = number of times, how often (NOT) was discarded
            (when (oddp invert)
              ;; permute true-label and false-label:
              (setf (car code) `(JMPCASE ,false-label ,true-label)))
            (when (plusp invert)
              ;; continue optimization:
              (optimize-part code)
              (optimize-short index))))))))

(defun optimize-value (index &optional (code (aref *code-parts* index)))
  (let ((item (car code)))
    (case (first item)
      ((JMPCASE JMPCASE1-TRUE JMPCASE1-FALSE)
       ;; (JMPCASE/... true-label false-label)
       (let ((true-label (second item))
             (false-label (third item)))
         (when (or (and (eq (first item) 'JMPCASE1-TRUE)
                        (not (eq (get true-label 'for-value) 'ALL))
                        ;; value-number 1 is not needed at true-label
                        ;; (JMPCASE1-TRUE ...) --> (JMPCASE ...)
                        )
                   (and (eq (first item) 'JMPCASE1-FALSE)
                        (not (eq (get false-label 'for-value) 'ALL))
                        ;; value-number 1 is not needed at false-label
                        ;; (JMPCASE1-FALSE ...) --> (JMPCASE ...)
                        ))
           (setq item (setf (car code) `(JMPCASE ,@(rest item))))
           ;; further optimizations possible:
           (optimize-jmpcase index code))
         ;; try to detect the boolean value at this place
         ;; and simplify if possible:
         (case (get-boolean-value (cdr code))
           (TRUE                ; jump always aims at true-label
            (unless (eq true-label false-label)
              ;; discard reference to false-label:
              (setf (symbol-value false-label)
                    (delete index (symbol-value false-label))))
            (setf (car code) `(JMP ,true-label TRUE))
            (when (eq (first item) 'JMPCASE1-TRUE)
              (push '(VALUES1) (cdr code))
              (simplify code))
            (optimize-part code) ; further possible optimization
            ;; further possible optimizations:
            (optimize-label false-label) ; because of reduced references
            (optimize-short index)) ; because of optimize-part above
           (FALSE
            (unless (eq true-label false-label)
              ;; discard reference to true-label
              (setf (symbol-value true-label)
                    (delete index (symbol-value true-label))))
            (setf (car code) `(JMP ,false-label FALSE))
            (when (eq (first item) 'JMPCASE1-FALSE)
              (push '(VALUES1) (cdr code))
              (simplify code))
            (optimize-part code) ; further possible optimization
            ;; further possible optimizations:
            (optimize-label true-label) ; because of reduced references
            (optimize-short index))))) ; because of optimize-part above
      (JMP
       (let ((label (second item)))
         (when (get label 'for-value)
           ;; value is required
           (when (null (third item))
             ;; but it is unknown.
             ;; maybe it can be ascertained?
             (let ((value (get-boolean-value (cdr code))))
               (when value
                 (setf (car code) `(JMP ,label ,value))
                 ;; value is now known, maybe it can be utilized:
                 (optimize-value (get label 'code-part)))))))))))

;; coalesce coalesces identical code-pieces in the given code-parts as far as
;; possible and returns as result a flag, if something was changed.
(defun coalesce (&optional (indexlist
                            ;; list of all possible indices
                            (let ((L '()))
                              (dotimes (i (fill-pointer *code-parts*))
                                (push i L))
                              (nreverse L))))
  (let ((parts-ht ; A Hashtable, that realizes the mapping:
                  ; code-end --> list of all indices of code-parts,
                  ;              that end with the same code-piece
         (let ((ht (make-hash-table :value-type 'list
                                    :test #'equal :size (length indexlist))))
           (dolist (index indexlist)
             (let ((code (aref *code-parts* index))) ; a code-piece
               ;; only pieces are coalesced that match in
               ;; at least the last 3 operations, because of the
               ;; simplification-rule for "short" codes-pieces.
               (when (and (consp code) (consp (cdr code)) (consp (cddr code)))
                 (push index
                       (gethash (list* (first code) (second code) (third code))
                                ht '())))))
           ht))
        (modified nil))
    ;; Then, iterate over the possible code-ends:
    (maphash
      #'(lambda (code-beginning indices)
          (declare (ignore code-beginning))
          (when (cdr indices) ; at least two indices with this code-end?
            ;; try to coalesce a code-piece that is as long as possible:
            (let ((codes ; list of code-pieces to be coalesced
                    (mapcar #'(lambda (i) (aref *code-parts* i)) indices))
                  (new-code '()) ; here the common code is collected
                  (new-index (fill-pointer *code-parts*)) ; its index
                  (new-order ; the common piece is sorted at the last part
                   (reduce #'max (mapcar #'(lambda (i)
                                             (aref *code-positions* i))
                                         indices))))
              (loop
               ;; all still match?
               (unless (every #'consp codes) (return))
               (let* ((code1 (first codes)) ; an arbitrary code-piece
                      (code11 (car code1))) ; its last operation
                 (unless (every #'(lambda (code) (equal (car code) code11))
                                (rest codes))
                   (return))
                 ;; yes. shorten all code-pieces from codes by one operation:
                 (mapc #'(lambda (code index) ; delete references
                           (remove-references (car code) index))
                       codes indices)
                 ;; shorten: (setq codes (mapcar #'cdr codes)), or:
                 (mapl #'(lambda (codesr)
                           (setf (car codesr) (cdr (car codesr))))
                       codes)
                 (push code11 new-code) ; lengthen new-code
                 (note-references code11 new-index)))
              (when new-code
                (let* ((new-label (make-label 'ALL))
                       ;; All code-pieces from codes were shortened, they
                       ;; are now lengthened by one (JMP new-label NIL).
                       (jmpop `(JMP ,new-label NIL)))
                  (mapc #'(lambda (code index)
                            (setf (aref *code-parts* index) (cons jmpop code)))
                        codes indices)
                  ;; References to new-label
                  (setf (symbol-value new-label) indices)
                  (setf (get new-label 'code-part) new-index)
                  (vector-push-extend (nreconc new-code new-label)
                                      *code-parts*)
                  (vector-push-extend new-order *code-positions*))
                ;; further possible optimizations:
                (optimize-part (aref *code-parts* new-index))
                (coalesce indices)
                (setq modified t))))) ; change has taken place
      parts-ht)
    modified))

;; The main-function of the 3rd step:
;; Performs all optimizations, and then collects all code-pieces
;; into one single code-list and returns it.
(defun optimize-all ()
  ;; optimizations:
  (loop
    ;; call optimizations:
    ;; if one makes a find, it will also call the optimization-
    ;; steps, that might thereby become possible. Thus they
    ;; have to be listed here only once.
    ;; Caution: *code-parts* and its content can be
    ;; completely changed by the optimizations.
    (do ((index 0 (1+ index)))
        ((eql index (fill-pointer *code-parts*)))
      (let ((code (aref *code-parts* index)))
        (when code
          (let* ((lastc (last code))
                 (label (cdr lastc)))
            (when label
              (unless (eql index (get label 'code-part))
                (compiler-error 'optimize-all 'code-part)))
            (optimize-label label index code lastc))))
      (let ((code (aref *code-parts* index)))
        (when code
          (optimize-jmpcase index code)))
      (let ((code (aref *code-parts* index)))
        (when code
          (optimize-value index code)))
      (let ((code (aref *code-parts* index)))
        (when code
          (optimize-short index code))))
    (unless (coalesce) (return))) ; (coalesce) did nothing -> finished
  ;; collect into one single code-list:
  ;; (The labels now become list-elements in the code instead of NTHCDRs.)
  (let ((start-index 0)) ; Start-"Label" NIL begins code-piece Nr. 0
    ;; if possible, first append at a time a code-piece that starts with label,
    ;; to a code-piece, that ends with a JMP or JMPCASE/... to label.
    (do ((index (fill-pointer *code-parts*)))
        ((eql (decf index) 0))
      ;; index loops through the indices of *code-parts*
      ;; top-down, apart from start-index=0.
      (let ((code (aref *code-parts* index)))
        (when code
          (loop
            ;; Treat the label at the end of code, in code-piece Nr. index:
            (let* ((lastc (last code)) ; last Cons of code
                   (label (cdr lastc)) ; Label at the end of code
                   (refs (symbol-value label)) ; References pointing to it
                   (pos (aref *code-positions* index)) ; Position of code
                   (jmp-ref nil) ; best found JMP-Reference to label so far
                   (jmpcase-ref nil) ; best found JMPCASE-Reference to label so far
                   (jmpcase1-ref nil)) ; best found JMPCASE1-...-Reference to label so far
              (if (null label)
                ;; The Start-Code-Piece was attached to another place!
                (progn
                  (setq start-index index)
                  (return)) ; go for the next index
                (flet ((better (new-ref old-ref)
                         ;; One Reference new-ref is "better" than another
                         ;; old-ref, if it is closer. Withal,
                         ;; forward-references have in general higher priority
                         ;; compared to backward-references.
                         (or (null old-ref) ; no old-ref yet?
                             (let ((old-pos (aref *code-positions* old-ref))
                                   (new-pos (aref *code-positions* new-ref)))
                               (if (> old-pos pos) ; so far only backward-jump?
                                 ;; yes: new-pos is better, if it is
                                 ;; < pos (forward-jump) or
                                 ;; >=pos, <=old-pos (shorter backward-jump).
                                 (<= new-pos old-pos)
                                 ;; no: new-pos is better, if it is
                                 ;; <=pos, >=old-pos (shorter forward-jump).
                                 (<= old-pos new-pos pos))))))
                  (macrolet ((update (old-ref new-ref) ; for determination of the best so far
                               `(when (better ,new-ref ,old-ref)
                                  (setq ,old-ref ,new-ref))))
                    ;; determine the best reference, to which the code-piece
                    ;; can be attached:
                    (dolist (refindex refs)
                      (when (and (integerp refindex)
                                 (not (eql refindex index))) ; do not attach to itself!
                        (let ((refcode1 (car (aref *code-parts* refindex))))
                          (case (first refcode1)
                            (JMP ; attachment possible to (JMP label ...)
                             (update jmp-ref refindex))
                            (JMPCASE ; attachment possible to (JMPCASE ... label ...)
                             (update jmpcase-ref refindex))
                            (JMPCASE1-TRUE ; attachment possible to (JMPCASE1-TRUE ... label)
                             (when (eq label (third refcode1))
                               (update jmpcase1-ref refindex)))
                            (JMPCASE1-FALSE ; attachment possible to (JMPCASE1-FALSE label ...)
                             (when (eq label (second refcode1))
                               (update jmpcase1-ref refindex)))))))
                    (cond (jmp-ref ; attach to (JMP label)
                           (setf (cdr lastc)
                                 (cons label (cdr (aref *code-parts*
                                                        jmp-ref))))
                           (setf (aref *code-parts* jmp-ref) nil)
                           (setq code lastc))
                          (jmpcase1-ref
                           (let* ((refcode (aref *code-parts* jmpcase1-ref))
                                  (refcode1 (car refcode))
                                  (jmpop
                                    (if (eq label (second refcode1))
                                      `(JMPIFNOT1 ,(third refcode1))
                                      `(JMPIF1 ,(second refcode1)))))
                             (setf (cdr lastc) (list* label jmpop
                                                      (cdr refcode)))
                             (setf (aref *code-parts* jmpcase1-ref) nil)
                             (setq code lastc)))
                          (jmpcase-ref
                           (let* ((refcode (aref *code-parts* jmpcase-ref))
                                  (refcode1 (car refcode))
                                  (for-value (or (get (second refcode1)
                                                      'for-value)
                                                 (get (third refcode1)
                                                      'for-value)))
                                  (jmpop
                                    (if (eq label (second refcode1))
                                      `(JMPIFNOT ,(third refcode1) ,for-value)
                                      `(JMPIF ,(second refcode1) ,for-value))))
                             (setf (cdr lastc)
                                   (list* label jmpop (cdr refcode)))
                             (setf (aref *code-parts* jmpcase-ref) nil)
                             (setq code lastc)))
                          (t ; no attachment possible
                           (return))))))))))) ; go for the next index
    ;; make sure, that the start-piece really makes it to the start:
    ;; (this would also work, by executing a
    ;; (setf (aref *code-positions* index) (aref *code-positions* jmp..-ref))
    ;; for each attachment. Why don't we do that??)
    (setf (aref *code-positions* start-index) 0)
    ;; assemble code-list:
    (let ((code-parts (map 'list #'cons *code-parts* *code-positions*)))
      (setq code-parts (delete-if-not #'car code-parts)) ; code=nil means: canceled
      (setq code-parts (sort code-parts #'> :key #'cdr)) ; sort by order
      ;; the pieces are now in the right order, only reversed.
      (let ((codelist '()))
        (dolist (code-part code-parts)
          (let ((code (car code-part)))
            ;; append code to codelist, thereby convert the leaving-jump:
            (let ((item (car code)))
              (case (first item)
                (JMP (setf (car code) `(JMP ,(second item))))
                (JMPCASE ; (JMPCASE true-label false-label)
                         ; --> (JMPIFNOT false-label fv) (JMP true-label)
                  (setq code
                    (list* `(JMP ,(second item))
                           `(JMPIFNOT ,(third item)
                                      ,(or (get (second item) 'for-value)
                                           (get (third item) 'for-value)))
                           (cdr code))))
                (JMPCASE1-TRUE ; (JMPCASE1-TRUE true-label false-label)
                               ; --> (JMPIF1 true-label) (JMP false-label)
                  (setq code
                    (list* `(JMP ,(third item))
                           `(JMPIF1 ,(second item))
                           (cdr code))))
                (JMPCASE1-FALSE ; (JMPCASE1-FALSE true-label false-label)
                                ; --> (JMPIFNOT1 false-label) (JMP true-label)
                  (setq code
                    (list* `(JMP ,(second item))
                           `(JMPIFNOT1 ,(third item))
                           (cdr code))))))
            ;; turn Label into a list-element:
            (let ((lastc (last code)))
              (when (cdr lastc)
                (setf (cdr lastc) (list (cdr lastc)))))
            ;; convert and prepend in front of codelist (that's why we sorted
            ;; with #'> instead of #'< beforehand):
            (setq codelist (nreconc code codelist))))
        codelist))))

#|
;; Debugging hints:
 (in-package "SYSTEM")
 (setq *print-circle* t *suppress-check-redefinition* t)
 (setq *print-length* 10 *print-level* 3)
 (setq *print-length* nil *print-level* nil)
 (setf (package-lock *system-package-list*) nil)
;; avoid stack overflow in trace output (calls CLOS::INSTALL-DISPATCH)
;; by adding all needed PRINT-OBJECT methods before tracing begins:
 (print (list (mk-anode #+CLISP-DEBUG nil nil #+CLISP-DEBUG nil nil nil
                        #+CLISP-DEBUG nil)
              (make-fnode) (make-block)
              (make-tagbody) (make-var) (make-const) (make-c-source-point)
              (make-signature) (clos::make-class-version) clos::<t>
              #'compile))
 (trace (sys::optimize-label :pre-print (list *code-parts* *trace-args*
  (let* ((label (first *trace-args*))
         (index (or (second *trace-args*) (get label 'code-part)))
         (code (or (third *trace-args*) (aref *code-parts* index)))
         (lastc (or (fourth *trace-args*) (last code))))
    (list label index code lastc)))))
 (trace compile-to-lap)
 (trace (traverse-anode :post-print *code-part*))
 (trace (traverse-anode :post-print (cons *code-part* (reverse (coerce *code-parts* 'list)))))
 (trace (optimize-part    :pre-print *code-parts* :post-print *code-parts*)
        (optimize-label   :pre-print *code-parts* :post-print *code-parts*)
        (optimize-short   :pre-print *code-parts* :post-print *code-parts*)
        (optimize-jmpcase :pre-print *code-parts* :post-print *code-parts*)
        (optimize-value   :pre-print *code-parts* :post-print *code-parts*)
        (coalesce         :pre-print *code-parts* :post-print *code-parts*)
        (optimize-all     :pre-print *code-parts* :post-print *code-parts*))
 (trace simplify)
;; Move out suspect code to a separate file which you load interpreted.

;; Special debugging checks:
 (defun optimize-check ()
   (do ((index 0 (1+ index)))
       ((eql index (fill-pointer *code-parts*)))
     (let ((code (aref *code-parts* index)))
       (when code
         (let* ((lastc (last code))
                (label (cdr lastc)))
           (when label
             (unless (eql index (get label 'code-part))
               (compiler-error 'optimize-check 'code-part))))))))
 (trace
 (optimize-part    :pre (optimize-check) :post (optimize-check) :suppress-if t)
 (optimize-label   :pre (optimize-check) :post (optimize-check) :suppress-if t)
 (optimize-short   :pre (optimize-check) :post (optimize-check) :suppress-if t)
 (optimize-jmpcase :pre (optimize-check) :post (optimize-check) :suppress-if t)
 (optimize-value   :pre (optimize-check) :post (optimize-check) :suppress-if t)
 (coalesce         :pre (optimize-check) :post (optimize-check) :suppress-if t)
 (optimize-all     :pre (optimize-check) :post (optimize-check) :suppress-if t)
)
|#

#| How about the following possible optimizations??

10. If there is an (UNWIND-PROTECT-CLEANUP) in front of (JMP label) and
   if there is a (UNWIND-PROTECT-3 cleanup-label) in front of the label,
   so it must be the same UNWIND-PROTECT-Frame; (UNWIND-PROTECT-CLEANUP)
   can be discarded and (JMP label) can be replaced by (JMP newlabel),
   whereas newlabel is a new label, that is located in front
   of (poss. to be supplemented) (UNWIND-PROTECT-2) ahead of
   cleanup-label:
   (UNWIND-PROTECT-CLEANUP) (JMP label) ...
   ... [(UNWIND-PROTECT-2)] cleanup-label
   ... (UNWIND-PROTECT-3 cleanup-label) label
   -->
   (JMP newlabel) ...
   ... newlabel (UNWIND-PROTECT-2) cleanup-label
   ... (UNWIND-PROTECT-3 cleanup-label) label

11. IF there is a (NIL) after a Label label,  each (JMPIFNOT label)
   and each (JMPIFNOT1 label) can be replaced by a (JMPIFNOT1 z) ,
   with z being a new Label after the (NIL) :
          (JMPIFNOT label) ... label (NIL) ...
   -->       (JMPIFNOT1 z) ... label (NIL) z ...

|#

;; Executes Steps 1, 2 and 3:
(defun compile-to-LAP ()        ; LAP = Lisp Assembly Program
  (let ((*code-parts* (make-array 10 :adjustable t :fill-pointer 0))
        (*code-positions* (make-array 10 :adjustable t :fill-pointer 0)))
    ;; Expands the Code of Fnode *func* and divides it into pieces.
    ;; leaves behind its values in *code-parts* and *code-positions*.
    (let ((*code-part* (list '(START))) ; NIL as Start-"Label"
          (*code-index* 0)
          (*dead-code* nil)
          (*label-subst* '())
          (*current-value* nil)
          (*current-vars* '()))
      (traverse-anode (anode-code (fnode-code *func*))))
    ;; Optimizes in *code-parts* and *code-positions*, then collects the code
    ;; in a list and returns it:
    (let ((code-list (optimize-all)))
      (unless (equal (pop code-list) '(START))
        (compiler-error 'compile-to-LAP 'start))
      code-list)))


#|
                            4. Step:
                      Elimination of (CONST n)

Generic Functions have a fixed size. The constants are stored
in VENV-Const. Transformations in this step:
  (LOADV k m)    -->  (LOADV k+1 m)
  (STOREV k m)   -->  (STOREV k+1 m)
  (CONST n [c])  -->  (LOADV 0 n)
  (VENV)         -->  (LOADV 0 0)
  (JMPHASH n ht label . labels)  -->  (JMPHASHV n ht label . labels)
  (GETVALUE n)         -->  illegal
  (SETVALUE n)         -->  illegal
  (BIND n)             -->  illegal
  (COPY-CLOSURE m n)   -->  illegal
  (CALL k n)           -->  illegal
  (CALL0 n)            -->  illegal
  (CALL1 n)            -->  illegal
  (CALL2 n)            -->  illegal
  (BLOCK-OPEN n label) -->  illegal
  (RETURN-FROM n)      -->  illegal
  (TAGBODY-OPEN n ...) -->  illegal
  (GO n l)             -->  illegal
|#

(defun CONST-to-LOADV (code-list)
  (do ((codelistr code-list (cdr codelistr)))
      ((null codelistr))
    (let ((item (car codelistr)))
      (when (consp item)
        (case (first item)
          ((LOADV STOREV)
           (setf (car codelistr)
                 `(,(first item) ,(1+ (second item)) ,@(cddr item))))
          (CONST
           (setf (car codelistr) `(LOADV 0 ,(second item))))
          (VENV
           (setf (car codelistr) `(LOADV 0 0)))
          (JMPHASH
           (setf (car codelistr) `(JMPHASHV ,@(cdr item))))
          ((GETVALUE SETVALUE BIND COPY-CLOSURE CALL CALL0 CALL1 CALL2
            BLOCK-OPEN RETURN-FROM TAGBODY-OPEN GO)
            (compiler-error 'CONST-to-LOADV "Illegal-in-GF"))))))
  code-list)


#|
                            5. Step:
                   Calculation of Stack-Demand

This step determines, how many SP-Entries the function needs at most.
|#

(defun SP-depth (code-list)
  ;; We have to compute the maximum SP depth in the two spd dimensions
  ;; separately. Instead of walking through the code twice, we walk only once.
  ;; When we see that a label can be reached with depths (d1 . d2) and (e1 . e2)
  ;; we pretend it can be reached with depth ((max d1 e1) . (max d2 e2)).
  ;; Similarly, when we have tracked a label at depths (d1 . d2) and (e1 . e2),
  ;; we pretend having tracked it at depth ((max d1 e1) . (max d2 e2)).
  ;; This is allowed because we are only interested in the two separate maxima.
  ;; Think of two different machines computing the two maxima in parallel.
  (let ((max-depth-1 0) (max-depth-2 0) ; Maximum-Depth so far
        (unseen-label-alist '()) ; Labels, that have not yet been tracked
        (seen-label-alist '()) ; Labels, that have already been tracked
         ;; both Alists ((label . depth) ...)
         ;; It is absolutely possible, that the same code-piece can be executed
         ;; with different SP-Depths (namely, when it ends with
         ;; a leaving-jump THROW, RETURN-FROM, RETURN-FROM-I, GO, GO-I
         ;; or BARRIER)!
         ;; seen-label-alist contains for each label the maximum-depth, with
         ;; which the tracking took place beginning from this Label.
         ;; unseen-label-alist contains for each Label the maximum noted
         ;; depth so far, with which tracking has still to take place
         ;; beginning from this label.
        (middle code-list) ; remaining code-list
        (depth (spd 0 0))) ; current depth
    (macrolet ((check-depth (wanted-depth)
                 ;; checks, if depth equals the depth wanted-depth
                 `(unless (equal depth ,wanted-depth)
                    (compiler-error 'SP-depth (cons depth ,wanted-depth)))))
      (loop
        ;; middle traverses the code-list, from the current position
        ;; to the next leaving-jump, and counts the depth.
        (loop
          (when (null middle) (return))
          (let ((item (car middle)))
            (if (atom item)
              ;; Label
              (let ((h (assoc item seen-label-alist)))
                (if h
                  (if (spd<= depth (cdr h))
                    (return)
                    (setf (cdr h) (setf depth (spdmax depth (cdr h)))))
                  (push (cons item depth) seen-label-alist)))
              ;; Instruction
              (macrolet ((note-label (labelform)
                           ; notice, that label can be reached by jump
                           (let ((label (gensym)))
                             `(let* ((,label ,labelform)
                                     (h (assoc ,label seen-label-alist)))
                                (unless (and h (spd<= depth (cdr h)))
                                  (let ((depth
                                          (if h (spdmax depth (cdr h)) depth)))
                                    (setq h (assoc ,label unseen-label-alist))
                                    (if h
                                      (unless (spd<= depth (cdr h))
                                        (setf (cdr h) (spdmax depth (cdr h))))
                                      (push (cons ,label depth)
                                            unseen-label-alist)))))))
                         (note-inc (amount)
                           ;; notice, that depth can be increased by amount
                           `(progn
                             (setq depth (spd+ depth ,amount))
                             (setq max-depth-1 (max max-depth-1 (car depth)))
                             (setq max-depth-2 (max max-depth-2 (cdr depth)))))
                         (note-dec (amount)
                           ;; notice, that depth can be decreased by amount
                           `(progn
                              (setq depth (spd- depth ,amount))
                              (when (or (minusp (car depth))
                                        (minusp (cdr depth)))
                                (compiler-error 'SP-depth "<0"))))
                         (note-jmp ()
                           ;; notice leaving-jump
                           `(return)))
                (case (first item)
                  (JMP ; (JMP label)
                    (note-label (second item))
                    (note-jmp))
                  ((JMPIF JMPIF1 JMPIFNOT JMPIFNOT1) ; (JMP... label)
                    (note-label (second item)))
                  (JMPIFBOUNDP ; (JMPIFBOUNDP n label)
                    (note-label (third item)))
                  ((JMPHASH JMPHASHV JMPTAIL) ; (JMPHASH.. n ht label . labels), (JMPTAIL m n label)
                    (dolist (label (cdddr item)) (note-label label))
                    (note-jmp))
                  (JSR ; (JSR n label)
                    (let ((depth (spd 0 0))) (note-label (third item))))
                  ((BARRIER THROW RETURN-FROM RETURN-FROM-I GO GO-I) ; (BARRIER), (THROW), (RETURN-FROM n), (RETURN-FROM-I k n), (GO n l), (GO-I k n l)
                    (note-jmp))
                  ((RET RETGF) ; (RET), (RETGF)
                    (check-depth (spd 0 0))
                    (note-jmp))
                  (PROGV ; (PROGV)
                    (note-inc (spd 1 0)))
                  (CATCH-OPEN ; (CATCH-OPEN label)
                    (note-label (second item))
                    (note-inc (spd 2 1)))
                  (CATCH-CLOSE ; (CATCH-CLOSE)
                    (note-dec (spd 2 1)))
                  (UNWIND-PROTECT-OPEN ; (UNWIND-PROTECT-OPEN label)
                    ; actually: (note-inc (spd 2 1))
                    (note-inc (spd 3 0)) (note-label (second item))
                    (note-dec (spd 3 0)) (note-inc (spd 2 1)))
                  (UNWIND-PROTECT-NORMAL-EXIT ; (UNWIND-PROTECT-NORMAL-EXIT), then comes label
                    (note-dec (spd 2 1)) (note-inc (spd 3 0)))
                  (UNWIND-PROTECT-CLOSE ; (UNWIND-PROTECT-CLOSE label)
                    ; actually: (note-dec (spd 3 0))
                    (note-label (second item)) (note-dec (spd 3 0)))
                  (UNWIND-PROTECT-CLEANUP ; (UNWIND-PROTECT-CLEANUP)
                    ; actually: (note-dec (spd 2 1)) (note-inc (spd 3 0)) ... (note-dec (spd 3 0))
                    (note-dec (spd 2 1)))
                  (BLOCK-OPEN ; (BLOCK-OPEN n label)
                    (note-label (third item))
                    (note-inc (spd 2 1)))
                  (BLOCK-CLOSE ; (BLOCK-CLOSE)
                    (note-dec (spd 2 1)))
                  (TAGBODY-OPEN ; (TAGBODY-OPEN n label1 ... labelm)
                    (note-inc (spd 1 1))
                    (dolist (label (cddr item)) (note-label label)))
                  ((TAGBODY-CLOSE-NIL TAGBODY-CLOSE) ; (TAGBODY-CLOSE-NIL), (TAGBODY-CLOSE)
                    (note-dec (spd 1 1)))
                  (HANDLER-OPEN ; (HANDLER-OPEN n v k label1 ... labelm)
                    (check-depth (fourth item))
                    (dolist (label (cddddr item)) (note-label label)))
                  ((MVCALLP HANDLER-BEGIN) ; (MVCALLP), (HANDLER-BEGIN)
                    (note-inc (spd 1 0)))
                  (MVCALL ; (MVCALL)
                    (note-dec (spd 1 0)))
                  (SKIPSP ; (SKIPSP k1 k2)
                    (note-dec (spd (second item) (third item))))
                  (SKIPI ; (SKIPI k1 k2 n)
                    (note-dec (spd (+ (second item) 1) (third item))))))))
          (setq middle (cdr middle)))
        ;; search next label to track:
        (loop
          (when (null unseen-label-alist) ; finished?
            (return-from SP-depth (spd max-depth-1 max-depth-2)))
          (let* ((unseen (pop unseen-label-alist))
                 (label (car unseen))) ; next label to track
            (unless (symbolp label) (compiler-error 'SP-depth "BAD LABEL"))
            (setq depth (cdr unseen))
            (let ((h (assoc label seen-label-alist)))
              (unless (and h (spd<= depth (cdr h)))
                (when h (setq depth (spdmax depth (cdr h))))
                ;; Starting at this label, process the code-list:
                ;; (Thereby (label . depth) is added to seen-label-alist,
                ;; it is already removed from unseen-label-alist.)
                (setq middle (memq label code-list))
                (return)))))))))


#|
                            6. Step:
                 Introduction of Short-Operations

This step works on the code-list and changes is destructively.

1. (ATOM) (JMPIF label NIL)             --> (JMPIFATOM label)
   (ATOM) (JMPIFNOT label NIL)          --> (JMPIFCONSP label)
   (CONSP) (JMPIF label NIL)            --> (JMPIFCONSP label)
   (CONSP) (JMPIFNOT label NIL)         --> (JMPIFATOM label)
   (ATOM)                               --> (PUSH) (CALLS ATOM)
   (CONSP)                              --> (PUSH) (CALLS CONSP)

2. (NIL) (PUSH)                         --> (NIL&PUSH)
   (NIL) (PUSH) ... (NIL) (PUSH)        --> (PUSH-NIL n)
   (NIL) (STORE n)                      --> (NIL&STORE n)
   (PUSH-NIL 1)                         --> (NIL&PUSH)

3. (T) (PUSH)                           --> (T&PUSH)
   (T) (STORE n)                        --> (T&STORE n)

4. (CONST n c)                          --> (CONST n)
   (CONST n) (PUSH)                     --> (CONST&PUSH n)
   (CONST n) (SYMBOL-FUNCTION denv) (PUSH)    --> (CONST&SYMBOL-FUNCTION&PUSH n)
   (CONST n) (SYMBOL-FUNCTION denv) (STORE m) --> (CONST&SYMBOL-FUNCTION&STORE n m)
   (CONST n) (SYMBOL-FUNCTION denv)     --> (CONST&SYMBOL-FUNCTION n)

5. (COPY-CLOSURE n m) (PUSH)            --> (COPY-CLOSURE&PUSH n m)

6. (LOAD n) (PUSH)                      --> (LOAD&PUSH n)
   (LOAD k) (STOREC n m)                --> (LOAD&STOREC k n m)
   (LOAD n) (JMPIF label fv)            --> (LOAD&JMPIF n label)
   (LOAD n) (JMPIFNOT label fv)         --> (LOAD&JMPIFNOT n label)
   (LOAD n) (CAR denv) (PUSH)           --> (LOAD&CAR&PUSH n)
   (LOAD n) (CDR denv) (PUSH)           --> (LOAD&CDR&PUSH n)
   (LOAD n) (CDR denv) (STORE n)        --> (LOAD&CDR&STORE n)
   (LOAD n+1) (CONS) (STORE n)          --> (LOAD&CONS&STORE n)
   (LOAD n) (PUSH) (CALLS 1+) (STORE n) --> (LOAD&INC&STORE n)
   (LOAD n) (PUSH) (CALLS 1-) (STORE n) --> (LOAD&DEC&STORE n)
   (LOAD n) (PUSH) (CALLS 1+) (PUSH)    --> (LOAD&INC&PUSH n)
   (LOAD n) (PUSH) (CALLS 1-) (PUSH)    --> (LOAD&DEC&PUSH n)
   (LOAD n) (CAR denv) (STORE m)        --> (LOAD&CAR&STORE n m)

7. (JMPIFBOUNDP n l) (NIL) (STORE n) l  --> (UNBOUND->NIL n) l

8. (LOADI n1 n2 n3) (PUSH)              --> (LOADI&PUSH n1 n2 n3)
   (LOADC n1 n2) (PUSH)                 --> (LOADC&PUSH n1 n2)
   (LOADV n1 n2) (PUSH)                 --> (LOADV&PUSH n1 n2)

9. (GETVALUE n) (PUSH)                  --> (GETVALUE&PUSH n)

10. (UNBIND1) ... (UNBIND1)             --> (UNBIND n)

11. (CAR denv) (PUSH)                   --> (CAR&PUSH)
    (CDR denv) (PUSH)                   --> (CDR&PUSH)
    (CONS) (PUSH)                       --> (CONS&PUSH)
    (LIST n) (PUSH)                     --> (LIST&PUSH n)
    (LIST* n) (PUSH)                    --> (LIST*&PUSH n)
    (FUNCALL n) (PUS)                   --> (FUNCALL&PUSH n)
    (APPLY n) (PUSH)                    --> (APPLY&PUSH n)

12. (POP) (STORE n)                     --> (POP&STORE n)

13. (SKIP n) (RET)                      --> (SKIP&RET n)
    (SKIP n) (RETGF)                    --> (SKIP&RETGF n)
    (RET)                               --> (SKIP&RET 0)
    (RETGF)                             --> (SKIP&RETGF 0)
    ;; the last 2 can occur despite the Closure itself being still in
    ;; the STACK because the preceding SKIP might have been folded into
    ;; the previous SKIPI

14. (UNWIND-PROTECT-CLOSE label)        --> (UNWIND-PROTECT-CLOSE)

15. (JMPHASH n ht label . labels)       --> (JMPHASH n ht label)
    (JMPHASHV n ht label . labels)      --> (JMPHASHV n ht label)

16. (JSR n label)                       --> (JSR label)
    (JSR n label) (PUSH)                --> (JSR&PUSH label)

17. (CALL m n) (PUSH)                   --> (CALL&PUSH m n)
    (CALL1 n) (PUSH)                    --> (CALL1&PUSH n)
    (CALL2 n) (PUSH)                    --> (CALL2&PUSH n)
    (CALLS1 n) (PUSH)                   --> (CALLS1&PUSH n)
    (CALLS2 n) (PUSH)                   --> (CALLS2&PUSH n)
    (CALLSR m n) (PUSH)                 --> (CALLSR&PUSH m n)
    (CALLC) (PUSH)                      --> (CALLC&PUSH)
    (CALLCKEY) (PUSH)                   --> (CALLCKEY&PUSH)

18. (CALL1 n) (JMPIF label fv)          --> (CALL1&JMPIF n label)
    (CALL1 n) (JMPIFNOT label fv)       --> (CALL1&JMPIFNOT n label)
    (CALL2 n) (JMPIF label fv)          --> (CALL2&JMPIF n label)
    (CALL2 n) (JMPIFNOT label fv)       --> (CALL2&JMPIFNOT n label)
    (CALLS1 n) (JMPIF label fv)         --> (CALLS1&JMPIF n label)
    (CALLS1 n) (JMPIFNOT label fv)      --> (CALLS1&JMPIFNOT n label)
    (CALLS2 n) (JMPIF label fv)         --> (CALLS2&JMPIF n label)
    (CALLS2 n) (JMPIFNOT label fv)      --> (CALLS2&JMPIFNOT n label)
    (CALLSR m n) (JMPIF label fv)       --> (CALLSR&JMPIF m n label)
    (CALLSR m n) (JMPIFNOT label fv)    --> (CALLSR&JMPIFNOT m n label)

19. (CALLS1 n) (STORE k)                --> (CALLS1&STORE n k)
    (CALLS2 n) (STORE k)                --> (CALLS2&STORE n k)
    (CALLSR m n) (STORE k)              --> (CALLSR&STORE m n k)

20. (EQ) (JMPIF label NIL)              --> (JMPIFEQ label)
    (EQ) (JMPIFNOT label NIL)           --> (JMPIFNOTEQ label)
    (CONST n) (EQ) (JMPIF label NIL)    --> (JMPIFEQTO n label)
    (CONST n) (EQ) (JMPIFNOT label NIL) --> (JMPIFNOTEQTO n label)

21. (APPLY n) (SKIP k) (RET)            --> (APPLY&SKIP&RET n k)
    (FUNCALL n) (SKIP k) (RETGF)        --> (FUNCALL&SKIP&RETGF n k)

22. (HANDLER-BEGIN) (PUSH)              --> (HANDLER-BEGIN&PUSH)

23. (BARRIER)                           -->

|#

(defun insert-combined-LAPs (code-list)
  ;; First the ATOM/CONSP-Conversion, because it can introduce PUSHs:
  (do ((crest code-list (cdr crest)))
      ((null crest))
    (let ((item (car crest)))
      (when (consp item)
        (case (first item)
          (CONST ; (CONST n c) -> (CONST n)
           (setf (cddr item) '()))
          (HANDLER-BEGIN ; we have HANDLER-BEGIN&PUSH but not HANDLER-BEGIN
           (unless (eq (caadr crest) 'PUSH)
             (push '(POP) (cdr crest))
             (push '(PUSH) (cdr crest))))
          ((ATOM CONSP)
           (setq item (first item))
           (if (and #| (consp (cdr crest)) |#
                   (consp (cadr crest))
                   (memq (first (cadr crest)) '(JMPIF JMPIFNOT))
                   (null (third (cadr crest))))
             ;; e.g. (ATOM) (JMPIF label NIL) --> (JMPIFATOM label)
             (setf (car crest)
                   `(,(if (eq (first (cadr crest)) 'JMPIF)
                          (if (eq item 'ATOM) 'JMPIFATOM 'JMPIFCONSP)
                          (if (eq item 'ATOM) 'JMPIFCONSP 'JMPIFATOM))
                      ,(second (cadr crest)))
                   (cdr crest) (cddr crest))
             ;; e.g. (ATOM) --> (PUSH) (CALLS ATOM)
             (setf (car crest) '(PUSH)
                   (cdr crest) (cons (if (eq item 'ATOM)
                                       (CALLS-code-fun atom)
                                       (CALLS-code-fun consp))
                                     (cdr crest)))))))))
  ;; Now the other Conversions: One single run.
  ;; Two pointers loop through the code-list: ...middle.right...
  (do* ((middle code-list right)
        (right (cdr middle) (cdr right)))
       ((null middle))
    (macrolet ((ersetze (length new-code)
                 ;; replaces the next length elements
                 ;; (nth 0 middle) ... (nth (- length 1) middle)
                 ;; by one single element new-code.
                 (assert (typep length '(INTEGER 0 4)))
                 `(progn
                    ,(case length
                       (0 `(setf (cdr middle)
                                 (setq right (cons (car middle) right))
                                 (car middle) ,new-code))
                       (1 `(setf (car middle) ,new-code))
                       (t `(setf (car middle) ,new-code
                                 (cdr middle) (setq right
                                                    ,(case length
                                                       (2 '(cdr right))
                                                       (3 '(cddr right))
                                                       (4 '(cdddr right)))))))
                    (go next))))
      (let ((item (car middle)))
        (when (consp item)
          ;; analysis of the instruction item and the consecutive ones:
          (when (and #| (consp right) |# (consp (car right)))
            ;; normal conversions, with chaining of the arguments:
            (let ((new-op
                    (cdr (assoc (first item)
                                (case (first (car right))
                                  (PUSH  '((T        . T&PUSH)
                                           (CONST    . CONST&PUSH)
                                           (LOADI    . LOADI&PUSH)
                                           (LOADC    . LOADC&PUSH)
                                           (LOADV    . LOADV&PUSH)
                                           (GETVALUE . GETVALUE&PUSH)
                                           (CALL     . CALL&PUSH)
                                           (CALL1    . CALL1&PUSH)
                                           (CALL2    . CALL2&PUSH)
                                           (CALLS1   . CALLS1&PUSH)
                                           (CALLS2   . CALLS2&PUSH)
                                           (CALLSR   . CALLSR&PUSH)
                                           (CALLC    . CALLC&PUSH)
                                           (CALLCKEY . CALLCKEY&PUSH)
                                           (CAR      . CAR&PUSH)
                                           (CDR      . CDR&PUSH)
                                           (CONS     . CONS&PUSH)
                                           (LIST     . LIST&PUSH)
                                           (LIST*    . LIST*&PUSH)
                                           (FUNCALL  . FUNCALL&PUSH)
                                           (APPLY    . APPLY&PUSH)
                                           (COPY-CLOSURE . COPY-CLOSURE&PUSH)
                                           (HANDLER-BEGIN . HANDLER-BEGIN&PUSH)))
                                  (JMPIF
                                   (let ((alist
                                           '((EQ     . JMPIFEQ)
                                             (LOAD   . LOAD&JMPIF)
                                             (CALL1  . CALL1&JMPIF)
                                             (CALL2  . CALL2&JMPIF)
                                             (CALLS1 . CALLS1&JMPIF)
                                             (CALLS2 . CALLS2&JMPIF)
                                             (CALLSR . CALLSR&JMPIF))))
                                     (when (third (car right))
                                       (setq alist (cdr alist)))
                                     (setf (cddr (car right)) '())
                                     alist))
                                  (JMPIFNOT
                                   (let ((alist
                                           '((EQ     . JMPIFNOTEQ)
                                             (LOAD   . LOAD&JMPIFNOT)
                                             (CALL1  . CALL1&JMPIFNOT)
                                             (CALL2  . CALL2&JMPIFNOT)
                                             (CALLS1 . CALLS1&JMPIFNOT)
                                             (CALLS2 . CALLS2&JMPIFNOT)
                                             (CALLSR . CALLSR&JMPIFNOT))))
                                     (when (third (car right))
                                       (setq alist (cdr alist)))
                                     (setf (cddr (car right)) '())
                                     alist))
                                 (STORE '((NIL    . NIL&STORE)
                                          (T      . T&STORE)
                                          (POP    . POP&STORE)
                                          (CALLS1 . CALLS1&STORE)
                                          (CALLS2 . CALLS2&STORE)
                                          (CALLSR . CALLSR&STORE)))
                                 (STOREC '((LOAD . LOAD&STOREC)))
                                 (RET '((SKIP . SKIP&RET)))
                                 (RETGF '((SKIP . SKIP&RETGF))))
                               :test #'eq))))
              (when new-op
                (ersetze 2 `(,new-op ,@(rest item) ,@(rest (car right)))))))
          ;; further conversions:
          (case (first item)
            ((NIL PUSH-NIL)
             (flet ((nilpusher-p (coder)
                      ;; if (NIL) (PUSH) --> 1,
                      ;; if (PUSH-NIL n) --> n,
                      ;; else nil.
                      (and #| (consp coder) |# (consp (car coder))
                           (case (first (car coder))
                             (PUSH-NIL (second (car coder)))
                             ((NIL) (when (equal (cadr coder) '(PUSH))
                                      (setf (cdr coder) (cddr coder))
                                      1))
                             (t nil)))))
               (let ((count (nilpusher-p middle)))
                 (when count
                   (setq right (cdr middle))
                   (loop
                     (let ((next-count (nilpusher-p right)))
                       (unless next-count (return))
                       (incf count next-count))
                     (setq right (cdr right)))
                   (setf (car middle)
                         (if (eql count 1) '(NIL&PUSH) `(PUSH-NIL ,count))
                         (cdr middle) right)))))
            (CONST
             (when (and #| (consp right) |# (consp (car right)))
               (case (first (car right))
                 (SYMBOL-FUNCTION
                  (let ((n (second item)))
                    (cond ((and #| (consp (cdr right)) |#
                            (equal (cadr right) '(PUSH)))
                           (ersetze 3 `(CONST&SYMBOL-FUNCTION&PUSH ,n)))
                          ((and #| (consp (cdr right)) |#
                            (consp (cadr right))
                            (eq (first (cadr right)) 'STORE))
                           (ersetze 3 `(CONST&SYMBOL-FUNCTION&STORE
                                        ,n ,(second (cadr right)))))
                          (t (ersetze 2 `(CONST&SYMBOL-FUNCTION ,n))))))
                 (EQ
                  (when (and #| (consp (cdr right)) |#
                             (consp (cadr right))
                             (memq (first (cadr right)) '(JMPIF JMPIFNOT))
                             (null (third (cadr right))))
                    (ersetze 3 `(,(if (eq (first (cadr right)) 'JMPIF)
                                    'JMPIFEQTO
                                    'JMPIFNOTEQTO)
                                 ,(second item)
                                 ,(second (cadr right)))))))))
            (LOAD
             (when (and #| (consp right) |# (consp (car right)))
               (let ((n (second item)))
                 (case (first (car right))
                   (CAR
                    (when (and #| (consp (cdr right)) |# (consp (cadr right)))
                      (case (first (cadr right))
                        (PUSH (ersetze 3 `(LOAD&CAR&PUSH ,n)))
                        (STORE
                         (ersetze 3 `(LOAD&CAR&STORE
                                      ,n ,(second (cadr right))))))))
                   (CDR
                    (when (and #| (consp (cdr right)) |# (consp (cadr right)))
                      (case (first (cadr right))
                        (PUSH (ersetze 3 `(LOAD&CDR&PUSH ,n)))
                        (STORE
                         (when (eql n (second (cadr right)))
                           (ersetze 3 `(LOAD&CDR&STORE ,n)))))))
                   (CONS
                    (when (and #| (consp (cdr right)) |# (consp (cadr right))
                               (eq (first (cadr right)) 'STORE)
                               (eql (second (cadr right)) (- n 1)))
                      (ersetze 3 `(LOAD&CONS&STORE ,(- n 1)))))
                   (PUSH
                    (when (and #| (consp (cdr right)) |# (consp (cadr right))
                               (or (equal (cadr right) (CALLS-code-fun 1+))
                                   (equal (cadr right) (CALLS-code-fun 1-)))
                               #| (consp (cddr right)) |# (consp (caddr right)))
                      (when (equal (caddr right) '(PUSH))
                        (ersetze 4 `(,(if (equal (cadr right)
                                                 (CALLS-code-fun 1+))
                                        'LOAD&INC&PUSH
                                        'LOAD&DEC&PUSH)
                                      ,n)))
                      (when (and (eq (first (caddr right)) 'STORE)
                                 (eql (second (caddr right)) n))
                        (ersetze 4 `(,(if (equal (cadr right)
                                                 (CALLS-code-fun 1+))
                                        'LOAD&INC&STORE
                                        'LOAD&DEC&STORE)
                                      ,n))))
                    (ersetze 2 `(LOAD&PUSH ,n)))))))
            (JMPIFBOUNDP ; simplify (JMPIFBOUNDP n l) (NIL) (STORE n) l
             (when (and #| (consp right) |#
                        (equal (car right) '(NIL))
                        #| (consp (cdr right)) |#
                        (consp (cadr right))
                        (eq (first (cadr right)) 'STORE)
                        (eql (second (cadr right)) (second item))
                        #| (consp (cddr right)) |#
                        (eq (caddr right) (third item)))
               (ersetze 3 `(UNBOUND->NIL ,(second item)))))
            (JSR
             (if (and #| (consp right) |# (equal (car right) '(PUSH)))
               (ersetze 2 `(JSR&PUSH ,(third item)))
               (ersetze 1 `(JSR ,(third item)))))
            (UNBIND1
             (let ((count 1))
               (loop
                 (unless (and #| (consp right) |#
                              (equal (car right) '(UNBIND1)))
                   (return))
                 (incf count)
                 (setq right (cdr right)))
               (unless (eql count 1)
                 (setf (car middle) `(UNBIND ,count))
                 (setf (cdr middle) right))))
            ;; We need these two rules because (RET) and (RETGF) are not
            ;; always preceded by (SKIP n); they can also be preceded by
            ;; (SKIPI k1 k2 n) with n >= 1.
            (RET (ersetze 1 '(SKIP&RET 0)))
            (RETGF (ersetze 1 '(SKIP&RETGF 0)))
            (UNWIND-PROTECT-CLOSE (ersetze 1 '(UNWIND-PROTECT-CLOSE)))
            ((JMPIF JMPIFNOT) (ersetze 1 `(,(first item) ,(second item))))
            ((JMPHASH JMPHASHV)
             (let ((hashtable (third item))
                   (labels (cddddr item)))
               (maphash
                #'(lambda (obj index) ; (gethash obj hashtable) = index
                    (setf (gethash obj hashtable) (nth index labels)))
                hashtable))
             (setf (cddddr item) '()))
            (HANDLER-OPEN
             (do ((v (third item))
                  (labels (cddddr item) (cdr labels))
                  (i 1 (+ i 2)))
                 ((null labels))
               (setf (svref v i) (car labels)))
             (setf (cdddr item) '()))
            (APPLY
             (when (and #| (consp right) |#
                        (consp (car right))
                        (eq (first (car right)) 'SKIP)
                        #| (consp (cdr right)) |#
                        (equal (cadr right) '(RET)))
               (ersetze 3 `(APPLY&SKIP&RET ,(second item)
                                           ,(second (car right))))))
            (FUNCALL
             (when (and #| (consp right) |#
                        (consp (car right))
                        (eq (first (car right)) 'SKIP)
                        #| (consp (cdr right)) |#
                        (equal (cadr right) '(RETGF)))
               (ersetze 3 `(FUNCALL&SKIP&RETGF ,(second item)
                                               ,(second (car right))))))))))
   next ; Here we are finished with (car middle) .
    (when (equal (car right) '(BARRIER))
      ;; discard element (car right)
      (setf (cdr middle) (setq right (cdr right)))))
  code-list)


#|
                                7. Step:
                Conversion of Instructions into a Byte-Sequence

First sub-step: each instruction is prepended by a classification of the
instruction and the length of the instruction (Label-Operands not counted),
each Label is assigned its PC as value.
The operand-lenghts - as far as possible - are determined, Labels occurring in
instructions are replaced by (presumable reference-length . label) .
Thus (BLOCK-OPEN 2 #:G7) --> (NL 2 . (67 2 (1 . #:G7))) .
Further sub-steps:
The code-list is looped over and over again,
with lengthening the jump-references possibly from 1 to 2 or 6 Byte.
Here the code can only be lenghtened, altogether.
Last sub-step:
The jump-references are transformed into distances, and the code-list is
freshly rebuilt as list of bytes.
|#
;; indicates, how many bytes a numeric operand needs:
(defun num-operand-length (n)
  (cond ((< n 128) 1) ; 7 Bit in 1 Byte
        ((< n 32768) 2) ; 15 Bit in 2 Bytes
        (t 6))) ; else 6 Bytes
(defun signed-operand-length (n)
  (cond ((<= -64 n 63) 1) ; 7 Bits in 1 Byte
        ((<= -16384 n 16383) 2) ; 15 Bits in 2 Bytes
        (t 6))) ; else 32 Bits in 6 Bytes
;; assembles a Code-List and returns the Bytecode-List:
(defun assemble-LAP (code-list)
  ; first sub-step:
  (do ((code-listr code-list (cdr code-listr))
       (PC 0))
      ((null code-listr))
    (let ((item (car code-listr)))
      (if (atom item)
        (setf (symbol-value item) PC)
        (let ((instr-code (gethash (first item) instruction-codes)))
          (unless instr-code (compiler-error 'assemble-LAP item))
          (let ((instr-class (second (svref instruction-table instr-code)))
                (instr-length 1))
            (if (and (eq instr-class 'K)
                     (< (second item)
                        (svref short-code-opsize
                               (position (first item) instruction-table-K))))
              (progn
                (setq instr-code
                  (+ (svref short-code-ops
                            (position (first item) instruction-table-K))
                     (second item)))
                (setq instr-class 'O)
                (setq item (list (first item))))
              (case instr-class
                (O)
                ((K N NC) (incf instr-length (num-operand-length
                                              (second item))))
                (B (incf instr-length 1))
                (L (incf PC 1) (push 1 (second item)))
                (NN (incf instr-length (num-operand-length (second item)))
                    (incf instr-length (num-operand-length (third item))))
                (NB (incf instr-length (num-operand-length (second item)))
                    (incf instr-length 1))
                (BN (incf instr-length 1)
                    (incf instr-length (num-operand-length (third item))))
                (NNN (incf instr-length (num-operand-length (second item)))
                     (incf instr-length (num-operand-length (third item)))
                     (incf instr-length (num-operand-length (fourth item))))
                (NBN (incf instr-length (num-operand-length (second item)))
                     (incf instr-length 1)
                     (incf instr-length (num-operand-length (fourth item))))
                (NNNN (incf instr-length (num-operand-length (second item)))
                      (incf instr-length (num-operand-length (third item)))
                      (incf instr-length (num-operand-length (fourth item)))
                      (incf instr-length (num-operand-length (fifth item))))
                (NL (incf instr-length (num-operand-length (second item)))
                    (incf PC 1) (push 1 (third item)))
                (BL (incf instr-length 1)
                    (incf PC 1) (push 1 (third item)))
                (NNL (incf instr-length (num-operand-length (second item)))
                     (incf instr-length (num-operand-length (third item)))
                     (incf PC 1) (push 1 (fourth item)))
                (NBL (incf instr-length (num-operand-length (second item)))
                     (incf instr-length 1)
                     (incf PC 1) (push 1 (fourth item)))
                (NHL (incf instr-length (num-operand-length (second item)))
                     (incf PC 1) (push 1 (fourth item)))
                (NLX (incf instr-length (num-operand-length (second item)))
                     (do ((L (cddr item) (cdr L)))
                         ((null L))
                       (incf PC 1) (push 1 (car L))))))
            (incf PC instr-length)
            (setf (car code-listr)
              (list* instr-class instr-length instr-code (cdr item))))))))
  ;; Further sub-steps.
  ;; Here we stretch the code by making the jump lengths longer, as needed.
  (loop
    ;; When there are no more changes in this step, the jump lengths are
    ;; optimal.
    (unless
      (let ((modified nil) (oldPC 0) (PC 0))
        (dolist (item code-list)
          (if (atom item)
            (progn
              (setf (symbol-value item) PC)
              (setf (get item 'seen) t))
            (progn
              (incf oldPC (cadr item))
              (incf PC (cadr item))
              (when (memq (car item) '(L NL BL NNL NBL NHL NLX))
                (let ((itemargs (cdddr item)))
                  (dolist (x (case (car item)
                               (L itemargs)
                               ((NL BL NLX) (cdr itemargs))
                               ((NNL NBL NHL) (cddr itemargs))))
                    (incf oldPC (car x))
                    (incf PC (car x))
                    (let* ((targetlabel (cdr x))
                           (targetPC
                             (if (get targetlabel 'seen)
                               ; backward jump: targetlabel already updated
                               (symbol-value targetlabel)
                               ; forward jump: use minimal estimate
                               (+ (symbol-value targetlabel) (- PC oldPC))))
                           (new-dist (- targetPC PC))
                           (new-jump-length (signed-operand-length new-dist))
                           (jump-length-diff (- new-jump-length (car x))))
                      ;; Synchronize the so far assumed jump-length and
                      ;; the newly calculated one.
                      ;; We have started with jumps of length 1 in the first
                      ;; sub-step, therefore the jump-lengths can increase.
                      ;; They cannot decrease.
                      (when (minusp jump-length-diff)
                        (compiler-error 'assemble-LAP "STRETCH < 0"))
                      (when (plusp jump-length-diff)
                        (setq modified t)
                        (incf PC jump-length-diff)
                        (setf (car x) new-jump-length)))))))))
        (dolist (item code-list)
          (when (atom item)
            (remprop item 'seen)))
        modified)
      (return)))
  ;; last sub-step:
  (let ((byte-list '()) (PC 0))
    (flet ((new-byte (n) (push n byte-list)))
      (flet ((num-operand (n)
               (cond ((< n 128) (new-byte n))
                     ((< n 32768) (new-byte (+ 128 (ldb (byte 7 8) n)))
                                  (new-byte (ldb (byte 8 0) n)))
                     (t (compiler-error 'assemble-LAP "15 BIT"))))
             (label-operand (x)
               (incf PC (car x))
               (let ((dist (- (symbol-value (cdr x)) PC)))
                 (case (car x)
                   (1 (new-byte (ldb (byte 7 0) dist)))
                   (2 (when (zerop dist)
                        (compiler-error 'assemble-LAP "ZERO JUMP"))
                      (new-byte (+ 128 (ldb (byte 7 8) dist)))
                      (new-byte (ldb (byte 8 0) dist)))
                   (6 (new-byte 128) (new-byte 0)
                      (new-byte (ldb (byte 8 24) dist))
                      (new-byte (ldb (byte 8 16) dist))
                      (new-byte (ldb (byte 8 8) dist))
                      (new-byte (ldb (byte 8 0) dist)))))))
        (dolist (item code-list)
          (when (consp item)
            (incf PC (cadr item))
            (new-byte (caddr item))
            (case (car item)
              (O) ; including the 1-Byte-Instructions of Type K
              ((K N) (num-operand (second (cddr item))))
              (B (new-byte (second (cddr item))))
              (L (label-operand (second (cddr item))))
              (NN (num-operand (second (cddr item)))
                  (num-operand (third (cddr item))))
              (NB (num-operand (second (cddr item)))
                  (new-byte (third (cddr item))))
              (BN (new-byte (second (cddr item)))
                  (num-operand (third (cddr item))))
              (NNN (num-operand (second (cddr item)))
                   (num-operand (third (cddr item)))
                   (num-operand (fourth (cddr item))))
              (NBN (num-operand (second (cddr item)))
                   (new-byte (third (cddr item)))
                   (num-operand (fourth (cddr item))))
              (NNNN (num-operand (second (cddr item)))
                    (num-operand (third (cddr item)))
                    (num-operand (fourth (cddr item)))
                    (num-operand (fifth (cddr item))))
              (NL (num-operand (second (cddr item)))
                  (label-operand (third (cddr item))))
              (BL (new-byte (second (cddr item)))
                  (label-operand (third (cddr item))))
              (NNL (num-operand (second (cddr item)))
                   (num-operand (third (cddr item)))
                   (label-operand (fourth (cddr item))))
              (NBL (num-operand (second (cddr item)))
                   (new-byte (third (cddr item)))
                   (label-operand (fourth (cddr item))))
              (NHL (num-operand (second (cddr item)))
                   (let ((ht (third (cddr item))))
                     (maphash
                       #'(lambda (obj x) ; x = (gethash obj ht)
                           (setf (gethash obj ht) (- (symbol-value x) PC)))
                       ht))
                   (label-operand (fourth (cddr item))))
              (NC (num-operand (second (cddr item)))
                  (let* ((v (third (cddr item)))
                         (m (length v)))
                    (do ((i 1 (+ i 2)))
                        ((>= i m))
                      (setf (svref v i) (symbol-value (svref v i))))))
              (NLX (num-operand (second (cddr item)))
                   (dolist (x (cddr (cddr item))) (label-operand x))))))))
    (nreverse byte-list)))

;; the reversion of assemble-LAP : returns for a bytecode-list the belonging
;; code-list. In this, however, each item is prepended by the PC.
(defun disassemble-LAP (byte-list const-list)
  (let ((code-list '()) (PC 0) instr-PC (label-alist '()))
    ; label-alist is a list of Conses (PC . label), in which the PCs are in
    ; strictly decreasing order.
    (flet ((PC->label-a (PC)
             (cons PC (make-symbol (string-concat "L" (prin1-to-string PC)))))
           (next-byte () (incf PC) (pop byte-list)))
      (flet ((num-operand ()
               (let ((a (next-byte)))
                 (cond ((< a 128) a)
                       (t (+ (* 256 (- a 128)) (next-byte))))))
             (label-operand
                  (&optional
                    (dist
                      (let ((a (next-byte)))
                        (cond ((< a 128) (if (< a 64) a (- a 128)))
                              (t (setq a (- a 128))
                                 (unless (< a 64) (setq a (- a 128)))
                                 (setq a (+ (* 256 a) (next-byte)))
                                 (if (zerop a)
                                   (+ (* 256 (+ (* 256 (+ (* 256 (next-byte))
                                                          (next-byte)))
                                                (next-byte)))
                                      (next-byte))
                                   a)))))
                    (label-PC (+ PC dist)))
               ;; search label-PC in label-alist:
               (do* ((L1 nil L2)
                     (L2 label-alist (cdr L2))) ; L1 = nil or L2 = (cdr L1)
                    ((cond
                       ((or (null L2) (> label-PC (caar L2))) ; insert
                        (setq L2 (cons (PC->label-a label-PC) L2))
                        (if L1 (setf (cdr L1) L2) (setq label-alist L2))
                        t)
                       ((= label-PC (caar L2)) t)
                       (t nil))
                     (cdar L2)))))
        (loop
          (when (null byte-list) (return))
          (setq instr-PC PC) ; PC at the start of the instruction
          (let ((instruction
                  (let ((instr-code (next-byte)))
                    (if (>= instr-code short-code-base)
                      (let* ((q (position instr-code short-code-ops
                                          :test #'>= :from-end t))
                             (r (- instr-code (svref short-code-ops q))))
                        (list (svref instruction-table-K q) r))
                      (let* ((table-entry (svref instruction-table instr-code))
                             (instr-name (first table-entry)))
                        (case (second table-entry)
                          (O (list instr-name))
                          ((K N) (list instr-name (num-operand)))
                          (B (list instr-name (next-byte)))
                          (L (list instr-name (label-operand)))
                          (NN (list instr-name (num-operand) (num-operand)))
                          (NB (list instr-name (num-operand) (next-byte)))
                          (BN (list instr-name (next-byte) (num-operand)))
                          (NNN (list instr-name (num-operand) (num-operand) (num-operand)))
                          (NBN (list instr-name (num-operand) (next-byte) (num-operand)))
                          (NNNN (list instr-name (num-operand) (num-operand) (num-operand) (num-operand)))
                          (NL (list instr-name (num-operand) (label-operand)))
                          (BL (list instr-name (next-byte) (label-operand)))
                          (NNL (list instr-name (num-operand) (num-operand) (label-operand)))
                          (NBL (list instr-name (num-operand) (next-byte) (label-operand)))
                          (NHL (let* ((n (num-operand))
                                      (ht (if (eq instr-name 'JMPHASH)
                                            (nth n const-list) ; JMPHASH
                                            (svref (first const-list) n))) ; JMPHASHV
                                      (labels '()))
                                 (maphash
                                   #'(lambda (obj dist)
                                       (declare (ignore obj))
                                       (push (label-operand dist) labels))
                                   ht)
                                 (list* instr-name n (label-operand) labels)))
                          (NC (let* ((n (num-operand))
                                     (v (car (nth n const-list)))
                                     (m (length v))
                                     (labels '()))
                                (do ((i 1 (+ i 2)))
                                    ((>= i m))
                                  (push (label-operand nil (svref v i))
                                        labels))
                                (list* instr-name n (nreverse labels))))
                          (NLX (let* ((n (num-operand))
                                      (m (length (nth n const-list)))
                                      (L '()))
                                 (dotimes (i m) (push (label-operand) L))
                                 (list* instr-name n (nreverse L))))))))))
            (push (cons instr-PC instruction) code-list)))))
    ;; (setq label-alist (sort label-alist #'> :key #'car))
    ;; reverse code-list and insert the Labels:
    (let ((new-code-list '()))
      (loop
        (when (and new-code-list label-alist
                   (= (caar new-code-list) (caar label-alist)))
          (push (car label-alist) new-code-list)
          (setq label-alist (cdr label-alist)))
        (when (null code-list) (return))
        ;; transfer an instruction from code-list to new-code-list:
        (psetq code-list (cdr code-list)
               new-code-list (rplacd code-list new-code-list)))
      new-code-list)))


#|
                           8th Step:
                    create functional object

The function make-closure is required.
|#
(defun non-user-symbol-p (sym)
  (let ((package (symbol-package sym)))
    (or (null package) (eq package #,(find-package "SYSTEM")))))
(defun generatedp (fname lambda-list)
  (or (null fname)              ; no name
      (keywordp fname)          ; :lambda
      (and (symbolp fname) (non-user-symbol-p fname)) ; gensym
      (and (consp fname) (non-user-symbol-p (second fname))) ; (setf gensym)
      (and (not (eq 'SYSTEM::<MACRO-FORM> (first lambda-list))) ; macroexpander
           (some #'(lambda (arg) (and (symbolp arg) (non-user-symbol-p arg)))
                 lambda-list)))) ; gensyms in lambda-list
;; enters a byte-list as Code into fnode.
(defun create-fun-obj (fnode byte-list SPdepth
                       &aux (fname (fnode-name fnode)) (denv (fnode-denv fnode))
                            (lambda-list (fnode-lambda-list fnode))
                            (space (declared-optimize 'space denv))
                            (speed (declared-optimize 'speed denv))
                            (!generatedp (not (generatedp fname lambda-list))))
  (setf (fnode-code fnode)
    (make-closure
      :name fname
      :code
        (macrolet ((as-word (anz)
                     (if *big-endian*
                       ;; BIG-ENDIAN-Processor
                       `(floor ,anz 256)
                       ;; LITTLE-ENDIAN-Processor
                       `(multiple-value-bind (q r) (floor ,anz 256)
                         (values r q)))))
          (multiple-value-call #'list*
            (as-word (car SPdepth))
            (as-word (cdr SPdepth))
            (as-word (fnode-req-num fnode))
            (as-word (fnode-opt-num fnode))
            (+ (if (fnode-rest-flag fnode) 1 0)
               (if (fnode-gf-p fnode) 16 0)
               (if (fnode-keyword-flag fnode)
                 (+ 128 (if (fnode-allow-other-keys-flag fnode) 64 0))
                 0))
            (values ; argument-type-shortcut
              (let ((req-num (fnode-req-num fnode))
                    (opt-num (fnode-opt-num fnode))
                    (rest (fnode-rest-flag fnode))
                    (key (fnode-keyword-flag fnode)))
                (cond ((and (not rest) (not key) (< (+ req-num opt-num) 6))
                       (+ (svref '#(1 7 12 16 19 21) opt-num) req-num))
                      ((and rest (not key) (zerop opt-num) (< req-num 5))
                       (+ 22 req-num))
                      ((and (not rest) key (< (+ req-num opt-num) 5))
                       (+ (svref '#(27 32 36 39 41) opt-num) req-num))
                      (t 0))))
            (if (fnode-keyword-flag fnode)
              (multiple-value-call #'values
                (as-word (length (fnode-keywords fnode)))
                (as-word (fnode-Keyword-Offset fnode)))
              (values))
            byte-list))
      :constants
        (let ((l (append
                   (make-list (fnode-Keyword-Offset fnode))
                   (fnode-keywords fnode)
                   (if *fasoutput-stream* ; not called right away
                     (mapcar #'(lambda (value form)
                                 (if form (make-load-time-eval form) value))
                             (fnode-Consts fnode) (fnode-Consts-forms fnode))
                     (fnode-Consts fnode)))))
          (if (fnode-gf-p fnode)
            (list (coerce l 'simple-vector))
            l))
      :seclass (anode-seclass (fnode-code fnode))
      ;; no metadata for anonymous functions
      ;; NB: :lambda-list 0 ==> :documentation 0
      :lambda-list (if (and !generatedp (>= 2 space))
                       lambda-list
                       0)       ; discard
      :documentation (if (and !generatedp (>= 1 space))
                         (fnode-documentation fnode)
                         0)     ; discard
      :jitc-p (if (or (>= 0 space) (<= 1 speed))
                  1             ; allow
                  0)))          ; not allow
  fnode)

;; Return the signature of the byte-compiled function object
;; values:
;; 1. req-num
;; 2. opt-num
;; 3. rest-p
;; 4. key-p
;; 5. keyword-list
;; 6. allow-other-keys-p
;; additionally:
;; 7. byte-list
;; 8. const-list
(defun signature (closure)
  (let ((const-list (closure-consts closure))
        (byte-list (coerce (closure-codevec closure) 'list)))
    (macrolet ((pop2 (listvar)
                 (if *big-endian*
                   ; BIG-ENDIAN-Processor
                   `(+ (* 256 (pop ,listvar)) (pop ,listvar))
                   ; LITTLE-ENDIAN-Processor
                   `(+ (pop ,listvar) (* 256 (pop ,listvar))))))
      (pop byte-list) (pop byte-list)
      (pop byte-list) (pop byte-list)
      (let* ((req-num (pop2 byte-list))
             (opt-num (pop2 byte-list))
             (h (pop byte-list))
             (key-p (logbitp 7 h)))
        (pop byte-list)
        (values
          req-num
          opt-num
          (logbitp 0 h)
          key-p
          (when key-p
            (let ((kw-count (pop2 byte-list))
                  (kw-offset (pop2 byte-list)))
              (subseq (if (logbitp 4 h) ; generic function?
                        (coerce (first const-list) 'list)
                        const-list)
                      kw-offset (+ kw-offset kw-count))))
          (logbitp 6 h)
          byte-list
          const-list)))))


;;;;****                  THIRD    PASS

(defun pass3 ()
  (dolist (pair *fnode-fixup-table*)
    (let ((code (fnode-code (first pair))) (n (second pair)))
      (setf (closure-const code n) (fnode-code (closure-const code n))))))


;;;;****             TOP - LEVEL   CALL

;;; compile a lambdabody and return its code.
(defun compile-lambdabody (name lambdabody)
  (let* ((*fnode-list* '())
         (fnode (c-lambdabody name lambdabody)))
    (assert (null (fnode-far-used-vars fnode)))
    (assert (null (fnode-far-assigned-vars fnode)))
    (assert (null (fnode-far-used-blocks fnode)))
    (assert (null (fnode-far-used-tagbodys fnode)))
    (unless *no-code*
      (let ((*fnode-fixup-table* '()))
        (pass2 fnode)
        (pass3))
      (when *compiling-from-file*
        (let ((kf (assoc name *known-functions* :test #'equal)))
          (when kf ; save seclass for other functions in the file
            (setf (fourth kf) (function-side-effect (fnode-code fnode))))))
      (dolist (fnode *fnode-list*)
        (let ((name (fnode-name fnode)))
          (unless (or (null (fnode-enclosing fnode))
                      (null (symbol-package (if (atom name)
                                                name (second name))))
                      (fnode-used fnode)
                      (fnode-ignore fnode)
                      (fnode-ignorable fnode))
            (c-style-warn (TEXT "function ~S is not used.~%Misspelled or missing IGNORE declaration?") name))))
      (fnode-code fnode))))

;; COMPILE-LAMBDA & COMPILE-FORM are "top-level", i.e., they bind all
;; compiler variables; they also cannot bind *COMPILING-FROM-FILE* to T
;; because they are called on (declare (compile))
;; this is why we need COMPILE-LAMBDA-HELPER: it will be called by
;; COMPILE-FORM-IN-TOPLEVEL-ENVIRONMENT, which has to bind
;; *COMPILING-FROM-FILE* to T so that the LOAD :COMPILING T would not complain
;; about functiond defined in one form which are calling each other

;; does everything compile-lambda does
;; except that it does not bind *compiling-from-file*
(proclaim '(inline compile-lambda-helper))
(defun compile-lambda-helper
    (name lambdabody %venv% %fenv% %benv% %genv% %denv% error-when-failed-p)
  (let ((*compiling* t)
        (*c-listing-output* nil)
        (*c-error-output* *error-output*)
        (*known-special-vars* '())
        (*constant-special-vars* '())
        (*func* nil)
        (*fenv* %fenv%)
        (*benv* %benv%)
        (*genv* %genv%)
        (*venv* %venv%)
        (*venvc* nil)
        (*denv* %denv%)
        (*error-count* 0) (*warning-count* 0) (*style-warning-count* 0)
        (*no-code* nil))
    (let ((funobj (compile-lambdabody name lambdabody)))
      (when (and error-when-failed-p (not (zerop *error-count*)))
        (let ((form (cons name lambdabody)))
          (error-of-type 'source-program-error
            :form form
            :detail form
            (TEXT "~S cannot be compiled") form)))
      funobj)))

;; is called for (lambda (...) (declare (compile)) ...) and returns a
;; functional object equivalent to this lambda-expression.
(defun compile-lambda (name lambdabody %venv% %fenv% %benv% %genv% %denv%
                       error-when-failed-p)
  (let ((*compiling-from-file* nil))
    (compile-lambda-helper name lambdabody %venv% %fenv% %benv% %genv% %denv%
                           error-when-failed-p)))

;; is called for (let/let*/multiple-value-bind ... (declare (compile)) ...)
;; and returns a functional object, that - called with 0 arguments -
;; executes this form.
(let ((form-count 0))
  (defun compile-form (form %venv% %fenv% %benv% %genv% %denv%
                       &optional (name (symbol-suffix '#:COMPILED-FORM
                                                      (incf form-count))))
    (compile-lambda name `(() ,form)
                    %venv% %fenv% %benv% %genv% %denv% nil))
  ;; compiles a form in the Toplevel-Environment - only for LOAD :COMPILING T
  (defun compile-form-in-toplevel-environment
      (form &optional (name (symbol-suffix '#:COMPILED-FORM (incf form-count)))
       &aux (env *toplevel-environment*))
    (let ((*compiling-from-file* t))
      (compile-lambda-helper name `(() ,form)
                             (svref env 0)    ; %venv%
                             (svref env 1)    ; %fenv%
                             (svref env 2)    ; %benv%
                             (svref env 3)    ; %genv%
                             (svref env 4)    ; %denv%
                             nil))))

;; Evaluates a form in an environment
(defun eval-env (form &optional (env *toplevel-environment*))
  (evalhook form nil nil env))

;; Common-Lisp-Function COMPILE
(defun compile (name &optional (definition nil svar)
                     &aux (macro-flag nil) (trace-flag nil) (save-flag nil)
                          (macro-lambda-list nil)
                #+clisp-debug (*form* definition))
  (setq name (check-function-name name 'compile))
  (let ((symbol (get-funname-symbol name)))
    (if svar
      ;; Re-Definition of name as function.
      (progn
        ;; if name is traced -> if previously a macro, first untrace.
        (when (and name (setq svar (get symbol 'sys::traced-definition)))
          (if (consp svar)
            (progn
              (warn (TEXT "~S: redefining ~S; it was traced!")
                    'compile name)
              (sys::untrace2 name))
            (setq trace-flag t)))
        (when (sys::%compiled-function-p definition)
          (warn #1=(TEXT "~S is already compiled.") definition)
          (when name
            (if trace-flag
              (setf (get symbol 'sys::traced-definition) definition)
              (setf (symbol-function symbol) definition)))
          (return-from compile (values (or name definition) nil nil)))
        (when name
          (setq save-flag
                (cons `(SETF (FDEFINITION ',name) ',definition)
                      sys::*toplevel-environment*))))
      ;; Compilation of the available Function-/Macro-Definition.
      (progn
        (unless (fboundp symbol)
          (error-of-type 'undefined-function
            :name name
            (TEXT "Undefined function ~S")
            name))
        (if (setq definition (get symbol 'sys::traced-definition))
          (setq trace-flag t)
          (setq definition (symbol-function symbol)))
        (when (macrop definition)
          (setq macro-flag t
                macro-lambda-list (macro-lambda-list definition)
                definition (macro-expander definition)))
        (when (sys::%compiled-function-p definition)
          (warn #1# name)
          (return-from compile (values (or name definition) nil nil)))))
    (unless (or (and (consp definition) (eq (car definition) 'lambda))
                (sys::closurep definition))
      (error-of-type 'error
        (TEXT "Not a lambda expression nor a function: ~S")
        definition))
    (flet ((closure-slot (obj num)
             (if (sys::closurep obj)
               (sys::%record-ref obj num)
               nil)))
      (let ((*compiling* t)
            (*error-count* 0)
            (*warning-count* 0)
            (*style-warning-count* 0)
            (*compiling-from-file* nil)
            (*c-listing-output* nil)
            (*fasoutput-stream* nil) ; compiled code may be called right away
            (*c-error-output* *error-output*)
            (*known-special-vars* '())
            (*constant-special-vars* '())
            (*func* nil)
            (*fenv* (closure-slot definition 5))
            (*benv* (closure-slot definition 6))
            (*genv* (closure-slot definition 7))
            (*venv* (closure-slot definition 4))
            (*venvc* nil)
            (*denv* (or (closure-slot definition 8)
                        *toplevel-denv*))
            (*no-code* nil))
        (let ((lambdabody (or (closure-slot definition 1)
                              (cdr definition))))
          (let ((funobj (compile-lambdabody name lambdabody)))
            ;; documentation in the closure might have been reset
            ;; and may now be different from the one in lambdabody
            (when funobj
              (sys::closure-set-documentation
               funobj (closure-slot definition 2)))
            (values
              (if (zerop *error-count*)
                (if name
                  (progn
                    (when macro-flag
                      (setq funobj (make-macro funobj (sys::maybe-arglist
                                                       macro-lambda-list))))
                    (if trace-flag
                      (setf (get symbol 'sys::traced-definition) funobj)
                      (setf (symbol-function symbol) funobj))
                    (when save-flag
                      (setf (get symbol 'sys::definition) save-flag))
                    name)
                  funobj)
                (compile-lambdabody '#:***COMPILED-WITH-ERRORS***
                  `((&REST ARGUMENTS) (DECLARE (IGNORE ARGUMENTS))
                    (COMPILED-WITH-ERRORS ',lambdabody))))
              (compile-warnings-p)
              (compile-failure-p))))))))

;; Signals an error.
(defun compiled-with-errors (lambdabody)
  (error-of-type 'source-program-error
    :form lambdabody
    :detail lambdabody
    (TEXT "A function compiled with errors cannot be executed.")))

;; Top-Level-Forms must be written solitary to the .fas-File,
;; because of the semantics of EVAL-WHEN and LOAD-TIME-VALUE.
;; As Top-Level-Forms can be split at EVAL-WHEN, PROGN and LOCALLY,
;; one has to use LET (), in order to circumvent this.

;; Compiles a Top-Level-Form for COMPILE-FILE. The *toplevel-name* is
;; mostly passed unchanged. *toplevel-for-value* indicates, if the value
;; is needed (for LOAD :PRINT T) or not.
(defvar *toplevel-name*)
(defvar *toplevel-for-value*)
(defun compile-toplevel-form (form &optional (*toplevel-name* *toplevel-name*))
  (unless form (return-from compile-toplevel-form))
  (catch 'c-error
    ;; CLtL2 p. 90: "Processing of top-level forms in the file compiler ..."
    ;; 1. step: macro expansion
    (if (atom form)
      (when (symbolp form)
        (multiple-value-bind (macrop expansion) (venv-search-macro form *venv*)
          (when macrop ; Symbol-Macro ?
            (return-from compile-toplevel-form
              (compile-toplevel-form expansion))))) ; -> expand
      (let ((fun (first form)))
        (when (symbolp fun)
          (multiple-value-bind (a m f1 f2 f3 f4) (fenv-search fun)
            (declare (ignore f2 f3 f4))
            (if (null a)
              ;; not defined locally
              (case fun
                (PROGN ; cf. c-PROGN
                 (test-list form 1)
                 (let ((L (cdr form))) ; List of Forms
                   (cond ((null L) (compile-toplevel-form 'NIL)) ; no Form
                         ((null (cdr L)) (compile-toplevel-form (car L))) ; exactly one Form
                         (t (let ((subform-count 0))
                              (do ((Lr L))
                                  ((null Lr))
                                (let* ((subform (pop Lr))
                                       (*toplevel-for-value*
                                         (and *toplevel-for-value* (null Lr))))
                                  (compile-toplevel-form
                                   subform
                                   (symbol-suffix *toplevel-name*
                                                  (incf subform-count)))))))))
                 (return-from compile-toplevel-form))
                ((LOCALLY EVAL-WHEN COMPILER-LET MACROLET SYMBOL-MACROLET
                  WITHOUT-PACKAGE-LOCK)
                 (let ((*form* form))
                   ;; call c-LOCALLY resp. c-EVAL-WHEN resp. c-COMPILER-LET
                   ;; resp. c-MACROLET resp. c-SYMBOL-MACROLET:
                   (funcall (gethash fun c-form-table)
                            #'compile-toplevel-form))
                 (return-from compile-toplevel-form))
                (t (when (macro-function fun) ; global Macro ?
                     (return-from compile-toplevel-form
                       (compile-toplevel-form
                         (mac-exp (macro-function fun) form))))))
              ;; defined locally
              (when (and m (null f1)) ; local Macro, but no local function
                (return-from compile-toplevel-form
                  (compile-toplevel-form (mac-exp m form)))))))))
    ;; 2. step: compile and write
    (when (and (not *toplevel-for-value*) (l-constantp form))
      (return-from compile-toplevel-form))
    (let ((*package-tasks* '()))
      (setq form
        (compile-lambdabody *toplevel-name*
          `(() ,form ,@(if *toplevel-for-value* '() '((VALUES))))))
      (when *c-listing-output*
        (disassemble-closures form *c-listing-output*))
      (when *fasoutput-stream*
        (write form :stream *fasoutput-stream* :pretty t
                  ; :closure t :circle t :array t :gensym t
                  ; :escape t :level nil :length nil :radix t
                    :readably t :right-margin 79)
        (terpri *fasoutput-stream*))
      (when (and *package-tasks-treat-specially* *package-tasks*)
        (c-eval-and-write-lib `(PROGN ,@(nreverse *package-tasks*)))))))

;; open C-Output-File, if not open yet:
(defun prepare-coutput-file ()
  (when (and *compiling-from-file* *coutput-file*)
    (unless *coutput-stream*
      (setq *coutput-stream* (open *coutput-file* :direction :output))
      (format *coutput-stream* "#include \"clisp.h\"~%~%"))
    t))
;; Hook for FFI:
(predefun finalize-coutput-file ())

(defun c-reset-globals ()
  ;; The global variables have to be assigned, not bound!
  (setq *functions-with-errors*  nil
        *known-special-vars*     nil
        *unknown-free-vars*      nil
        *constant-special-vars*  nil
        *known-functions*        nil
        *unknown-functions*      nil
        *deprecated-functions*   nil
        *inline-functions*       nil
        *notinline-functions*    nil
        *inline-definitions*     nil
        *inline-constants*       nil
        *notinline-constants*    nil
        *user-declaration-types* nil
        *compiled-modules*       nil))

;;; compare an element of `*unknown-functions*' with
;;; an element of `*known-functions*'
;;; returns T if the functions match, NIL otherwise
;;; this function should be suitable as a :test argument
;;; for `set-difference'
(defun match-known-unknown-functions (uf kf)
  ;; uf: (function c-source-point arglist . apply-arglist)
  ;; kf: (function c-source-point signature seclass)
  (when (equal (car uf) (car kf))
    (let ((*compile-file-lineno1* (c-source-point-lineno1 (second uf)))
          (*compile-file-lineno2* (c-source-point-lineno2 (second uf)))
          (*compile-file-truename* (c-source-point-file (second uf)))
          (known-sig (third kf)))
      (unless (or (null (cddr uf)) ; nothing to test
                  (test-argument-syntax (caddr uf) (cdddr uf) (car uf)
                                        (sig-req-num  known-sig)
                                        (sig-opt-num  known-sig)
                                        (sig-rest-p   known-sig)
                                        (sig-keys-p   known-sig)
                                        (sig-keywords known-sig)
                                        (sig-allow-p  known-sig))
                  (null (c-source-point-file (second kf))))
        (c-comment (TEXT "[~s was defined~a]")
                   (car kf) (c-source-point-location (second kf))))
      t)))

;; report the compilation problems accumulated so far and reset them
(defun c-report-problems ()
  (when *functions-with-errors*
    (c-comment (TEXT "There were errors in the following functions:~%~{~<~%~:; ~S~>~^~}")
               (nreverse *functions-with-errors*)))
  (setq *unknown-functions*
        (nset-difference *unknown-functions* *known-functions*
                         :test #'match-known-unknown-functions))
  (when *unknown-functions*
    (c-comment (TEXT "The following functions were used but not defined:~%~{~<~%~:; ~S~>~^~}")
               (delete-duplicates (mapcar #'car (nreverse *unknown-functions*))
                                  :test #'equal)))
  (let ((unknown-vars (set-difference *unknown-free-vars*
                                      *known-special-vars*))
        (too-late-vars (intersection *unknown-free-vars*
                                     *known-special-vars*)))
    (when unknown-vars
      (c-comment (TEXT "The following special variables were not defined:~%~{~<~%~:; ~S~>~^~}")
                 (nreverse unknown-vars)))
    (when too-late-vars
      (c-comment (TEXT "The following special variables were defined too late:~%~{~<~%~:; ~S~>~^~}")
                 (nreverse too-late-vars))))
  (when *deprecated-functions*
    (c-comment (TEXT "The following functions were used but are deprecated:~%~:{~<~%~:; ~S - ~@?~>~^~}")
               (mapcar #'(lambda (funname)
                           (assoc funname *deprecated-functions-alist* :test #'eq))
                       (nreverse *deprecated-functions*))))
  (when (boundp '*error-count*) ; then `*warning-count*' is bound too
    (c-comment (TEXT "~D error~:P, ~D warning~:P")
               *error-count* *warning-count*))
  ;; clean-up for the next compilation unit
  (c-reset-globals))

;; non-NIL means that the current compilation is the top call,
;; i.e., it will report the errors/warnings &c.
;; this is T inside the outer-most `with-compilation-unit'/`compile-file'
;; or when `with-compilation-unit' is given non-NIL `:override' argument
(defvar *c-top-call*)

(defmacro with-compilation-unit ((&key override) &body forms)
  `(let ((*c-top-call* (or ,override (not (boundp '*c-top-call*))))
         #+ffi (ffi::*foreign-language* ffi::*foreign-language*)
         #+ffi (ffi::*foreign-library* ffi::*foreign-library*)
         (*c-listing-output* nil)
         (*c-error-output* *error-output*))
     ;; clean up from the outer `with-compilation-unit':
     ;; <http://www.lisp.org/HyperSpec/Body/mac_with-compilation-unit.html>
     ;; [CLHS]: If nested dynamically only the outer call to
     ;; `with-compilation-unit' has any effect unless the value associated
     ;; with `:override' is true, in which case warnings are deferred only
     ;; to the end of the innermost call for which override is true.
     (when *c-top-call*
       (c-report-problems))
     (progv (when *c-top-call*
              '(*error-count* *warning-count* *style-warning-count*))
         (when *c-top-call* '(0 0 0))
       (unwind-protect
            (progn ,@forms)
         ;; report the errors and reset
         (when *c-top-call*
           (c-report-problems))))))

;; return a path with the specified type and the rest as in the path argument
(defun merge-extension (type path) (make-pathname :type type :defaults path))

;; Common part of COMPILE-FILE and COMPILE-FILE-PATHNAME.
;; Returns two values:
;; 1. the output file (pathname or stream or NIL),
;; 2. the input file pathname.
(defun compile-file-pathname-helper (file output-file)
  (let ((input-file
          (or (and (not (logical-pathname-p (pathname file)))
                   (first (search-file file *source-file-types*)))
              (merge-pathnames file #.(make-pathname :type "lisp")))))
    (values
      (if (or (null output-file)
              (and (streamp output-file)
                   (open-stream-p output-file)
                   (output-stream-p output-file)))
        output-file
        (let ((tmp (merge-extension *internal-compiled-file-type* input-file)))
          (if (eq output-file 'T)
            tmp
            ;; Not (merge-pathnames output-file tmp) because that doesn't
            ;; do the right thing when output-file is a relative pathname
            ;; and either *merge-pathnames-ansi* is true or input-file is
            ;; absolute.
            (let ((output-file (merge-pathnames output-file)))
              (when (and (not (logical-pathname-p output-file))
                         (logical-pathname-p tmp))
                (setq tmp (translate-logical-pathname tmp)))
              (make-pathname
               :host (or (pathname-host output-file)
                         (pathname-host tmp))
               :device (if (pathname-host output-file)
                         (pathname-device output-file)
                         (if (pathname-host tmp)
                           (pathname-device tmp)
                           (or (pathname-device output-file)
                               (pathname-device tmp))))
               :directory (if (pathname-host output-file)
                            (pathname-directory output-file)
                            (if (pathname-host tmp)
                              (pathname-directory tmp)
                              (if (pathname-device output-file)
                                (pathname-directory output-file)
                                (if (pathname-device tmp)
                                  (pathname-directory tmp)
                                  (pathname-directory output-file)))))
               :name (or (pathname-name output-file)
                         (pathname-name tmp))
               :type (or (pathname-type output-file)
                         (pathname-type tmp))
               :version (or (pathname-version output-file)
                            (pathname-version tmp)))))))
      input-file)))

(defun set-output-stream-fasl (stream)
  (sys::stream-fasl-p stream t) ; set FASL flag for current output
  (write-string "#0Y_ " stream) ; set FASL flag for future input
  #+UNICODE ;; Set the stream's encoding to UTF-8, if it supports it.
  (let ((*error-handler*
         #'(lambda (&rest error-args)
             (declare (ignore error-args))
             (return-from set-output-stream-fasl nil)))
        (encoding 'charset:utf-8))
    (setf (stream-external-format stream) encoding)
    (write-string "#0Y " stream)
    (let ((*package* #,(find-package "CHARSET")))
      (write encoding :stream stream :readably t))
    (terpri stream)))

;; Common-Lisp-Function COMPILE-FILE
;; file          should be a Pathname/String/Symbol.
;; :output-file  should be nil or t or a Pathname/String/Symbol or
;;               an Output-Stream. Default: t.
;; :listing      should be nil or t or a Pathname/String/Symbol or
;;               an Output-Stream. Default: nil.
;; :warnings     indicates, if the Warnings should also appear on the screen.
;; :verbose      indicates, if the Errors also have to appear on the screen.
(defun compile-file (file &key (output-file 'T) listing
                               ((:warnings *compile-warnings*)
                                *compile-warnings*)
                               ((:verbose *compile-verbose*) *compile-verbose*)
                               ((:print *compile-print*) *compile-print*)
                               (external-format :default)
                          &aux liboutput-file (*coutput-file* nil) input-file
                               (*compile-file-directory*
                                 (if (eq t output-file)
                                   nil
                                   (make-pathname :name nil :type nil
                                                  :defaults output-file)))
                               (new-output-stream nil)
                               (new-listing-stream nil))
  (multiple-value-setq (output-file input-file)
    (compile-file-pathname-helper file output-file))
  (when (and output-file (not (streamp output-file)))
    (setq liboutput-file (merge-extension "lib" output-file))
    (setq *coutput-file* (merge-extension "c" output-file))
    (setq new-output-stream t))
  (when (and listing (not (streamp listing)))
    (setq listing (if (eq listing 'T)
                    (merge-extension "lis" output-file)
                    (merge-pathnames listing)))
    (setq new-listing-stream t))
  (with-open-file (istream input-file :direction :input-immutable
                                      :external-format external-format)
    (let ((listing-stream ; a stream or NIL
            (if new-listing-stream
              (open listing :direction :output)
              (if (streamp listing) listing nil))))
      (unwind-protect
        (let* ((*compile-file-pathname* (merge-pathnames file)) ; as per ANSI
               (*compile-file-resolved-pathname* input-file) ; more useful
               (*compile-file-truename* (truename input-file))
               (*current-source-file* *compile-file-truename*)
               (*compile-file-lineno1* nil)
               (*compile-file-lineno2* nil)
               (*fasoutput-stream* ; a Stream or NIL
                 (if new-output-stream
                   (open output-file :direction :output)
                   (if (streamp output-file) output-file nil)))
               (*liboutput-stream* ; a Stream or NIL
                 (if new-output-stream
                   (open liboutput-file :direction :output)
                   nil))
               (*coutput-stream* nil) ; a Stream or NIL at the moment
               (*ffi-module* nil) ; NIL at the moment
               (*load-forms* (make-hash-table :key-type 't :value-type 't
                                              :test 'eq))
               (compilation-successful nil))
          (unwind-protect
            (with-compilation-unit ()
              (when listing-stream
                (fresh-line listing-stream)
                (format listing-stream
                  (TEXT "Listing of compilation of file ~A~%on ~A by ~A, version ~A")
                  input-file (date-string)
                  (lisp-implementation-type) (lisp-implementation-version)))
              (let ((*compiling* t)
                    (*compiling-from-file* t)
                    (*package* *package*)
                    (*readtable* *readtable*)
                    (*c-listing-output* listing-stream)
                    (*c-error-output*
                      (if listing-stream
                        (make-broadcast-stream *error-output* listing-stream)
                        *error-output*))
                    (verbose-out
                      (when *compile-verbose*
                        (if listing-stream
                          (make-broadcast-stream *standard-output*
                                                 listing-stream)
                          *standard-output*)))
                    (*func* nil)
                    (*fenv* nil)
                    (*benv* nil)
                    (*genv* nil)
                    (*venv* nil)
                    (*venvc* nil)
                    (*denv* *toplevel-denv*)
                    (*no-code* (and (null *fasoutput-stream*)
                                    (null listing-stream)))
                    (*toplevel-for-value* t)
                    (eof-value istream)
                    (form-count 0))
                (when verbose-out
                  (fresh-line verbose-out)
                  (format verbose-out (TEXT ";; Compiling file ~A ...")
                          input-file)
                  (elastic-newline verbose-out))
                (when (and new-output-stream *fasoutput-stream*)
                  (let ((*package* *keyword-package*))
                    (write `(SYSTEM::VERSION ',(version))
                           :stream *fasoutput-stream*
                         ; :escape t :level nil :length nil :radix t
                           :readably t :right-margin 79 :case ':upcase))
                  (terpri *fasoutput-stream*)
                  (set-output-stream-fasl *fasoutput-stream*))
                (when (and new-output-stream *liboutput-stream*)
                  (set-output-stream-fasl *liboutput-stream*))
                (loop
                  (peek-char t istream nil eof-value)
                  (setq *compile-file-lineno1* (line-number istream))
                  (let* ((form (read istream nil eof-value))
                         (form-name (write-to-string
                                     form :level 2 :length 3 :pretty nil)))
                    (setq *compile-file-lineno2* (line-number istream))
                    (when (eql form eof-value) (return))
                    (when *compile-print* (format t "~&; ~A~." form-name))
                    (compile-toplevel-form
                     form (symbol-suffix
                           (make-symbol
                            (string-concat
                             (prin1-to-string *compile-file-lineno1*) #3=" "
                             (prin1-to-string *compile-file-lineno2*) #3#
                             form-name))
                           (incf form-count)))))
                (finalize-coutput-file)
                (setq compilation-successful (zerop *error-count*))
                (when verbose-out
                  (cond (compilation-successful
                         (fresh-line verbose-out)
                         (format verbose-out #1=(TEXT ";; Wrote file ~A")
                                 output-file)
                         (when *coutput-stream*
                           (terpri verbose-out)
                           (format verbose-out #1# *coutput-file*))
                         (elastic-newline verbose-out))
                        (new-output-stream
                         (fresh-line verbose-out)
                         (format verbose-out #2=(TEXT ";; Deleted file ~A")
                                 output-file)
                         (when *coutput-stream*
                           (terpri verbose-out)
                           (format verbose-out #2# *coutput-file*))
                         (elastic-newline verbose-out)))
                  (when new-listing-stream
                    (terpri verbose-out)
                    (format verbose-out #1# listing)
                    (elastic-newline verbose-out)))
                (values (and compilation-successful output-file
                             (truename *fasoutput-stream*))
                        (compile-warnings-p)
                        (compile-failure-p))))
            (when new-output-stream
              (close *fasoutput-stream*)
              (close *liboutput-stream*)
              (when *coutput-stream*
                (close *coutput-stream*))
              (unless compilation-successful
                (delete-file output-file)
                (delete-file liboutput-file)
                (when *coutput-stream*
                  (delete-file *coutput-file*))))))
        (when new-listing-stream
          (fresh-line listing-stream)
          (close listing-stream))))))

;; This must be consistent with compile-file (see above)!
(defun compile-file-pathname (file &key (output-file 'T) &allow-other-keys)
  (values (compile-file-pathname-helper file output-file)))

(defun disassemble-closures (closure stream)
  (let ((closures '()))
    (labels ((mark (cl) ; enters a Closure cl (recursive) in closures.
               (push cl closures) ; mark cl
               (dolist (c (closure-consts cl)) ; and all Sub-Closures
                 (when (and (sys::closurep c) (sys::%compiled-function-p c))
                   (unless (member c closures) (mark c)))))) ; mark likewise
      (mark closure)) ; mark Main-Closure
    (dolist (c (nreverse closures)) ; disassemble all Closures
      (disassemble-closure c stream))))

(defun stream-tab (stream tab)
  (sys::write-spaces (let ((pos (sys::line-position stream)))
                       (if pos (max 1 (- tab pos)) 2))
                     stream))
(defun disassemble-closure (closure &optional (stream *standard-output*))
  (fresh-line stream)
  (terpri stream)
  (format stream (TEXT "Disassembly of function ~S") (closure-name closure))
  (multiple-value-bind (req-num opt-num rest-p
                        key-p keyword-list allow-other-keys-p
                        byte-list const-list)
      (signature closure)
    (do ((L const-list (cdr L))
         (i 0 (1+ i)))
        ((null L))
      (format stream "~%(CONST ~S) = ~S" i (car L)))
    (terpri stream)
    (format stream (TEXT "~S required argument~:P") req-num)
    (terpri stream)
    (format stream (TEXT "~S optional argument~:P") opt-num)
    (terpri stream)
    (if rest-p
      (write-string (TEXT "Rest parameter") stream)
      (write-string (TEXT "No rest parameter") stream))
    (if key-p
      (let ((kw-count (length keyword-list)))
        (terpri stream)
        (format stream (TEXT "~S keyword parameter~:P: ") kw-count)
        (do ((L keyword-list))
            ((endp L))
          (prin1 (pop L) stream)
          (if (endp L) (write-string "." stream) (write-string ", " stream)))
        (when allow-other-keys-p
          (terpri stream)
          (write-string (TEXT "Other keywords are allowed.") stream)))
      (progn
        (terpri stream)
        (write-string (TEXT "No keyword parameters") stream)))
    (let ((const-string-list
            (mapcar #'(lambda (x) (sys::write-to-short-string x 35))
                    const-list))
          (special-vars-read '())
          (special-vars-write '())
          (lap-list (disassemble-LAP byte-list const-list)))
      (dolist (L lap-list)
        (when (consp (cdr L))
          (case (cadr L)        ; instruction
            ((GETVALUE GETVALUE&PUSH)
             (pushnew (nth (caddr L) const-list) special-vars-read))
            ((SETVALUE)
             (pushnew (nth (caddr L) const-list) special-vars-write)))))
      (when special-vars-read
        (terpri stream)
        (format stream (TEXT "reads special variable~P: ~{~S~^ ~}")
                (length special-vars-read) special-vars-read))
      (when special-vars-write
        (terpri stream)
        (format stream (TEXT "writes special variable~P: ~{~S~^ ~}")
                (length special-vars-write) special-vars-write))
      (terpri stream)
      (format stream (TEXT "~S byte-code instruction~:P:") (length lap-list))
      (dolist (L lap-list)
        (let ((PC (car L)) (instr (cdr L)))
          (terpri stream)
          (prin1 PC stream)
          (stream-tab stream 6)
          (princ instr stream) ; write instr, Symbols without Package-Marker!
          (multiple-value-bind (commentp comment)
            (when (consp instr)
              (case (first instr)
                ((CALLS1 CALLS1&PUSH CALLS1&STORE CALLS1&JMPIFNOT CALLS1&JMPIF)
                 (values t (%funtabref (second instr))))
                ((CALLS2 CALLS2&PUSH CALLS2&STORE CALLS2&JMPIFNOT CALLS2&JMPIF)
                 (values t (%funtabref (+ 256 (second instr)))))
                ((CALLSR CALLSR&PUSH CALLSR&STORE CALLSR&JMPIFNOT CALLSR&JMPIF)
                 (values t (%funtabref (+ funtabR-index (third instr)))))
                ((CALL CALL&PUSH)
                 (values 'string (nth (third instr) const-string-list)))
                ((CALL0 CALL1 CALL1&PUSH CALL1&JMPIFNOT CALL1&JMPIF
                  CALL2 CALL2&PUSH CALL2&JMPIFNOT CALL2&JMPIF
                  JMPIFEQTO JMPIFNOTEQTO CONST CONST&PUSH SETVALUE GETVALUE
                  GETVALUE&PUSH BIND CONST&STORE CONST&SYMBOL-FUNCTION&PUSH
                  CONST&SYMBOL-FUNCTION COPY-CLOSURE&PUSH COPY-CLOSURE
                  CONST&SYMBOL-FUNCTION&STORE TAGBODY-OPEN HANDLER-OPEN)
                 (values 'string (nth (second instr) const-string-list)))))
            (when commentp
              (stream-tab stream 42)
              (write-string "; " stream)
              (if (eq commentp 'string)
                (write-string comment stream)
                (prin1 comment stream)))))))
    (elastic-newline stream)))

;; Creates a trampoline bytecode vector for jumping to a given function.
;; Used by set-funcallable-instance-function.
(defun make-trampoline (function)
  (multiple-value-bind (name req-num opt-num rest-p key-p)
      (function-signature function)
    (declare (ignore name))
    ; Don't use optional parameters, since the RETGF instruction doesn't
    ; support them.
    (when (> opt-num 0)
      (setq opt-num 0 rest-p t))
    (let ((fnode
            (make-fnode :name 'trampoline
                        :req-num req-num
                        :opt-num opt-num
                        :rest-flag (or rest-p key-p)
                        ;; no lalist, docstring or jitc:
                        :denv '((optimize (space 3) (speed 0)))
                        :code (let ((*form* nil) (*stackz* nil))
                                (make-anode :seclass *seclass-dirty*))
                        :Blocks-Offset 0
                        :Tagbodys-Offset 0
                        :Keyword-Offset 0
                        :Consts-Offset 0)))
      (create-fun-obj fnode
                      (assemble-LAP
                       `((VENV) (SKIP&RETGF ,(+ 1 req-num
                                                (if (or rest-p key-p) 1 0)))))
                      '(0 . 0))
      (let ((trampoline (fnode-code fnode)))
        (sys::closure-codevec trampoline)))))

;; The compilation of code using symbol-macros requires venv-search in
;; compiled form.
(unless (compiled-function-p #'venv-search)
  (compile 'venv-search))

(eval-when (compile load eval)
  (setq clos::*compile-accessor-functions* t))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./compiler.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./timezone.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; time zone definition for non-UNIX/WIN32 systems
;;; Bruno Haible 8.-11.2.1994
;;; The data here comes from the /usr/lib/zoneinfo/ directory of the Linux
;;; package util-linux-1.5 and was constrained to the range 1950..2020.

;; see also
;; <http://www.stopwatchmaps.com/services/products/data/world_tz_dst.htm>

(in-package "SYSTEM")

(defvar *default-time-zone*)
(defvar *default-dst-check*)

(labels
  ;; functions to check whether DST is in effect at a certain day and hour
  ;; in a certain march-based year.
  ((no-DST-p (Jahr Jahrtag Stunde) ; no DST at all
     (declare (ignore Jahr Jahrtag Stunde))
     nil
   )
   ;; Europe:
   (GB-Eire-DST-p (Jahr Jahrtag Stunde)
     (when (and (= Jahr 1967) (>= Jahrtag 337)) ; February 1968 ?
       (incf Jahr) (decf Jahrtag 366)
     )
     (and (<= 1960 Jahr 2020)
       (let ((Jahresstunde (+ (* 24 Jahrtag) Stunde))
             (Grenzen
               (svref '#((961 . 5160) ; 1960 : 10.4. 1h to 2.10. 1h
                         ; last Sunday in March 1h to last Sunday in October 1h
                         (601 . 5808) ; 1961 : 26.3. 1h to 29.10. 1h
                         (577 . 5784) ; 1962 : 25.3. 1h to 28.10. 1h
                         (721 . 5760) ; 1963 : 31.3. 1h to 27.10. 1h
                         ; Sunday>=19 in March 1h to last Sunday in October 1h
                         (505 . 5712) ; 1964 : 22.3. 1h to 25.10. 1h
                         (481 . 5688) ; 1965 : 21.3. 1h to 24.10. 1h
                         (457 . 5664) ; 1966 : 20.3. 1h to 23.10. 1h
                         (433 . 5808) ; 1967 : 19.3. 1h to 29.10. 1h
                         ; all year
                         (-263 . 8759) ; 1968 : 18.2. 1h to end of year
                         (0 . 8759) ; 1969 : all year
                         (0 . 8759) ; 1970 : all year
                         (0 . 5856) ; 1971 : beginning of year to 31.10. 1h
                         ; Sunday>=16 in March 1h to last Sunday in October 1h
                         (433 . 5808) ; 1972 : 19.3. 1h to 29.10. 1h
                         (409 . 5784) ; 1973 : 18.3. 1h to 28.10. 1h
                         (385 . 5760) ; 1974 : 17.3. 1h to 27.10. 1h
                         (361 . 5736) ; 1975 : 16.3. 1h to 26.10. 1h
                         (481 . 5688) ; 1976 : 21.3. 1h to 24.10. 1h
                         (457 . 5664) ; 1977 : 20.3. 1h to 23.10. 1h
                         (433 . 5808) ; 1978 : 19.3. 1h to 29.10. 1h
                         (409 . 5784) ; 1979 : 18.3. 1h to 28.10. 1h
                         (361 . 5736) ; 1980 : 16.3. 1h to 26.10. 1h
                         ; last Sunday in March 1h to last Sunday in October 1h
                         (673 . 5712) ; 1981 : 29.3. 1h to 25.10. 1h
                         (649 . 5688) ; 1982 : 28.3. 1h to 24.10. 1h
                         (625 . 5664) ; 1983 : 27.3. 1h to 23.10. 1h
                         (577 . 5784) ; 1984 : 25.3. 1h to 28.10. 1h
                         (721 . 5760) ; 1985 : 31.3. 1h to 27.10. 1h
                         (697 . 5736) ; 1986 : 30.3. 1h to 26.10. 1h
                         (673 . 5712) ; 1987 : 29.3. 1h to 25.10. 1h
                         (625 . 5664) ; 1988 : 27.3. 1h to 23.10. 1h
                         (601 . 5808) ; 1989 : 26.3. 1h to 29.10. 1h
                         (577 . 5784) ; 1990 : 25.3. 1h to 28.10. 1h
                         (721 . 5760) ; 1991 : 31.3. 1h to 27.10. 1h
                         (673 . 5712) ; 1992 : 29.3. 1h to 25.10. 1h
                         (649 . 5688) ; 1993 : 28.3. 1h to 24.10. 1h
                         (625 . 5664) ; 1994 : 27.3. 1h to 23.10. 1h
                         (601 . 5808) ; 1995 : 26.3. 1h to 29.10. 1h
                         (721 . 5760) ; 1996 : 31.3. 1h to 27.10. 1h
                         (697 . 5736) ; 1997 : 30.3. 1h to 26.10. 1h
                         (673 . 5712) ; 1998 : 29.3. 1h to 25.10. 1h
                         (649 . 5688) ; 1999 : 28.3. 1h to 24.10. 1h
                         (601 . 5808) ; 2000 : 26.3. 1h to 29.10. 1h
                         (577 . 5784) ; 2001 : 25.3. 1h to 28.10. 1h
                         (721 . 5760) ; 2002 : 31.3. 1h to 27.10. 1h
                         (697 . 5736) ; 2003 : 30.3. 1h to 26.10. 1h
                         (649 . 5688) ; 2004 : 28.3. 1h to 24.10. 1h
                         (625 . 5664) ; 2005 : 27.3. 1h to 23.10. 1h
                         (601 . 5808) ; 2006 : 26.3. 1h to 29.10. 1h
                         (577 . 5784) ; 2007 : 25.3. 1h to 28.10. 1h
                         (697 . 5736) ; 2008 : 30.3. 1h to 26.10. 1h
                         (673 . 5712) ; 2009 : 29.3. 1h to 25.10. 1h
                         (649 . 5688) ; 2010 : 28.3. 1h to 24.10. 1h
                         (625 . 5664) ; 2011 : 27.3. 1h to 23.10. 1h
                         (577 . 5784) ; 2012 : 25.3. 1h to 28.10. 1h
                         (721 . 5760) ; 2013 : 31.3. 1h to 27.10. 1h
                         (697 . 5736) ; 2014 : 30.3. 1h to 26.10. 1h
                         (673 . 5712) ; 2015 : 29.3. 1h to 25.10. 1h
                         (625 . 5664) ; 2016 : 27.3. 1h to 23.10. 1h
                         (601 . 5808) ; 2017 : 26.3. 1h to 29.10. 1h
                         (577 . 5784) ; 2018 : 25.3. 1h to 28.10. 1h
                         (721 . 5760) ; 2019 : 31.3. 1h to 27.10. 1h
                         (673 . 5712) ; 2020 : 29.3. 1h to 25.10. 1h
                        )
                      (- Jahr 1960)
            )) )
         (<= (car Grenzen) Jahresstunde (cdr Grenzen))
   ) ) )
   (West-Europe-DST-p (Jahr Jahrtag Stunde)
     (and (<= 1980 Jahr 2020)
       (let ((Jahresstunde (+ (* 24 Jahrtag) Stunde))
             (Grenzen
               (svref '#(; last Sunday in March 1h to last Sunday in September 1h
                         (697 . 5064) ; 1980 : 30.3. 1h to 28.9. 1h
                         (673 . 5040) ; 1981 : 29.3. 1h to 27.9. 1h
                         (649 . 5016) ; 1982 : 28.3. 1h to 26.9. 1h
                         (625 . 4992) ; 1983 : 27.3. 1h to 25.9. 1h
                         (577 . 5112) ; 1984 : 25.3. 1h to 30.9. 1h
                         (721 . 5088) ; 1985 : 31.3. 1h to 29.9. 1h
                         (697 . 5064) ; 1986 : 30.3. 1h to 28.9. 1h
                         (673 . 5040) ; 1987 : 29.3. 1h to 27.9. 1h
                         (625 . 4992) ; 1988 : 27.3. 1h to 25.9. 1h
                         (601 . 4968) ; 1989 : 26.3. 1h to 24.9. 1h
                         (577 . 5112) ; 1990 : 25.3. 1h to 30.9. 1h
                         (721 . 5088) ; 1991 : 31.3. 1h to 29.9. 1h
                         (673 . 5040) ; 1992 : 29.3. 1h to 27.9. 1h
                         (649 . 5016) ; 1993 : 28.3. 1h to 26.9. 1h
                         (625 . 4992) ; 1994 : 27.3. 1h to 25.9. 1h
                         (601 . 4968) ; 1995 : 26.3. 1h to 24.9. 1h
                         (721 . 5088) ; 1996 : 31.3. 1h to 29.9. 1h
                         (697 . 5064) ; 1997 : 30.3. 1h to 28.9. 1h
                         (673 . 5040) ; 1998 : 29.3. 1h to 27.9. 1h
                         (649 . 5016) ; 1999 : 28.3. 1h to 26.9. 1h
                         (601 . 4968) ; 2000 : 26.3. 1h to 24.9. 1h
                         (577 . 5112) ; 2001 : 25.3. 1h to 30.9. 1h
                         (721 . 5088) ; 2002 : 31.3. 1h to 29.9. 1h
                         (697 . 5064) ; 2003 : 30.3. 1h to 28.9. 1h
                         (649 . 5016) ; 2004 : 28.3. 1h to 26.9. 1h
                         (625 . 4992) ; 2005 : 27.3. 1h to 25.9. 1h
                         (601 . 4968) ; 2006 : 26.3. 1h to 24.9. 1h
                         (577 . 5112) ; 2007 : 25.3. 1h to 30.9. 1h
                         (697 . 5064) ; 2008 : 30.3. 1h to 28.9. 1h
                         (673 . 5040) ; 2009 : 29.3. 1h to 27.9. 1h
                         (649 . 5016) ; 2010 : 28.3. 1h to 26.9. 1h
                         (625 . 4992) ; 2011 : 27.3. 1h to 25.9. 1h
                         (577 . 5112) ; 2012 : 25.3. 1h to 30.9. 1h
                         (721 . 5088) ; 2013 : 31.3. 1h to 29.9. 1h
                         (697 . 5064) ; 2014 : 30.3. 1h to 28.9. 1h
                         (673 . 5040) ; 2015 : 29.3. 1h to 27.9. 1h
                         (625 . 4992) ; 2016 : 27.3. 1h to 25.9. 1h
                         (601 . 4968) ; 2017 : 26.3. 1h to 24.9. 1h
                         (577 . 5112) ; 2018 : 25.3. 1h to 30.9. 1h
                         (721 . 5088) ; 2019 : 31.3. 1h to 29.9. 1h
                         (673 . 5040) ; 2020 : 29.3. 1h to 27.9. 1h
                        )
                      (- Jahr 1980)
            )) )
         (<= (car Grenzen) Jahresstunde (cdr Grenzen))
   ) ) )
   (Mid-Europe-DST-p (Jahr Jahrtag Stunde)
     (and (<= 1980 Jahr 2020)
       (let ((Jahresstunde (+ (* 24 Jahrtag) Stunde))
             (Grenzen
               (svref '#(; I think DST was introduced in Germany in 1980.
                         ; last Sunday in March 2h to last Sunday in September 2h
                         (698 . 5065) ; 1980 : 30.3. 2h to 28.9. 2h
                         (674 . 5041) ; 1981 : 29.3. 2h to 27.9. 2h
                         (650 . 5017) ; 1982 : 28.3. 2h to 26.9. 2h
                         (626 . 4993) ; 1983 : 27.3. 2h to 25.9. 2h
                         (578 . 5113) ; 1984 : 25.3. 2h to 30.9. 2h
                         (722 . 5089) ; 1985 : 31.3. 2h to 29.9. 2h
                         (698 . 5065) ; 1986 : 30.3. 2h to 28.9. 2h
                         (674 . 5041) ; 1987 : 29.3. 2h to 27.9. 2h
                         (626 . 4993) ; 1988 : 27.3. 2h to 25.9. 2h
                         (602 . 4969) ; 1989 : 26.3. 2h to 24.9. 2h
                         (578 . 5113) ; 1990 : 25.3. 2h to 30.9. 2h
                         (722 . 5089) ; 1991 : 31.3. 2h to 29.9. 2h
                         (674 . 5041) ; 1992 : 29.3. 2h to 27.9. 2h
                         (650 . 5017) ; 1993 : 28.3. 2h to 26.9. 2h
                         (626 . 4993) ; 1994 : 27.3. 2h to 25.9. 2h
                         (602 . 4969) ; 1995 : 26.3. 2h to 24.9. 2h
                         ; last Sunday in March 2h to last Sunday in October 2h
                         (722 . 5761) ; 1996 : 31.3. 2h to 27.10. 2h
                         (698 . 5737) ; 1997 : 30.3. 2h to 26.10. 2h
                         (674 . 5713) ; 1998 : 29.3. 2h to 25.10. 2h
                         (650 . 5857) ; 1999 : 28.3. 2h to 31.10. 2h
                         (602 . 5809) ; 2000 : 26.3. 2h to 29.10. 2h
                         (578 . 5785) ; 2001 : 25.3. 2h to 28.10. 2h
                         (722 . 5761) ; 2002 : 31.3. 2h to 27.10. 2h
                         (698 . 5737) ; 2003 : 30.3. 2h to 26.10. 2h
                         (650 . 5857) ; 2004 : 28.3. 2h to 31.10. 2h
                         (626 . 5833) ; 2005 : 27.3. 2h to 30.10. 2h
                         (602 . 5809) ; 2006 : 26.3. 2h to 29.10. 2h
                         (578 . 5785) ; 2007 : 25.3. 2h to 28.10. 2h
                         (698 . 5737) ; 2008 : 30.3. 2h to 26.10. 2h
                         (674 . 5713) ; 2009 : 29.3. 2h to 25.10. 2h
                         (650 . 5857) ; 2010 : 28.3. 2h to 31.10. 2h
                         (626 . 5833) ; 2011 : 27.3. 2h to 30.10. 2h
                         (578 . 5785) ; 2012 : 25.3. 2h to 28.10. 2h
                         (722 . 5761) ; 2013 : 31.3. 2h to 27.10. 2h
                         (698 . 5737) ; 2014 : 30.3. 2h to 26.10. 2h
                         (674 . 5713) ; 2015 : 29.3. 2h to 25.10. 2h
                         (626 . 5833) ; 2016 : 27.3. 2h to 30.10. 2h
                         (602 . 5809) ; 2017 : 26.3. 2h to 29.10. 2h
                         (578 . 5785) ; 2018 : 25.3. 2h to 28.10. 2h
                         (722 . 5761) ; 2019 : 31.3. 2h to 27.10. 2h
                         (674 . 5713) ; 2020 : 29.3. 2h to 25.10. 2h
                        )
                      (- Jahr 1980)
            )) )
         (<= (car Grenzen) Jahresstunde (cdr Grenzen))
   ) ) )
   (East-Europe-DST-p (Jahr Jahrtag Stunde)
     (and (<= 1980 Jahr 2020)
       (let ((Jahresstunde (+ (* 24 Jahrtag) Stunde))
             (Grenzen
               (svref '#(; last Sunday in March 3h to last Sunday in September 3h
                         (699 . 5066) ; 1980 : 30.3. 3h to 28.9. 3h
                         (675 . 5042) ; 1981 : 29.3. 3h to 27.9. 3h
                         (651 . 5018) ; 1982 : 28.3. 3h to 26.9. 3h
                         (627 . 4994) ; 1983 : 27.3. 3h to 25.9. 3h
                         (579 . 5114) ; 1984 : 25.3. 3h to 30.9. 3h
                         (723 . 5090) ; 1985 : 31.3. 3h to 29.9. 3h
                         (699 . 5066) ; 1986 : 30.3. 3h to 28.9. 3h
                         (675 . 5042) ; 1987 : 29.3. 3h to 27.9. 3h
                         (627 . 4994) ; 1988 : 27.3. 3h to 25.9. 3h
                         (603 . 4970) ; 1989 : 26.3. 3h to 24.9. 3h
                         (579 . 5114) ; 1990 : 25.3. 3h to 30.9. 3h
                         (723 . 5090) ; 1991 : 31.3. 3h to 29.9. 3h
                         (675 . 5042) ; 1992 : 29.3. 3h to 27.9. 3h
                         (651 . 5018) ; 1993 : 28.3. 3h to 26.9. 3h
                         (627 . 4994) ; 1994 : 27.3. 3h to 25.9. 3h
                         (603 . 4970) ; 1995 : 26.3. 3h to 24.9. 3h
                         (723 . 5090) ; 1996 : 31.3. 3h to 29.9. 3h
                         (699 . 5066) ; 1997 : 30.3. 3h to 28.9. 3h
                         (675 . 5042) ; 1998 : 29.3. 3h to 27.9. 3h
                         (651 . 5018) ; 1999 : 28.3. 3h to 26.9. 3h
                         (603 . 4970) ; 2000 : 26.3. 3h to 24.9. 3h
                         (579 . 5114) ; 2001 : 25.3. 3h to 30.9. 3h
                         (723 . 5090) ; 2002 : 31.3. 3h to 29.9. 3h
                         (699 . 5066) ; 2003 : 30.3. 3h to 28.9. 3h
                         (651 . 5018) ; 2004 : 28.3. 3h to 26.9. 3h
                         (627 . 4994) ; 2005 : 27.3. 3h to 25.9. 3h
                         (603 . 4970) ; 2006 : 26.3. 3h to 24.9. 3h
                         (579 . 5114) ; 2007 : 25.3. 3h to 30.9. 3h
                         (699 . 5066) ; 2008 : 30.3. 3h to 28.9. 3h
                         (675 . 5042) ; 2009 : 29.3. 3h to 27.9. 3h
                         (651 . 5018) ; 2010 : 28.3. 3h to 26.9. 3h
                         (627 . 4994) ; 2011 : 27.3. 3h to 25.9. 3h
                         (579 . 5114) ; 2012 : 25.3. 3h to 30.9. 3h
                         (723 . 5090) ; 2013 : 31.3. 3h to 29.9. 3h
                         (699 . 5066) ; 2014 : 30.3. 3h to 28.9. 3h
                         (675 . 5042) ; 2015 : 29.3. 3h to 27.9. 3h
                         (627 . 4994) ; 2016 : 27.3. 3h to 25.9. 3h
                         (603 . 4970) ; 2017 : 26.3. 3h to 24.9. 3h
                         (579 . 5114) ; 2018 : 25.3. 3h to 30.9. 3h
                         (723 . 5090) ; 2019 : 31.3. 3h to 29.9. 3h
                         (675 . 5042) ; 2020 : 29.3. 3h to 27.9. 3h
                        )
                      (- Jahr 1980)
            )) )
         (<= (car Grenzen) Jahresstunde (cdr Grenzen))
   ) ) )
   ;; Asia:
   (Israel-DST-p (Jahr Jahrtag Stunde)
     (and (<= 1987 Jahr 2020)
       (let ((Jahresstunde (+ (* 24 Jahrtag) Stunde))
             (Grenzen
               (svref '#(; 3rd Sunday in April 2h to 4th Saturday in August 2h
                         (1178 . 4152) ; 1987 : 19.4. 2h to 21.8. 1h
                         (1130 . 4272) ; 1988 : 17.4. 2h to 26.8. 1h
                         (1106 . 4248) ; 1989 : 16.4. 2h to 25.8. 1h
                         (1082 . 4224) ; 1990 : 15.4. 2h to 24.8. 1h
                         (1226 . 4200) ; 1991 : 21.4. 2h to 23.8. 1h
                         (1178 . 4152) ; 1992 : 19.4. 2h to 21.8. 1h
                         (1154 . 4320) ; 1993 : 18.4. 2h to 28.8. 1h
                         (1130 . 4272) ; 1994 : 17.4. 2h to 26.8. 1h
                         (1106 . 4248) ; 1995 : 16.4. 2h to 25.8. 1h
                         (1226 . 4200) ; 1996 : 21.4. 2h to 23.8. 1h
                         (1202 . 4176) ; 1997 : 20.4. 2h to 22.8. 1h
                         (1178 . 4152) ; 1998 : 19.4. 2h to 21.8. 1h
                         (1154 . 4320) ; 1999 : 18.4. 2h to 28.8. 1h
                         (1106 . 4248) ; 2000 : 16.4. 2h to 25.8. 1h
                         (1082 . 4224) ; 2001 : 15.4. 2h to 24.8. 1h
                         (1226 . 4200) ; 2002 : 21.4. 2h to 23.8. 1h
                         (1202 . 4176) ; 2003 : 20.4. 2h to 22.8. 1h
                         (1154 . 4320) ; 2004 : 18.4. 2h to 28.8. 1h
                         (1130 . 4272) ; 2005 : 17.4. 2h to 26.8. 1h
                         (1106 . 4248) ; 2006 : 16.4. 2h to 25.8. 1h
                         (1082 . 4224) ; 2007 : 15.4. 2h to 24.8. 1h
                         (1202 . 4176) ; 2008 : 20.4. 2h to 22.8. 1h
                         (1178 . 4152) ; 2009 : 19.4. 2h to 21.8. 1h
                         (1154 . 4320) ; 2010 : 18.4. 2h to 28.8. 1h
                         (1130 . 4272) ; 2011 : 17.4. 2h to 26.8. 1h
                         (1082 . 4224) ; 2012 : 15.4. 2h to 24.8. 1h
                         (1226 . 4200) ; 2013 : 21.4. 2h to 23.8. 1h
                         (1202 . 4176) ; 2014 : 20.4. 2h to 22.8. 1h
                         (1178 . 4152) ; 2015 : 19.4. 2h to 21.8. 1h
                         (1130 . 4272) ; 2016 : 17.4. 2h to 26.8. 1h
                         (1106 . 4248) ; 2017 : 16.4. 2h to 25.8. 1h
                         (1082 . 4224) ; 2018 : 15.4. 2h to 24.8. 1h
                         (1226 . 4200) ; 2019 : 21.4. 2h to 23.8. 1h
                         (1178 . 4152) ; 2020 : 19.4. 2h to 21.8. 1h
                        )
                      (- Jahr 1987)
            )) )
         (<= (car Grenzen) Jahresstunde (cdr Grenzen))
   ) ) )
   (Iran-DST-p (Jahr Jahrtag Stunde)
     (and (<= 1988 Jahr 2020)
       (let ((Jahresstunde (+ (* 24 Jahrtag) Stunde))
             (Grenzen
               (svref '#(; last Sunday in March 2h to 3rd Sunday in September 2h
                         (626 . 4824) ; 1988 : 27.3. 2h to 18.9. 1h
                         (602 . 4800) ; 1989 : 26.3. 2h to 17.9. 1h
                         (578 . 4776) ; 1990 : 25.3. 2h to 16.9. 1h
                         (722 . 4752) ; 1991 : 31.3. 2h to 15.9. 1h
                         (674 . 4872) ; 1992 : 29.3. 2h to 20.9. 1h
                         (650 . 4848) ; 1993 : 28.3. 2h to 19.9. 1h
                         (626 . 4824) ; 1994 : 27.3. 2h to 18.9. 1h
                         (602 . 4800) ; 1995 : 26.3. 2h to 17.9. 1h
                         (722 . 4752) ; 1996 : 31.3. 2h to 15.9. 1h
                         (698 . 4896) ; 1997 : 30.3. 2h to 21.9. 1h
                         (674 . 4872) ; 1998 : 29.3. 2h to 20.9. 1h
                         (650 . 4848) ; 1999 : 28.3. 2h to 19.9. 1h
                         (602 . 4800) ; 2000 : 26.3. 2h to 17.9. 1h
                         (578 . 4776) ; 2001 : 25.3. 2h to 16.9. 1h
                         (722 . 4752) ; 2002 : 31.3. 2h to 15.9. 1h
                         (698 . 4896) ; 2003 : 30.3. 2h to 21.9. 1h
                         (650 . 4848) ; 2004 : 28.3. 2h to 19.9. 1h
                         (626 . 4824) ; 2005 : 27.3. 2h to 18.9. 1h
                         (602 . 4800) ; 2006 : 26.3. 2h to 17.9. 1h
                         (578 . 4776) ; 2007 : 25.3. 2h to 16.9. 1h
                         (698 . 4896) ; 2008 : 30.3. 2h to 21.9. 1h
                         (674 . 4872) ; 2009 : 29.3. 2h to 20.9. 1h
                         (650 . 4848) ; 2010 : 28.3. 2h to 19.9. 1h
                         (626 . 4824) ; 2011 : 27.3. 2h to 18.9. 1h
                         (578 . 4776) ; 2012 : 25.3. 2h to 16.9. 1h
                         (722 . 4752) ; 2013 : 31.3. 2h to 15.9. 1h
                         (698 . 4896) ; 2014 : 30.3. 2h to 21.9. 1h
                         (674 . 4872) ; 2015 : 29.3. 2h to 20.9. 1h
                         (626 . 4824) ; 2016 : 27.3. 2h to 18.9. 1h
                         (602 . 4800) ; 2017 : 26.3. 2h to 17.9. 1h
                         (578 . 4776) ; 2018 : 25.3. 2h to 16.9. 1h
                         (722 . 4752) ; 2019 : 31.3. 2h to 15.9. 1h
                         (674 . 4872) ; 2020 : 29.3. 2h to 20.9. 1h
                        )
                      (- Jahr 1988)
            )) )
         (<= (car Grenzen) Jahresstunde (cdr Grenzen))
   ) ) )
   (ROK-DST-p (Jahr Jahrtag Stunde)
     (and (<= 1987 Jahr 2020)
       (let ((Jahresstunde (+ (* 24 Jahrtag) Stunde))
             (Grenzen
               (svref '#(; 2nd Sunday in May 2h to 2nd Sunday in October 2h
                         (1682 . 5376) ; 1987 : 10.5. 2h to 11.10. 2h
                         (1634 . 5328) ; 1988 : 8.5. 2h to 9.10. 2h
                         (1778 . 5304) ; 1989 : 14.5. 2h to 8.10. 2h
                         (1754 . 5448) ; 1990 : 13.5. 2h to 14.10. 2h
                         (1730 . 5424) ; 1991 : 12.5. 2h to 13.10. 2h
                         (1682 . 5376) ; 1992 : 10.5. 2h to 11.10. 2h
                         (1658 . 5352) ; 1993 : 9.5. 2h to 10.10. 2h
                         (1634 . 5328) ; 1994 : 8.5. 2h to 9.10. 2h
                         (1778 . 5304) ; 1995 : 14.5. 2h to 8.10. 2h
                         (1730 . 5424) ; 1996 : 12.5. 2h to 13.10. 2h
                         (1706 . 5400) ; 1997 : 11.5. 2h to 12.10. 2h
                         (1682 . 5376) ; 1998 : 10.5. 2h to 11.10. 2h
                         (1658 . 5352) ; 1999 : 9.5. 2h to 10.10. 2h
                         (1778 . 5304) ; 2000 : 14.5. 2h to 8.10. 2h
                         (1754 . 5448) ; 2001 : 13.5. 2h to 14.10. 2h
                         (1730 . 5424) ; 2002 : 12.5. 2h to 13.10. 2h
                         (1706 . 5400) ; 2003 : 11.5. 2h to 12.10. 2h
                         (1658 . 5352) ; 2004 : 9.5. 2h to 10.10. 2h
                         (1634 . 5328) ; 2005 : 8.5. 2h to 9.10. 2h
                         (1778 . 5304) ; 2006 : 14.5. 2h to 8.10. 2h
                         (1754 . 5448) ; 2007 : 13.5. 2h to 14.10. 2h
                         (1706 . 5400) ; 2008 : 11.5. 2h to 12.10. 2h
                         (1682 . 5376) ; 2009 : 10.5. 2h to 11.10. 2h
                         (1658 . 5352) ; 2010 : 9.5. 2h to 10.10. 2h
                         (1634 . 5328) ; 2011 : 8.5. 2h to 9.10. 2h
                         (1754 . 5448) ; 2012 : 13.5. 2h to 14.10. 2h
                         (1730 . 5424) ; 2013 : 12.5. 2h to 13.10. 2h
                         (1706 . 5400) ; 2014 : 11.5. 2h to 12.10. 2h
                         (1682 . 5376) ; 2015 : 10.5. 2h to 11.10. 2h
                         (1634 . 5328) ; 2016 : 8.5. 2h to 9.10. 2h
                         (1778 . 5304) ; 2017 : 14.5. 2h to 8.10. 2h
                         (1754 . 5448) ; 2018 : 13.5. 2h to 14.10. 2h
                         (1730 . 5424) ; 2019 : 12.5. 2h to 13.10. 2h
                         (1682 . 5376) ; 2020 : 10.5. 2h to 11.10. 2h
                        )
                      (- Jahr 1987)
            )) )
         (<= (car Grenzen) Jahresstunde (cdr Grenzen))
   ) ) )
   ;; Australia:
   (Australia-Oz-DST-p (Jahr Jahrtag Stunde)
     (when (< Jahrtag 31) ; March?
       (setq Jahrtag (+ Jahrtag (- (UTag Jahr) (UTag (- Jahr 1))))
             Jahr (- Jahr 1)
     ) )
     (and (<= 1971 Jahr 2020)
       (let ((Jahresstunde (+ (* 24 Jahrtag) Stunde))
             (Grenzen
               (svref '#(; last Sunday in October 2h to 27.2. 2h
                         (5858 . 8713) ; 1971 : 31.10. 2h to 27.2. 2h
                         ; last Sunday in October 2h to first Sunday in March 2h
                         (5810 . 8833) ; 1972 : 29.10. 2h to 4.3. 2h
                         (5786 . 8809) ; 1973 : 28.10. 2h to 3.3. 2h
                         (5762 . 8785) ; 1974 : 27.10. 2h to 2.3. 2h
                         (5738 . 8929) ; 1975 : 26.10. 2h to 7.3. 2h
                         (5858 . 8881) ; 1976 : 31.10. 2h to 6.3. 2h
                         (5834 . 8857) ; 1977 : 30.10. 2h to 5.3. 2h
                         (5810 . 8833) ; 1978 : 29.10. 2h to 4.3. 2h
                         (5786 . 8809) ; 1979 : 28.10. 2h to 2.3. 2h
                         (5738 . 8761) ; 1980 : 26.10. 2h to 1.3. 2h
                         (5714 . 8905) ; 1981 : 25.10. 2h to 7.3. 2h
                         (5858 . 8881) ; 1982 : 31.10. 2h to 6.3. 2h
                         (5834 . 8857) ; 1983 : 30.10. 2h to 4.3. 2h
                         (5786 . 8809) ; 1984 : 28.10. 2h to 3.3. 2h
                         (5762 . 8785) ; 1985 : 27.10. 2h to 2.3. 2h
                         ; next-to-last Sunday in October 2h to third Sunday in March 2h
                         (5570 . 9097) ; 1986 : 19.10. 2h to 15.3. 2h
                         (5546 . 9241) ; 1987 : 18.10. 2h to 20.3. 2h
                         (5666 . 9193) ; 1988 : 23.10. 2h to 19.3. 2h
                         (5642 . 9169) ; 1989 : 22.10. 2h to 18.3. 2h
                         (5618 . 9145) ; 1990 : 21.10. 2h to 17.3. 2h
                         (5594 . 9121) ; 1991 : 20.10. 2h to 15.3. 2h
                         (5546 . 9241) ; 1992 : 18.10. 2h to 21.3. 2h
                         (5690 . 9217) ; 1993 : 24.10. 2h to 20.3. 2h
                         (5666 . 9193) ; 1994 : 23.10. 2h to 19.3. 2h
                         (5642 . 9169) ; 1995 : 22.10. 2h to 17.3. 2h
                         (5594 . 9121) ; 1996 : 20.10. 2h to 16.3. 2h
                         (5570 . 9097) ; 1997 : 19.10. 2h to 15.3. 2h
                         (5546 . 9241) ; 1998 : 18.10. 2h to 21.3. 2h
                         (5690 . 9217) ; 1999 : 24.10. 2h to 19.3. 2h
                         (5642 . 9169) ; 2000 : 22.10. 2h to 18.3. 2h
                         (5618 . 9145) ; 2001 : 21.10. 2h to 17.3. 2h
                         (5594 . 9121) ; 2002 : 20.10. 2h to 16.3. 2h
                         (5570 . 9265) ; 2003 : 19.10. 2h to 21.3. 2h
                         (5690 . 9217) ; 2004 : 24.10. 2h to 20.3. 2h
                         (5666 . 9193) ; 2005 : 23.10. 2h to 19.3. 2h
                         (5642 . 9169) ; 2006 : 22.10. 2h to 18.3. 2h
                         (5618 . 9145) ; 2007 : 21.10. 2h to 16.3. 2h
                         (5570 . 9097) ; 2008 : 19.10. 2h to 15.3. 2h
                         (5546 . 9241) ; 2009 : 18.10. 2h to 21.3. 2h
                         (5690 . 9217) ; 2010 : 24.10. 2h to 20.3. 2h
                         (5666 . 9193) ; 2011 : 23.10. 2h to 18.3. 2h
                         (5618 . 9145) ; 2012 : 21.10. 2h to 17.3. 2h
                         (5594 . 9121) ; 2013 : 20.10. 2h to 16.3. 2h
                         (5570 . 9097) ; 2014 : 19.10. 2h to 15.3. 2h
                         (5546 . 9241) ; 2015 : 18.10. 2h to 20.3. 2h
                         (5666 . 9193) ; 2016 : 23.10. 2h to 19.3. 2h
                         (5642 . 9169) ; 2017 : 22.10. 2h to 18.3. 2h
                         (5618 . 9145) ; 2018 : 21.10. 2h to 17.3. 2h
                         (5594 . 9121) ; 2019 : 20.10. 2h to 15.3. 2h
                         (5546 . 9241) ; 2020 : 18.10. 2h to 21.3. 2h
                        )
                      (- Jahr 1971)
            )) )
         (<= (car Grenzen) Jahresstunde (cdr Grenzen))
   ) ) )
   (Australia-Victoria-DST-p (Jahr Jahrtag Stunde)
     (when (< Jahrtag 31) ; March?
       (setq Jahrtag (+ Jahrtag (- (UTag Jahr) (UTag (- Jahr 1))))
             Jahr (- Jahr 1)
     ) )
     (and (<= 1971 Jahr 2020)
       (let ((Jahresstunde (+ (* 24 Jahrtag) Stunde))
             (Grenzen
               (svref '#(; last Sunday in October 2h to 27.2. 2h
                         (5858 . 8713) ; 1971 : 31.10. 2h to 27.2. 2h
                         ; last Sunday in October 2h to first Sunday in March 2h
                         (5810 . 8833) ; 1972 : 29.10. 2h to 4.3. 2h
                         (5786 . 8809) ; 1973 : 28.10. 2h to 3.3. 2h
                         (5762 . 8785) ; 1974 : 27.10. 2h to 2.3. 2h
                         (5738 . 8929) ; 1975 : 26.10. 2h to 7.3. 2h
                         (5858 . 8881) ; 1976 : 31.10. 2h to 6.3. 2h
                         (5834 . 8857) ; 1977 : 30.10. 2h to 5.3. 2h
                         (5810 . 8833) ; 1978 : 29.10. 2h to 4.3. 2h
                         (5786 . 8809) ; 1979 : 28.10. 2h to 2.3. 2h
                         (5738 . 8761) ; 1980 : 26.10. 2h to 1.3. 2h
                         (5714 . 8905) ; 1981 : 25.10. 2h to 7.3. 2h
                         (5858 . 8881) ; 1982 : 31.10. 2h to 6.3. 2h
                         (5834 . 8857) ; 1983 : 30.10. 2h to 4.3. 2h
                         (5786 . 8809) ; 1984 : 28.10. 2h to 3.3. 2h
                         (5762 . 9121) ; 1985 : 27.10. 2h to 16.3. 2h
                         ; next-to-last Sunday in October 2h to third Sunday in March 2h
                         (5570 . 9097) ; 1986 : 19.10. 2h to 15.3. 2h
                         (5546 . 9241) ; 1987 : 18.10. 2h to 20.3. 2h
                         (5666 . 9193) ; 1988 : 23.10. 2h to 19.3. 2h
                         (5642 . 9169) ; 1989 : 22.10. 2h to 18.3. 2h
                         (5618 . 9145) ; 1990 : 21.10. 2h to 17.3. 2h
                         (5594 . 9121) ; 1991 : 20.10. 2h to 15.3. 2h
                         (5546 . 9241) ; 1992 : 18.10. 2h to 21.3. 2h
                         (5690 . 9217) ; 1993 : 24.10. 2h to 20.3. 2h
                         (5666 . 9193) ; 1994 : 23.10. 2h to 19.3. 2h
                         (5642 . 9169) ; 1995 : 22.10. 2h to 17.3. 2h
                         (5594 . 9121) ; 1996 : 20.10. 2h to 16.3. 2h
                         (5570 . 9097) ; 1997 : 19.10. 2h to 15.3. 2h
                         (5546 . 9241) ; 1998 : 18.10. 2h to 21.3. 2h
                         (5690 . 9217) ; 1999 : 24.10. 2h to 19.3. 2h
                         (5642 . 9169) ; 2000 : 22.10. 2h to 18.3. 2h
                         (5618 . 9145) ; 2001 : 21.10. 2h to 17.3. 2h
                         (5594 . 9121) ; 2002 : 20.10. 2h to 16.3. 2h
                         (5570 . 9265) ; 2003 : 19.10. 2h to 21.3. 2h
                         (5690 . 9217) ; 2004 : 24.10. 2h to 20.3. 2h
                         (5666 . 9193) ; 2005 : 23.10. 2h to 19.3. 2h
                         (5642 . 9169) ; 2006 : 22.10. 2h to 18.3. 2h
                         (5618 . 9145) ; 2007 : 21.10. 2h to 16.3. 2h
                         (5570 . 9097) ; 2008 : 19.10. 2h to 15.3. 2h
                         (5546 . 9241) ; 2009 : 18.10. 2h to 21.3. 2h
                         (5690 . 9217) ; 2010 : 24.10. 2h to 20.3. 2h
                         (5666 . 9193) ; 2011 : 23.10. 2h to 18.3. 2h
                         (5618 . 9145) ; 2012 : 21.10. 2h to 17.3. 2h
                         (5594 . 9121) ; 2013 : 20.10. 2h to 16.3. 2h
                         (5570 . 9097) ; 2014 : 19.10. 2h to 15.3. 2h
                         (5546 . 9241) ; 2015 : 18.10. 2h to 20.3. 2h
                         (5666 . 9193) ; 2016 : 23.10. 2h to 19.3. 2h
                         (5642 . 9169) ; 2017 : 22.10. 2h to 18.3. 2h
                         (5618 . 9145) ; 2018 : 21.10. 2h to 17.3. 2h
                         (5594 . 9121) ; 2019 : 20.10. 2h to 15.3. 2h
                         (5546 . 9241) ; 2020 : 18.10. 2h to 21.3. 2h
                        )
                      (- Jahr 1971)
            )) )
         (<= (car Grenzen) Jahresstunde (cdr Grenzen))
   ) ) )
   (Australia-NSW-DST-p (Jahr Jahrtag Stunde)
     (when (< Jahrtag 61) ; March or April?
       (setq Jahrtag (+ Jahrtag (- (UTag Jahr) (UTag (- Jahr 1))))
             Jahr (- Jahr 1)
     ) )
     (and (<= 1971 Jahr 2020)
       (let ((Jahresstunde (+ (* 24 Jahrtag) Stunde))
             (Grenzen
               (svref '#(; last Sunday in October 2h to 27.2. 2h
                         (5858 . 8713) ; 1971 : 31.10. 2h to 27.2. 2h
                         ; last Sunday in October 2h to first Sunday in March 2h
                         (5810 . 8833) ; 1972 : 29.10. 2h to 4.3. 2h
                         (5786 . 8809) ; 1973 : 28.10. 2h to 3.3. 2h
                         (5762 . 8785) ; 1974 : 27.10. 2h to 2.3. 2h
                         (5738 . 8929) ; 1975 : 26.10. 2h to 7.3. 2h
                         (5858 . 8881) ; 1976 : 31.10. 2h to 6.3. 2h
                         (5834 . 8857) ; 1977 : 30.10. 2h to 5.3. 2h
                         (5810 . 8833) ; 1978 : 29.10. 2h to 4.3. 2h
                         (5786 . 8809) ; 1979 : 28.10. 2h to 2.3. 2h
                         (5738 . 8761) ; 1980 : 26.10. 2h to 1.3. 2h
                         (5714 . 9577) ; 1981 : 25.10. 2h to 4.4. 2h
                         (5858 . 8881) ; 1982 : 31.10. 2h to 6.3. 2h
                         (5834 . 8857) ; 1983 : 30.10. 2h to 4.3. 2h
                         (5786 . 8809) ; 1984 : 28.10. 2h to 3.3. 2h
                         (5762 . 9121) ; 1985 : 27.10. 2h to 16.3. 2h
                         ; next-to-last Sunday in October 2h to third Sunday in March 2h
                         (5570 . 9097) ; 1986 : 19.10. 2h to 15.3. 2h
                         ; last Sunday in October 2h to third Sunday in March 2h
                         (5714 . 9241) ; 1987 : 25.10. 2h to 20.3. 2h
                         (5834 . 9193) ; 1988 : 30.10. 2h to 19.3. 2h
                         (5810 . 9169) ; 1989 : 29.10. 2h to 18.3. 2h
                         (5786 . 9145) ; 1990 : 28.10. 2h to 17.3. 2h
                         (5762 . 9121) ; 1991 : 27.10. 2h to 15.3. 2h
                         (5714 . 9241) ; 1992 : 25.10. 2h to 21.3. 2h
                         (5858 . 9217) ; 1993 : 31.10. 2h to 20.3. 2h
                         (5834 . 9193) ; 1994 : 30.10. 2h to 19.3. 2h
                         (5810 . 9169) ; 1995 : 29.10. 2h to 17.3. 2h
                         (5762 . 9121) ; 1996 : 27.10. 2h to 16.3. 2h
                         (5738 . 9097) ; 1997 : 26.10. 2h to 15.3. 2h
                         (5714 . 9241) ; 1998 : 25.10. 2h to 21.3. 2h
                         (5858 . 9217) ; 1999 : 31.10. 2h to 19.3. 2h
                         (5810 . 9169) ; 2000 : 29.10. 2h to 18.3. 2h
                         (5786 . 9145) ; 2001 : 28.10. 2h to 17.3. 2h
                         (5762 . 9121) ; 2002 : 27.10. 2h to 16.3. 2h
                         (5738 . 9265) ; 2003 : 26.10. 2h to 21.3. 2h
                         (5858 . 9217) ; 2004 : 31.10. 2h to 20.3. 2h
                         (5834 . 9193) ; 2005 : 30.10. 2h to 19.3. 2h
                         (5810 . 9169) ; 2006 : 29.10. 2h to 18.3. 2h
                         (5786 . 9145) ; 2007 : 28.10. 2h to 16.3. 2h
                         (5738 . 9097) ; 2008 : 26.10. 2h to 15.3. 2h
                         (5714 . 9241) ; 2009 : 25.10. 2h to 21.3. 2h
                         (5858 . 9217) ; 2010 : 31.10. 2h to 20.3. 2h
                         (5834 . 9193) ; 2011 : 30.10. 2h to 18.3. 2h
                         (5786 . 9145) ; 2012 : 28.10. 2h to 17.3. 2h
                         (5762 . 9121) ; 2013 : 27.10. 2h to 16.3. 2h
                         (5738 . 9097) ; 2014 : 26.10. 2h to 15.3. 2h
                         (5714 . 9241) ; 2015 : 25.10. 2h to 20.3. 2h
                         (5834 . 9193) ; 2016 : 30.10. 2h to 19.3. 2h
                         (5810 . 9169) ; 2017 : 29.10. 2h to 18.3. 2h
                         (5786 . 9145) ; 2018 : 28.10. 2h to 17.3. 2h
                         (5762 . 9121) ; 2019 : 27.10. 2h to 15.3. 2h
                         (5714 . 9241) ; 2020 : 25.10. 2h to 21.3. 2h
                        )
                      (- Jahr 1971)
            )) )
         (<= (car Grenzen) Jahresstunde (cdr Grenzen))
   ) ) )
   (NZ-DST-p (Jahr Jahrtag Stunde)
     (when (< Jahrtag 31) ; March?
       (setq Jahrtag (+ Jahrtag (- (UTag Jahr) (UTag (- Jahr 1))))
             Jahr (- Jahr 1)
     ) )
     (and (<= 1974 Jahr 2020)
       (let ((Jahresstunde (+ (* 24 Jahrtag) Stunde))
             (Grenzen
               (svref '#(; last Sunday in October 2h to first Sunday in March 2h
                         (5762 . 8785) ; 1974 : 27.10. 2h to 2.3. 2h
                         (5738 . 8929) ; 1975 : 26.10. 2h to 7.3. 2h
                         (5858 . 8881) ; 1976 : 31.10. 2h to 6.3. 2h
                         (5834 . 8857) ; 1977 : 30.10. 2h to 5.3. 2h
                         (5810 . 8833) ; 1978 : 29.10. 2h to 4.3. 2h
                         (5786 . 8809) ; 1979 : 28.10. 2h to 2.3. 2h
                         (5738 . 8761) ; 1980 : 26.10. 2h to 1.3. 2h
                         (5714 . 8905) ; 1981 : 25.10. 2h to 7.3. 2h
                         (5858 . 8881) ; 1982 : 31.10. 2h to 6.3. 2h
                         (5834 . 8857) ; 1983 : 30.10. 2h to 4.3. 2h
                         (5786 . 8809) ; 1984 : 28.10. 2h to 3.3. 2h
                         (5762 . 8785) ; 1985 : 27.10. 2h to 2.3. 2h
                         (5738 . 8761) ; 1986 : 26.10. 2h to 1.3. 2h
                         (5714 . 8905) ; 1987 : 25.10. 2h to 6.3. 2h
                         (5834 . 8857) ; 1988 : 30.10. 2h to 5.3. 2h
                         (5810 . 8833) ; 1989 : 29.10. 2h to 4.3. 2h
                         (5786 . 8809) ; 1990 : 28.10. 2h to 3.3. 2h
                         (5762 . 8785) ; 1991 : 27.10. 2h to 1.3. 2h
                         (5714 . 8905) ; 1992 : 25.10. 2h to 7.3. 2h
                         (5858 . 8881) ; 1993 : 31.10. 2h to 6.3. 2h
                         (5834 . 8857) ; 1994 : 30.10. 2h to 5.3. 2h
                         (5810 . 8833) ; 1995 : 29.10. 2h to 3.3. 2h
                         (5762 . 8785) ; 1996 : 27.10. 2h to 2.3. 2h
                         (5738 . 8761) ; 1997 : 26.10. 2h to 1.3. 2h
                         (5714 . 8905) ; 1998 : 25.10. 2h to 7.3. 2h
                         (5858 . 8881) ; 1999 : 31.10. 2h to 5.3. 2h
                         (5810 . 8833) ; 2000 : 29.10. 2h to 4.3. 2h
                         (5786 . 8809) ; 2001 : 28.10. 2h to 3.3. 2h
                         (5762 . 8785) ; 2002 : 27.10. 2h to 2.3. 2h
                         (5738 . 8929) ; 2003 : 26.10. 2h to 7.3. 2h
                         (5858 . 8881) ; 2004 : 31.10. 2h to 6.3. 2h
                         (5834 . 8857) ; 2005 : 30.10. 2h to 5.3. 2h
                         (5810 . 8833) ; 2006 : 29.10. 2h to 4.3. 2h
                         (5786 . 8809) ; 2007 : 28.10. 2h to 2.3. 2h
                         (5738 . 8761) ; 2008 : 26.10. 2h to 1.3. 2h
                         (5714 . 8905) ; 2009 : 25.10. 2h to 7.3. 2h
                         (5858 . 8881) ; 2010 : 31.10. 2h to 6.3. 2h
                         (5834 . 8857) ; 2011 : 30.10. 2h to 4.3. 2h
                         (5786 . 8809) ; 2012 : 28.10. 2h to 3.3. 2h
                         (5762 . 8785) ; 2013 : 27.10. 2h to 2.3. 2h
                         (5738 . 8761) ; 2014 : 26.10. 2h to 1.3. 2h
                         (5714 . 8905) ; 2015 : 25.10. 2h to 6.3. 2h
                         (5834 . 8857) ; 2016 : 30.10. 2h to 5.3. 2h
                         (5810 . 8833) ; 2017 : 29.10. 2h to 4.3. 2h
                         (5786 . 8809) ; 2018 : 28.10. 2h to 3.3. 2h
                         (5762 . 8785) ; 2019 : 27.10. 2h to 1.3. 2h
                         (5714 . 8905) ; 2020 : 25.10. 2h to 7.3. 2h
                        )
                      (- Jahr 1974)
            )) )
         (<= (car Grenzen) Jahresstunde (cdr Grenzen))
   ) ) )
   ;; Africa:
   (Egypt-DST-p (Jahr Jahrtag Stunde)
     (and (>= Jahr 1960) (not (<= 1981 Jahr 1982))
          ; 1.5. 2h to 1.10. 1h
          (let ((Jahresstunde (+ (* 24 Jahrtag) Stunde)))
            (<= 1466 Jahresstunde 5136)
   ) )    )
   (Libya-DST-p (Jahr Jahrtag Stunde)
     (and (>= Jahr 1982)
          ; 1.4. 2h to 30.9. 1h
          (let ((Jahresstunde (+ (* 24 Jahrtag) Stunde)))
            (<= 746 Jahresstunde 5112)
   ) )    )
   ;; North America:
   (Canada-DST-p (Jahr Jahrtag Stunde)
     (and (<= 1969 Jahr 2020)
       (let ((Jahresstunde (+ (* 24 Jahrtag) Stunde))
             (Grenzen
               (svref '#(; last Sunday in April 2h to last Sunday in October 2h
                         (1370 . 5736) ; 1969 : 27.4. 2h to 26.10. 1h
                         (1346 . 5712) ; 1970 : 26.4. 2h to 25.10. 1h
                         (1322 . 5856) ; 1971 : 25.4. 2h to 31.10. 1h
                         (1442 . 5808) ; 1972 : 30.4. 2h to 29.10. 1h
                         (1418 . 5784) ; 1973 : 29.4. 2h to 28.10. 1h
                         (1394 . 5760) ; 1974 : 28.4. 2h to 27.10. 1h
                         (1370 . 5736) ; 1975 : 27.4. 2h to 26.10. 1h
                         (1322 . 5856) ; 1976 : 25.4. 2h to 31.10. 1h
                         (1298 . 5832) ; 1977 : 24.4. 2h to 30.10. 1h
                         (1442 . 5808) ; 1978 : 30.4. 2h to 29.10. 1h
                         (1418 . 5784) ; 1979 : 29.4. 2h to 28.10. 1h
                         (1370 . 5736) ; 1980 : 27.4. 2h to 26.10. 1h
                         (1346 . 5712) ; 1981 : 26.4. 2h to 25.10. 1h
                         (1322 . 5856) ; 1982 : 25.4. 2h to 31.10. 1h
                         (1298 . 5832) ; 1983 : 24.4. 2h to 30.10. 1h
                         (1418 . 5784) ; 1984 : 29.4. 2h to 28.10. 1h
                         (1394 . 5760) ; 1985 : 28.4. 2h to 27.10. 1h
                         (1370 . 5736) ; 1986 : 27.4. 2h to 26.10. 1h
                         ; first Sunday in April 2h to last Sunday in October 2h
                         (842 . 5712) ; 1987 : 5.4. 2h to 25.10. 1h
                         (794 . 5832) ; 1988 : 3.4. 2h to 30.10. 1h
                         (770 . 5808) ; 1989 : 2.4. 2h to 29.10. 1h
                         (746 . 5784) ; 1990 : 1.4. 2h to 28.10. 1h
                         (890 . 5760) ; 1991 : 7.4. 2h to 27.10. 1h
                         (842 . 5712) ; 1992 : 5.4. 2h to 25.10. 1h
                         (818 . 5856) ; 1993 : 4.4. 2h to 31.10. 1h
                         (794 . 5832) ; 1994 : 3.4. 2h to 30.10. 1h
                         (770 . 5808) ; 1995 : 2.4. 2h to 29.10. 1h
                         (890 . 5760) ; 1996 : 7.4. 2h to 27.10. 1h
                         (866 . 5736) ; 1997 : 6.4. 2h to 26.10. 1h
                         (842 . 5712) ; 1998 : 5.4. 2h to 25.10. 1h
                         (818 . 5856) ; 1999 : 4.4. 2h to 31.10. 1h
                         (770 . 5808) ; 2000 : 2.4. 2h to 29.10. 1h
                         (746 . 5784) ; 2001 : 1.4. 2h to 28.10. 1h
                         (890 . 5760) ; 2002 : 7.4. 2h to 27.10. 1h
                         (866 . 5736) ; 2003 : 6.4. 2h to 26.10. 1h
                         (818 . 5856) ; 2004 : 4.4. 2h to 31.10. 1h
                         (794 . 5832) ; 2005 : 3.4. 2h to 30.10. 1h
                         (770 . 5808) ; 2006 : 2.4. 2h to 29.10. 1h
                         (746 . 5784) ; 2007 : 1.4. 2h to 28.10. 1h
                         (866 . 5736) ; 2008 : 6.4. 2h to 26.10. 1h
                         (842 . 5712) ; 2009 : 5.4. 2h to 25.10. 1h
                         (818 . 5856) ; 2010 : 4.4. 2h to 31.10. 1h
                         (794 . 5832) ; 2011 : 3.4. 2h to 30.10. 1h
                         (746 . 5784) ; 2012 : 1.4. 2h to 28.10. 1h
                         (890 . 5760) ; 2013 : 7.4. 2h to 27.10. 1h
                         (866 . 5736) ; 2014 : 6.4. 2h to 26.10. 1h
                         (842 . 5712) ; 2015 : 5.4. 2h to 25.10. 1h
                         (794 . 5832) ; 2016 : 3.4. 2h to 30.10. 1h
                         (770 . 5808) ; 2017 : 2.4. 2h to 29.10. 1h
                         (746 . 5784) ; 2018 : 1.4. 2h to 28.10. 1h
                         (890 . 5760) ; 2019 : 7.4. 2h to 27.10. 1h
                         (842 . 5712) ; 2020 : 5.4. 2h to 25.10. 1h
                        )
                      (- Jahr 1969)
            )) )
         (<= (car Grenzen) Jahresstunde (cdr Grenzen))
   ) ) )
   (Cuba-DST-p (Jahr Jahrtag Stunde)
     (and (<= 1979 Jahr 2020)
       (let ((Jahresstunde (+ (* 24 Jahrtag) Stunde))
             (Grenzen
               (svref '#(; third Sunday in March 0h to 2nd Sunday in October 0h
                         (408 . 5446) ; 1979 : 18.3. 0h to 13.10. 23h
                         (360 . 5398) ; 1980 : 16.3. 0h to 11.10. 23h
                         ; 2nd Sunday in May 0h to 2nd Sunday in October 0h
                         (1680 . 5374) ; 1981 : 10.5. 0h to 10.10. 23h
                         (1656 . 5350) ; 1982 : 9.5. 0h to 9.10. 23h
                         (1632 . 5326) ; 1983 : 8.5. 0h to 8.10. 23h
                         (1752 . 5446) ; 1984 : 13.5. 0h to 13.10. 23h
                         (1728 . 5422) ; 1985 : 12.5. 0h to 12.10. 23h
                         (1704 . 5398) ; 1986 : 11.5. 0h to 11.10. 23h
                         (1680 . 5374) ; 1987 : 10.5. 0h to 10.10. 23h
                         (1632 . 5326) ; 1988 : 8.5. 0h to 8.10. 23h
                         (1776 . 5302) ; 1989 : 14.5. 0h to 7.10. 23h
                         (1752 . 5446) ; 1990 : 13.5. 0h to 13.10. 23h
                         (1728 . 5422) ; 1991 : 12.5. 0h to 12.10. 23h
                         (1680 . 5374) ; 1992 : 10.5. 0h to 10.10. 23h
                         (1656 . 5350) ; 1993 : 9.5. 0h to 9.10. 23h
                         (1632 . 5326) ; 1994 : 8.5. 0h to 8.10. 23h
                         (1776 . 5302) ; 1995 : 14.5. 0h to 7.10. 23h
                         (1728 . 5422) ; 1996 : 12.5. 0h to 12.10. 23h
                         (1704 . 5398) ; 1997 : 11.5. 0h to 11.10. 23h
                         (1680 . 5374) ; 1998 : 10.5. 0h to 10.10. 23h
                         (1656 . 5350) ; 1999 : 9.5. 0h to 9.10. 23h
                         (1776 . 5302) ; 2000 : 14.5. 0h to 7.10. 23h
                         (1752 . 5446) ; 2001 : 13.5. 0h to 13.10. 23h
                         (1728 . 5422) ; 2002 : 12.5. 0h to 12.10. 23h
                         (1704 . 5398) ; 2003 : 11.5. 0h to 11.10. 23h
                         (1656 . 5350) ; 2004 : 9.5. 0h to 9.10. 23h
                         (1632 . 5326) ; 2005 : 8.5. 0h to 8.10. 23h
                         (1776 . 5302) ; 2006 : 14.5. 0h to 7.10. 23h
                         (1752 . 5446) ; 2007 : 13.5. 0h to 13.10. 23h
                         (1704 . 5398) ; 2008 : 11.5. 0h to 11.10. 23h
                         (1680 . 5374) ; 2009 : 10.5. 0h to 10.10. 23h
                         (1656 . 5350) ; 2010 : 9.5. 0h to 9.10. 23h
                         (1632 . 5326) ; 2011 : 8.5. 0h to 8.10. 23h
                         (1752 . 5446) ; 2012 : 13.5. 0h to 13.10. 23h
                         (1728 . 5422) ; 2013 : 12.5. 0h to 12.10. 23h
                         (1704 . 5398) ; 2014 : 11.5. 0h to 11.10. 23h
                         (1680 . 5374) ; 2015 : 10.5. 0h to 10.10. 23h
                         (1632 . 5326) ; 2016 : 8.5. 0h to 8.10. 23h
                         (1776 . 5302) ; 2017 : 14.5. 0h to 7.10. 23h
                         (1752 . 5446) ; 2018 : 13.5. 0h to 13.10. 23h
                         (1728 . 5422) ; 2019 : 12.5. 0h to 12.10. 23h
                         (1680 . 5374) ; 2020 : 10.5. 0h to 10.10. 23h
                        )
                      (- Jahr 1979)
            )) )
         (<= (car Grenzen) Jahresstunde (cdr Grenzen))
   ) ) )
   (Mexico-DST-p (Jahr Jahrtag Stunde)
     (and (<= 1987 Jahr 2020)
       (let ((Jahresstunde (+ (* 24 Jahrtag) Stunde))
             (Grenzen
               (svref '#(; first Sunday in April 2h to last Sunday in October 2h
                         (842 . 5712) ; 1987 : 5.4. 2h to 25.10. 1h
                         (794 . 5832) ; 1988 : 3.4. 2h to 30.10. 1h
                         (770 . 5808) ; 1989 : 2.4. 2h to 29.10. 1h
                         (746 . 5784) ; 1990 : 1.4. 2h to 28.10. 1h
                         (890 . 5760) ; 1991 : 7.4. 2h to 27.10. 1h
                         (842 . 5712) ; 1992 : 5.4. 2h to 25.10. 1h
                         (818 . 5856) ; 1993 : 4.4. 2h to 31.10. 1h
                         (794 . 5832) ; 1994 : 3.4. 2h to 30.10. 1h
                         (770 . 5808) ; 1995 : 2.4. 2h to 29.10. 1h
                         (890 . 5760) ; 1996 : 7.4. 2h to 27.10. 1h
                         (866 . 5736) ; 1997 : 6.4. 2h to 26.10. 1h
                         (842 . 5712) ; 1998 : 5.4. 2h to 25.10. 1h
                         (818 . 5856) ; 1999 : 4.4. 2h to 31.10. 1h
                         (770 . 5808) ; 2000 : 2.4. 2h to 29.10. 1h
                         (746 . 5784) ; 2001 : 1.4. 2h to 28.10. 1h
                         (890 . 5760) ; 2002 : 7.4. 2h to 27.10. 1h
                         (866 . 5736) ; 2003 : 6.4. 2h to 26.10. 1h
                         (818 . 5856) ; 2004 : 4.4. 2h to 31.10. 1h
                         (794 . 5832) ; 2005 : 3.4. 2h to 30.10. 1h
                         (770 . 5808) ; 2006 : 2.4. 2h to 29.10. 1h
                         (746 . 5784) ; 2007 : 1.4. 2h to 28.10. 1h
                         (866 . 5736) ; 2008 : 6.4. 2h to 26.10. 1h
                         (842 . 5712) ; 2009 : 5.4. 2h to 25.10. 1h
                         (818 . 5856) ; 2010 : 4.4. 2h to 31.10. 1h
                         (794 . 5832) ; 2011 : 3.4. 2h to 30.10. 1h
                         (746 . 5784) ; 2012 : 1.4. 2h to 28.10. 1h
                         (890 . 5760) ; 2013 : 7.4. 2h to 27.10. 1h
                         (866 . 5736) ; 2014 : 6.4. 2h to 26.10. 1h
                         (842 . 5712) ; 2015 : 5.4. 2h to 25.10. 1h
                         (794 . 5832) ; 2016 : 3.4. 2h to 30.10. 1h
                         (770 . 5808) ; 2017 : 2.4. 2h to 29.10. 1h
                         (746 . 5784) ; 2018 : 1.4. 2h to 28.10. 1h
                         (890 . 5760) ; 2019 : 7.4. 2h to 27.10. 1h
                         (842 . 5712) ; 2020 : 5.4. 2h to 25.10. 1h
                        )
                      (- Jahr 1987)
            )) )
         (<= (car Grenzen) Jahresstunde (cdr Grenzen))
   ) ) )
   (US-DST-p (Jahr Jahrtag Stunde)
     (when (>= Jahrtag 306) ; January or February?
       (setq Jahr (+ Jahr 1)
             Jahrtag (- Jahrtag (- (UTag Jahr) (UTag (- Jahr 1))))
     ) )
     (and (<= 1967 Jahr 2020)
       (let ((Jahresstunde (+ (* 24 Jahrtag) Stunde))
             (Grenzen
               (svref '#(; last Sunday in April 2h to last Sunday in October 2h
                         (1442 . 5808) ; 1967 : 30.4. 2h to 29.10. 1h
                         (1394 . 5760) ; 1968 : 28.4. 2h to 27.10. 1h
                         (1370 . 5736) ; 1969 : 27.4. 2h to 26.10. 1h
                         (1346 . 5712) ; 1970 : 26.4. 2h to 25.10. 1h
                         (1322 . 5856) ; 1971 : 25.4. 2h to 31.10. 1h
                         (1442 . 5808) ; 1972 : 30.4. 2h to 29.10. 1h
                         (1418 . 5784) ; 1973 : 29.4. 2h to 28.10. 1h
                         ; 6.1. 2h to last Sunday in October 2h
                         (-1294 . 5760) ; 1974 : 6.1. 2h to 27.10. 1h
                         ; 23.2. 2h to last Sunday in October 2h
                         (-142 . 5736) ; 1975 : 23.2. 2h to 26.10. 1h
                         ; last Sunday in April 2h to last Sunday in October 2h
                         (1322 . 5856) ; 1976 : 25.4. 2h to 31.10. 1h
                         (1298 . 5832) ; 1977 : 24.4. 2h to 30.10. 1h
                         (1442 . 5808) ; 1978 : 30.4. 2h to 29.10. 1h
                         (1418 . 5784) ; 1979 : 29.4. 2h to 28.10. 1h
                         (1370 . 5736) ; 1980 : 27.4. 2h to 26.10. 1h
                         (1346 . 5712) ; 1981 : 26.4. 2h to 25.10. 1h
                         (1322 . 5856) ; 1982 : 25.4. 2h to 31.10. 1h
                         (1298 . 5832) ; 1983 : 24.4. 2h to 30.10. 1h
                         (1418 . 5784) ; 1984 : 29.4. 2h to 28.10. 1h
                         (1394 . 5760) ; 1985 : 28.4. 2h to 27.10. 1h
                         (1370 . 5736) ; 1986 : 27.4. 2h to 26.10. 1h
                         ; first Sunday in April 2h to last Sunday in October 2h
                         (842 . 5712) ; 1987 : 5.4. 2h to 25.10. 1h
                         (794 . 5832) ; 1988 : 3.4. 2h to 30.10. 1h
                         (770 . 5808) ; 1989 : 2.4. 2h to 29.10. 1h
                         (746 . 5784) ; 1990 : 1.4. 2h to 28.10. 1h
                         (890 . 5760) ; 1991 : 7.4. 2h to 27.10. 1h
                         (842 . 5712) ; 1992 : 5.4. 2h to 25.10. 1h
                         (818 . 5856) ; 1993 : 4.4. 2h to 31.10. 1h
                         (794 . 5832) ; 1994 : 3.4. 2h to 30.10. 1h
                         (770 . 5808) ; 1995 : 2.4. 2h to 29.10. 1h
                         (890 . 5760) ; 1996 : 7.4. 2h to 27.10. 1h
                         (866 . 5736) ; 1997 : 6.4. 2h to 26.10. 1h
                         (842 . 5712) ; 1998 : 5.4. 2h to 25.10. 1h
                         (818 . 5856) ; 1999 : 4.4. 2h to 31.10. 1h
                         (770 . 5808) ; 2000 : 2.4. 2h to 29.10. 1h
                         (746 . 5784) ; 2001 : 1.4. 2h to 28.10. 1h
                         (890 . 5760) ; 2002 : 7.4. 2h to 27.10. 1h
                         (866 . 5736) ; 2003 : 6.4. 2h to 26.10. 1h
                         (818 . 5856) ; 2004 : 4.4. 2h to 31.10. 1h
                         (794 . 5832) ; 2005 : 3.4. 2h to 30.10. 1h
                         (770 . 5808) ; 2006 : 2.4. 2h to 29.10. 1h
                         (746 . 5784) ; 2007 : 1.4. 2h to 28.10. 1h
                         (866 . 5736) ; 2008 : 6.4. 2h to 26.10. 1h
                         (842 . 5712) ; 2009 : 5.4. 2h to 25.10. 1h
                         (818 . 5856) ; 2010 : 4.4. 2h to 31.10. 1h
                         (794 . 5832) ; 2011 : 3.4. 2h to 30.10. 1h
                         (746 . 5784) ; 2012 : 1.4. 2h to 28.10. 1h
                         (890 . 5760) ; 2013 : 7.4. 2h to 27.10. 1h
                         (866 . 5736) ; 2014 : 6.4. 2h to 26.10. 1h
                         (842 . 5712) ; 2015 : 5.4. 2h to 25.10. 1h
                         (794 . 5832) ; 2016 : 3.4. 2h to 30.10. 1h
                         (770 . 5808) ; 2017 : 2.4. 2h to 29.10. 1h
                         (746 . 5784) ; 2018 : 1.4. 2h to 28.10. 1h
                         (890 . 5760) ; 2019 : 7.4. 2h to 27.10. 1h
                         (842 . 5712) ; 2020 : 5.4. 2h to 25.10. 1h
                        )
                      (- Jahr 1967)
            )) )
         (<= (car Grenzen) Jahresstunde (cdr Grenzen))
   ) ) )
   (US-Michigan-DST-p (Jahr Jahrtag Stunde)
     (if (<= 1968 Jahr 1972) nil (US-DST-p Jahr Jahrtag Stunde))
   )
   (US-Pacific-New-DST-p (Jahr Jahrtag Stunde)
     (and (<= 1967 Jahr 2020)
       (if (and (>= Jahr 1992) (zerop (mod Jahr 4)))
         ; Twilite-DST-p: DST lasts two (or one) weeks longer since 1992
         (let ((Jahresstunde (+ (* 24 Jahrtag) Stunde))
               (Grenzen
                 (svref '#(; first Sunday in April 2h to Sunday>=7 in November 2h
                           (842 . 6048) ; 1992 : 5.4. 2h to 8.11. 1h
                           (890 . 6096) ; 1996 : 7.4. 2h to 10.11. 1h
                           (770 . 6144) ; 2000 : 2.4. 2h to 12.11. 1h
                           (818 . 6024) ; 2004 : 4.4. 2h to 7.11. 1h
                           (866 . 6072) ; 2008 : 6.4. 2h to 9.11. 1h
                           (746 . 6120) ; 2012 : 1.4. 2h to 11.11. 1h
                           (794 . 6168) ; 2016 : 3.4. 2h to 13.11. 1h
                           (842 . 6048) ; 2020 : 5.4. 2h to 8.11. 1h
                          )
                        (/ (- Jahr 1992) 4)
              )) )
           (<= (car Grenzen) Jahresstunde (cdr Grenzen))
         )
         (US-DST-p Jahr Jahrtag Stunde)
   ) ) )
   (SystemV-DST-p (Jahr Jahrtag Stunde) ; obsolete
     (when (>= Jahrtag 306) ; January or February?
       (setq Jahr (+ Jahr 1)
             Jahrtag (- Jahrtag (- (UTag Jahr) (UTag (- Jahr 1))))
     ) )
     (and (<= 1950 Jahr 2020)
       (let ((Jahresstunde (+ (* 24 Jahrtag) Stunde))
             (Grenzen
               (svref '#(; last Sunday in April 2h to last Sunday in October 2h
                         (1442 . 5808) ; 1950 : 30.4. 2h to 29.10. 1h
                         (1418 . 5784) ; 1951 : 29.4. 2h to 28.10. 1h
                         (1370 . 5736) ; 1952 : 27.4. 2h to 26.10. 1h
                         (1346 . 5712) ; 1953 : 26.4. 2h to 25.10. 1h
                         (1322 . 5856) ; 1954 : 25.4. 2h to 31.10. 1h
                         (1298 . 5832) ; 1955 : 24.4. 2h to 30.10. 1h
                         (1418 . 5784) ; 1956 : 29.4. 2h to 28.10. 1h
                         (1394 . 5760) ; 1957 : 28.4. 2h to 27.10. 1h
                         (1370 . 5736) ; 1958 : 27.4. 2h to 26.10. 1h
                         (1346 . 5712) ; 1959 : 26.4. 2h to 25.10. 1h
                         (1298 . 5832) ; 1960 : 24.4. 2h to 30.10. 1h
                         (1442 . 5808) ; 1961 : 30.4. 2h to 29.10. 1h
                         (1418 . 5784) ; 1962 : 29.4. 2h to 28.10. 1h
                         (1394 . 5760) ; 1963 : 28.4. 2h to 27.10. 1h
                         (1346 . 5712) ; 1964 : 26.4. 2h to 25.10. 1h
                         (1322 . 5856) ; 1965 : 25.4. 2h to 31.10. 1h
                         (1298 . 5832) ; 1966 : 24.4. 2h to 30.10. 1h
                         (1442 . 5808) ; 1967 : 30.4. 2h to 29.10. 1h
                         (1394 . 5760) ; 1968 : 28.4. 2h to 27.10. 1h
                         (1370 . 5736) ; 1969 : 27.4. 2h to 26.10. 1h
                         (1346 . 5712) ; 1970 : 26.4. 2h to 25.10. 1h
                         (1322 . 5856) ; 1971 : 25.4. 2h to 31.10. 1h
                         (1442 . 5808) ; 1972 : 30.4. 2h to 29.10. 1h
                         (1418 . 5784) ; 1973 : 29.4. 2h to 28.10. 1h
                         ; 6.1. 2h to last Sunday in November 2h
                         (-1294 . 6432) ; 1974 : 6.1. 2h to 24.11. 1h
                         ; 23.2. 2h to last Sunday in October 2h
                         (-142 . 5736) ; 1975 : 23.2. 2h to 26.10. 1h
                         ; last Sunday in April 2h to last Sunday in October 2h
                         (1322 . 5856) ; 1976 : 25.4. 2h to 31.10. 1h
                         (1298 . 5832) ; 1977 : 24.4. 2h to 30.10. 1h
                         (1442 . 5808) ; 1978 : 30.4. 2h to 29.10. 1h
                         (1418 . 5784) ; 1979 : 29.4. 2h to 28.10. 1h
                         (1370 . 5736) ; 1980 : 27.4. 2h to 26.10. 1h
                         (1346 . 5712) ; 1981 : 26.4. 2h to 25.10. 1h
                         (1322 . 5856) ; 1982 : 25.4. 2h to 31.10. 1h
                         (1298 . 5832) ; 1983 : 24.4. 2h to 30.10. 1h
                         (1418 . 5784) ; 1984 : 29.4. 2h to 28.10. 1h
                         (1394 . 5760) ; 1985 : 28.4. 2h to 27.10. 1h
                         (1370 . 5736) ; 1986 : 27.4. 2h to 26.10. 1h
                         (1346 . 5712) ; 1987 : 26.4. 2h to 25.10. 1h
                         (1298 . 5832) ; 1988 : 24.4. 2h to 30.10. 1h
                         (1442 . 5808) ; 1989 : 30.4. 2h to 29.10. 1h
                         (1418 . 5784) ; 1990 : 29.4. 2h to 28.10. 1h
                         (1394 . 5760) ; 1991 : 28.4. 2h to 27.10. 1h
                         (1346 . 5712) ; 1992 : 26.4. 2h to 25.10. 1h
                         (1322 . 5856) ; 1993 : 25.4. 2h to 31.10. 1h
                         (1298 . 5832) ; 1994 : 24.4. 2h to 30.10. 1h
                         (1442 . 5808) ; 1995 : 30.4. 2h to 29.10. 1h
                         (1394 . 5760) ; 1996 : 28.4. 2h to 27.10. 1h
                         (1370 . 5736) ; 1997 : 27.4. 2h to 26.10. 1h
                         (1346 . 5712) ; 1998 : 26.4. 2h to 25.10. 1h
                         (1322 . 5856) ; 1999 : 25.4. 2h to 31.10. 1h
                         (1442 . 5808) ; 2000 : 30.4. 2h to 29.10. 1h
                         (1418 . 5784) ; 2001 : 29.4. 2h to 28.10. 1h
                         (1394 . 5760) ; 2002 : 28.4. 2h to 27.10. 1h
                         (1370 . 5736) ; 2003 : 27.4. 2h to 26.10. 1h
                         (1322 . 5856) ; 2004 : 25.4. 2h to 31.10. 1h
                         (1298 . 5832) ; 2005 : 24.4. 2h to 30.10. 1h
                         (1442 . 5808) ; 2006 : 30.4. 2h to 29.10. 1h
                         (1418 . 5784) ; 2007 : 29.4. 2h to 28.10. 1h
                         (1370 . 5736) ; 2008 : 27.4. 2h to 26.10. 1h
                         (1346 . 5712) ; 2009 : 26.4. 2h to 25.10. 1h
                         (1322 . 5856) ; 2010 : 25.4. 2h to 31.10. 1h
                         (1298 . 5832) ; 2011 : 24.4. 2h to 30.10. 1h
                         (1418 . 5784) ; 2012 : 29.4. 2h to 28.10. 1h
                         (1394 . 5760) ; 2013 : 28.4. 2h to 27.10. 1h
                         (1370 . 5736) ; 2014 : 27.4. 2h to 26.10. 1h
                         (1346 . 5712) ; 2015 : 26.4. 2h to 25.10. 1h
                         (1298 . 5832) ; 2016 : 24.4. 2h to 30.10. 1h
                         (1442 . 5808) ; 2017 : 30.4. 2h to 29.10. 1h
                         (1418 . 5784) ; 2018 : 29.4. 2h to 28.10. 1h
                         (1394 . 5760) ; 2019 : 28.4. 2h to 27.10. 1h
                         (1346 . 5712) ; 2020 : 26.4. 2h to 25.10. 1h
                        )
                      (- Jahr 1950)
            )) )
         (<= (car Grenzen) Jahresstunde (cdr Grenzen))
   ) ) )
   ;; South America:
   (Brazil-DST-p (Jahr Jahrtag Stunde)
     (and (<= 1987 Jahr 2020)
       (let ((Jahresstunde (+ (* 24 Jahrtag) Stunde))
             (Grenzen
               (svref '#(; 4th Saturday in October 2h to 2nd Saturday in February 2h
                         (5666 . 8352) ; 1987 : 23.10. 2h to 12.2. 1h
                         (5618 . 8304) ; 1988 : 21.10. 2h to 10.2. 1h
                         (5786 . 8280) ; 1989 : 28.10. 2h to 9.2. 1h
                         (5738 . 8256) ; 1990 : 26.10. 2h to 8.2. 1h
                         (5714 . 8232) ; 1991 : 25.10. 2h to 7.2. 1h
                         (5666 . 8352) ; 1992 : 23.10. 2h to 12.2. 1h
                         (5642 . 8328) ; 1993 : 22.10. 2h to 11.2. 1h
                         (5618 . 8304) ; 1994 : 21.10. 2h to 10.2. 1h
                         (5786 . 8280) ; 1995 : 28.10. 2h to 9.2. 1h
                         (5714 . 8232) ; 1996 : 25.10. 2h to 7.2. 1h
                         (5690 . 8400) ; 1997 : 24.10. 2h to 14.2. 1h
                         (5666 . 8352) ; 1998 : 23.10. 2h to 12.2. 1h
                         (5642 . 8328) ; 1999 : 22.10. 2h to 11.2. 1h
                         (5786 . 8280) ; 2000 : 28.10. 2h to 9.2. 1h
                         (5738 . 8256) ; 2001 : 26.10. 2h to 8.2. 1h
                         (5714 . 8232) ; 2002 : 25.10. 2h to 7.2. 1h
                         (5690 . 8400) ; 2003 : 24.10. 2h to 14.2. 1h
                         (5642 . 8328) ; 2004 : 22.10. 2h to 11.2. 1h
                         (5618 . 8304) ; 2005 : 21.10. 2h to 10.2. 1h
                         (5786 . 8280) ; 2006 : 28.10. 2h to 9.2. 1h
                         (5738 . 8256) ; 2007 : 26.10. 2h to 8.2. 1h
                         (5690 . 8400) ; 2008 : 24.10. 2h to 14.2. 1h
                         (5666 . 8352) ; 2009 : 23.10. 2h to 12.2. 1h
                         (5642 . 8328) ; 2010 : 22.10. 2h to 11.2. 1h
                         (5618 . 8304) ; 2011 : 21.10. 2h to 10.2. 1h
                         (5738 . 8256) ; 2012 : 26.10. 2h to 8.2. 1h
                         (5714 . 8232) ; 2013 : 25.10. 2h to 7.2. 1h
                         (5690 . 8400) ; 2014 : 24.10. 2h to 14.2. 1h
                         (5666 . 8352) ; 2015 : 23.10. 2h to 12.2. 1h
                         (5618 . 8304) ; 2016 : 21.10. 2h to 10.2. 1h
                         (5786 . 8280) ; 2017 : 28.10. 2h to 9.2. 1h
                         (5738 . 8256) ; 2018 : 26.10. 2h to 8.2. 1h
                         (5714 . 8232) ; 2019 : 25.10. 2h to 7.2. 1h
                         (5666 . 8352) ; 2020 : 23.10. 2h to 12.2. 1h
                        )
                      (- Jahr 1987)
            )) )
         (<= (car Grenzen) Jahresstunde (cdr Grenzen))
   ) ) )
   (Chile-DST-p (Jahr Jahrtag Stunde)
     (when (< Jahrtag 31) ; March?
       (setq Jahrtag (+ Jahrtag (- (UTag Jahr) (UTag (- Jahr 1))))
             Jahr (- Jahr 1)
     ) )
     (and (<= 1977 Jahr 2020)
       (let ((Jahresstunde (+ (* 24 Jahrtag) Stunde))
             (Grenzen
               (svref '#(; 2nd Sunday in October 0h to 2nd Sunday in March 0h
                         (5328 . 9022) ; 1977 : 9.10. 0h to 11.3. 23h
                         (5304 . 8998) ; 1978 : 8.10. 0h to 10.3. 23h
                         (5448 . 8974) ; 1979 : 14.10. 0h to 8.3. 23h
                         (5400 . 8926) ; 1980 : 12.10. 0h to 7.3. 23h
                         (5376 . 9070) ; 1981 : 11.10. 0h to 13.3. 23h
                         (5352 . 9046) ; 1982 : 10.10. 0h to 12.3. 23h
                         (5328 . 9022) ; 1983 : 9.10. 0h to 10.3. 23h
                         (5448 . 8974) ; 1984 : 14.10. 0h to 9.3. 23h
                         (5424 . 8950) ; 1985 : 13.10. 0h to 8.3. 23h
                         (5400 . 8926) ; 1986 : 12.10. 0h to 7.3. 23h
                         (5376 . 9070) ; 1987 : 11.10. 0h to 12.3. 23h
                         (5328 . 9022) ; 1988 : 9.10. 0h to 11.3. 23h
                         (5304 . 8998) ; 1989 : 8.10. 0h to 10.3. 23h
                         (5448 . 8974) ; 1990 : 14.10. 0h to 9.3. 23h
                         (5424 . 8950) ; 1991 : 13.10. 0h to 7.3. 23h
                         (5376 . 9070) ; 1992 : 11.10. 0h to 13.3. 23h
                         (5352 . 9046) ; 1993 : 10.10. 0h to 12.3. 23h
                         (5328 . 9022) ; 1994 : 9.10. 0h to 11.3. 23h
                         (5304 . 8998) ; 1995 : 8.10. 0h to 9.3. 23h
                         (5424 . 8950) ; 1996 : 13.10. 0h to 8.3. 23h
                         (5400 . 8926) ; 1997 : 12.10. 0h to 7.3. 23h
                         (5376 . 9070) ; 1998 : 11.10. 0h to 13.3. 23h
                         (5352 . 9046) ; 1999 : 10.10. 0h to 11.3. 23h
                         (5304 . 8998) ; 2000 : 8.10. 0h to 10.3. 23h
                         (5448 . 8974) ; 2001 : 14.10. 0h to 9.3. 23h
                         (5424 . 8950) ; 2002 : 13.10. 0h to 8.3. 23h
                         (5400 . 9094) ; 2003 : 12.10. 0h to 13.3. 23h
                         (5352 . 9046) ; 2004 : 10.10. 0h to 12.3. 23h
                         (5328 . 9022) ; 2005 : 9.10. 0h to 11.3. 23h
                         (5304 . 8998) ; 2006 : 8.10. 0h to 10.3. 23h
                         (5448 . 8974) ; 2007 : 14.10. 0h to 8.3. 23h
                         (5400 . 8926) ; 2008 : 12.10. 0h to 7.3. 23h
                         (5376 . 9070) ; 2009 : 11.10. 0h to 13.3. 23h
                         (5352 . 9046) ; 2010 : 10.10. 0h to 12.3. 23h
                         (5328 . 9022) ; 2011 : 9.10. 0h to 10.3. 23h
                         (5448 . 8974) ; 2012 : 14.10. 0h to 9.3. 23h
                         (5424 . 8950) ; 2013 : 13.10. 0h to 8.3. 23h
                         (5400 . 8926) ; 2014 : 12.10. 0h to 7.3. 23h
                         (5376 . 9070) ; 2015 : 11.10. 0h to 12.3. 23h
                         (5328 . 9022) ; 2016 : 9.10. 0h to 11.3. 23h
                         (5304 . 8998) ; 2017 : 8.10. 0h to 10.3. 23h
                         (5448 . 8974) ; 2018 : 14.10. 0h to 9.3. 23h
                         (5424 . 8950) ; 2019 : 13.10. 0h to 7.3. 23h
                         (5376 . 9070) ; 2020 : 11.10. 0h to 13.3. 23h
                        )
                      (- Jahr 1977)
            )) )
         (<= (car Grenzen) Jahresstunde (cdr Grenzen))
   ) ) )
  )
  (declare (ignorable
            #'no-DST-p
            ;; Europe:
            #'GB-Eire-DST-p
            #'West-Europe-DST-p
            #'Mid-Europe-DST-p
            #'East-Europe-DST-p
            ;; Asia:
            #'Israel-DST-p
            #'Iran-DST-p
            #'ROK-DST-p
            ;; Australia:
            #'Australia-Oz-DST-p
            #'Australia-Victoria-DST-p
            #'Australia-NSW-DST-p
            #'NZ-DST-p
            ;; Africa:
            #'Egypt-DST-p
            #'Libya-DST-p
            ;; North America:
            #'Canada-DST-p
            #'Cuba-DST-p
            #'Mexico-DST-p
            #'US-DST-p
            #'US-Michigan-DST-p
            #'US-Pacific-New-DST-p
            #'SystemV-DST-p
            ;; South America:
            #'Brazil-DST-p
            #'Chile-DST-p))
  (labels
    (;; ==================== LIST OF AVAILABLE TIME ZONES ====================
     (Australia-LHI () (values -21/2 #'Australia-NSW-DST-p))
     (Australia-NSW () (values -10 #'Australia-NSW-DST-p))
     (Australia-North () (values -19/2 #'no-DST-p))
     (Australia-Queensland () (values -10 #'no-DST-p))
     (Australia-South () (values -19/2 #'Australia-Oz-DST-p)) ; DST switch incorrect by half an hour??
     (Australia-Tasmania () (values -10 #'Australia-Oz-DST-p))
     (Australia-Victoria () (values -10 #'Australia-Victoria-DST-p))
     (Australia-West () (values -8 #'no-DST-p))
     (Australia-Yancowinna () (values -19/2 #'Australia-NSW-DST-p))
     (Brazil-Acre () (values 5 #'Brazil-DST-p))
     (Brazil-DeNoronha () (values 2 #'Brazil-DST-p))
     (Brazil-East () (values 3 #'Brazil-DST-p))
     (Brazil-West () (values 4 #'Brazil-DST-p))
     (CET () (MET))
     (Canada-Atlantic () (values 4 #'Canada-DST-p))
     (Canada-Central () (values 6 #'Canada-DST-p))
     (Canada-East-Saskatchewan () (values 6 #'no-DST-p))
     (Canada-Eastern () (values 5 #'Canada-DST-p))
     (Canada-Mountain () (values 7 #'Canada-DST-p))
     (Canada-Newfoundland () (values 7/2 #'Canada-DST-p)) ; DST switch incorrect by half an hour??
     (Canada-Pacific () (values 8 #'Canada-DST-p))
     (Canada-Yukon () (values 9 #'Canada-DST-p))
     (Chile-Continental () (values 4 #'Chile-DST-p))
     (Chile-EasterIsland () (values 6 #'Chile-DST-p))
     (Cuba () (values 5 #'Cuba-DST-p))
     (EET () (values -2 #'East-Europe-DST-p))
     (Egypt () (values -2 #'Egypt-DST-p))
     (Factory () (GMT)) ; who cares?
     (GB-Eire () (values 0 #'GB-Eire-DST-p))
     (GMT () (values 0 #'no-DST-p))
     (GMT+0 () (GMT))
     (GMT+1 () (values -1 #'no-DST-p))
     (GMT+2 () (values -2 #'no-DST-p))
     (GMT+3 () (values -3 #'no-DST-p))
     (GMT+4 () (values -4 #'no-DST-p))
     (GMT+5 () (values -5 #'no-DST-p))
     (GMT+6 () (values -6 #'no-DST-p))
     (GMT+7 () (values -7 #'no-DST-p))
     (GMT+8 () (values -8 #'no-DST-p))
     (GMT+9 () (values -9 #'no-DST-p))
     (GMT+10 () (values -10 #'no-DST-p))
     (GMT+11 () (values -11 #'no-DST-p))
     (GMT+12 () (values -12 #'no-DST-p))
     (GMT+13 () (values -13 #'no-DST-p))
     (GMT-0 () (GMT))
     (GMT-1 () (values 1 #'no-DST-p))
     (GMT-2 () (values 2 #'no-DST-p))
     (GMT-3 () (values 3 #'no-DST-p))
     (GMT-4 () (values 4 #'no-DST-p))
     (GMT-5 () (values 5 #'no-DST-p))
     (GMT-6 () (values 6 #'no-DST-p))
     (GMT-7 () (values 7 #'no-DST-p))
     (GMT-8 () (values 8 #'no-DST-p))
     (GMT-9 () (values 9 #'no-DST-p))
     (GMT-10 () (values 10 #'no-DST-p))
     (GMT-11 () (values 11 #'no-DST-p))
     (GMT-12 () (values 12 #'no-DST-p))
     (GMT0 () (GMT+0))
     (GMT1 () (GMT+1))
     (GMT2 () (GMT+2))
     (GMT3 () (GMT+3))
     (GMT4 () (GMT+4))
     (GMT5 () (GMT+5))
     (GMT6 () (GMT+6))
     (GMT7 () (GMT+7))
     (GMT8 () (GMT+8))
     (GMT9 () (GMT+9))
     (GMT10 () (GMT+10))
     (GMT11 () (GMT+11))
     (GMT12 () (GMT+12))
     (GMT13 () (GMT+13))
     (Greenwich () (GMT))
     (Hongkong () (values -8 #'no-DST-p))
     (Iceland () (values 0 #'no-DST-p))
     (Iran () (values -7/2 #'Iran-DST-p)) ; DST switch incorrect by half an hour??
     (Israel () (values -3 #'Israel-DST-p))
     (Jamaica () (US-Eastern))
     (Japan () (values -9 #'no-DST-p))
     (Libya () (values -2 #'Libya-DST-p))
     (MET () (values -1 #'Mid-Europe-DST-p))
     (Mexico-BajaNorte () (values 8 #'Mexico-DST-p))
     (Mexico-BajaSur () (values 7 #'no-DST-p))
     (Mexico-General () (values 6 #'no-DST-p))
     (NZ () (values -10 #'NZ-DST-p)) ; New Zealand
     (Navajo () (US-Mountain))
     (PRC () (values -8 #'no-DST-p))
     (Poland () (values -1 #'West-Europe-DST-p))
     (ROC () (values -8 #'no-DST-p)) ; "Republic of China" aka Taiwan
     (ROK () (values -9 #'ROK-DST-p)) ; "Republic of Korea"
     (Singapore () (values -8 #'no-DST-p))
     (SystemV-AST4 () (values 4 #'no-DST-p))
     (SystemV-AST4ADT () (values 4 #'SystemV-DST-p))
     (SystemV-CST6 () (values 6 #'no-DST-p))
     (SystemV-CST6CDT () (values 6 #'SystemV-DST-p))
     (SystemV-EST5 () (values 5 #'no-DST-p))
     (SystemV-EST5EDT () (values 5 #'SystemV-DST-p))
     (SystemV-HST10 () (values 10 #'no-DST-p))
     (SystemV-MST7 () (values 7 #'no-DST-p))
     (SystemV-MST7MDT () (values 7 #'SystemV-DST-p))
     (SystemV-PST8 () (values 8 #'no-DST-p))
     (SystemV-PST8PDT () (values 8 #'SystemV-DST-p))
     (SystemV-YST9 () (values 9 #'no-DST-p))
     (SystemV-YST9YDT () (values 9 #'SystemV-DST-p))
     (Turkey () (values -3 #'West-Europe-DST-p))
     (UCT () (GMT))
     (US-Alaska () (values 9 #'US-DST-p))
     (US-Aleutian () (values 10 #'US-DST-p))
     (US-Arizona () (values 7 #'no-DST-p))
     (US-Central () (values 6 #'US-DST-p))
     (US-East-Indiana () (values 5 #'no-DST-p))
     (US-Eastern () (values 5 #'US-DST-p))
     (US-Hawaii () (values 10 #'no-DST-p))
     (US-Michigan () (values 5 #'US-Michigan-DST-p))
     (US-Mountain () (values 7 #'US-DST-p))
     (US-Pacific () (values 8 #'US-DST-p))
     (US-Pacific-New () (values 8 #'US-Pacific-New-DST-p))
     (US-Samoa () (values 11 #'no-DST-p))
     (UTC () (GMT))
     (Universal () (GMT))
     (W-SU () (values -3 #'Mid-Europe-DST-p))
     (WET () (values 0 #'West-Europe-DST-p))
     (Zulu () (GMT))
    )
    (declare (ignorable
              #'Australia-LHI #'Australia-NSW #'Australia-North #'Australia-Queensland #'Australia-South #'Australia-Tasmania #'Australia-Victoria #'Australia-West #'Australia-Yancowinna
              #'Brazil-Acre #'Brazil-DeNoronha #'Brazil-East #'Brazil-West
              #'CET
              #'Canada-Atlantic #'Canada-Central #'Canada-East-Saskatchewan #'Canada-Eastern #'Canada-Mountain #'Canada-Newfoundland #'Canada-Pacific #'Canada-Yukon
              #'Chile-Continental #'Chile-EasterIsland
              #'Cuba
              #'EET
              #'Egypt
              #'Factory
              #'GB-Eire
              #'GMT #'GMT+0 #'GMT+1 #'GMT+2 #'GMT+3 #'GMT+4 #'GMT+5 #'GMT+6 #'GMT+7 #'GMT+8 #'GMT+9 #'GMT+10 #'GMT+11 #'GMT+12 #'GMT+13 #'GMT-0 #'GMT-1 #'GMT-2 #'GMT-3 #'GMT-4 #'GMT-5 #'GMT-6 #'GMT-7 #'GMT-8 #'GMT-9 #'GMT-10 #'GMT-11 #'GMT-12 #'GMT0 #'GMT1 #'GMT2 #'GMT3 #'GMT4 #'GMT5 #'GMT6 #'GMT7 #'GMT8 #'GMT9 #'GMT10 #'GMT11 #'GMT12 #'GMT13
              #'Greenwich
              #'Hongkong
              #'Iceland
              #'Iran
              #'Israel
              #'Jamaica
              #'Japan
              #'Libya
              #'MET
              #'Mexico-BajaNorte #'Mexico-BajaSur #'Mexico-General
              #'NZ
              #'Navajo
              #'PRC
              #'Poland
              #'ROC
              #'ROK
              #'Singapore
              #'SystemV-AST4 #'SystemV-AST4ADT #'SystemV-CST6 #'SystemV-CST6CDT #'SystemV-EST5 #'SystemV-EST5EDT #'SystemV-HST10 #'SystemV-MST7 #'SystemV-MST7MDT #'SystemV-PST8 #'SystemV-PST8PDT #'SystemV-YST9 #'SystemV-YST9YDT
              #'Turkey
              #'UCT
              #'US-Alaska #'US-Aleutian #'US-Arizona #'US-Central #'US-East-Indiana #'US-Eastern #'US-Hawaii #'US-Michigan #'US-Mountain #'US-Pacific #'US-Pacific-New #'US-Samoa
              #'UTC #'Universal
              #'W-SU
              #'WET
              #'Zulu))
    (macrolet ((timezone (form)
                 `(MULTIPLE-VALUE-SETQ (*DEFAULT-TIME-ZONE* *DEFAULT-DST-CHECK*)
                                       ,form
                  )
              ))
      (timezone
        (
         ;; ==================== PUT IN YOUR TIME ZONE HERE ====================
         MET
         ;; ====================================================================
) ) ) ) )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./timezone.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./lambdalist.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Parsing ordinary lambda lists
;;; Bruno Haible 1988-2004
;;; Sam Steingold 1999-2005, 2010

(in-package "SYSTEM")

;; this is the standard errfunc argument for analyze-lambdalist et al.
(defun lambda-list-error (form detail &rest args)
  (apply #'error-of-type 'ext:source-program-error
         :form form :detail detail args))

(macrolet ((push (element-form list-var)
             `(setq ,list-var (cons ,element-form ,list-var)))
           (err-misplaced (item)
             `(funcall errfunc lambdalist ,item
                       (TEXT "Lambda list marker ~S not allowed here.")
                       ,item))
           (err-invalid (item)
             `(funcall errfunc lambdalist ,item
                       (if (or (symbolp ,item) (listp ,item))
                           (TEXT "Invalid lambda list element ~S")
                           (TEXT "Invalid lambda list element ~S. A lambda list may only contain symbols and lists."))
                       ,item))
           (err-no-default (marker item)
             `(funcall errfunc lambdalist ,item
                       (TEXT "Invalid lambda list element ~S. ~S parameters cannot have default value forms in generic function lambda lists.")
                       ',marker ,item))
           (check-item (item permissible)
             `(if (memq ,item ',permissible)
                (return)
                (err-misplaced ,item)))
           (dolist ((item L) &body body)
             ;; this is different from CL:DOLIST which uses ENDP instead of ATOM
             `(loop (if (atom ,L) (return))
                (let ((,item (car ,L))) ,@body)
                (setq ,L (cdr ,L))))
           (check-exhausted (L)
             `(when ,L
                (funcall errfunc lambdalist ,L
                         (TEXT "Lambda lists with dots are only allowed in macros, not here: ~S")
                         lambdalist)))
           (symbol-or-pair-p (x) ; FOO or (FOO BAR)
             `(or (symbolp ,x)
                  (and (consp ,x)
                       (symbolp (car ,x))
                       (consp (cdr ,x))
                       (symbolp (cadr ,x))
                       (null (cddr ,x)))))
           (singleton-symbol-p (x) ; (FOO)
             `(and (consp ,x) (symbolp (car ,x)) (null (cdr ,x))))
           (err-missing (marker)
             `(funcall errfunc lambdalist lambdalist
                       (TEXT "Missing ~S parameter in lambda list ~S")
                       ',marker lambdalist))
           (last-parameter (L var marker &body body)
             `(when (and (consp ,L) (eq (car ,L) ',marker))
                (setq ,L (cdr ,L))
                (if (atom L)
                  (err-missing ,marker)
                  (prog ((item (car ,L)))
                    (if (symbolp item)
                      (if (memq item lambda-list-keywords)
                        (progn (err-missing ,marker) (return))
                        (setq ,var item))
                      (err-invalid item))
                    (setq ,L (cdr ,L))))
                ,@body))
           (process-required (L reqvar permissible &optional no-duplicates)
             `(dolist (item ,L)
                (if (symbolp item)
                  (if (memq item lambda-list-keywords)
                    (check-item item ,permissible)
                    ,(if no-duplicates
                       `(if (memq item ,reqvar)
                          (funcall errfunc lambdalist item
                                   (TEXT "Duplicate variable name ~S") item)
                          (push item ,reqvar))
                       `(push item ,reqvar)))
                  (err-invalid item))))
           (push3 (s1 s2 s3 d1 d2 d3)
             `(progn (push ,s1 ,d1) (push ,s2 ,d2) (push ,s3 ,d3)))
           (process-optional (L optvar optinit optsvar permissible)
             `(when (and (consp ,L) (eq (car ,L) '&optional))
                (setq ,L (cdr ,L))
                (dolist (item ,L)
                  (if (symbolp item)
                    (if (memq item lambda-list-keywords)
                      (check-item item ,permissible)
                      (push3 item nil 0 optvar optinit optsvar))
                    (if (and (consp item) (symbolp (car item)))
                      (if (null (cdr item))
                        (push3 (car item) nil 0 optvar optinit optsvar)
                        (if (consp (cdr item))
                          (if (null (cddr item))
                            (push3 (car item) (cadr item) 0
                                   optvar optinit optsvar)
                            (if (singleton-symbol-p (cddr item))
                              (push3 (car item) (cadr item) (caddr item)
                                     optvar optinit optsvar)
                              (err-invalid item)))
                          (err-invalid item)))
                      (err-invalid item))))))
           (process-allow-other-keys (L allow-other-keys permissible)
             `(when (and (consp ,L) (eq (car ,L) '&allow-other-keys))
                (setq ,allow-other-keys t)
                (setq ,L (cdr ,L))
                (skip-L &allow-other-keys ,permissible)))
           (process-keywords (L keyflag keyword keyvar keyinit keysvar
                              allow-other-keys permissible)
             `(when (and (consp ,L) (eq (car ,L) '&key))
                (setq ,L (cdr ,L))
                (setq ,keyflag t)
                (dolist (item ,L)
                  (if (symbolp item)
                    (if (memq item lambda-list-keywords)
                      (check-item item ,permissible)
                      (progn
                        (push (symbol-to-keyword item) ,keyword)
                        (push3 item nil 0 ,keyvar ,keyinit ,keysvar)))
                    (if (and (consp item)
                             (symbol-or-pair-p (car item))
                             (or (null (cdr item))
                                 (and (consp (cdr item))
                                      (or (null (cddr item))
                                          (singleton-symbol-p (cddr item))))))
                      (progn
                        (if (consp (car item))
                          (progn
                            (push (caar item) ,keyword)
                            (push (cadar item) ,keyvar))
                          (progn
                            (push (symbol-to-keyword (car item)) ,keyword)
                           (push (car item) ,keyvar)))
                        (if (consp (cdr item))
                          (progn
                            (push (cadr item) ,keyinit)
                            (if (consp (cddr item))
                              (push (caddr item) ,keysvar)
                              (push 0 ,keysvar)))
                          (progn (push nil ,keyinit) (push 0 ,keysvar))))
                      (err-invalid item))))
               ;; Now (or (atom L) (member (car L) permissible)).
               (process-allow-other-keys ,L ,allow-other-keys
                                         ,(cdr permissible))))
           (skip-L (lastseen items)
             `(dolist (item L)
                (if (memq item lambda-list-keywords)
                  (check-item item ,items)
                  (funcall errfunc lambdalist item
                           ,(case lastseen
                              ((&REST &ENVIRONMENT) '(TEXT "Lambda list element ~S is superfluous. Only one variable is allowed after ~S."))
                              (&ALLOW-OTHER-KEYS '(TEXT "Lambda list element ~S is superfluous. No variable is allowed right after ~S."))
                              (t '(TEXT "Lambda list element ~S (after ~S) is superfluous.")))
                           item ',lastseen)))))

;;; Analyzes a lambda-list of a function (CLtL2 p. 76, ANSI CL 3.4.1.).
;;; Reports errors through errfunc (a function taking form & detail objects,
;;;  an error format string and format string arguments).
;; Returns 13 values:
;; 1. list of required parameters
;; 2. list of optional parameters
;; 3. list of init-forms of the optional parameters
;; 4. list of supplied-vars for the optional parameters (0 for the missing)
;; 5. &rest parameter or 0
;; 6. flag, if keywords are allowed
;; 7. list of keywords
;; 8. list of keyword parameters
;; 9. list of init-forms of the keyword parameters
;; 10. list of supplied-vars for the keyword parameters (0 for the missing)
;; 11. flag, if other keywords are allowed
;; 12. list of &aux variables
;; 13. list of init-forms of the &aux variables
(defun analyze-lambdalist (lambdalist errfunc)
  (let ((L lambdalist) ; rest of the lambda-list
        (reqvar nil)
        (optvar nil)
        (optinit nil)
        (optsvar nil)
        (rest 0)
        (keyflag nil)
        (keyword nil)
        (keyvar nil)
        (keyinit nil)
        (keysvar nil)
        (allow-other-keys nil)
        (auxvar nil)
        (auxinit nil))
    ;; The lists are all accumulated in reversed order.
    ;; Required parameters:
    (process-required L reqvar (&optional &rest &key &aux))
    ;; Now (or (atom L) (member (car L) '(&optional &rest &key &aux))).
    ;; Optional parameters:
    (process-optional L optvar optinit optsvar (&rest &key &aux))
    ;; Now (or (atom L) (member (car L) '(&rest &key &aux))).
    ;; &rest parameters:
    (last-parameter L rest &rest (skip-L &rest (&key &aux)))
    ;; Now (or (atom L) (member (car L) '(&key &aux))).
    ;; Keyword & Allow-other-keys parameters:
    (process-keywords L keyflag keyword keyvar keyinit keysvar
                      allow-other-keys (&allow-other-keys &aux))
    ;; Now (or (atom L) (member (car L) '(&aux))).
    ;; &aux variables:
    (when (and (consp L) (eq (car L) '&aux))
      (setq L (cdr L))
      (dolist (item L)
        (if (symbolp item)
          (if (memq item lambda-list-keywords)
            (err-misplaced item)
            (progn (push item auxvar) (push nil auxinit)))
          (if (and (consp item) (symbolp (car item)))
            (if (null (cdr item))
              (progn (push (car item) auxvar) (push nil auxinit))
              (if (and (consp (cdr item)) (null (cddr item)))
                (progn (push (car item) auxvar) (push (cadr item) auxinit))
                (err-invalid item)))
            (err-invalid item)))))
    ;; Now (atom L).
    (check-exhausted L)
    (values
      (nreverse reqvar)
      (nreverse optvar) (nreverse optinit) (nreverse optsvar)
      rest
      keyflag
      (nreverse keyword) (nreverse keyvar) (nreverse keyinit) (nreverse keysvar)
      allow-other-keys
      (nreverse auxvar) (nreverse auxinit))))

;;; Analyzes a lambda-list of a generic function (ANSI CL 3.4.2.).
;;; Reports errors through errfunc (a function taking form & detail objects,
;;;  an error format string and format string arguments).
;; Returns 7 values:
;; 1. list of required parameters
;; 2. list of optional parameters
;; 3. &rest parameter or 0
;; 4. flag, if keywords are allowed
;; 5. list of keywords
;; 6. list of keyword parameters
;; 7. flag, if other keywords are allowed
(defun analyze-generic-function-lambdalist (lambdalist errfunc)
  (let ((L lambdalist) ; rest of the lambda-list
        (reqvar nil)
        (optvar nil)
        (rest 0)
        (keyflag nil)
        (keyword nil)
        (keyvar nil)
        (allow-other-keys nil))
    ;; The lists are all accumulated in reversed order.
    ;; Required parameters:
    ;; Need to check for duplicates here because otherwise the
    ;; :arguments-precedence-order makes no sense.
    (process-required L reqvar (&optional &rest &key) t)
    ;; Now (or (atom L) (member (car L) '(&optional &rest &key))).
    ;; Optional parameters:
    (when (and (consp L) (eq (car L) '&optional))
      (setq L (cdr L))
      (dolist (item L)
        (if (symbolp item)
          (if (memq item lambda-list-keywords)
            (check-item item (&rest &key))
            (push item optvar))
          (if (and (consp item) (symbolp (car item)))
            (if (null (cdr item))
              (push (car item) optvar)
              (err-no-default &optional item))
            (err-invalid item)))))
    ;; Now (or (atom L) (member (car L) '(&rest &key))).
    ;; &rest parameters:
    (last-parameter L rest &rest (skip-L &rest (&key)))
    ;; Now (or (atom L) (member (car L) '(&key))).
    ;; Keyword parameters:
    (when (and (consp L) (eq (car L) '&key))
      (setq L (cdr L))
      (setq keyflag t)
      (dolist (item L)
        (if (symbolp item)
          (if (memq item lambda-list-keywords)
            (check-item item (&allow-other-keys))
            (progn
              (push (symbol-to-keyword item) keyword)
              (push item keyvar)))
          (if (and (consp item)
                   (symbol-or-pair-p (car item)))
            (if (null (cdr item))
              (if (consp (car item))
                (progn
                  (push (caar item) keyword)
                  (push (cadar item) keyvar))
                (progn
                  (push (symbol-to-keyword (car item)) keyword)
                  (push (car item) keyvar)))
              (err-no-default &key item))
            (err-invalid item))))
      ;; Now (or (atom L) (member (car L) '(&allow-other-keys))).
      (process-allow-other-keys L allow-other-keys ()))
    ;; Now (atom L).
    (check-exhausted L)
    (values
      (nreverse reqvar)
      (nreverse optvar)
      rest
      keyflag
      (nreverse keyword) (nreverse keyvar)
      allow-other-keys)))

;;; Analyzes a defsetf lambda-list (ANSI CL 3.4.7.).
;;; Reports errors through errfunc (a function taking form & detail objects,
;;;  an error format string and format string arguments).
;; Returns 12 values:
;; 1. list of required parameters
;; 2. list of optional parameters
;; 3. list of init-forms of the optional parameters
;; 4. list of supplied-vars for the optional parameters (0 for the missing)
;; 5. &rest parameter or 0
;; 6. flag, if keywords are allowed
;; 7. list of keywords
;; 8. list of keyword parameters
;; 9. list of init-forms of the keyword parameters
;; 10. list of supplied-vars for the keyword parameters (0 for the missing)
;; 11. flag, if other keywords are allowed
;; 12. &environment parameter or 0
(defun analyze-defsetf-lambdalist (lambdalist errfunc)
  (let ((L lambdalist) ; rest of the lambda-list
        (reqvar nil)
        (optvar nil)
        (optinit nil)
        (optsvar nil)
        (rest 0)
        (keyflag nil)
        (keyword nil)
        (keyvar nil)
        (keyinit nil)
        (keysvar nil)
        (allow-other-keys nil)
        (env 0))
    ;; The lists are all accumulated in reversed order.
    ;; Required parameters:
    (process-required L reqvar (&optional &rest &key &environment))
    ;; Now (or (atom L) (member (car L) '(&optional &rest &key &environment))).
    ;; Optional parameters:
    (process-optional L optvar optinit optsvar (&rest &key &environment))
    ;; Now (or (atom L) (member (car L) '(&rest &key &environment))).
    ;; &rest parameters:
    (last-parameter L rest &rest (skip-L &rest (&key &environment)))
    ;; Now (or (atom L) (member (car L) '(&key &environment))).
    ;; Keyword & Allow-other-keys parameters:
    (process-keywords L keyflag keyword keyvar keyinit keysvar
                      allow-other-keys (&allow-other-keys &environment))
    ;; Now (or (atom L) (member (car L) '(&environment))).
    ;; &environment parameter:
    (last-parameter L env &environment (skip-L &environment ()))
    ;; Now (atom L).
    (check-exhausted L)
    (values
      (nreverse reqvar)
      (nreverse optvar) (nreverse optinit) (nreverse optsvar)
      rest
      keyflag
      (nreverse keyword) (nreverse keyvar) (nreverse keyinit) (nreverse keysvar)
      allow-other-keys
      env)))

;;; Analyzes a define-modify-macro lambda-list (ANSI CL 3.4.9.).
;;; Reports errors through errfunc (a function taking form & detail objects,
;;;  an error format string and format string arguments).
;; Returns 5 values:
;; 1. list of required parameters
;; 2. list of optional parameters
;; 3. list of init-forms of the optional parameters
;; 4. list of supplied-vars for the optional parameters (0 for the missing)
;; 5. &rest parameter or 0
(defun analyze-modify-macro-lambdalist (lambdalist errfunc)
  (let ((L lambdalist) ; rest of the lambda-list
        (reqvar nil)
        (optvar nil)
        (optinit nil)
        (optsvar nil)
        (rest 0))
    ;; The lists are all accumulated in reversed order.
    ;; Required parameters:
    (process-required L reqvar (&optional &rest))
    ;; Now (or (atom L) (member (car L) '(&optional &rest))).
    ;; Optional parameters:
    (process-optional L optvar optinit optsvar (&rest))
    ;; Now (or (atom L) (member (car L) '(&rest))).
    ;; &rest parameters:
    (last-parameter L rest &rest (skip-L &rest ()))
    ;; Now (atom L).
    (check-exhausted L)
    (values
      (nreverse reqvar)
      (nreverse optvar) (nreverse optinit) (nreverse optsvar)
      rest)))

;;; Analyzes a define-method-combination lambda-list (ANSI CL 3.4.10.).
;;; Reports errors through errfunc (a function taking form & detail objects,
;;;  an error format string and format string arguments).
;; Returns 14 values:
;; 1. &whole parameter or 0
;; 2. list of required parameters
;; 3. list of optional parameters
;; 4. list of init-forms of the optional parameters
;; 5. list of supplied-vars for the optional parameters (0 for the missing)
;; 6. &rest parameter or 0
;; 7. flag, if keywords are allowed
;; 8. list of keywords
;; 9. list of keyword parameters
;; 10. list of init-forms of the keyword parameters
;; 11. list of supplied-vars for the keyword parameters (0 for the missing)
;; 12. flag, if other keywords are allowed
;; 13. list of &aux variables
;; 14. list of init-forms of the &aux variables
(defun analyze-method-combination-lambdalist (lambdalist errfunc)
  (let ((L lambdalist) ; rest of the lambda-list
        (whole 0))
    ;; The lists are all accumulated in reversed order.
    ;; &whole parameter:
    (last-parameter L whole &whole)
    ;; The rest should be an ordinary lambda-list.
    (multiple-value-bind (reqvar optvar optinit optsvar rest
                          keyflag keyword keyvar keyinit keysvar allow-other-keys
                          auxvar auxinit)
        (analyze-lambdalist L errfunc)
      (values
        whole
        reqvar
        optvar optinit optsvar
        rest
        keyflag
        keyword keyvar keyinit keysvar
        allow-other-keys
        auxvar auxinit))))

) ; macrolet
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./lambdalist.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./fill-out.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; filling/indenting stream
;;;
;;; Copyright (C) 2004-2008 by Sam Steingold
;;; Copyright (C) 2004 by Bruno Haible
;;; This is Free Software, distributed under the GNU GPL v2+
;;; See http://www.gnu.org/copyleft/gpl.html

(in-package "EXT")
(export '(custom::*fill-indent-sexp*) "CUSTOM")
(export '(fill-stream with-fill-stream custom:*fill-indent-sexp*))
(import '(fill-stream with-fill-stream) "SYS")
(in-package "SYSTEM")

(defvar *fill-indent-sexp* #'1+
  "The default indentation of new FILL-STREAMs inside SEXPs.
This should be a number (the actual indentation),
a function of one argument (the text indentation),
NIL (no indentation) or
T (same indentation as the text, i.e., the same effect as #'IDENTITY).")

(declaim (inline right-margin))
(defun right-margin () (or *print-right-margin* sys::*prin-linelength*))

(defclass fill-stream (fundamental-character-output-stream)
  ((target-stream :initarg :stream :type stream)
   (buffer :type string :initform
           (make-array (right-margin) :element-type 'character
                       :fill-pointer 0 :adjustable t))
   (inside-sexp :initform nil :type boolean)
   (sexp-indent :initarg :sexp-indent :initform *fill-indent-sexp*
                :type (or symbol integer function))
   ;; the indentation level variable or number:
   (indent-var :initarg :text-indent :initform 0 :type (or symbol integer))
   (pending-space :initform nil :type boolean)
   (current-indent :initform 0 :type integer) ; current line indentation
   (pending-indent :initform nil :type (or null integer))))

(defun fill-stream-line-position (fill-stream)
  (with-slots (target-stream buffer pending-space) fill-stream
    (let ((pos (sys::line-position target-stream)))
      (if pos
          (+ pos (if pending-space 1 0) (string-width buffer))
          nil))))

(defun fill-stream-text-indent (stream)
  (let ((text-indent-raw (slot-value stream 'indent-var)))
    (etypecase text-indent-raw
      (number text-indent-raw)
      (symbol (symbol-value text-indent-raw)))))

(defun fill-stream-sexp-indent (stream)
  (let* ((sexp-indent-raw (slot-value stream 'sexp-indent))
         (text-indent (fill-stream-text-indent stream))
         (sexp-indent-value
          (etypecase sexp-indent-raw
            (number sexp-indent-raw)
            (symbol (symbol-value sexp-indent-raw))
            (function (funcall sexp-indent-raw text-indent)))))
    (case sexp-indent-value
      ((nil) 0)
      ((t) text-indent)
      (t sexp-indent-value))))

;; SEXP is either a single line, then it is formatted inline as a word,
;; or it takes several lines, then it is formatted as an indented block

;; flush the buffer and print a newline (when NEWLINE-P is non-NIL)
(defun fill-stream-flush-buffer (stream newline-p &aux sexp-block-p)
  (with-slots (target-stream buffer pending-indent current-indent
               pending-space inside-sexp)
      stream
    (flet ((newline ()          ; terpri
             (setq current-indent (fill-stream-text-indent stream)
                   pending-indent current-indent)
             (terpri target-stream)))
      (when (plusp (length buffer)) ; something in the buffer to flush
        ;; fill: if the buffer does not fit on the line, TERPRI
        (let ((pos (fill-stream-line-position stream)))
          (when (and pos (<= (right-margin) pos)) ; does not fit on this line
            (setq sexp-block-p (find #\newline buffer)) ; only inside sexp
            (unless sexp-block-p (newline))
            (when inside-sexp ; just finished an S-expression
              (setq newline-p (or newline-p sexp-block-p)))))
        (unless sexp-block-p ; S-expression in a block
          (cond (pending-indent      ; do the indent
                 (sys::write-spaces pending-indent target-stream)
                 (setq pending-indent nil))
                (pending-space
                 (write-char #\Space target-stream))))
        (setq pending-space nil)
        (if sexp-block-p
          (do* ((indent (fill-stream-sexp-indent stream))
                (beg 0 (1+ end))
                (end (position #\Newline buffer)
                     (position #\Newline buffer :start beg)))
               ((null end)
                (write-char-sequence buffer target-stream :start beg))
            (write-char-sequence buffer target-stream :start beg :end end)
            (terpri target-stream)
            (sys::write-spaces indent target-stream))
          (write-char-sequence buffer target-stream))
        (setf (fill-pointer buffer) 0))
      (when newline-p (newline)))))

(progn
(defmethod stream-write-char ((stream fill-stream) ch)
  (with-slots #1=(buffer pending-space inside-sexp) stream
    #2=
    (if inside-sexp
        (vector-push-extend ch buffer)
        (case ch
          (#\Newline (fill-stream-flush-buffer stream t))
          ((#\Space #\Tab)
           (when (plusp (length buffer))
             (fill-stream-flush-buffer stream nil))
           (setq pending-space t))
          (t (vector-push-extend ch buffer))))))
(defmethod stream-write-char-sequence ((stream fill-stream) sequence
                                       &optional (start 0) (end nil))
  (with-slots #1# stream
    ;; make sure that the buffer can accommodate the sequence
    (let ((new-size (+ (length sequence) (length buffer))))
      (when (> new-size (array-dimension buffer 0))
        (adjust-array buffer new-size)))
    ;; Same body as in stream-write-char.
    (count-if (lambda (ch) #2#) sequence :start start :end end))
  sequence))

(defmethod stream-line-column ((stream fill-stream))
  (let ((pos (fill-stream-line-position stream)))
    (if pos (max (- pos (slot-value stream 'current-indent)) 0) nil)))
(defmethod stream-start-line-p ((stream fill-stream))
  (let ((pos (fill-stream-line-position stream)))
    (if pos (<= pos (slot-value stream 'current-indent)) nil)))
(defmethod stream-finish-output ((stream fill-stream))
  (fill-stream-flush-buffer stream nil)
  (finish-output (slot-value stream 'target-stream)))
(defmethod stream-force-output ((stream fill-stream))
  (fill-stream-flush-buffer stream nil)
  (force-output (slot-value stream 'target-stream)))
(defmethod stream-clear-output ((stream fill-stream))
  (with-slots (target-stream buffer pending-indent pending-space) stream
    (setq pending-indent nil pending-space nil)
    (setf (fill-pointer buffer) 0)
    (clear-output target-stream)))

(defmacro with-fill-stream ((stream-var target-stream &rest opts) &body body)
  (multiple-value-bind (body-rest declarations) (parse-body body)
    `(LET ((,stream-var (MAKE-INSTANCE 'fill-stream :STREAM ,target-stream
                                       ,@opts)))
       (DECLARE (READ-ONLY ,stream-var) ,@declarations)
       (UNWIND-PROTECT (PROGN ,@body-rest)
         (FORCE-OUTPUT ,stream-var)))))

;;; for format, see `format-s-expression'
(fmakunbound 'stream-start-s-expression)
(fmakunbound 'stream-end-s-expression)
(defgeneric stream-start-s-expression (stream)
  (:documentation "Return the new binding for *PRINT-RIGHT-MARGIN*.")
  (:method ((stream t)) (declare (ignore stream)) *print-right-margin*)
  (:method ((stream fill-stream))
    (fill-stream-flush-buffer stream nil)
    (setf (slot-value stream 'inside-sexp) t)
    (- (right-margin) (fill-stream-sexp-indent stream))))
(defgeneric stream-end-s-expression (stream)
  (:method ((stream t)) (declare (ignore stream)))
  (:method ((stream fill-stream))
    (fill-stream-flush-buffer stream nil)
    (setf (slot-value stream 'inside-sexp) nil)))

(defmacro with-stream-s-expression ((stream) &body body)
  `(let ((*print-right-margin* (stream-start-s-expression ,stream)))
     ,@body
     (stream-end-s-expression ,stream)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./fill-out.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./gllib/uniname/gen-uninames.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#!/usr/local/bin/clisp -C

;;; Creation of gnulib's uninames.h from the UnicodeData.txt table.
;;; Bruno Haible 2000-12-28

(defparameter add-comments nil)

(defstruct unicode-char
  (index nil :type integer)
  (name nil :type string)
  word-indices
  word-indices-index
)

(defstruct range
  (index nil :type integer)
  (start-code nil :type integer)
  (end-code nil :type integer)
)

(defstruct word-list
  (hashed nil :type hash-table)
  (sorted nil :type list)
  size                          ; number of characters total
  length                        ; number of words
)

(defun main (inputfile outputfile aliasfile)
  (declare (type string inputfile outputfile aliasfile))
  #+UNICODE (setq *default-file-encoding* charset:utf-8)
  (let ((all-chars '())
        (all-chars-hashed (make-hash-table :test #'equal))
        (all-aliases '())
        all-chars-and-aliases
        (all-ranges '())
        (name-index 0)
        range)
    ;; Read all characters and names from the input file.
    (with-open-file (istream inputfile :direction :input)
      (loop
        (let ((line (read-line istream nil nil)))
          (unless line (return))
          (let* ((i1 (position #\; line))
                 (i2 (position #\; line :start (1+ i1)))
                 (code-string (subseq line 0 i1))
                 (code (parse-integer code-string :radix 16))
                 (name-string (subseq line (1+ i1) i2)))
            ; Ignore characters whose name starts with "<".
            (unless (eql (char name-string 0) #\<)
              ; Also ignore Hangul syllables; they are treated specially.
              (unless (<= #xAC00 code #xD7A3)
                ; Also ignore CJK compatibility ideographs; they are treated
                ; specially as well.
                (unless (or (<= #xF900 code #xFA2D) (<= #xFA30 code #xFA6A)
                            (<= #xFA70 code #xFAD9) (<= #x2F800 code #x2FA1D))
                  ;; Also ignore variationselectors; they are treated
                  ;; specially as well.
                  (unless (or (<= #xFE00 code #xFE0F) (<= #xE0100 code #xE01EF))
                    (push (make-unicode-char :index name-index
                                             :name name-string)
                          all-chars)
                    (setf (gethash code all-chars-hashed) (car all-chars))
                    ;; Update the contiguous range, or start a new range.
                    (if (and range (= (1+ (range-end-code range)) code))
                        (setf (range-end-code range) code)
                      (progn
                        (when range
                          (push range all-ranges))
                        (setq range (make-range :index name-index
                                                :start-code code
                                                :end-code code))))
                    (incf name-index)
                    (setq last-code code)
                  ) ) ) )
    ) ) ) )
    (setq all-chars (nreverse all-chars))
    (if range
        (push range all-ranges))
    (setq all-ranges (nreverse all-ranges))
    (when aliasfile
      ;; Read all characters and names from the alias file.
      (with-open-file (istream aliasfile :direction :input)
        (loop
         (let ((line (read-line istream nil nil)))
           (unless line (return))
           (let* ((i1 (position #\; line))
                  (i2 (position #\; line :start (1+ i1)))
                  (code-string (subseq line 0 i1))
                  (code (parse-integer code-string :radix 16))
                  (name-string (subseq line (1+ i1) i2))
                  (uc (gethash code all-chars-hashed)))
             (when uc
               (push (make-unicode-char :index (unicode-char-index uc)
                                        :name name-string)
                     all-aliases)
             ) ) ) ) ) )
    (setq all-aliases (nreverse all-aliases)
          all-chars-and-aliases (append all-chars all-aliases))
    ;; Split into words.
    (let ((words-by-length (make-array 0 :adjustable t)))
      (dolist (name (list* "HANGUL SYLLABLE" "CJK COMPATIBILITY" "VARIATION"
                           (mapcar #'unicode-char-name all-chars-and-aliases)))
        (let ((i1 0))
          (loop
            (when (>= i1 (length name)) (return))
            (let ((i2 (or (position #\Space name :start i1) (length name))))
              (let* ((word (subseq name i1 i2))
                     (len (length word)))
                (when (>= len (length words-by-length))
                  (adjust-array words-by-length (1+ len))
                )
                (unless (aref words-by-length len)
                  (setf (aref words-by-length len)
                        (make-word-list
                          :hashed (make-hash-table :test #'equal)
                          :sorted '()
                ) )     )
                (let ((word-list (aref words-by-length len)))
                  (unless (gethash word (word-list-hashed word-list))
                    (setf (gethash word (word-list-hashed word-list)) t)
                    (push word (word-list-sorted word-list))
                ) )
              )
              (setq i1 (1+ i2))
      ) ) ) )
      ;; Sort the word lists.
      (dotimes (len (length words-by-length))
        (unless (aref words-by-length len)
          (setf (aref words-by-length len)
                (make-word-list
                  :hashed (make-hash-table :test #'equal)
                  :sorted '()
        ) )     )
        (let ((word-list (aref words-by-length len)))
          (setf (word-list-sorted word-list)
                (sort (word-list-sorted word-list) #'string<)
          )
          (setf (word-list-size word-list)
                (reduce #'+ (mapcar #'length (word-list-sorted word-list)))
          )
          (setf (word-list-length word-list)
                (length (word-list-sorted word-list))
      ) ) )
      ;; Output the tables.
      (with-open-file (ostream outputfile :direction :output
                       #+UNICODE :external-format #+UNICODE charset:ascii)
        (format ostream "/* DO NOT EDIT! GENERATED AUTOMATICALLY! */~%")
        (format ostream "/*~%")
        (format ostream " * ~A~%" (file-namestring outputfile))
        (format ostream " *~%")
        (format ostream " * Unicode character name table.~%")
        (format ostream " * Generated automatically by the gen-uninames utility.~%")
        (format ostream " */~%")
        (format ostream "~%")
        (format ostream "static const char unicode_name_words[~D] = {~%"
                        (let ((sum 0))
                          (dotimes (len (length words-by-length))
                            (let ((word-list (aref words-by-length len)))
                              (incf sum (word-list-size word-list))
                          ) )
                          sum
        )               )
        (dotimes (len (length words-by-length))
          (let ((word-list (aref words-by-length len)))
            (dolist (word (word-list-sorted word-list))
              (format ostream " ~{ '~C',~}~%" (coerce word 'list))
        ) ) )
        (format ostream "};~%")
        (format ostream "#define UNICODE_CHARNAME_NUM_WORDS ~D~%"
                        (let ((sum 0))
                          (dotimes (len (length words-by-length))
                            (let ((word-list (aref words-by-length len)))
                              (incf sum (word-list-length word-list))
                          ) )
                          sum
        )               )
        #| ; Redundant data
        (format ostream "static const uint16_t unicode_name_word_offsets[~D] = {~%"
                        (let ((sum 0))
                          (dotimes (len (length words-by-length))
                            (let ((word-list (aref words-by-length len)))
                              (incf sum (word-list-length word-list))
                          ) )
                          sum
        )               )
        (dotimes (len (length words-by-length))
          (let ((word-list (aref words-by-length len)))
            (when (word-list-sorted word-list)
              (format ostream " ")
              (do ((l (word-list-sorted word-list) (cdr l))
                   (offset 0 (+ offset (length (car l)))))
                  ((endp l))
                (format ostream "~<~% ~0,79:; ~D,~>" offset)
              )
              (format ostream "~%")
        ) ) )
        (format ostream "};~%")
        |#
        (format ostream "static const struct { uint32_t extra_offset; uint16_t ind_offset; } unicode_name_by_length[~D] = {~%"
                        (1+ (length words-by-length))
        )
        (let ((extra-offset 0)
              (ind-offset 0))
          (dotimes (len (length words-by-length))
            (let ((word-list (aref words-by-length len)))
              (format ostream "  { ~D, ~D },~%" extra-offset ind-offset)
              (incf extra-offset (word-list-size word-list))
              (incf ind-offset (word-list-length word-list))
          ) )
          (format ostream "  { ~D, ~D }~%" extra-offset ind-offset)
        )
        (format ostream "};~%")
        (let ((ind-offset 0))
          (dotimes (len (length words-by-length))
            (let ((word-list (aref words-by-length len)))
              (dolist (word (word-list-sorted word-list))
                (setf (gethash word (word-list-hashed word-list)) ind-offset)
                (incf ind-offset)
        ) ) ) )
        (dolist (word '("HANGUL" "SYLLABLE" "CJK" "COMPATIBILITY" "VARIATION"))
          (format ostream "#define UNICODE_CHARNAME_WORD_~A ~D~%" word
                          (gethash word (word-list-hashed (aref words-by-length (length word))))
        ) )
        ;; Compute the word-indices for every unicode-char.
        (dolist (uc all-chars-and-aliases)
          (let ((name (unicode-char-name uc))
                (indices '()))
            (let ((i1 0))
              (loop
                (when (>= i1 (length name)) (return))
                (let ((i2 (or (position #\Space name :start i1) (length name))))
                  (let* ((word (subseq name i1 i2))
                         (len (length word)))
                    (push (gethash word (word-list-hashed (aref words-by-length len)))
                          indices
                    )
                  )
                  (setq i1 (1+ i2))
            ) ) )
            (setf (unicode-char-word-indices uc)
                  (coerce (nreverse indices) 'vector)
            )
        ) )
        ;; Sort the list of unicode-chars by word-indices.
        (setq all-chars-and-aliases
              (sort all-chars-and-aliases
                    (lambda (vec1 vec2)
                      (let ((len1 (length vec1))
                            (len2 (length vec2)))
                        (do ((i 0 (1+ i)))
                            (nil)
                          (if (< i len2)
                            (if (< i len1)
                              (cond ((< (aref vec1 i) (aref vec2 i)) (return t))
                                    ((> (aref vec1 i) (aref vec2 i)) (return nil))
                              )
                              (return t)
                            )
                            (return nil)
                    ) ) ) )
                    :key #'unicode-char-word-indices
        )     )
        ;; Output the word-indices.
        (format ostream "static const uint16_t unicode_names[~D] = {~%"
                        (reduce #'+ (mapcar (lambda (uc) (length (unicode-char-word-indices uc))) all-chars-and-aliases))
        )
        (let ((i 0))
          (dolist (uc all-chars-and-aliases)
            (format ostream " ~{ ~D,~}"
                            (maplist (lambda (r) (+ (* 2 (car r)) (if (cdr r) 1 0)))
                                     (coerce (unicode-char-word-indices uc) 'list)
                            )
            )
            (when add-comments
              (format ostream "~40T/* ~A */" (unicode-char-name uc))
            )
            (format ostream "~%")
            (setf (unicode-char-word-indices-index uc) i)
            (incf i (length (unicode-char-word-indices uc)))
        ) )
        (format ostream "};~%")
        (format ostream "static const struct { uint16_t index; uint32_t name:24; }~%")
        (format ostream "#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 7)~%__attribute__((__packed__))~%#endif~%")
        (format ostream "unicode_name_to_index[~D] = {~%"
                        (length all-chars-and-aliases)
        )
        (dolist (uc all-chars-and-aliases)
          (format ostream "  { 0x~4,'0X, ~D },"
                          (unicode-char-index uc)
                          (unicode-char-word-indices-index uc)
          )
          (when add-comments
            (format ostream "~21T/* ~A */" (unicode-char-name uc))
          )
          (format ostream "~%")
        )
        (format ostream "};~%")
        (format ostream "static const struct { uint16_t index; uint32_t name:24; }~%")
        (format ostream "#if __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ >= 7)~%__attribute__((__packed__))~%#endif~%")
        (format ostream "unicode_index_to_name[~D] = {~%"
                        (length all-chars)
        )
        (dolist (uc (sort (copy-list all-chars) #'< :key #'unicode-char-index))
          (format ostream "  { 0x~4,'0X, ~D },"
                          (unicode-char-index uc)
                          (unicode-char-word-indices-index uc)
          )
          (when add-comments
            (format ostream "~21T/* ~A */" (unicode-char-name uc))
          )
          (format ostream "~%")
        )
        (format ostream "};~%")
        (format ostream "#define UNICODE_CHARNAME_MAX_LENGTH ~D~%"
                        (reduce #'max (mapcar (lambda (uc) (length (unicode-char-name uc))) all-chars-and-aliases))
        )
        (format ostream "#define UNICODE_CHARNAME_MAX_WORDS ~D~%"
                        (reduce #'max (mapcar (lambda (uc) (length (unicode-char-word-indices uc))) all-chars-and-aliases))
        )
        (format ostream "static const struct { uint16_t index; uint32_t gap; uint16_t length; } unicode_ranges[~D] = {~%"
                        (length all-ranges))
        (dolist (range all-ranges)
          (format ostream "  { ~D, ~D, ~D },~%"
                  (range-index range)
                  (- (range-start-code range) (range-index range))
                  (1+ (- (range-end-code range) (range-start-code range))))
        )
        (format ostream "};~%")
      )
) ) )

(main (first *args*) (second *args*) (third *args*))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./gllib/uniname/gen-uninames.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./edit.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Ed, Edit-file, Uncompile

(in-package "EXT")
(export '(editor-name editor-tempfile edit-file uncompile))
(in-package "SYSTEM")

;;-----------------------------------------------------------------------------
;; ED

;; *editor*, editor-name und editor-tempfile sind in CONFIG.LISP definiert.
;; Hier stehen nur die Defaults.

;; Der Name des Editors:
(defparameter *editor* nil)

;; Liefert den Namen des Editors:
(predefun editor-name () *editor*)

;; Das temporre File, das LISP beim Editieren anlegt:
(predefun editor-tempfile ()
  #+(or UNIX WIN32) (merge-pathnames "lisptemp.lisp" (user-homedir-pathname))
)

;; (edit-file file) editiert ein File.
(predefun edit-file (file)
  (unless (editor-name)
    (error-of-type 'error
      (TEXT "No external editor installed.")
  ) )
  ; Damit TRUENAME keinen Fehler liefert, wenn das File noch nicht existiert,
  ; stellen wir sicher, dass das File existiert:
  #+UNIX
  (unless (probe-file file)
    (close (open file :direction :output))
  )
  #+WIN32
    (execute (editor-name) ; das ist der Name des Editors
             (namestring (absolute-pathname file))) ; file as String
  #+UNIX
    (shell (format nil "~A ~A" (editor-name) (truename file)))
)

(defun ed (&optional arg &aux funname sym fun def)
  (if (null arg)
    (edit-file "")
    (if (or (pathnamep arg) (stringp arg))
      (edit-file arg)
      (if (and (cond ((function-name-p arg) (setq funname arg) t)
                     ((functionp arg) (function-name-p (setq funname (sys::closure-name arg))))
                     (t nil)
               )
               (fboundp (setq sym (get-funname-symbol funname)))
               (or (setq fun (macro-function sym))
                   (setq fun (symbol-function sym))
               )
               (functionp fun)
               (or (function-name-p arg) (eql fun arg))
               (setq def (get sym 'sys::definition))
          )
        (let ((tempfile (editor-tempfile)))
          (with-open-file (f tempfile :direction :output)
            (write (car def) :escape t :pretty t :stream f)
            (terpri f) (terpri f)
          )
          (let ((date (file-write-date tempfile)))
            (edit-file tempfile)
            (when (> (file-write-date tempfile) date)
              (with-open-file (f tempfile :direction :input)
                (let ((*package* *package*) ; *PACKAGE* binden
                      (end-of-file "EOF")) ; einmaliges Objekt
                  (loop
                    (let ((obj (read f nil end-of-file)))
                      (when (eql obj end-of-file) (return))
                      (prin1 (evalhook obj nil nil (cdr def)))
                      (terpri)
              ) ) ) )
              (when (sys::%compiled-function-p fun) (compile funname))
          ) )
          funname
        )
        (error-of-type 'error
          (TEXT "~S cannot be edited.")
          arg
) ) ) ) )

(defun uncompile (arg &aux funname sym fun def)
  (if (and (cond ((function-name-p arg) (setq funname arg) t)
                 ((functionp arg) (function-name-p (setq funname (sys::closure-name arg))))
                 (t nil)
           )
           (fboundp (setq sym (get-funname-symbol funname)))
           (or (setq fun (macro-function sym))
               (setq fun (symbol-function sym))
           )
           (functionp fun)
           (or (function-name-p arg) (eql fun arg))
           (setq def (get sym 'sys::definition))
      )
    (evalhook (car def) nil nil (cdr def))
    (error-of-type 'error
      (TEXT "~S: source code for ~S not available.")
      'uncompile funname
    )
) )
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./edit.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./init.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;   INITIALIZATION FILE

;; German comments translated into English: Stefan Kain 2001-08-27

(eval-when (compile load eval)
  (setq *package* (sys::%find-package "COMMON-LISP")))

;;; Exports:
(export
 '(;; types:
   array atom base-char base-string bignum bit bit-vector boolean character
   compiled-function complex cons double-float extended-char fixnum float
   function hash-table integer keyword list list* char-code-limit
   #+LOGICAL-PATHNAMES logical-pathname
   long-float nil null number package pathname random-state ratio rational
   readtable real sequence short-float simple-array simple-base-string
   simple-bit-vector simple-string simple-vector single-float standard-char
   stream file-stream synonym-stream broadcast-stream concatenated-stream
   two-way-stream echo-stream string-stream string symbol t vector
   satisfies values mod signed-byte unsigned-byte
   ;; constants:
   lambda-list-keywords lambda-parameters-limit nil t call-arguments-limit
   multiple-values-limit pi
   boole-clr boole-set boole-1 boole-2 boole-c1 boole-c2 boole-and
   boole-ior boole-xor boole-eqv boole-nand boole-nor boole-andc1
   boole-andc2 boole-orc1 boole-orc2
   most-positive-fixnum most-negative-fixnum
   most-positive-short-float least-positive-short-float
   least-negative-short-float most-negative-short-float
   most-positive-single-float least-positive-single-float
   least-negative-single-float most-negative-single-float
   most-positive-double-float least-positive-double-float
   least-negative-double-float most-negative-double-float
   most-positive-long-float least-positive-long-float
   least-negative-long-float most-negative-long-float
   least-positive-normalized-short-float
   least-negative-normalized-short-float
   least-positive-normalized-single-float
   least-negative-normalized-single-float
   least-positive-normalized-double-float
   least-negative-normalized-double-float
   least-positive-normalized-long-float
   least-negative-normalized-long-float
   short-float-epsilon single-float-epsilon
   double-float-epsilon long-float-epsilon
   short-float-negative-epsilon single-float-negative-epsilon
   double-float-negative-epsilon long-float-negative-epsilon
   array-rank-limit array-dimension-limit
   array-total-size-limit internal-time-units-per-second
   ;; variables:
   *macroexpand-hook* *gensym-counter* *package* *modules* *random-state*
   + ++ +++ - * ** *** / // /// *standard-input*
   *standard-output* *error-output* *query-io* *debug-io* *terminal-io*
   *trace-output* *read-base* *read-suppress* *read-eval* *readtable*
   *print-readably* *print-escape* *print-pretty* *print-circle* *print-base*
   *print-radix* *print-case* *print-gensym* *print-level* *print-length*
   *print-lines* *print-miser-width* *print-pprint-dispatch* *print-array*
   *print-right-margin* *read-default-float-format* *default-pathname-defaults*
   *load-verbose* *load-print* *load-pathname* *load-truename*
   *compile-verbose* *compile-print* *compile-file-pathname*
   *compile-file-truename* *features*
   ;; functions:
   coerce type-of upgraded-array-element-type upgraded-complex-part-type
   typep subtypep null symbolp
   atom consp listp numberp integerp rationalp floatp realp complexp characterp
   stringp bit-vector-p vectorp simple-vector-p simple-string-p
   simple-bit-vector-p arrayp packagep functionp compiled-function-p eq
   eql equal equalp not symbol-value symbol-function fdefinition boundp fboundp
   special-operator-p set makunbound fmakunbound
   get-setf-expansion
   apply funcall mapcar maplist mapc mapl mapcan mapcon values values-list
   macro-function macroexpand macroexpand-1 proclaim get remprop symbol-plist
   getf get-properties symbol-name make-symbol copy-symbol gensym gentemp
   symbol-package keywordp make-package in-package find-package package-name
   package-nicknames rename-package package-use-list package-used-by-list
   package-shadowing-symbols list-all-packages delete-package
   intern find-symbol unintern export unexport import shadowing-import shadow
   use-package unuse-package find-all-symbols provide require zerop plusp
   minusp oddp evenp = /= < > <= >= max min + - * / 1+ 1- conjugate gcd lcm exp
   expt log sqrt isqrt abs phase signum sin cos tan cis asin acos atan sinh
   cosh tanh asinh acosh atanh float rational rationalize numerator denominator
   floor ceiling truncate round mod rem ffloor fceiling ftruncate fround
   decode-float scale-float float-radix float-sign float-digits float-precision
   integer-decode-float complex realpart imagpart logior logxor logand logeqv
   lognand lognor logandc1 logandc2 logorc1 logorc2 boole lognot logtest
   logbitp ash logcount integer-length
   byte byte-size byte-position ldb ldb-test mask-field dpb deposit-field
   random make-random-state random-state-p
   standard-char-p graphic-char-p alpha-char-p upper-case-p lower-case-p
   both-case-p digit-char-p alphanumericp char= char/= char< char> char<=
   char>= char-equal char-not-equal char-lessp char-greaterp char-not-greaterp
   char-not-lessp char-code code-char character char-upcase char-downcase
   digit-char char-int char-name name-char
   complement constantly elt subseq copy-seq length reverse
   nreverse make-sequence concatenate map map-into some every notany notevery
   reduce fill replace remove remove-if remove-if-not delete delete-if
   delete-if-not remove-duplicates delete-duplicates substitute substitute-if
   substitute-if-not nsubstitute nsubstitute-if nsubstitute-if-not find find-if
   find-if-not position position-if position-if-not count count-if count-if-not
   mismatch search sort stable-sort merge car cdr caar cadr cdar cddr caaar
   caadr cadar caddr cdaar cdadr cddar cdddr caaaar caaadr caadar caaddr cadaar
   cadadr caddar cadddr cdaaar cdaadr cdadar cdaddr cddaar cddadr cdddar cddddr
   cons tree-equal endp list-length nth first second third fourth fifth sixth
   seventh eighth ninth tenth rest nthcdr last list make-list append
   copy-list copy-alist copy-tree revappend nconc nreconc butlast nbutlast
   ldiff rplaca rplacd subst subst-if subst-if-not nsubst nsubst-if
   nsubst-if-not sublis nsublis member member-if member-if-not tailp adjoin
   union nunion intersection nintersection set-difference nset-difference
   set-exclusive-or nset-exclusive-or subsetp acons pairlis assoc assoc-if
   assoc-if-not rassoc rassoc-if rassoc-if-not
   make-hash-table hash-table-p gethash remhash maphash clrhash
   hash-table-count hash-table-rehash-size hash-table-rehash-threshold
   hash-table-size hash-table-test sxhash
   make-array vector aref svref array-element-type array-rank array-dimension
   array-dimensions array-total-size array-in-bounds-p array-row-major-index
   row-major-aref adjustable-array-p array-displacement
   bit sbit bit-and bit-ior bit-xor bit-eqv bit-nand bit-nor bit-andc1
   bit-andc2 bit-orc1 bit-orc2 bit-not
   array-has-fill-pointer-p fill-pointer vector-push
   vector-push-extend vector-pop adjust-array char schar string= string-equal
   string< string> string<= string>= string/= string-lessp string-greaterp
   string-not-greaterp string-not-lessp string-not-equal make-string
   string-trim string-left-trim string-right-trim string-upcase string-downcase
   string-capitalize nstring-upcase nstring-downcase nstring-capitalize string
   copy-structure
   eval constantp make-synonym-stream make-broadcast-stream
   make-concatenated-stream make-two-way-stream make-echo-stream
   make-string-input-stream make-string-output-stream get-output-stream-string
   streamp open-stream-p input-stream-p output-stream-p stream-element-type
   stream-external-format close broadcast-stream-streams
   concatenated-stream-streams echo-stream-input-stream
   echo-stream-output-stream synonym-stream-symbol two-way-stream-input-stream
   two-way-stream-output-stream interactive-stream-p
   copy-readtable readtablep set-syntax-from-char set-macro-character
   get-macro-character make-dispatch-macro-character
   set-dispatch-macro-character get-dispatch-macro-character readtable-case
   read read-preserving-whitespace read-delimited-list read-line read-char
   unread-char peek-char listen read-char-no-hang clear-input read-from-string
   parse-integer read-byte write prin1 print pprint princ write-to-string
   pprint-dispatch copy-pprint-dispatch set-pprint-dispatch pprint-fill
   pprint-indent pprint-linear pprint-newline pprint-tab pprint-tabular
   pprint-exit-if-list-exhausted pprint-logical-block pprint-pop
   prin1-to-string princ-to-string write-char write-string write-line terpri
   fresh-line finish-output force-output clear-output write-byte format
   y-or-n-p yes-or-no-p wild-pathname-p pathname-match-p translate-pathname
   #+LOGICAL-PATHNAMES logical-pathname
   #+LOGICAL-PATHNAMES translate-logical-pathname
   #+LOGICAL-PATHNAMES logical-pathname-translations
   #+LOGICAL-PATHNAMES load-logical-pathname-translations
   compile-file-pathname pathname truename parse-namestring merge-pathnames
   make-pathname pathnamep pathname-host pathname-device pathname-directory
   pathname-name pathname-type pathname-version namestring file-namestring
   directory-namestring host-namestring enough-namestring user-homedir-pathname
   open rename-file delete-file probe-file file-write-date file-author
   file-position file-length file-string-length load directory
   ensure-directories-exist error cerror warn break compile
   compile-file disassemble with-compilation-unit
   variable structure type ; three documentation-types
   describe inspect room ed dribble apropos apropos-list get-decoded-time
   get-universal-time decode-universal-time encode-universal-time
   get-internal-run-time get-internal-real-time sleep lisp-implementation-type
   lisp-implementation-version machine-type machine-version machine-instance
   software-type software-version short-site-name long-site-name identity
   ;; Special-forms:
   eval-when quote function setq progn let let* locally progv flet
   labels macrolet symbol-macrolet if block return-from tagbody go
   multiple-value-call multiple-value-prog1 catch unwind-protect throw declare
   the load-time-value
   ;; Macros:
   deftype defun defvar defparameter defconstant and or psetq setf psetf shiftf
   rotatef define-modify-macro defsetf define-setf-expander
   prog1 prog2 when unless cond nth-value function-lambda-expression
   case typecase otherwise ; otherwise is the marker for the catchall-clause
   return loop do do* dolist dotimes prog prog* multiple-value-list
   multiple-value-bind multiple-value-setq defmacro remf do-symbols
   do-external-symbols do-all-symbols with-package-iterator incf decf
   push pushnew pop defstruct
   with-open-stream with-input-from-string with-output-to-string
   print-unreadable-object
   with-standard-io-syntax with-open-file define-symbol-macro
   check-type assert etypecase ctypecase ecase ccase trace untrace step time
   formatter
   compiler-macro compiler-macro-function define-compiler-macro
   ;; other markers:
   ;; EVAL-WHEN situations:
   eval load compile
   ;; DECLARE specifiers:
   special type ftype function inline notinline ignore ignorable optimize speed
   space safety compilation-speed debug declaration dynamic-extent compile
   ;; exports from condition.lisp
   make-condition               ; pre-drawn for clos.lisp
   handler-bind                 ; pre-drawn for compiler.lisp
   end-of-file restart          ; avoid conflict with defs2.lisp
   abort                        ; avoid conflict with gray.lisp
   ;; types for error-of-type:
   condition warning serious-condition error storage-condition type-error
   program-error control-error package-error print-not-readable parse-error
   stream-error end-of-file reader-error file-error cell-error unbound-variable
   undefined-function unbound-slot arithmetic-error division-by-zero
   floating-point-overflow floating-point-underflow floating-point-inexact
   floating-point-invalid-operation))

(sys::%proclaim-constant 'lambda-list-keywords
  '(&optional &rest &key &allow-other-keys &aux &body &whole &environment))
(export lambda-list-keywords)

(proclaim '(special *features*))

(use-package '("COMMON-LISP" "EXT") "SYSTEM")
;; (in-package "SYSTEM")
(common-lisp:eval-when (common-lisp:compile common-lisp:load common-lisp:eval)
  (common-lisp:setq common-lisp:*package* (sys::%find-package "SYSTEM")))

(proclaim '(special sys::*compiling* sys::*compiling-from-file*
            sys::*c-error-output*)) ; for load/compiling
(setq sys::*compiling* nil)

#-COMPILER ; only for bootstrapping
(progn

;; preliminary, no expansion at GET_CLOSURE:
(sys::%set-symbol-function '%expand-lambdabody-main
  (function %expand-lambdabody-main (lambda (lambdabody venv fenv)
    (declare (source nil) (ignore venv fenv))
    lambdabody)))

;; preliminary, defun is to be expanded trivially:
(sys::%set-symbol-function 'defun
  (sys::make-macro
    (function defun (lambda (form env)
      (declare (ignore env))
      #| (let ((name (cadr form))
               (lambdalist (caddr form))
               (body (cdddr form)))
           `(SYS::%SET-SYMBOL-FUNCTION ',name (FUNCTION ,name (LAMBDA ,lambdalist ,@body))))
      |#
      (let ((name (cadr form)))
        (list 'sys::%set-symbol-function (list 'quote name)
              (list 'function name (cons 'lambda (cddr form)))))))
    '(function-name lambda-list &body forms)))

)

(sys::%set-symbol-function 'sys::make-preliminary
  (function sys::make-preliminary (lambda (closure) ; ABI
    (sys::\(setf\ closure-name\)
     (list 'ext::preliminary (sys::closure-name closure)) closure)
    closure)))

(sys::%set-symbol-function 'in-package
  (sys::make-macro
    (function in-package (lambda (form env)
      (declare (ignore env))
      (let ((package-name (string (cadr form))))
        (list 'EVAL-WHEN '(:COMPILE-TOPLEVEL LOAD EVAL)
              (list 'SETQ 'COMMON-LISP::*PACKAGE*
                    (list 'SYS::%FIND-PACKAGE package-name))))))
    '(package-name)))

;; A preliminary definition that understands only ~S, ~A and ~C.
(sys::%set-symbol-function 'format
  (sys::make-preliminary
    (function format
      (lambda (destination control-string &rest arguments &aux stream)
        (cond ((null destination)
               (setq stream (make-string-output-stream)))
              ((eq destination 'T)
               (setq stream *standard-output*))
              ((streamp destination)
               (setq stream destination))
              (t (error (TEXT "The destination argument ~S is invalid (not NIL or T or a stream or a string).")
                        destination)))
        (cond ((stringp control-string)
               (let ((i 0) (n (length control-string)))
                 (tagbody
                   next
                     (when (< i n)
                       (when (eq (char control-string i) #\~)
                         (when (< (1+ i) n)
                           (let ((c (char control-string (1+ i))))
                             (cond ((eq c #\S)
                                    (prin1 (car arguments) stream)
                                    (setq arguments (cdr arguments))
                                    (setq i (+ i 2))
                                    (go next))
                                   ((eq c #\A)
                                    (princ (car arguments) stream)
                                    (setq arguments (cdr arguments))
                                    (setq i (+ i 2))
                                    (go next))
                                   ((eq c #\C)
                                    (write-char (car arguments) stream)
                                    (setq arguments (cdr arguments))
                                    (setq i (+ i 2))
                                    (go next))))))
                       (write-char (char control-string i) stream)
                       (setq i (+ i 1))
                       (go next)))))
              ((functionp control-string)
               (apply control-string stream arguments))
              (t (error (TEXT "~S: The control-string must be a string, not ~S")
                        'format control-string)))
        (if (null destination)
          (get-output-stream-string stream)
          nil)))))

;; Yet another preliminary definition.
(sys::%set-symbol-function 'cerror
  (sys::make-preliminary
    (function cerror
      (lambda (continue-format-string error-format-string &rest args)
        (fresh-line *error-output*)
        (write-string "** - " *error-output*)
        (write-string (TEXT "Continuable Error") *error-output*)
        (terpri *error-output*)
        (apply #'format *error-output* error-format-string args)
        (ext::elastic-newline *error-output*)
        (fresh-line *debug-io*)
        (apply #'format *debug-io* continue-format-string args)
        (ext::elastic-newline *debug-io*)
        nil))))

(use-package '("COMMON-LISP" "CUSTOM") "EXT")

(in-package "EXT")

(sys::%set-symbol-function 'exit #'sys::%exit)
(sys::%set-symbol-function 'quit #'sys::%exit)
(sys::%set-symbol-function 'bye #'sys::%exit)

(export
 '(re-export featurep make-encoding encoding
   encoding-line-terminator #+UNICODE encoding-charset
   times show-stack gc exit quit bye expand-form xor mapcap maplap
   proper-list-p elastic-newline absolute-pathname default-directory cd dir
   probe-directory make-directory delete-directory rename-directory
   xgcd exquo mod-expt ! evalhook applyhook substring string-concat
   string-char make-char string-width char-width probe-pathname
   int-char char-bits char-font char-bit set-char-bit char-key
   base-char-code-limit char-font-limit char-bits-limit char-control-bit
   char-meta-bit char-super-bit char-hyper-bit string-char-p
   char-invertcase string-invertcase nstring-invertcase
   long-float-digits package-lock hash-table-weak-p weak-key-value-table
   the-environment arglist getenv special-variable-p
   list-length-dotted list-length-proper
   *driver* *break-driver* *args* *keyboard-input* shell execute
   fasthash-eq stablehash-eq fasthash-eql stablehash-eql fasthash-equal
   stablehash-equal define-hash-table-test package-case-sensitive-p
   package-case-inverted-p argv hash-table-warn-if-needs-rehash-after-gc
   package-shortest-name symbol-macro-expand
   ;; declarations
   constant-inline constant-notinline notspecial
   ;; pseudo-types:
   simple-2bit-vector 2bit-vector simple-4bit-vector 4bit-vector
   simple-8bit-vector 8bit-vector simple-16bit-vector 16bit-vector
   simple-32bit-vector 32bit-vector special-form system-function
   function-macro foreign-pointer symbol-macro global-symbol-macro designator
   address special-operator finalize finalizer
   ;; weak containers
   weak-pointer make-weak-pointer weak-pointer-p weak-pointer-value
   weak-list make-weak-list weak-list-p weak-list-list
   weak-and-relation make-weak-and-relation weak-and-relation-p
   weak-and-relation-list
   weak-or-relation make-weak-or-relation weak-or-relation-p
   weak-or-relation-list
   weak-mapping make-weak-mapping weak-mapping-p weak-mapping-pair
   weak-mapping-value
   weak-and-mapping make-weak-and-mapping weak-and-mapping-p
   weak-and-mapping-pair weak-and-mapping-value
   weak-or-mapping make-weak-or-mapping weak-or-mapping-p weak-or-mapping-pair
   weak-or-mapping-value
   weak-alist make-weak-alist weak-alist-p weak-alist-type weak-alist-contents
   weak-alist-assoc weak-alist-rassoc weak-alist-value
   ;; structure MOP
   structure-slots structure-direct-slots ; structure-instance-size
   structure-keyword-constructor structure-boa-constructors
   structure-copier structure-predicate
   ;; i/o
   read-integer read-float write-integer write-float
   make-completion longest-common-prefix
   read-byte-lookahead read-byte-will-hang-p read-byte-no-hang
   read-char-will-hang-p
   read-char-sequence write-char-sequence
   read-byte-sequence write-byte-sequence
   convert-string-from-bytes convert-string-to-bytes make-stream
   #+(or UNIX WIN32) make-pipe-output-stream
   #+(or UNIX WIN32) make-pipe-input-stream
   #+(or UNIX WIN32) make-pipe-io-stream
   make-buffered-input-stream make-buffered-output-stream stream-handles
   get-setf-method preliminary local module-info
   source-program-error source-program-error-form source-program-error-detail
   compiler-let load-time-eval compile-time-value)
 "EXT")

(common-lisp:in-package "CUSTOM")

(common-lisp:export
 '(*load-paths* *editor* *clhs-root-default* *browsers* *browser* *http-proxy*
   *http-log-stream* clhs-root *impnotes-root-default* impnotes-root
   *saveinitmem-verbose* *completion*
   *load-echo* *applyhook* *evalhook* *load-compiling* *compile-warnings*
   *load-obsolete-action* *suppress-check-redefinition*
   *eq-hashfunction* *eql-hashfunction* *equal-hashfunction*
   ;; places.lisp
   *ansi* *current-language* *lib-directory* *default-file-encoding*
   #+UNICODE *misc-encoding*
   #+UNICODE *terminal-encoding*
   #+UNICODE *pathname-encoding*
   *source-file-types* *compiled-file-types*)
 "CUSTOM")
(common-lisp:in-package "SYSTEM")

(ext:re-export "CUSTOM" "EXT")

(in-package "COMMON-LISP")
(proclaim
  '(ext::constant-notinline
    ;; These constants are platform dependent and therefore shouldn't be
    ;; inlined in compiled bytecode files.
    lambda-parameters-limit call-arguments-limit
    system::*jmpbuf-size* system::*big-endian*
    most-positive-fixnum most-negative-fixnum
    most-positive-short-float most-negative-short-float
    least-positive-short-float least-negative-short-float
    most-positive-single-float most-negative-single-float
    least-positive-single-float least-negative-single-float
    most-positive-double-float most-negative-double-float
    least-positive-double-float least-negative-double-float
    short-float-epsilon short-float-negative-epsilon
    single-float-epsilon single-float-negative-epsilon
    double-float-epsilon double-float-negative-epsilon
    char-code-limit
    array-total-size-limit array-dimension-limit array-rank-limit
    internal-time-units-per-second))

(use-package '("COMMON-LISP") "CLOS")
(in-package "CLOS")

;;; Exports:
(export
 '(;; names of functions and macros:
   slot-value slot-boundp slot-makunbound slot-exists-p with-slots
   with-accessors documentation
   find-class class-of defclass defmethod call-next-method next-method-p
   defgeneric generic-function
   class-name no-applicable-method no-next-method
   find-method add-method remove-method
   compute-applicable-methods method-qualifiers function-keywords
   slot-missing slot-unbound
   print-object describe-object
   make-instance allocate-instance initialize-instance reinitialize-instance
   shared-initialize ensure-generic-function
   make-load-form make-load-form-saving-slots
   change-class update-instance-for-different-class
   update-instance-for-redefined-class make-instances-obsolete
   ;; names of classes:
   class standard-class structure-class built-in-class
   standard-object structure-object
   generic-function standard-generic-function method standard-method
   ;; method combinations
   standard method-combination define-method-combination
   method-combination-error invalid-method-error
   call-method make-method))

(use-package '("CLOS") "COMMON-LISP")
(ext:re-export "CLOS" "COMMON-LISP")
(progn ; not in ANSI - export separately, after `re-export' above
(export
     #1='(metaobject
          ;; MOP for dependents
          add-dependent remove-dependent map-dependents update-dependent
          ;; MOP for slot definitions
          slot-definition standard-slot-definition
          direct-slot-definition standard-direct-slot-definition
          effective-slot-definition standard-effective-slot-definition
          slot-definition-name
          slot-definition-initform slot-definition-initfunction
          slot-definition-type slot-definition-allocation
          slot-definition-initargs
          slot-definition-readers slot-definition-writers
          slot-definition-location
          ;; MOP for slot access
          slot-value-using-class slot-boundp-using-class
          slot-makunbound-using-class
          standard-instance-access funcallable-standard-instance-access
          ;; MOP for classes
          class forward-referenced-class
          built-in-class structure-class standard-class
          class-name class-direct-superclasses class-precedence-list
          class-direct-subclasses class-direct-slots class-slots
          class-direct-default-initargs class-default-initargs class-prototype
          class-finalized-p finalize-inheritance
          compute-direct-slot-definition-initargs direct-slot-definition-class
          compute-class-precedence-list
          compute-slots compute-effective-slot-definition
          compute-effective-slot-definition-initargs
          effective-slot-definition-class
          compute-default-initargs
          validate-superclass add-direct-subclass remove-direct-subclass
          standard-accessor-method
          standard-reader-method standard-writer-method
          reader-method-class writer-method-class
          ensure-class ensure-class-using-class
          ;; MOP for specializers
          specializer eql-specializer
          specializer-direct-generic-functions specializer-direct-methods
          add-direct-method remove-direct-method
          eql-specializer-object intern-eql-specializer
          ;; MOP for methods
          method standard-method
          method-function method-generic-function method-lambda-list
          method-specializers method-qualifiers accessor-method-slot-definition
          extract-lambda-list extract-specializer-names
          ;; MOP for method combinations
          find-method-combination compute-effective-method
          ;; MOP for generic functions
          funcallable-standard-class funcallable-standard-object
          set-funcallable-instance-function
          generic-function-name generic-function-methods
          generic-function-method-class generic-function-lambda-list
          generic-function-method-combination
          generic-function-argument-precedence-order
          generic-function-declarations
          compute-discriminating-function
          compute-applicable-methods compute-applicable-methods-using-classes
          compute-effective-method-as-function
          ensure-generic-function ensure-generic-function-using-class
          ;; CLISP specific symbols
          generic-flet generic-labels no-primary-method
          method-call-error method-call-type-error
          method-call-error-generic-function
          method-call-error-method method-call-error-argument-list
          standard-stablehash structure-stablehash dynamically-modifiable
          clos-warning gf-already-called-warning gf-replacing-method-warning
          clos-novice-warning clos-style-warning class-obsolescence-warning)
     "CLOS")
;; so that they are available in CL-USER even though it does not use CLOS
(import #1# "EXT")
(export #1# "EXT"))

(in-package "SYSTEM")

(use-package '("COMMON-LISP" "EXT") "CL-USER")

(sys::%set-symbol-function 'sys::preliminary-p
  (function sys::preliminary-p (lambda (name)
    (and (consp name) (eq (car name) 'ext:preliminary)))))

(sys::%set-symbol-function 'sys::fbound-string
  (function sys::fbound-string (lambda (sym)
    (cond ((special-operator-p sym) (TEXT "special operator"))
          ((macro-function sym)
           (if (not (and (sys::closurep (macro-function sym))
                         (sys::preliminary-p (sys::closure-name
                                              (macro-function sym)))))
             (TEXT "macro")
             nil))
          ((fboundp sym)
           (if (not (and (sys::closurep (symbol-function sym))
                         (sys::preliminary-p (sys::closure-name
                                              (symbol-function sym)))))
             (TEXT "function")
             nil))))))


;; Mapping funname -> symbol (required by PROCLAIM SPECIAL)
(sys::%set-symbol-function 'get-funname-symbol
  (function get-funname-symbol (lambda (funname)
    (if (atom funname)
      funname
      (get-setf-symbol (second funname))))))

;; return the SYMBOL on whose plist the object's documentation will be kept
;; and the CALLER that indicates what the doc pertains to.
;; OBJECT can be a symbol, (setf symbol), or (func-name quals specs)
;; CALLER is a symbol
;; the doc entity symbol is a symbol from object
;; and doc entity caller is a symbol or list from caller
;; e.g.: (defun foo ...) ==> (FOO DEFUN/DEFMACRO) -> (FOO DEFUN/DEFMACRO)
;; (defmethod foo ...) ==> ((FOO ...) DEFMETHOD) -> (FOO (DEFMETHOD ...))
(sys::%set-symbol-function 'sys::get-doc-entity-symbol
  (function sys::get-doc-entity-symbol (lambda (object)
    (get-funname-symbol (if (function-name-p object) object (first object))))))
(sys::%set-symbol-function 'sys::get-doc-entity-caller
  (function sys::get-doc-entity-caller (lambda (object caller)
    (if (function-name-p object) caller (cons caller (rest object))))))

(sys::%set-symbol-function 'sys::%set-documentation
  (function sys::%set-documentation (lambda (object doctype value) ; ABI
    (let* ((symbol (sys::get-doc-entity-symbol object))
           (rec (get symbol 'sys::doc)))
      (if value
        (let ((new-val (sys::%putf rec doctype value)))
          (when new-val (sys::%put symbol 'sys::doc new-val)))
        (when rec
          (setq rec (sys::%remf rec doctype))
          (cond ((null rec) (remprop symbol 'sys::doc))
                ((atom rec) (sys::%put symbol 'sys::doc rec))))))
    value)))

(proclaim '(special *load-truename* custom:*suppress-check-redefinition*
            *current-source-line-1* *current-source-line-2*
            *current-source-file*))
(setq *load-truename* nil
      custom:*suppress-check-redefinition* nil
      *current-source-line-1* nil
      *current-source-line-2* nil
      *current-source-file* nil)

(sys::%set-symbol-function 'sys::check-special-operator
  (function sys::check-special-operator (lambda (caller symbol)
    (when (special-operator-p symbol)
      (error-of-type 'source-program-error
        ;; note that caller may be SYS::DEFUN/DEFMACRO !
        ;; maybe (SETF FDEFINITION) is better?
        :form (list caller symbol) :detail symbol
        (TEXT "~A: ~S is a special operator and may not be redefined.")
        caller symbol)))))

;; sys::file doc is an alist ((caller . file-location) ...)
(sys::%set-symbol-function 'sys::get-file-doc
  (function sys::get-file-doc (lambda (object caller)
    (assoc (sys::get-doc-entity-caller object caller)
           (getf (get (sys::get-doc-entity-symbol object) 'sys::doc) 'sys::file)
           ;; caller can be (list* funname qualifiers spec-list)
           :test #'equal))))
(sys::%set-symbol-function 'sys::set-file-doc
  (function sys::set-file-doc (lambda (object caller value)
    (let* ((symbol (sys::get-doc-entity-symbol object))
           (caller (sys::get-doc-entity-caller object caller))
           (doc-plist (get symbol 'sys::doc))
           (file-alist (getf doc-plist 'sys::file))
           (old-pair (assoc caller file-alist :test #'equal)))
      (if old-pair
        ;; In theory, we should remove the OLD-PAIR from FILE-ALIST
        ;; and then maybe remove the SYS::FILE & SYS::DOC properties...
        ;; Alas, DELETE does not work at this point yet, so it is not trivial.
        ;; Note however that VALUE=NIL & OLD-PAIR/=NIL ==> top-level
        ;; ==> performance non-critical
        (rplacd old-pair value)
        (when value             ; VALUE=NIL, OLD-PAIR=NIL => do nothing
          (let ((new-doc-plist  ; nil if %PUTF worked in-place
                 (sys::%putf doc-plist 'sys::file
                             (acons caller value file-alist))))
            (when new-doc-plist
              (sys::%put symbol 'sys::doc new-doc-plist)))))))))

(sys::%set-symbol-function 'sys::check-redefinition
  (function sys::check-redefinition (lambda (object caller what)
    (when (and (symbolp object)
               (not (eq caller 'define-setf-expander))
               (not (equal caller '(setf find-class))))
      ;; see (define-setf-expander THE) in places.lisp
      ;; and (def <t> <function>...) in clos-class3.lisp
      (sys::check-special-operator caller object))
    (unless custom:*suppress-check-redefinition*
      (sys::check-package-lock
       caller
       (cond ((atom object) (symbol-package object))
             ((function-name-p object) (symbol-package (second object)))
             ((mapcar #'(lambda (obj) ; handle (setf NAME) and (eql NAME)
                          (let ((oo (if (atom obj) obj (second obj))))
                            (when (symbolp oo)
                              (symbol-package oo))))
                      object)))
       object))
    (let ((cur-file *current-source-file*)
          (old-file ; distinguish between undefined and defined at top-level
           (if (and (not (or (eq caller 'define-setf-expander)
                             (eq caller 'defsetf)))
                    (sys::subr-info object))
               "C" (cdr (sys::get-file-doc object caller)))))
      (when (consp old-file) (setq old-file (car old-file)))
      (unless (or custom:*suppress-check-redefinition*
                  (equalp old-file cur-file)
                  (and (pathnamep old-file) (pathnamep cur-file)
                       (equal (pathname-name old-file)
                              (pathname-name cur-file))))
        (when what ; when not yet defined, `what' is NIL
          (warn-of-type 'simple-style-warning
            (TEXT "~A: redefining ~A ~S in ~A, was defined in ~A")
            caller what object (or cur-file #2="top-level")
            (or old-file #2#))))
      (sys::set-file-doc
       object caller
       ;; note that when CUR-FILE is "foo.fas",
       ;; *current-source-line-[12]* point into "foo.lisp"!
       (and cur-file (list cur-file *current-source-line-1*
                           *current-source-line-2*)))))))

;; in-package has to be defined very early, so we have to do it now
(let ((sys::*current-source-file* "init")) ; still using C load at this time
  (sys::check-redefinition 'in-package 'defmacro nil))

(sys::%set-symbol-function 'sys::remove-old-definitions
  (function sys::remove-old-definitions (lambda (symbol &optional (preliminary nil)) ; ABI
    ;; removes the old function-definitions of a symbol
    (if preliminary
      (sys::check-special-operator 'defun/defmacro symbol)
      (sys::check-redefinition symbol 'defun/defmacro
                               (sys::fbound-string symbol)))
    (fmakunbound symbol) ; discard function & macro definition
    (remprop symbol 'sys::definition) ; discard function lambda expression
    (remprop symbol 'sys::macro) ; discard macro definition
    (remprop symbol 'sys::defstruct-reader) ; discard DEFSTRUCT information
    (sys::%set-documentation symbol 'FUNCTION nil)
    (when (get symbol 'sys::inline-expansion)
      (sys::%put symbol 'sys::inline-expansion t))
    (when (get symbol 'sys::traced-definition) ; discard Trace
      (warn-of-type 'simple-style-warning
        (TEXT "~A: redefining ~S; it was traced!") 'defun/defmacro symbol)
      (untrace2 symbol)))))

;; THE-ENVIRONMENT as in SCHEME
(sys::%set-symbol-function '%the-environment
  (function %the-environment (lambda (form env) ; ABI
    (declare (ignore form))
    (sys::svstore env 0 (svref (svref env 0) 2)) ; nuke *evalhook* binding
    env)))
(sys::%set-symbol-function '%uncompilable
  (function %uncompilable (lambda (form) ; ABI
    (error-of-type 'source-program-error
      :form form
      :detail form
      (TEXT "~S is impossible in compiled code") form))))
(sys::%set-symbol-function 'the-environment
  (sys::make-macro
    (function the-environment (lambda (form env)
      (declare (ignore form env))
      '(progn
        (eval-when ((not eval)) (%uncompilable 'the-environment))
        (let ((*evalhook* #'%the-environment)) 0))))
    '()))
(let ((sys::*current-source-file* "init"))
  (sys::check-redefinition 'the-environment 'defmacro nil))

;; The toplevel environment
(proclaim '(special *toplevel-environment*))
(setq *toplevel-environment* (eval '(the-environment)))
(proclaim '(special *toplevel-denv*)) ; ABI
(setq *toplevel-denv* (svref *toplevel-environment* 4))

;;; functions for expansion of macros within a piece of code
;;;
;;; Altogether, the whole Code (of a function) is walked through and
;;; global and local Macros are expanded.
;;;           #'(lambda lambdalist . body)
;;; becomes   #'(lambda expanded-lambdalist
;;;               (declare (source (lambdalist . body))) . expanded-body
;;;             )
;;; This declaration guarantees, that a formerly processed
;;; function is recognized as such and not unnecessarily processed
;;; a second time.

;; Caution! For bootstrapping purposes (recognizable with #-COMPILER) some
;; of the functions have to be written in a more primitive Lisp
;; (without do, do*, case).

(PROGN

(proclaim '(special *keyword-package*))
(setq *keyword-package* (find-package "KEYWORD"))
(defun symbol-to-keyword (s) (intern (symbol-name s) *keyword-package*))

(proclaim '(special *fenv*))
;; *FENV* = the current function environment during expansion of a form.
;; structure: NIL or a 2n+1-element vector
;;   (n1 f1 ... nn fn next),
;; where the ni are function-names,
;;       the fi are their functional meanings
;;           (closure or macro or function-macro or still NIL)
;; continued similarly at 'next'.

;; (fenv-assoc s fenv) searches symbol S in function-environment FENV.
;; the search routine uses EQUAL
(defun fenv-assoc (s fenv &optional (from-inside-macrolet nil))
  (if fenv
    (if (simple-vector-p fenv)
      #+COMPILER
      (do ((l (1- (length fenv)))
           (i 0 (+ i 2)))
          ((= i l) (fenv-assoc s (svref fenv i) from-inside-macrolet))
        (if (equal s (svref fenv i))
          (if (and from-inside-macrolet (not (macrop (svref fenv (1+ i)))))
            (error-of-type 'source-program-error
              :form (list 'FUNCTION s)
              :detail s
              (TEXT "Invalid access to the local function definition of ~S from within a ~S definition")
              s 'macrolet)
            (return (svref fenv (1+ i))))))
      #-COMPILER
      (let ((l (1- (length fenv)))
            (i 0))
        (block nil
          (tagbody
            1 (if (= i l) (return-from nil (fenv-assoc s (svref fenv i) from-inside-macrolet)))
              (if (equal s (svref fenv i))
                (if (and from-inside-macrolet (not (macrop (svref fenv (1+ i)))))
                  (error-of-type 'source-program-error
                    :form (list 'FUNCTION s)
                    :detail s
                    (TEXT "Invalid access to the local function definition of ~S from within a ~S definition")
                    s 'macrolet)
                  (return-from nil (svref fenv (1+ i)))))
              (setq i (+ i 2))
              (go 1))))
      (if (and (consp fenv) (eq (car fenv) 'MACROLET))
        (fenv-assoc s (cdr fenv) t)
        (error-of-type 'type-error
          :datum fenv :expected-type '(or null simple-vector (cons (eql macrolet) t))
          (TEXT "~S is an invalid function environment")
          fenv)))
    'T)) ; not found
;; Determines, if a function-name S in function-environment FENV is not
;; defined and thus refers to the global function.
(sys::%set-symbol-function 'global-in-fenv-p
  (sys::make-preliminary
    (function global-in-fenv-p (lambda (s fenv) ; preliminary
      (eq (fenv-assoc s fenv) 'T)))))

(proclaim '(special *venv*))
;; *VENV* = the current variable-environment during the expansion of a form.
;; Structure: NIL or a 2n+1-element Vector
;;   (n1 v1 ... nn vn next),
;; where the ni are Symbols,
;;      the vi are their syntactic meanings (symbol-macro-object or sth. else)
;; continued similarly at 'next'.

;; (venv-assoc s venv) searches symbol S in variable-environment VENV.
;; Returns the value (or NIL if there's no value).
;; Caution: The value can be #<SPECDECL> or #<SYMBOL-MACRO ...> , thus
;; may not be temporarily saved in a variable in interpreted Code.
;; the search routine uses EQ
(defun venv-assoc (s venv &optional (from-inside-macrolet nil))
  (if venv
    (if (simple-vector-p venv)
      #+COMPILER
      (do ((l (1- (length venv)))
           (i 0 (+ i 2)))
          ((= i l) (venv-assoc s (svref venv i) from-inside-macrolet))
        (if (eq s (svref venv i))
          (if (and from-inside-macrolet
                   (not (eq (svref venv (1+ i)) sys::specdecl))
                   (not (symbol-macro-p (svref venv (1+ i)))))
            (error-of-type 'source-program-error
              :form s
              :detail s
              (TEXT "Invalid access to the value of the lexical variable ~S from within a ~S definition")
              s 'macrolet)
            (return (svref venv (1+ i))))))
      #-COMPILER
      (let ((l (1- (length venv)))
            (i 0))
        (block nil
          (tagbody
            1 (if (= i l) (return-from nil (venv-assoc s (svref venv i) from-inside-macrolet)))
              (if (eq s (svref venv i))
                (if (and from-inside-macrolet
                         (not (symbol-macro-p (svref venv (1+ i)))))
                  (error-of-type 'source-program-error
                    :form s
                    :detail s
                    (TEXT "Invalid access to the value of the lexical variable ~S from within a ~S definition")
                    s 'macrolet)
                  (return-from nil (svref venv (1+ i)))))
              (setq i (+ i 2))
              (go 1))))
      (if (and (consp venv) (eq (car venv) 'MACROLET))
        (venv-assoc s (cdr venv) t)
        (error-of-type 'type-error
          :datum venv :expected-type '(or null simple-vector)
          (TEXT "~S is an invalid variable environment")
          venv)))
    ; not found
    (if (symbol-macro-expand s)
      (global-symbol-macro-definition (get s 'SYMBOLMACRO))
      (and (boundp s) (symbol-value s)))))

;; Most of the Expansion-functions return two values:
;;  (1) the expansion result,
;;  (2) (NIL or T) indicates, if something was changed within it.

(proclaim '(special %whole-form)) ; the whole form being expanded

;; (%expand-cons ...) composes a cons. returns 2 values.
;; form=old Form,
;; expf,flagf = expansion of the first-part,
;; expr,flagr = expansion of the rest-part.
(defun %expand-cons (form expf flagf expr flagr)
  (if (or flagf flagr)
    (values (cons expf expr) t)
    (values form nil)))

;; cons specs on top of *fenv*
(defun cons-*fenv* (specs) (apply #'vector (nreverse (cons *fenv* specs))))

(defun illegal-syntax (detail form-name &optional (whole-form %whole-form))
  (error-of-type 'source-program-error
    :form whole-form :detail detail
    (TEXT "Illegal syntax in ~A: ~S")
    form-name detail))

;; (%expand-form form) expands a whole Form. returns 2 values.
(defun %expand-form (form &aux (%whole-form form))
  (if (atom form)
    #+COMPILER
    (let (h)
      (if (and (symbolp form)
               (symbol-macro-p (setq h (venv-assoc form *venv*))))
        (values (%expand-form (sys::%record-ref h 0)) t)
        (values form nil)))
    #-COMPILER
    (if (and (symbolp form) (symbol-macro-p (venv-assoc form *venv*)))
      (values (%expand-form (sys::%record-ref (venv-assoc form *venv*) 0)) t)
      (values form nil))
    ;; form is a CONS
    (let ((f (first form)))
      (if (function-name-p f)
        (let ((h (fenv-assoc f *fenv*)))
          ;; f is in *fenv* associated to h
          (if (eq h 'T)
            ;; f has no local definition
            ;; Now the separate expanders for the special-forms:
            (case f
              ((RETURN-FROM THE) ; skip the 1st argument, expand the rest
               (multiple-value-call #'%expand-cons form
                  (first form) nil
                  (multiple-value-call #'%expand-cons (rest form)
                    (second form) nil
                    (%expand-list (cddr form)))))
              ((QUOTE GO DECLARE LOAD-TIME-VALUE) ; expand nothing
               (values form nil))
              ((FUNCTION)
               ;; if 1st or 2nd argument is a list,
               ;; expand as lambda expression.
               (multiple-value-call #'%expand-cons form
                 'FUNCTION nil
                 (if (atom (cddr form))
                   (if (function-name-p (second form))
                     (let ((h (fenv-assoc (second form) *fenv*)))
                       (cond ((or (eq h 'T) (closurep h)
                                  (function-macro-p h) (null h))
                              (values (rest form) nil))
                             ((macrop h)
                              (error-of-type 'source-program-error
                                :form form
                                :detail (second form)
                                (TEXT "~S: ~S is illegal since ~S is a local macro")
                                '%expand form (second form)))
                             (t (error-of-type 'error
                                  (TEXT "~S: invalid function environment ~S")
                                  '%expand *fenv*))))
                     (if (atom (second form))
                       (error-of-type 'source-program-error
                         :form form
                         :detail (second form)
                         (TEXT "~S: ~S is invalid since ~S is not a symbol")
                         '%expand form (second form))
                       (multiple-value-call #'%expand-cons (rest form)
                         (%expand-lambda (second form))
                         (cddr form) nil)))
                   (multiple-value-call #'%expand-cons (rest form)
                     (second form) nil
                     (multiple-value-call #'%expand-cons (cddr form)
                       (%expand-lambda (third form))
                       (cdddr form) nil)))))
              ((EVAL-WHEN)
               (let ((situations (second form)))
                 (if (or (member 'EVAL situations)
                         (member ':EXECUTE situations))
                   (multiple-value-call #'%expand-cons form
                     (first form) nil
                     (multiple-value-call #'%expand-cons (rest form)
                       (second form) nil
                       (%expand-list (cddr form))))
                   (values 'NIL t))))
              ((LET)            ; expand variable-list and body
               (let ((*venv* *venv*))
                 (%expand-special-declarations (cddr form))
                 (multiple-value-call #'%expand-cons form
                   (first form) nil
                   (multiple-value-call #'%expand-cons (rest form)
                     (%expand-varspez (second form))
                     (%expand-list (cddr form))))))
              ((LET*)           ; expand variable-list and body
               (let ((*venv* *venv*))
                 (%expand-special-declarations (cddr form))
                 (multiple-value-call #'%expand-cons form
                   (first form) nil
                   (multiple-value-call #'%expand-cons (rest form)
                     (%expand-varspez* (second form))
                     (%expand-list (cddr form))))))
              ((LOCALLY)        ; expand body
               (let ((*venv* *venv*))
                 (%expand-special-declarations (cdr form))
                 (multiple-value-call #'%expand-cons form
                   (first form) nil
                   (%expand-list (cdr form)))))
              ((MULTIPLE-VALUE-BIND) ; expand form and body, separately
               (let ((*venv* *venv*))
                 (%expand-special-declarations (cdddr form))
                 (multiple-value-call #'%expand-cons form
                   'MULTIPLE-VALUE-BIND nil
                   (multiple-value-call #'%expand-cons (rest form)
                     (second form) nil
                     (multiple-value-call #'%expand-cons (cddr form)
                       (%expand-form (third form))
                       (progn
                         (%expand-lexical-variables (second form))
                         (%expand-list (cdddr form))))))))
              ((COMPILER-LET) ; expand var-list in empty environment and body
               (progv
                   (mapcar #'%expand-varspec-var (second form))
                   (mapcar #'%expand-varspec-val (second form))
                 (values (%expand-form (cons 'PROGN (cddr form))) t)))
              ((COND) ; expand all Sub-Forms of the clauses:
               (multiple-value-call #'%expand-cons form
                 (first form) nil
                 (%expand-cond (rest form))))
              ((CASE) ; expand 1st argument and all sub-forms of the clauses
               (multiple-value-call #'%expand-cons form
                 (first form) nil
                 (multiple-value-call #'%expand-cons (rest form)
                   (%expand-form (second form))
                   (%expand-case (cddr form)))))
              ((BLOCK)
               ;; expand body. If there is a RETURN-FROM in this
               ;; block, keep BLOCK, else turn it into a PROGN.
               (multiple-value-bind (body flagb) (%expand-list (cddr form))
                 (if (%return-p (second form) body)
                   (multiple-value-call #'%expand-cons form
                     (first form) nil
                     (multiple-value-call #'%expand-cons (rest form)
                       (second form) nil
                       body flagb))
                    (values
                      (cond ((atom body) body)
                            ((null (cdr body)) (car body))
                            (t (cons 'progn body)))
                      t))))
              ((SETQ PSETQ) ; expand each second Argument
               (if (%expand-setqlist-macrop (rest form))
                 (let ((new (if (eq (first form) 'SETQ) 'SETF 'PSETF)))
                   (values
                    (%expand-form
                     (funcall (macro-function new) (cons new (rest form))
                              (vector *venv* *fenv*)))
                    t))
                 (multiple-value-call #'%expand-cons form
                   (first form) nil
                   (%expand-setqlist (rest form)))))
              ((MULTIPLE-VALUE-SETQ) ; skip 1st argument, expand the rest
               (if (%expand-varlist-macrop (second form))
                 (values (%expand-form (cons 'MULTIPLE-VALUE-SETF (rest form)))
                         t)
                 (multiple-value-call #'%expand-cons form
                   'MULTIPLE-VALUE-SETQ nil
                   (multiple-value-call #'%expand-cons (rest form)
                     (second form) nil
                     (%expand-list (cddr form))))))
              ((TAGBODY)
               ;; expand all arguments,
               ;; skip atoms that are created during expansion
               (multiple-value-call #'%expand-cons form
                 (first form) nil
                 (%expand-tagbody (rest form))))
              ((PROGN) ; expand all arguments, possibly simplify them.
               (if (null (rest form))
                 (values nil t)
                 (if (null (cddr form))
                   (values (%expand-form (second form)) t)
                   (multiple-value-call #'%expand-cons form
                     (first form) nil
                     (%expand-list (rest form))))))
              ((FLET) ; expand function definitions
               (if (null (second form))
                 (values (%expand-form (cons 'LOCALLY (cddr form))) t)
                 (let ((newfenv (%expand-fundefs-1 (second form)))
                       (*venv* *venv*))
                   (%expand-special-declarations (cddr form))
                   (multiple-value-call #'%expand-cons form
                     (first form) nil
                     (multiple-value-call #'%expand-cons (rest form)
                       (%expand-fundefs-2 (second form))
                       (let ((*fenv* (apply #'vector newfenv)))
                         (%expand-list (cddr form))))))))
              ((LABELS)
               ;; expand function definitions and body
               ;; in the extended environment
               (if (null (second form))
                 (values (%expand-form (cons 'LOCALLY (cddr form))) t)
                 (let ((newfenv (%expand-fundefs-1 (second form)))
                       (*venv* *venv*))
                   (%expand-special-declarations (cddr form))
                   (let ((*fenv* (apply #'vector newfenv)))
                     (multiple-value-call #'%expand-cons form
                       (first form) nil
                       (multiple-value-call #'%expand-cons (rest form)
                         (%expand-fundefs-2 (second form))
                         (%expand-list (cddr form))))))))
              ((MACROLET) ; expand the body in the extended environment
               (do ((L1 (second form) (cdr L1))
                    (L2 nil))
                   ((atom L1)
                    (if L1
                      (error-of-type 'source-program-error
                        :form form
                        :detail L1
                        (TEXT "code after MACROLET contains a dotted list, ending with ~S")
                        L1)
                      (let ((*fenv* (cons-*fenv* L2))
                            (*venv* *venv*))
                        (%expand-special-declarations (cddr form))
                        (values (%expand-form (cons 'PROGN (cddr form))) t))))
                 (let ((macrodef (car L1)))
                   (if (and (consp macrodef)
                            (symbolp (car macrodef))
                            (consp (cdr macrodef)))
                     (setq L2 (list* (make-macro-expander macrodef form)
                                     (car macrodef) L2))
                     (illegal-syntax macrodef 'MACROLET)))))
              ((FUNCTION-MACRO-LET)
               ;; expand function-definitions,
               ;; expand body in extended environment
               (if (null (second form))
                 (values (%expand-form (cons 'PROGN (cddr form))) t)
                 (let ((newfenv (%expand-funmacdefs-1 (second form))))
                   (multiple-value-call #'%expand-cons form
                     (first form) nil
                     (multiple-value-call #'%expand-cons (rest form)
                       (%expand-funmacdefs-2 (second form))
                       (let ((*fenv* (apply #'vector newfenv)))
                         (%expand-list (cddr form))))))))
              ((SYMBOL-MACROLET) ; expand body in extended environment
               (do ((L1 (second form) (cdr L1))
                    (L2 nil))
                   ((atom L1)
                    (if L1
                      (error-of-type 'source-program-error
                        :form form
                        :detail L1
                        (TEXT "code after SYMBOL-MACROLET contains a dotted list, ending with ~S")
                        L1)
                      (let ((*venv* (apply #'vector
                                           (nreverse (cons *venv* L2)))))
                        (let ((specials (%expand-special-declarations
                                         (cddr form))))
                          (do ((L3 (second form) (cdr L3)))
                              ((atom L3))
                            (if (memq (caar L3) specials)
                              (error-of-type 'source-program-error
                                :form form
                                :detail (caar L3)
                                (TEXT "~S: symbol ~S must not be declared SPECIAL and a macro at the same time")
                                'symbol-macrolet (caar L3)))))
                        (values (%expand-form (cons 'LOCALLY (cddr form)))
                                t))))
                 (let ((symdef (car L1)))
                   (if (and (consp symdef)
                            (symbolp (car symdef))
                            (consp (cdr symdef))
                            (null (cddr symdef)))
                     (let ((symbol (car symdef))
                           (expansion (cadr symdef)))
                       (if (special-variable-p symbol)
                         (error-of-type 'program-error
                           (TEXT "~S: symbol ~S is declared special and must not be declared a macro")
                           'symbol-macrolet symbol)
                         (setq L2 (list* (make-symbol-macro expansion)
                                         symbol L2))))
                     (illegal-syntax symdef 'SYMBOL-MACROLET)))))
              (t (cond ((and (symbolp f) (special-operator-p f))
                        ;; other Special-forms,
                        ;; e.g. IF, CATCH, THROW, PROGV, UNWIND-PROTECT, PROGN,
                        ;; PROG1, PROG2, WHEN, UNLESS, MULTIPLE-VALUE-LIST,
                        ;; MULTIPLE-VALUE-CALL, MULTIPLE-VALUE-PROG1, AND, OR:
                        (multiple-value-call #'%expand-cons form
                          f nil
                          (%expand-list (rest form))))
                       ((and (symbolp f) (setq h (macro-function f)))
                        ;; global Macro-Definition
                        (%expand-macro h form))
                       (t ; normal function-call
                        (multiple-value-call #'%expand-cons form
                          f nil
                          (%expand-list (rest form)))))))
            ;; f has a local definition
            (cond ((or (closurep h) (function-macro-p h) (null h))
                   ;; function to be called
                   (multiple-value-call #'%expand-cons form
                     f nil
                     (%expand-list (rest form))))
                  ((macrop h) ; macro to be expanded
                   (%expand-macro (macro-expander h) form)) ; call expander
                  (t (error-of-type 'error
                       (TEXT "bad function environment occurred in ~S: ~S")
                       '%expand-form *fenv*)))))
        (if (consp f)
          (multiple-value-call #'%expand-cons form
            (%expand-lambda f)
            (%expand-list (rest form)))
          (error-of-type 'source-program-error
            :form form
            :detail form
            (TEXT "~S: invalid form ~S")
            '%expand-form form))))))

;; Auxiliary functions for the the expansion:

;; call the macro-expander on the form (expanding after)
(defun %expand-macro (macro-expander form)
  (values (%expand-form (funcall macro-expander form (vector *venv* *fenv*)))
          t))

;; expands a list of forms. returns 2 values.
(defun %expand-list (l)
  (if (atom l)
    (if l
      (error-of-type 'source-program-error
        :form %whole-form
        :detail l
        (TEXT "code contains a dotted list, ending with ~S")
        l)
      (values nil nil))
    (multiple-value-call #'%expand-cons l
                         (%expand-form (first l))
                         (%expand-list (rest l)))))

;; Adds lexical variables to *venv* .
;; (only used for shadowing symbol-macros.)
(defun %expand-lexical-variables (vars)
  (if vars
    (setq *venv*
      (apply #'vector
        (nconc (mapcan #'(lambda (v) (declare (source nil)) (list v nil)) vars)
               (list *venv*))))))

;; Adds SPECIAL-Declarations at the beginning of a Body to *venv* .
(defun %expand-special-declarations (body)
  (multiple-value-bind (body-rest declarations) (sys::parse-body body)
    (declare (ignore body-rest)) ; do not throw away declarations!
    (let ((specials nil))
      (mapc #'(lambda (declspec)
                (declare (source nil))
                (if (and (consp declspec) (null (cdr (last declspec))))
                  (if (eq (car declspec) 'SPECIAL)
                    (mapc #'(lambda (x)
                              (declare (source nil))
                              (if (symbolp x)
                                (setq specials (cons x specials))))
                          (cdr declspec)))))
            (nreverse declarations))
      (setq specials (nreverse specials))
      (%expand-lexical-variables specials) ; specdecl doesn't matter here
      specials)))

;; expands a function-name, that is a Cons (that must be a
;; Lambda-Expression). returns 2 values.
(defun %expand-lambda (l)
  (unless (eq (first l) 'lambda)
    (error-of-type 'source-program-error
      :form %whole-form
      :detail l
      (TEXT "~S: ~S should be a lambda expression")
      '%expand-form l))
  (multiple-value-call #'%expand-cons l
      'lambda nil ; LAMBDA
      (%expand-lambdabody (rest l))))

;; expands the CDR of a Lambda-Expression, a (lambdalist . body).
;; returns 2 values.
(defun %expand-lambdabody (lambdabody &optional name blockp)
  (let ((body (rest lambdabody)))
    (if (and (consp body)
             (let ((form (car body)))
               (and (consp form)
                    (eq (car form) 'DECLARE)
                    (let ((declspecs (cdr form)))
                      (and (consp declspecs)
                           (let ((declspec (car declspecs)))
                             (and (consp declspec)
                                  (eq (car declspec) 'SOURCE))))))))
      (values lambdabody nil) ; already expanded -> leave untouched
      (let ((*venv* *venv*))
        (if blockp (setq lambdabody (add-implicit-block name lambdabody)))
        (values (list* (%expand-lambdalist (first lambdabody))
                       (list 'DECLARE (list 'SOURCE lambdabody))
                       (%expand-list (rest lambdabody)))
                t)))))

;; expands a Lambda-list. returns 2 values.
(defun %expand-lambdalist (ll)
  (if (atom ll)
    (if ll
      (error-of-type 'source-program-error
        :form %whole-form
        :detail ll
        (TEXT "lambda list must not end with the atom ~S")
        ll)
      (values nil nil))
    (multiple-value-call #'%expand-cons ll
        (%expand-parspez (first ll))
        (progn
          (let ((v (first ll)))
            (if (not (memq v lambda-list-keywords))
              (setq *venv* (vector (%expand-varspec-var v) nil *venv*))))
          (%expand-lambdalist (rest ll))))))

;; expands an element of a lambda-list. returns 2 values.
;; (expands only on lists, and then only the second element.)
(defun %expand-parspez (ps)
  (if (or (atom ps) (atom (rest ps)))
    (values ps nil)
    (multiple-value-call #'%expand-cons ps
        (first ps) nil
        (multiple-value-call #'%expand-cons (rest ps)
            (%expand-form (second ps))
            (cddr ps) nil))))

;; expand a Variable-list for LET. returns 2 values.
(defun %expand-varspez (vs &optional (nvenv nil))
  (if (atom vs)
    (if vs
      (error-of-type 'source-program-error
        :form %whole-form
        :detail vs
        (TEXT "~S: variable list ends with the atom ~S")
        'let vs)
      (progn
        (setq *venv* (apply #'vector (nreverse (cons *venv* nvenv))))
        (values nil nil)))
    (multiple-value-call #'%expand-cons vs
        (%expand-parspez (first vs)) ; For List: Expand 2nd Element
        (%expand-varspez (rest vs) (list* nil (%expand-varspec-var (first vs))
                                          nvenv)))))

;; expands a Variable-list for LET*. returns 2 values.
(defun %expand-varspez* (vs)
  (if (atom vs)
    (if vs
      (error-of-type 'source-program-error
        :form %whole-form
        :detail vs
        (TEXT "~S: variable list ends with the atom ~S")
        'let* vs)
      (values nil nil))
    (multiple-value-call #'%expand-cons vs
        (%expand-parspez (first vs)) ; for list: expand 2nd Element
        (progn
          (setq *venv* (vector (%expand-varspec-var (first vs)) nil *venv*))
          (%expand-varspez* (rest vs))))))

(defun %expand-varspec-var (varspec)
  (if (atom varspec) varspec (first varspec)))

(defun %expand-varspec-val (varspec)
  (if (atom varspec) nil (eval (second varspec))))

;; expands a cond-clause-list. returns 2 values.
(defun %expand-cond (clauses)
  (if (atom clauses)
    (values clauses nil)
    (multiple-value-call #'%expand-cons clauses
        (%expand-list (first clauses))
        (%expand-cond (rest clauses)))))

;; expands a case-clause-list. returns 2 values.
(defun %expand-case (clauses)
  (if (atom clauses)
    (values clauses nil)
    (multiple-value-call #'%expand-cons clauses
      (multiple-value-call #'%expand-cons (first clauses)
        (caar clauses) nil
        (%expand-list (cdar clauses)))
      (%expand-case (rest clauses)))))

;; Apply the following to the already expanded body:
;; (%return-p name list) determines, if the form-list list contains
;; a (RETURN-FROM name ...) somewhere.
(defun %return-p (name body)
  (block return-p
    (tagbody 1
      (if (atom body) (return-from return-p nil))
      (let ((form (car body)))
        (if ; determine, if form contains a (RETURN-FROM name ...) :
         (and (consp form)
              (not (eq (first form) 'quote))
              (or (and (eq (first form) 'return-from) ; (RETURN-FROM name ...)
                       (eq (second form) name))
                  (and (consp (first form))           ; lambda-list
                       (%return-p name (first form)))
                  (and (not ; no new definition of the same block ?
                        (and (eq (first form) 'block) (eq (second form) name)))
                       (%return-p name (rest form))))) ; function call
         (return-from return-p t)))
       (setq body (cdr body))
       (go 1))))

(defun %expand-varlist-macrop (l)
  (and (consp l)
       (or (and (symbolp (car l)) (symbol-macro-p (venv-assoc (car l) *venv*)))
           (%expand-varlist-macrop (cdr l)))))

(defun %expand-setqlist-macrop (l)
  (and (consp l) (consp (cdr l))
       (or (and (symbolp (car l)) (symbol-macro-p (venv-assoc (car l) *venv*)))
           (%expand-setqlist-macrop (cddr l)))))

(defun %expand-setqlist (l)
  (if (or (atom l) (atom (cdr l)))
    (values l nil)
    (multiple-value-call #'%expand-cons l
        (first l) nil
        (multiple-value-call #'%expand-cons (rest l)
            (%expand-form (second l))
            (%expand-setqlist (cddr l))))))

;; (%expand-tagbody list) expands the elements of a list
;; and leaves atoms, that are created meanwhile, untouched.
;; (thus no new tags are created that could hide other tags).
;; returns 2 values.
(defun %expand-tagbody (body)
  (cond ((atom body) (values body nil))
        ((atom (first body))
         (multiple-value-call #'%expand-cons body
             (first body) nil
             (%expand-tagbody (rest body))))
        (t (multiple-value-bind (exp flag) (%expand-form (first body))
             (if (atom exp)
               (values (%expand-tagbody (rest body)) t) ; omit
               (multiple-value-call #'%expand-cons body
                   exp flag
                   (%expand-tagbody (rest body))))))))
;; returns a list (name1 nil ... namek nil *fenv*)
(defun %expand-fundefs-1 (fundefs)
  (if (atom fundefs)
    (if fundefs
      (error-of-type 'source-program-error
        :form %whole-form
        :detail fundefs
        (TEXT "FLET/LABELS: code contains a dotted list, ending with ~S")
        fundefs)
      (list *fenv*))
    (let ((fundef (car fundefs)))
      (if (and (consp fundef) (function-name-p (car fundef))
               (consp (cdr fundef)))
        (list* (car fundef) nil (%expand-fundefs-1 (cdr fundefs)))
        (illegal-syntax fundef "FLET/LABELS")))))
;; (%expand-fundefs-2 fundefs) expands a function-definition-list,
;; like in FLET, LABELS. returns 2 values.
(defun %expand-fundefs-2 (fundefs)
  (if (atom fundefs)
    (values fundefs nil)
    (let ((fundef (car fundefs)))
      (multiple-value-call #'%expand-cons fundefs
             (multiple-value-call #'%expand-cons fundef
                     (car fundef) nil
                     (%expand-lambdabody (cdr fundef) (car fundef) t))
             (%expand-fundefs-2 (rest fundefs))))))
;; returns a list (name1 nil ... namek nil *fenv*)
(defun %expand-funmacdefs-1 (funmacdefs)
  (if (atom funmacdefs)
    (if funmacdefs
      (error-of-type 'source-program-error
        :form %whole-form
        :detail funmacdefs
        (TEXT "FUNCTION-MACRO-LET: code contains a dotted list, ending with ~S")
        funmacdefs)
      (list *fenv*))
    (let ((funmacdef (car funmacdefs)))
      (if (and (consp funmacdef)
               (symbolp (car funmacdef))
               (consp (cdr funmacdef)) (consp (second funmacdef))
               (consp (cddr funmacdef)) (consp (third funmacdef))
               (null (cdddr funmacdef)))
        (list* (car funmacdef) nil (%expand-funmacdefs-1 (cdr funmacdefs)))
        (illegal-syntax funmacdef 'FUNCTION-MACRO-LET)))))
;; (%expand-funmacdefs-2 funmacdefs) expands a function-macro-
;; definition-list, like in FUNCTION-MACRO-LET. returns 2 values.
(defun %expand-funmacdefs-2 (funmacdefs)
  (if (atom funmacdefs)
    (values funmacdefs nil)
    (let ((funmacdef (car funmacdefs)))
      (multiple-value-call #'%expand-cons funmacdefs
        (multiple-value-call #'%expand-cons funmacdef
          (car funmacdef) nil
          (multiple-value-call #'%expand-cons (cdr funmacdef)
            (%expand-lambdabody (cadr funmacdef))
            (multiple-value-call #'%expand-cons (cddr funmacdef)
              (let ((*venv* nil) (*fenv* nil))
                (%expand-lambdabody (caddr funmacdef)))
              (cdddr funmacdef) nil)))
        (%expand-funmacdefs-2 (rest funmacdefs))))))
;; expands (lambdalist . body) in a given function-environment.
;; Is called by GET_CLOSURE.
(defun %expand-lambdabody-main (lambdabody *venv* *fenv*)
  (%expand-lambdabody lambdabody))

(VALUES) )

;; from now on, FUNCTION is operational,
;; as long as no MACROLET occurs within it.

(PROGN

(proclaim '(special *load-paths*)) ; defined in spvw.d
(proclaim '(special *source-file-types*))
(setq *source-file-types* '("lisp" "lsp" "cl"))
(proclaim '(special *internal-compiled-file-type*))
(setq *internal-compiled-file-type* "fas")
(proclaim '(special *compiled-file-types*))
(setq *compiled-file-types* (list *internal-compiled-file-type*))

;; for the time being the files don't have to be searched:
(sys::%set-symbol-function 'search-file
 (sys::make-preliminary
  (function search-file (lambda (filename &optional extensions (keep-dirs t))
    (declare (ignore keep-dirs))
    (mapcan #'(lambda (directory)
                (let ((directory (pathname-directory directory)))
                  (mapcan #'(lambda (extension)
                              (let ((filename (merge-pathnames filename
                                                (make-pathname
                                                 :directory directory
                                                 :type extension))))
                                (if (probe-file filename) (list filename) '())))
                          extensions)))
            (cons #"" *load-paths*))))))

(proclaim '(special *compile-verbose*))
(setq *compile-verbose* t)      ; defined in spvw.d
(proclaim '(special *load-verbose*))
(setq *load-verbose* t)         ; defined in spvw.d
(proclaim '(special *load-print*))
(setq *load-print* nil)         ; defined in spvw.d
(proclaim '(special *load-echo*))
(setq *load-echo* nil)          ; defined in spvw.d
(proclaim '(special *load-compiling*))
(setq *load-compiling* nil)     ; defined in spvw.d
(proclaim '(special *load-pathname*))
(setq *load-pathname* nil)
(proclaim '(special *load-input-stream*))
(setq *load-input-stream* nil)
(proclaim '(special *load-level*))
(setq *load-level* 0)
(proclaim '(special *load-obsolete-action*))
(setq *load-obsolete-action* nil)
#+ffi ; the default :language for DEF-CALL-* & C-FUNCTION -- see foreign1.lisp
(proclaim '(special ffi::*foreign-language*))
#+ffi (setq ffi::*foreign-language* nil)
#+ffi ; default :LIBRARY argument for DEF-CALL-OUT and DEF-C-VAR
(proclaim '(special ffi::*foreign-library*))
#+ffi (setq ffi::*foreign-library* nil)

;; preliminary; needed here for open-for-load
(sys::%set-symbol-function 'warn
  (sys::make-preliminary
    (function warn (lambda (format-string &rest args)
      (fresh-line *error-output*)
      (write-string (TEXT "WARNING:") *error-output*)
      (terpri *error-output*)
      (apply #'format *error-output* format-string args)
      (elastic-newline *error-output*)
      nil))))

;; preliminary definition of warn-of-type for CLOS before CLCS
(sys::%set-symbol-function 'warn-of-type
  (sys::make-preliminary
   (function warn-of-type (lambda (type format-string &rest args)
     (declare (ignore type))
     (apply #'warn format-string args)))))

(unless (fboundp 'ext::muffle-cerrors) ; predef for bootstrap
  (sys::%set-symbol-function 'ext::muffle-cerrors #'identity))

(defun open-for-load (filename extra-file-types external-format
                      ignore-pathname-defaults
                      &aux stream (present-files t) obj path bad-file)
 (block open-for-load
  (when (and (streamp filename)
             (open-stream-p filename)
             (input-stream-p filename))
    (return-from open-for-load (values filename filename)))
  (labels ((compiledp (name)
             (member (pathname-type name) *compiled-file-types*
                     :test #'string=))
           (my-open (name)
             (open name :direction :input-immutable :element-type 'character
                   #+UNICODE :external-format
                   #+UNICODE (if (compiledp name)
                                 charset:utf-8
                                 external-format)
                   :if-does-not-exist nil))
           (bad (error-p stream message)
             (sys::built-in-stream-close stream)
             (when (eq *load-obsolete-action* :delete) (delete-file stream))
             (setq bad-file (pathname stream))
             (if error-p
                 (error-of-type 'file-error :pathname (pathname stream)
                                message 'load (pathname stream))
                 (warn message 'load (pathname stream))))
           (check-compiled-file (stream last-p obj)
             (and (or (and (consp obj) (eq (car obj) 'system::version))
                      (bad last-p stream (TEXT "~S: compiled file ~A lacks a version marker")))
                  (or (= 2 (length obj))
                      (bad last-p stream (TEXT "~S: compiled file ~A has a corrupt version marker ~S")))
                  (or (equal (system::version) (eval (second obj)))
                      (bad last-p stream (TEXT "~S: compiled file ~A was created by an older CLISP version and needs to be recompiled"))))))
    (setq filename (if ignore-pathname-defaults
                       (pathname filename) (merge-pathnames filename))
          path filename)
    ;; (OPEN "foo") errors out if we do (LOAD "foo")
    ;; and both "foo.lisp" and "foo/" are present
    (let ((truename? (probe-pathname path)))
      (unless (and truename? (null (pathname-name truename?)))
        (setq stream (my-open path))))
    (tagbody proceed
      (when (and stream
                 (if (compiledp stream)
                   (check-compiled-file
                     stream
                     (or (eq *load-obsolete-action* :error)
                         (eq present-files t)
                         (cdr present-files))
                     (setq obj
                           #+compiler ; normal operation; handler-bind works
                           (block nil
                             (handler-bind ((error (lambda (c) (return c))))
                               (read stream)))
                           #-compiler (read stream))) ; bootstrap
                   #+compiler
                   (if (and bad-file (eq *load-obsolete-action* :compile))
                     ;; assume that BAD-FILE was compiled from STREAM
                     (let ((compiled-file ; try to compile
                            (compile-file stream :output-file bad-file)))
                       (if compiled-file ; ==> compiled-file == bad-file
                         (progn
                           (sys::built-in-stream-close stream)
                           (setq stream (my-open compiled-file)
                                 path compiled-file))
                         ;; compilation failed - try to load the source
                         stream))
                     stream)
                   #-compiler stream))
        (return-from open-for-load (values stream path)))
      (when (eq present-files t)
        ;; File with precisely this name not present OR bad
        ;; Search among the files the most recent one
        ;; with the same name and the Extensions "LISP", "FAS":
        (setq present-files
              (ext::muffle-cerrors ; ignore encoding errors in DIRECTORY
               (search-file filename (append extra-file-types
                                             *compiled-file-types*
                                             *source-file-types*)
                            nil))))
      (if present-files
        ;; proceed with the next present file
        (setq path (car present-files) present-files (cdr present-files)
              stream (my-open path))
        (if stream
          ;; bad compiled STREAM, nowhere else to look ==> die
          (check-compiled-file stream t obj)
          ;; no file - return NIL
          (return-from open-for-load (values nil filename))))
      (go proceed)))))

;; in theory this is a good idea:
;;   (proclaim '(inline eval-loaded-form-low))
;; unfortunately, when condition.lisp is compiled,
;; this function is not necessarily already compiled
;; due to our bootstrapping process,
;; so it will not be inlined there (in eval-loaded-form),
;; therefore the "test" target (self-recompilation) will fail
(defun eval-loaded-form-low (obj)
  (multiple-value-list
   (cond ((compiled-function-p obj)
          ;; assume that this is a top-level form compiled by COMPILE-FILE
          ;; then its name starts with the source file line numbers --
          ;; extract them and put into *current-source-line-[12]*
          (let ((name (and (closurep obj) (symbol-name (closure-name obj)))))
            (multiple-value-bind (l1 pos) (parse-integer name :junk-allowed t)
              (when l1
                (let ((l2 (parse-integer name :junk-allowed t :start pos)))
                  (when l2
                    (setq *current-source-line-1* l1
                          *current-source-line-2* l2))))))
          (funcall obj))
         (*load-compiling* (funcall (compile-form-in-toplevel-environment obj)))
         (t (eval obj)))))

;; redefined in condition.lisp
(proclaim '(notinline eval-loaded-form))
(sys::%set-symbol-function 'eval-loaded-form
  (sys::make-preliminary
    (function eval-loaded-form (lambda (obj file)
      (declare (ignore file))
      (eval-loaded-form-low obj)))))

(defun loading-message (format &rest arguments)
  (when *load-verbose*
    (fresh-line)
    (write-string ";;")
    (write-spaces *load-level*)
    (apply #'format t format arguments)
    (elastic-newline)))

;; (LOAD filename [:verbose] [:print] [:if-does-not-exist] [:external-format]
;;                [:echo] [:compiling] [:extra-file-types] [:obsolete-action]),
;; CLTL p. 426
(defun load (filename
             &key ((:verbose *load-verbose*) *load-verbose*)
                  ((:print *load-print*) *load-print*)
                  (if-does-not-exist t) (external-format ':default)
                  ((:echo *load-echo*) *load-echo*)
                  ((:compiling *load-compiling*) *load-compiling* c-top)
                  ((:obsolete-action *load-obsolete-action*)
                   *load-obsolete-action*)
                  (extra-file-types '())
                  (ignore-pathname-defaults nil)
             &aux stream)
  (multiple-value-setq (stream filename)
    (open-for-load filename extra-file-types external-format
                   ignore-pathname-defaults))
  (if (null stream)
    (if if-does-not-exist
      (error-of-type 'file-error
        :pathname filename
        (TEXT "~S: A file with name ~A does not exist")
        'load filename)
      nil)
    (let* ((input-stream
             (if *load-echo*
               (make-echo-stream stream *standard-output*)
               stream))
           (*load-level* (1+ *load-level*))
           (*load-input-stream* input-stream)
           (*load-pathname*
            (if (pathnamep filename) filename nil))
           (*load-truename*
             (if (pathnamep filename) (truename filename) nil))
           (*current-source-file* *load-truename*)
           (*current-source-line-1* nil)
           (*current-source-line-2* nil)
           #+ffi (ffi::*foreign-language* ffi::*foreign-language*)
           #+ffi (ffi::*foreign-library* ffi::*foreign-library*)
           (*package* *package*) ; bind *PACKAGE*
           (*readtable* *readtable*) ; bind *READTABLE*
           (*c-error-output* *error-output*) ; for compiling
           (eof-indicator input-stream))
      (loading-message (TEXT "Loading file ~A ...") filename)
      (when *load-compiling* (sys::c-reset-globals))
      ;; see `with-compilation-unit' -- `:compiling' sets a compilation unit
      ;; the user might set `*load-compiling*' to T either directly
      ;; or using the -C option, so we have to check that
      ;; `*error-output*' et al are already bound
      (progv (when (and *load-compiling*
                        (or c-top (not (boundp '*error-count*))))
               '(*error-count* *warning-count* *style-warning-count*))
             '(0 0 0)
        (unwind-protect
            (tagbody proceed
              (when *load-echo* (fresh-line))
              (peek-char t input-stream nil eof-indicator)
              (setq *current-source-line-1* (line-number input-stream))
              (let ((obj (read input-stream nil eof-indicator)) res)
                (setq *current-source-line-2* (line-number input-stream))
                (when (eql obj eof-indicator) (go done))
                (tagbody ext::retry ; exported in condition.lisp
                  (case (setq res (eval-loaded-form obj *load-truename*))
                    (skip (go proceed))
                    (ext::retry (go ext::retry))
                    (stop (go done))))
                (when *load-print*
                  (when res
                    (fresh-line)
                    (prin1 (first res))
                    (elastic-newline))))
              (go proceed) done)
          (or (eq input-stream stream)
              (sys::built-in-stream-close input-stream))
          (or (eq stream filename)
              (sys::built-in-stream-close stream))
          (when (and *load-compiling* *load-verbose* *compile-verbose*)
            (c-report-problems))))
      (loading-message (TEXT "Loaded file ~A") filename)
      ;; filename could be a non-file stream, so (truename filename) is unsafe
      (or *load-truename* filename))))
(let ((sys::*current-source-file* "init"))
  (sys::check-redefinition 'load 'defun nil))

(sys::%set-symbol-function 'defun              ; preliminary:
  (sys::make-macro
    (function defun (lambda (form env)
      (declare (ignore env))
      (unless (and (consp (cdr form)) (consp (cddr form)))
        (error-of-type 'source-program-error
          :form form
          :detail form
          (TEXT "~S: missing function name and/or parameter list")
          'defun))
      (let ((name (cadr form))
            (lambdalist (caddr form))
            (body (cdddr form)))
        (setq name (check-symbol name 'defun))
        (when (special-operator-p name)
          (error-of-type 'source-program-error
            :form form
            :detail name
            (TEXT "~S: special operator ~S cannot be redefined.")
            'defun name))
        (multiple-value-bind (body-rest declarations) (sys::parse-body body t)
          #| `(PROGN
               (SYS::%PUT ',name 'SYS::DEFINITION
                 (CONS ',form (THE-ENVIRONMENT)))
               (SYS::%SET-SYMBOL-FUNCTION ',name
                 (FUNCTION ,name
                   (LAMBDA ,lambdalist
                     (DECLARE (SYS::IN-DEFUN ,name) ,@declarations)
                     (BLOCK ,name ,@body-rest))))
               ',name) |#
          (list 'progn
                (list 'sys::%put (list 'quote name) ''sys::definition
                      (list 'cons (list 'quote form) '(the-environment)))
                (list 'sys::%set-symbol-function (list 'quote name)
                      (list 'FUNCTION name
                            (list 'LAMBDA lambdalist
                                  (list* 'DECLARE (list 'SYS::IN-DEFUN name)
                                         declarations)
                                  (list* 'BLOCK name body-rest))))
                (list 'quote name))))))
    '(function-name lambda-list &body forms)))

(sys::%set-symbol-function 'do               ; preliminary definition of the macro DO
  (sys::make-macro
    (function do (lambda (form env)
      (declare (ignore env))
      (let ((varclauselist (second form))
            (exitclause (third form))
            (body (cdddr form)))
        (when (atom exitclause)
          (error-of-type 'source-program-error
            :form form
            :detail exitclause
            (TEXT "exit clause in ~S must be a list")
            'do))
        (let ((bindlist nil)
              (reinitlist nil)
              (bodytag (gensym))
              (exittag (gensym)))
          (multiple-value-bind (body-rest declarations) (sys::parse-body body)
            (block do
              (tagbody 1
                (when (atom varclauselist)
                  (return-from do
                    #| `(block nil
                         (let ,(nreverse bindlist)
                           (declare ,@declarations)
                           (tagbody
                             (go ,exittag)
                             ,bodytag
                             ,@body-rest
                             (psetq ,@(nreverse reinitlist))
                             ,exittag
                             (or ,(first exitclause) (go ,bodytag))
                             (return-from nil (progn ,@(rest exitclause))))))
                    |#
                    (list 'block 'nil
                      (list 'let (nreverse bindlist)
                        (cons 'declare declarations)
                        (list* 'tagbody
                          (list 'go exittag)
                          bodytag
                          (append body-rest
                            (list
                              (cons 'psetq (nreverse reinitlist))
                              exittag
                              (list 'or (first exitclause) (list 'go bodytag))
                              (list 'return-from 'nil
                                (cons 'progn (rest exitclause))))))))))
                (let ((varclause (first varclauselist)))
                  (setq varclauselist (rest varclauselist))
                  (cond ((atom varclause)
                         (setq bindlist
                               (cons varclause bindlist)))
                        ((atom (cdr varclause))
                         (setq bindlist
                               (cons (first varclause) bindlist)))
                        ((atom (cddr varclause))
                         (setq bindlist
                               (cons varclause bindlist)))
                        (t (setq bindlist
                                 (cons (list (first varclause)
                                             (second varclause))
                                       bindlist))
                           (setq reinitlist
                                 (list* (third varclause)
                                        (first varclause)
                                        reinitlist)))))
                (go 1))))))))
    '((&body var-init-step-forms)
      (end-test-form &body result-forms)
      &body statements)))

(sys::%set-symbol-function 'dotimes       ; preliminary Definition of the Macro DOTIMES
  (sys::make-macro
    (function dotimes (lambda (form env)
      (declare (ignore env))
      (let ((var (first (second form)))
            (countform (second (second form)))
            (resultform (third (second form)))
            (body (cddr form)))
        (multiple-value-bind (body-rest declarations) (sys::parse-body body)
          (let ((g (gensym)))
            #| `(DO ((,var 0 (1+ ,var))
                     (,g ,countform))
                    ((>= ,var ,g) ,resultform)
                  (declare ,@declarations)
                  ,@body-rest) |#
            (list* 'do (list (list var '0 (list '1+ var)) (list g countform))
                   (list (list '>= var g) resultform)
                   (cons 'declare declarations)
                   body-rest))))))
    '((var count-form &optional result-form) &body statements)))

(VALUES) )

;; from now on LOAD, DEFUN, DO, DOTIMES are operational (with limitations) .

(LOAD "defseq")                 ; Definitions of Standard-Sequences

(LOAD "backquote")              ; backquote readmacro

;; from now on Backquote is operational

(LOAD "defmacro")

;; from now on FUNCTION is operational (without limitations).

(PROGN

(sys::%set-symbol-function 'sys::maybe-arglist ; arglist if permitted by compiler optimizations
  (function sys::maybe-arglist (lambda (arglist)
    (if (and sys::*compiling* (< 2 (sys::declared-optimize 'space)))
        0 arglist))))

(sys::%set-symbol-function 'defmacro
(sys::%set-symbol-function 'sys::predefmacro ; predefmacro means "preliminary defmacro"
  (sys::make-macro
    (function defmacro (lambda (form env)
      (declare (ignore env))
      (let ((preliminaryp (eq (car form) 'sys::predefmacro)))
        (multiple-value-bind
              (expansion expansion-lambdabody name lambdalist docstring)
            (sys::make-macro-expansion (cdr form) form)
          (declare (ignore expansion-lambdabody docstring))
          `(LET ()
             (EVAL-WHEN ,(if preliminaryp '(LOAD EVAL) '(COMPILE LOAD EVAL))
               (SYSTEM::REMOVE-OLD-DEFINITIONS ',name
                 ,@(if preliminaryp '('T)))
               (SYSTEM::%SET-SYMBOL-FUNCTION ',name
                 (SYSTEM::MAKE-MACRO
                  ,(if preliminaryp
                       `(SYSTEM::MAKE-PRELIMINARY ,expansion)
                       expansion)
                  ',(sys::maybe-arglist lambdalist))))
             (EVAL-WHEN (EVAL)
               (SYSTEM::%PUT ',name 'SYSTEM::DEFINITION
                             (CONS ',form (THE-ENVIRONMENT))))
             ',name)))))
    '(macro-name macro-lambda-list &body forms))))
(let ((sys::*current-source-file* "init"))
  (sys::check-redefinition 'defmacro 'defmacro nil))

#-compiler
(predefmacro SYS::EVAL-WHEN-COMPILE (&body body) ; preliminary
  `(eval-when (compile) ,@body))

;; return 2 values: ordinary lambda list and reversed list of type declarations
(sys::%set-symbol-function 'sys::specialized-lambda-list-to-ordinary
  (function sys::specialized-lambda-list-to-ordinary (lambda (spelalist caller)
    (multiple-value-bind (lalist speclist)
        #+clos (clos::decompose-specialized-lambda-list
                spelalist (clos::program-error-reporter caller))
        #-clos (copy-list spelalist) ; pacify "make check-recompile"
      (values
        lalist ; MAPCAN needs a LAMBDA which leads to infinite recursion
        (let ((decls '()))
          (block spelalist-to-ordinary
            (tagbody start
              (when (null lalist) (return-from spelalist-to-ordinary decls))
              (when (null speclist) (return-from spelalist-to-ordinary decls))
              (let ((arg (car lalist)) (spec (car speclist)))
                (if (not (eq spec 'T))
                  (setq decls (cons (list spec arg) decls))))
              (setq lalist (cdr lalist) speclist (cdr speclist))
              (go start)))))))))

(sys::%set-symbol-function 'defun
(sys::%set-symbol-function 'sys::predefun ; predefun means "preliminary defun"
  (sys::make-macro
    (function defun (lambda (form env)
      (if (atom (cdr form))
        (error-of-type 'source-program-error
          :form form
          :detail (cdr form)
          (TEXT "~S: cannot define a function from that: ~S")
          (car form) (cdr form)))
      (unless (function-name-p (cadr form))
        (error-of-type 'source-program-error
          :form form
          :detail (cadr form)
          (TEXT "~S: the name of a function must be a symbol, not ~S")
          (car form) (cadr form)))
      (if (atom (cddr form))
        (error-of-type 'source-program-error
          :form form
          :detail (cddr form)
          (TEXT "~S: function ~S is missing a lambda list")
          (car form) (cadr form)))
      (let ((preliminaryp (eq (car form) 'sys::predefun))
            (name (cadr form))
            (lambdalist (caddr form))
            (body (cdddr form)))
        (multiple-value-bind (body-rest declarations docstring)
            (sys::parse-body body t)
          (when *defun-accept-specialized-lambda-list*
            (multiple-value-bind (lalist decl-list)
                (sys::specialized-lambda-list-to-ordinary lambdalist (car form))
              (setq lambdalist lalist
                    declarations (nreconc decl-list declarations))))
          (let ((symbolform
                 (if (atom name)
                   `',name
                   `(LOAD-TIME-VALUE (GET-SETF-SYMBOL ',(second name)))))
                (lambdabody `(,lambdalist
                              ,@(if docstring `(,docstring) '())
                              (DECLARE (SYS::IN-DEFUN ,name) ,@declarations)
                              (BLOCK ,(function-block-name name)
                                ,@body-rest))))
            `(LET ()
               (SYSTEM::REMOVE-OLD-DEFINITIONS ,symbolform
                 ,@(if preliminaryp '('T)))
               ,@(if ; Is name declared inline?
                  (if (and sys::*compiling*
                           sys::*compiling-from-file*)
                    (member name sys::*inline-functions* :test #'equal)
                    (eq (get (get-funname-symbol name) 'inlinable) 'inline))
                  ;; Is the lexical environment the top-level environment?
                  ;; If yes, save the lambdabody for inline compilation.
                  (if sys::*compiling*
                    (if (and (null sys::*venv*)
                             (null sys::*fenv*)
                             (null sys::*benv*)
                             (null sys::*genv*)
                             (eql sys::*denv* *toplevel-denv*))
                      `((SYS::EVAL-WHEN-COMPILE
                         (SYS::C-DEFUN
                          ',name (lambda-list-to-signature ',lambdalist)
                          ',lambdabody))
                        (EVAL-WHEN (LOAD)
                          (SYSTEM::%PUT ,symbolform 'SYSTEM::INLINE-EXPANSION
                                        ',lambdabody)))
                      `((SYS::EVAL-WHEN-COMPILE
                         (SYS::C-DEFUN
                          ',name (lambda-list-to-signature ',lambdalist)))))
                    (if (and (null (svref env 0))  ; venv
                             (null (svref env 1))) ; fenv
                       `((EVAL-WHEN (EVAL)
                           (LET ((%ENV (THE-ENVIRONMENT)))
                             (IF (AND (NULL (SVREF %ENV 0)) ; venv
                                      (NULL (SVREF %ENV 1)) ; fenv
                                      (NULL (SVREF %ENV 2)) ; benv
                                      (NULL (SVREF %ENV 3)) ; genv
                                      (EQL (SVREF %ENV 4) *TOPLEVEL-DENV*)) ; denv
                               (SYSTEM::%PUT ,symbolform
                                             'SYSTEM::INLINE-EXPANSION
                                             ',lambdabody)))))
                       '()))
                  `((SYS::EVAL-WHEN-COMPILE
                     (SYS::C-DEFUN
                      ',name (lambda-list-to-signature ',lambdalist)))))
               (SYSTEM::%SET-SYMBOL-FUNCTION ,symbolform
                 ,(if preliminaryp
                    `(SYSTEM::MAKE-PRELIMINARY (FUNCTION ,name (LAMBDA ,@lambdabody)))
                    `(FUNCTION ,name (LAMBDA ,@lambdabody))))
               (EVAL-WHEN (EVAL)
                 (SYSTEM::%PUT ,symbolform 'SYSTEM::DEFINITION
                               (CONS ',form (THE-ENVIRONMENT))))
               ',name))))))
    '(function-name lambda-list &body forms))))
(let ((sys::*current-source-file* "init"))
  (sys::check-redefinition 'defun 'defmacro nil))

;; see condition.lisp for the final definition
(predefun check-not-declaration (symbol caller) (check-symbol symbol caller))

(VALUES) )

;; from now on DEFMACRO and DEFUN are operational.
(in-package "SYSTEM")

(LOAD "macros1")                ; control-structure - macros
(LOAD "macros2")                ; further macros

(LOAD "defs1")      ; definitions for symbols, numbers, characters, time
#-(or UNIX WIN32)
(LOAD "timezone")               ; Definition of the time zone

(LOAD "lambdalist")             ; parsing ordinary lambda lists

(LOAD "places")                 ; SETF-places: definitions and macros

;; from now on SETF etc. are working.

(LOAD "floatprint")             ; output of floating-points

(LOAD "defpackage")             ; DEFPACKAGE

(LOAD "type")                   ; TYPEP

(LOAD "clos-package")           ; Early CLOS
(LOAD "clos-macros")
(LOAD "clos-class0")
(LOAD "clos-metaobject1")
(LOAD "clos-slotdef1")
(LOAD "clos-stablehash1")
(LOAD "clos-specializer1")
(LOAD "clos-class1")
(LOAD "clos-class2")
(LOAD "clos-class3")

(LOAD "defstruct")              ; DEFSTRUCT-macro

(LOAD "format")                 ; FORMAT

;; from now on FORMATTER is working.

(LOAD "international")          ; internationalization

(in-package "SYSTEM")

;; A piece of "DO-WHAT-I-MEAN":
;; Searches for a program file.
;;   We search in the current directory and then in the directories
;; listed in *load-paths*.
;;   If an extension is specified in the filename, we search only for
;; files with this extension. If no extension is specified, we additionally
;; search for files with an extension from the given list.
;;   The return value is a list of all matching files from the FIRST directory
;; [because otherwise every load will mean a full traversal of ~/lisp/**/]
;; containing any matching file, sorted according to decreasing FILE-WRITE-DATE
;; (i.e. from new to old), or NIL if no matching file was found.
;;   The file names are NOT truenames, this is important so that symlinks
;; are compiled into the target directory, not the original one.
;;   If the searched filename is a directory, the directory pathname
;; is returned, NOT its contents.
(defun ppn-fwd (f keep-dirs)    ; probe-pathname + file-write-date
  (multiple-value-bind (true-name phys-name fwd) (probe-pathname f)
    (when (and true-name (or keep-dirs (pathname-name true-name)))
      (cons phys-name fwd))))
(defun search-file (filename &optional extensions (keep-dirs t))
  ;; <http://article.gmane.org/gmane.lisp.clisp.general:9893>
  ;; <https://sourceforge.net/p/clisp/mailman/message/12276025/>
  ;; <http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=443520>
  ;; <http://article.gmane.org/gmane.lisp.clisp.devel/18532>
  ;; <https://sourceforge.net/p/clisp/mailman/message/19813221/>
  ;; we use DIRECTORY only for *LOAD-PATHS* elements with wild components
  ;; to avoid the denial-of-service attack whereas a file in $HOME
  ;; with a name incompatible with *PATHNAME-ENCODING* prevents CLISP from
  ;; starting up (unless -norc or -E 1:1 is passed)
  ;; because (DIRECTORY "~/*") fails
  (let* ((already-searched nil) found
         ;; not (merge-pathnames filename) because filename can come
         ;; from `load-logical-pathname-translations' or `require'
         ;; and must be searched in "implementation-defined" locations
         ;; while `*default-pathname-defaults*' may contain a directore
         ;; which would preclude searching
         (path-nonW (pathname filename))
         (path-wild (if (pathname-name path-nonW)
                        (merge-pathnames path-nonW '#P"*.*")
                        ;; do not append *.* to directories
                        path-nonW))
         (use-extensions (null (pathname-type path-nonW))))
    (dolist (dir (cons '#P""
                       ;; when filename has "..", ignore *load-paths*
                       ;; (to avoid errors with "**/../foo"):
                       (if (memq :UP (pathname-directory path-nonW))
                           '()
                           (mapcar #'pathname *load-paths*))))
      (let* ((wild-p (wild-pathname-p dir))
             (search-filename
              (merge-pathnames (if wild-p path-wild path-nonW) dir)))
        (unless (member search-filename already-searched :test #'equal)
          (push search-filename already-searched)
          (let ((xpathnames
                 (if wild-p
                     (nconc
                      (directory search-filename :full t :circle t
                                 :if-does-not-exist :ignore)
                      (and (eq :wild (pathname-type search-filename))
                           (nconc
                            (directory (make-pathname
                                        :type nil :defaults search-filename)
                                       :if-does-not-exist :ignore
                                       :full t :circle t)
                            (directory (make-pathname
                                        :type nil :name nil
                                        :directory (append (pathname-directory search-filename) (list (pathname-name search-filename)))
                                        :defaults search-filename)
                                       :if-does-not-exist :ignore
                                       :full t :circle t))))
                     (let ((f (ppn-fwd search-filename keep-dirs))
                           (e (and use-extensions extensions
                                   (mapcan #'(lambda (ext)
                                               (let ((f (ppn-fwd (make-pathname :type ext :defaults search-filename) keep-dirs)))
                                                 (and f (list f))))
                                           extensions))))
                       (if f (cons f e) e)))))
            (when wild-p
              (when (and use-extensions extensions) ; filter the extensions
                (setq xpathnames
                      (delete-if-not
                       #'(lambda (xpathname)
                           (let ((ext (pathname-type (first xpathname))))
                             (or (null ext) ; no extension - good!
                                 (member ext extensions
                                         :test #+WIN32 #'string-equal
                                               #-WIN32 #'string=))))
                       xpathnames))))
            (when xpathnames
              (setq found
                    (if wild-p
                      (dolist (xpathname xpathnames xpathnames)
                        (setf (rest xpathname)
                              (apply #'encode-universal-time
                                     (third xpathname))))
                      xpathnames))
              (return))))))
    (mapcar #'car (sort (delete-duplicates found :test #'equal)
                        #'> :key #'cdr))))

(LOAD "room")                   ; room, space

;; preliminary definition of CERROR, CLtL2 p. 887
(predefun cerror (continue-format-string error-format-string &rest args)
  (if *error-handler*
    (apply *error-handler*
           (or continue-format-string t) error-format-string args)
    (progn
      (fresh-line *error-output*)
      (write-string "** - " *error-output*)
      (write-string (TEXT "Continuable Error") *error-output*)
      (terpri *error-output*)
      (apply #'format *error-output* error-format-string args)
      (elastic-newline *error-output*)
      (fresh-line *debug-io*)
      (if (interactive-stream-p *debug-io*)
        (progn
          (write-string (TEXT "If you continue (by typing 'continue'): ")
                        *debug-io*)
          (apply #'format *debug-io* continue-format-string args)
          (initial-break-driver t))
        (progn
          (apply #'format *debug-io* continue-format-string args)
          (elastic-newline *debug-io*))))))

(LOAD "functions")              ; function objects

(LOAD "trace")                  ; TRACE

(load "cmacros")                ; compiler macros

(LOAD "compiler")               ; compiler

(LOAD "defs2")                  ; CLtL2-definitions, optional

(LOAD "loop")                   ; CLtL2/ANSI-CL-LOOP, optional

(LOAD "clos")                   ; CLOS

(LOAD "gray")                   ; STREAM-DEFINITION-BY-USER:GENERIC-FUNCTIONS

(LOAD "fill-out")               ; FILL-OUTPUT-STREAM (for condition & describe)

(LOAD "disassem")               ; Disassembler

(LOAD "condition")              ; Conditions

(load "loadform")               ; `make-load-form'

;; At this point the core Common Lisp is complete.

#+mt (load "threads")           ; Multi-Threading

;; Fancy streams:
#+generic-streams
(LOAD "gstream")                ; generic streams, optional

(LOAD "xcharin")                ; extended character input, optional

(LOAD "keyboard")               ; keyboard stream, optional

#+SCREEN
(LOAD "screen")                 ; screen-package, optional


;; Environmental facilities:
#+sockets
(use-package '("SOCKET") "EXT")
#+sockets
(in-package "SOCKET")
#+sockets
(common-lisp:export
 '(socket-server socket-server-close socket-server-port socket-server-host
   socket-accept socket-wait socket-status socket-connect socket-options
   socket-stream-host socket-stream-port socket-stream-peer socket-stream-local)
 "SOCKET")
#+sockets
(ext:re-export "SOCKET" "EXT")

(common-lisp:in-package "SYSTEM")

(LOAD "runprog")                ; run-program and friends, optional

;; User interface:

(LOAD "query")                  ; querying the user

(LOAD "reploop")                ; prompt, debugger, stepper

(LOAD "savemem")                ; saveinitmem

(LOAD "dribble")                ; dribble

(load "pprint")                 ; pretty printer

(LOAD "describe")               ; apropos, describe

(LOAD "edit")                   ; edit-file, ed, uncompile

(LOAD "clhs")                   ; HyperSpec access

(load "inspect")                ; inspector

;; Random extensions:

(LOAD "macros3")                ; more macros, optional

(LOAD "complete")               ; gnu readline completion (requires macros3)

(LOAD "case-sensitive")         ; case-sensitive packages

#+FFI ; when (find-package "FFI")
(LOAD "foreign1")               ; foreign function interface, optional

(LOAD "exporting")              ; auto-exporting defining macros

#+(and GETTEXT UNICODE) (LOAD "danish")  ; Danish messages
#+(and GETTEXT UNICODE) (LOAD "german")  ; German messages
#+(and GETTEXT UNICODE) (LOAD "french")  ; French messages
#+(and GETTEXT UNICODE) (LOAD "spanish") ; Spanish messages
#+(and GETTEXT UNICODE) (LOAD "dutch")   ; Dutch messages
#+(and GETTEXT UNICODE) (LOAD "russian") ; Russian messages

(load "deprecated")             ; the deprecated functionality -- optional

(LOAD "config")    ; configuration parameters to be adjusted by the user

(setq *defun-accept-specialized-lambda-list* t);was disabled for bootstrapping
(setq sys::*home-package* nil ext:*command-index* 0)

(in-package "CL-USER")        ; make the default package the current one
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./init.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./dribble.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Dribble

(in-package "EXT")
(export '(make-dribble-stream dribble-stream-p dribble-stream
          dribble-stream-source dribble-stream-target dribble-toggle))

(in-package "SYSTEM")

(defun make-dribble-stream (source target)
  (make-two-way-stream (make-echo-stream source target)
                       (make-broadcast-stream source target)))
(defun dribble-stream (stream)
  (and (sys::two-way-stream-p stream)
       (let ((in (two-way-stream-input-stream stream))
             (out (two-way-stream-output-stream stream)))
         (and (sys::echo-stream-p in) (sys::broadcast-stream-p out)
              (let ((source (echo-stream-input-stream in))
                    (target (echo-stream-output-stream in))
                    (broadcast-list (broadcast-stream-streams out)))
                (when (and (eq source (pop broadcast-list))
                           (eq target (pop broadcast-list)))
                  (values source target)))))))
(defun dribble-stream-p (obj) (not (null (dribble-stream obj))))
;; should this be integrated into CLOS and the rest of CLISP?
;; right now DRIBBLE-STREAM is not a recognizable subtype of TWO-WAY-STREAM.
;; should it be?  should it be printed specially?
(deftype dribble-stream () '(satisfies dribble-stream-p))
(defun check-dribble-stream (obj caller)
  (loop
    (multiple-value-bind (so ta) (dribble-stream obj)
      (when so (return-from check-dribble-stream (values so ta))))
    (setq obj (check-value
               nil (make-condition 'simple-type-error
                     :format-control (TEXT "~S: ~S should be a ~S")
                     :format-arguments (list caller obj 'dribble-stream)
                     :datum obj :expected-type 'dribble-stream)))))
(defun dribble-stream-source (ds)
  (check-dribble-stream ds 'dribble-stream-source))
(defun dribble-stream-target (ds)
  (nth-value 1 (check-dribble-stream ds 'dribble-stream-target)))
(defun dribble-toggle (stream &optional file)
  (multiple-value-bind (source target) (dribble-stream stream)
    (if source
      (if file                  ; already dribbling
        (warn (TEXT "Already dribbling ~S to ~S") source target)
        (progn
          (format target (TEXT "~&;; Dribble of ~S finished on ~A.~%")
                  source (date-string))
          (values source target)))
      (if file                    ; not dribbling
        (let ((target
               (if (and (streamp file)
                        (open-stream-p file) (output-stream-p file))
                 file
                 (open file :direction :output
                            :external-format (stream-external-format stream)
                            :if-exists :append
                            :if-does-not-exist :create))))
          (format target (TEXT ";; Dribble of ~S started on ~A.~%")
                  stream (date-string))
          (values (make-dribble-stream stream target) target))
        (warn (TEXT "Currently not dribbling from ~S.") stream)))))

(defun dribble (&optional file)
  (multiple-value-bind (source target) (dribble-toggle *terminal-io* file)
    (when (streamp source)         ; no warning
      (unless file (close target)) ; dribble off
      (setq *terminal-io* source))
    target))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./dribble.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./clhs.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Sam Steingold 2000-2008, 2010-2011, 2017
;;; Bruno Haible 2017
;;; This file is a part of CLISP (http://clisp.org), and, as such,
;;; is distributed under the GNU GPL v2+ (http://www.gnu.org/copyleft/gpl.html)

(in-package "EXT")

(export '(clhs clhs-root browse-url open-http with-http-input http-proxy
          starts-with-p))

(in-package "SYSTEM")

;;; ============== Presenting data from the Internet to the user ==============

(defvar *browsers*
  '((:netscape "netscape" "~a")
    (:netscape-window "netscape" "-remote" "openURL(~a,new-window)")
    (:netscape-tab "netscape" "-remote" "openURL(~a,new-tab)")
    (:mozilla "mozilla" "~a")
    (:mozilla-window "mozilla" "-remote" "openURL(~a,new-window)")
    (:mozilla-tab "mozilla" "-remote" "openURL(~a,new-tab)")
    (:firefox "firefox" "~a")
    (:firefox-window "firefox" "-new-window" "~a")
    (:firefox-tab "firefox" "-new-tab" "~a")
    (:konqueror "kfmclient" "openURL" "~a")
    (:lynx "lynx" "~a")
    #+unix (:lynx-xterm "xterm" "-e" "lynx" "~a")
    (:links "links" "~a")
    #+unix (:links-xterm "xterm" "-e" "links" "~a")
    (:w3m "w3m" "~a")
    #+unix (:w3m-xterm "xterm" "-e" "w3m" "~a")
    #+cygwin (:default "cygstart" "~a")
    #+macos (:default "open" "~a")
    (:mmm "mmm" "-external" "~a")
    (:mosaic "xmosaic" "~a")
    (:chromium "chromium-browser" "~a")
    (:conkeror "conkeror" "~a")
    (:opera "opera" "~a")
    (:emacs "emacsclient" "--eval" "(browse-url ~s)"))
  "Alist of browsers and commands that invoke them.
`~a' will be replaced with the URL to view.")
(defvar *browser* nil
  "The default browser - a key in `*browsers*' or a list of strings.")

(defun browse-url (url &key (browser *browser*) (out *standard-output*))
  "Run the browser (a keyword in *BROWSERS* or a list) on the URL."
  #+WIN32
  (when (eq browser :default) ; feed url to ShellExecute
    (when out
      (format out "~&;; starting the default system browser with url ~s..." url)
      (force-output (if (eq out t) *standard-output* out)))
    (ext::shell-execute "open" url nil nil) ;to start default browser
    (when out (format out "done~%"))
    (return-from browse-url))
  (let* ((command
          (etypecase browser
            (list browser)
            (symbol (or (cdr (assoc browser *browsers* :test #'eq))
                        (error "unknown browser: `~s' (must be a key in `~s')"
                               browser '*browsers*)))))
         (args (mapcar (lambda (arg) (format nil arg url)) (cdr command))))
    (cond (command
           (when out
             (format out "~&;; running [~s~{ ~s~}]..." (car command) args)
             (force-output (if (eq out t) *standard-output* out)))
           (#+WIN32 ext::launch #-WIN32 run-program (car command) :arguments args :wait nil)
           (when out
             (format out "done~%")))
          (t (format t "~s: no browser specified; please point your browser at
 --> <URL:~a>~%" 'browse-url url)))))

;;; ===================== Reading data from the Internet =====================

(defun starts-with-p (string prefix)
  "Check whether the string starts with the supplied prefix (case-insensitive)."
  (string-equal string prefix :end1 (min (length string) (length prefix))))
#+(or)                          ; not worth it
(define-compiler-macro starts-with-p (string prefix &whole form)
  "Inline and pre-compute prefix length."
  (print (list string prefix form))
  (if (stringp prefix)
      `(string-equal ,string ,prefix :end1 (min (length ,string) ,(length prefix)))
      form))

(defvar *http-log-stream* (make-synonym-stream '*terminal-io*))
;;; keep in sync with clocc/cllib/url.lisp
(defvar *http-proxy* nil
  "A list of 3 elements (user:password host port), parsed from $http_proxy
\[http://]proxy-user:proxy-password@proxy-host:proxy-port[/]
by HTTP-PROXY.")
(defconstant *http-port* 80)
(defun http-proxy (&optional (proxy-string (getenv "http_proxy") proxy-p))
  "When the argument is supplied or *HTTP-PROXY* is NIL, parse the argument,
set *HTTP-PROXY*, and return it; otherwise just return *HTTP-PROXY*."
  (when (or proxy-p (and (null *http-proxy*) proxy-string))
    (check-type proxy-string string)
    (let* ((start (if (starts-with-p proxy-string #1="http://")
                      #.(length #1#) 0))
           (at (position #\@ proxy-string :start start))
           (colon (position #\: proxy-string :start (or at start)))
           (slash (position #\/ proxy-string :start (or colon at start))))
      (setq *http-proxy*
            (list (and at (subseq proxy-string start at))
                  (subseq proxy-string (if at (1+ at) start) (or colon slash))
                  (if colon
                      (parse-integer proxy-string :start (1+ colon) :end slash)
                      *http-port*)))
      (format *http-log-stream* "~&;; ~S=~S~%" '*http-proxy* *http-proxy*)))
  *http-proxy*)

(defmacro with-http-input ((var url) &body body)
  (if (symbolp var)
      `(with-open-stream (,var (open-http ,url)) ,@body)
      (multiple-value-bind (body-rest declarations) (SYSTEM::PARSE-BODY body)
        `(multiple-value-bind ,var (open-http ,url)
           (DECLARE (READ-ONLY ,@var) ,@declarations)
           (UNWIND-PROTECT
                (MULTIPLE-VALUE-PROG1 (PROGN ,@body-rest)
                  (when ,(first var) (CLOSE ,(first var))))
             (when ,(first var) (CLOSE ,(first var) :ABORT T)))))))
(defun open-http (url &key (if-does-not-exist :error)
                  ((:log *http-log-stream*) *http-log-stream*))
  (unless (starts-with-p url #1="http://")
    (error "~S: ~S is not an HTTP URL" 'open-http url))
  (format *http-log-stream* "~&;; connecting to ~S..." url)
  (force-output *http-log-stream*)
  (http-proxy)
  (let* ((host-port-end (position #\/ url :start #2=#.(length #1#)))
         (port-start (position #\: url :start #2# :end host-port-end))
         (url-host (subseq url #2# (or port-start host-port-end)))
         (host (if *http-proxy* (second *http-proxy*) url-host))
         (url-port (if port-start
                       (parse-integer url :start (1+ port-start)
                                      :end host-port-end)
                       *http-port*))
         (port (if *http-proxy* (third *http-proxy*) url-port))
         (path (if *http-proxy* url
                   (if host-port-end (subseq url host-port-end) "/")))
         (sock (handler-bind ((error (lambda (c)
                                       (unless (eq if-does-not-exist :error)
                                         (format *http-log-stream*
                                                 "cannot connect to ~S:~D: ~A~%"
                                                 host port c)
                                         (return-from open-http nil)))))
                 (socket:socket-connect port host :external-format :dos)))
         status code content-length)
    (format *http-log-stream* "connected...") (force-output *http-log-stream*)
    ;; http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.23
    ;; http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.43
    (format sock "GET ~A HTTP/1.0~%User-agent: ~A ~A~%Host: ~A:~D~%" path
            (lisp-implementation-type) (lisp-implementation-version)
            url-host url-port)
    #+unicode ; base64 requires unicode for some weird infrastructure reasons
    (when (first *http-proxy*) ; auth: http://www.ietf.org/rfc/rfc1945.txt
      ;; http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.34
      (format sock "Proxy-Authorization: Basic ~A~%"
              (convert-string-from-bytes
               (convert-string-to-bytes (first *http-proxy*)
                                        *http-encoding*)
               charset:base64)))
    ;; http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.1
    ;; http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.10
    (format sock "Accept: */*~%Connection: close~2%") ; finish request
    (write-string (setq status (read-line sock))) (force-output)
    (let* ((pos1 (position #\Space status))
           (pos2 (position #\Space status :start (1+ pos1))))
      (setq code (parse-integer status :start pos1 :end pos2)))
    (when (>= code 400)
      ;; dump headers
      (loop :for line = (read-line sock nil nil) :while line
        :do (format *http-log-stream* "~&;; ~S~%" line))
      (case if-does-not-exist
        (:error (error (TEXT "~S: error ~D: ~S") 'open-http code status))
        (t (close sock)
           (return-from open-http nil))))
    (if (>= code 300)        ; redirection
        (loop :for res = (read-line sock)
          :until (starts-with-p res #3="Location: ")
          :finally (let ((new-url (subseq res #.(length #3#))))
                     (format *http-log-stream* " --> ~S~%" new-url)
                     (unless (starts-with-p new-url #1#)
                       (setq new-url (string-concat #1# host new-url)))
                     (return-from open-http (open-http new-url))))
        ;; drop response headers
        (loop :for line = (read-line sock) :while (plusp (length line)) :do
          (when (starts-with-p line #5="Content-Length: ")
            (format *http-log-stream* "...~:D bytes"
                    (setq content-length (parse-integer line :start #.(length #5#)))))
          :finally (terpri)))
    (values sock content-length)))

(defun open-url (path &rest options &aux (len (length path)))
  (cond ((starts-with-p path "http://")
         (apply #'open-http path options))
        ((starts-with-p path #1="file:/")
         ;; Tomas Zellerin writes in bug#344:
         ;; I think that proper RFC compliant URL of this kind is
         ;; file://<machine>/<path>, where machine may be the empty string
         ;; for localhost and path should be an absolute path (including
         ;; the leading slash on Unix), but browsers usually do not require
         ;; four slashes in row.
         (let ((path-beg (position #\/ path :test-not #'eql :start #.(length #1#))))
           ;; we first try stripping all leading slashes to catch things like
           ;; file:///c:/foo/bar and then resort to keeping one leading #\/
           (apply #'open (or #+(or win32 cygwin)
                             (probe-file (subseq path path-beg))
                             (subseq path (1- path-beg)))
                  options)))
        (t (open path))))

;;; ========== Common Lisp HyperSpec and CLISP implementation notes ==========

;;; the CLHS & IMPNOTES documentation:
;; * symbols (and packages for IMPNOTES) can have a doc string that points
;;   to the position of the documentation text in the CLHS or IMPNOTES.
;; * (documentation foo 'sys::clhs) and (documentation foo 'sys::impnotes)
;;   return a valid URL that can be printed or passed to the browser
;; * (setf (documentation foo 'sys::clhs) "bar") and
;;   (setf (documentation foo 'sys::impnotes) "bar")
;;   "bar" is the URL sans (clhs-root) and (impnotes-root)

;;; ============ Using the Common Lisp HyperSpec as documentation ============

;; (clhs-root) is defined in cfgunix.lisp or cfgwin32.lisp.
;; The CLHS is not free documentation: the legal notices state that it must
;; not be "made or distributed or displayed or transmitted for direct
;; commercial advantage". Therefore neither Linux distros nor CLISP source
;; or binary packages may include it. Instead, the only options to use it are:
;; * Reference it on the web. The most common (official) URLs are
;;   (1996) http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/FrontMatter/
;;          http://cliki.net/site/HyperSpec/FrontMatter/index.html
;;   (2001) http://yon.maclisp.org/clhs/HyperSpec/Front/
;;   (2005) http://www.lispworks.com/documentation/HyperSpec/Front/
;;          http://clhs.lisp.se/Front/index.htm
;; * Let the user download it as a complete package and install it in their
;;   file system.
;;   Download location:
;;   ftp://ftp.lispworks.com/pub/software_tools/reference/HyperSpec-7-0.tar.gz

(defun get-clhs-map (stream)
  "Download and install the CLHS map."
  (format *http-log-stream* "~&;; ~S(~S)..." 'get-clhs-map stream)
  (force-output *http-log-stream*)
  (loop :with good = 0 :for symbol-name = (read-line stream nil nil)
    :and destination = (read-line stream nil nil)
    :and total :upfrom 0
    :while (and symbol-name destination) :do
    (multiple-value-bind (symbol status) (find-symbol symbol-name "COMMON-LISP")
      (cond (status
             (incf good)
             (setf (documentation symbol 'sys::clhs)
                   (subseq destination #.(length "../"))))
            (t (warn (TEXT "~S is not found") symbol-name))))
    :finally (format *http-log-stream* "~:D/~:D symbol~:P~%" good total)))

(let ((clhs-map-source nil) (clhs-map-good nil))
  ;; if clhs-map-source is the same as (clhs-root), do nothing and
  ;; return (clhs-root); otherwise set clhs-map-source to (clhs-root)
  ;; and try to get the clhs map from (clhs-root)
  ;; nil return value means no map exists
(defun ensure-clhs-map ()
  "make sure that the CLHS map is present"
  (let ((clhs-root (clhs-root)))
    (when (and clhs-root (string/= clhs-map-source clhs-root))
      (setq clhs-map-source clhs-root)
      ;; The symbol map exists under different names:
      ;;   (1996) http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Data/Symbol-Table.text
      ;;          http://cliki.net/site/HyperSpec/Data/Symbol-Table.text
      ;;   (2001) http://yon.maclisp.org/clhs/HyperSpec/Data/Map_Sym.txt
      ;;   (2005) http://www.lispworks.com/documentation/HyperSpec/Data/Map_Sym.txt
      ;;          http://clhs.lisp.se/Data/Map_Sym.txt
      ;; We support both names.
      ;; If you are scared of logging on the screen,
      ;; bind or set *HTTP-LOG-STREAM*
      (flet ((get-map-1996 ()
               (open-url (string-concat clhs-root "Data/Symbol-Table.text") :if-does-not-exist nil))
             (get-map-2001 ()
               (open-url (string-concat clhs-root "Data/Map_Sym.txt") :if-does-not-exist nil)))
        (with-open-stream (s (cond ((or (search "ai.mit.edu/" clhs-root)
                                        (search "cliki.net/" clhs-root))
                                    (get-map-1996))
                                   ((or (search "maclisp.org/" clhs-root)
                                        (search "lispworks.com/" clhs-root)
                                        (search "lisp.se/" clhs-root))
                                    (get-map-2001))
                                   (t (or (get-map-1996) (get-map-2001)))))
          (unless s
            (warn (TEXT "~S returns invalid value ~S, fix it, ~S, ~S, or ~S")
                  'clhs-root clhs-root '(getenv "CLHSROOT")
                  '*clhs-root-default* '*http-proxy*)
            (return-from ensure-clhs-map))
          (get-clhs-map s)))
      (setq clhs-map-good t))
    (and clhs-map-good clhs-root))))

(defmethod documentation ((obj symbol) (type (eql 'sys::clhs)))
  (when (and (eq (symbol-package obj) #,(find-package "CL")) (ensure-clhs-map))
    (let ((doc (call-next-method)))
      (when doc (string-concat (clhs-root) doc)))))

(defun clhs (symbol &key (browser *browser*) (out *standard-output*))
  "Dump the CLHS doc for the symbol."
  (warn "function ~S is deprecated, set ~S and use ~S instead"
        'clhs '*browser* 'describe)
  (browse-url (or (documentation symbol 'sys::clhs)
                  (error "No HyperSpec doc for ~S" symbol))
              :browser browser :out out))

;;; ========== Using the CLISP implementation notes as documentation ==========

(defun get-string-map (stream &aux (table (make-hash-table :test 'equal)))
  (format *http-log-stream* "~&;; ~S(~S)..." 'get-string-map stream)
  (force-output *http-log-stream*)
  (loop :for total :upfrom 0 :and id = (read-line stream nil nil)
    :and destination = (read-line stream nil nil)
    :while (and id destination) :do
    (when (or (find-if #'whitespacep id) (find-if #'whitespacep destination)
              (zerop (length id)) (zerop (length destination)))
      (warn "~S: invalid map ~S --> ~S" 'get-string-map id destination)
      (return-from get-string-map nil))
    (let ((old (gethash id table)))
          (when old (warn "~S: remapping ~S: ~S --> ~S"
                          'get-string-map id old destination)))
    (setf (gethash id table) destination)
    :finally (format *http-log-stream* "~:D ID~:P~%" total))
  table)

(let ((impnotes-map-source nil) (impnotes-map-good nil) id-href
      (dest (lambda (id) (string-concat "#" id))))
  ;; if impnotes-map-source is the same as (impnotes-root), do nothing
  ;; and return (and impnotes-map-good (impnotes-root));
  ;; otherwise set impnotes-map-source to (impnotes-root) and try to get
  ;; the impnotes map from (impnotes-root)
  ;; nil return value means no map exists
(defun ensure-impnotes-map (&optional check-symbol-map)
  "make sure that the impnotes map is present"
  (let ((impnotes-root (impnotes-root)))
    (when (and impnotes-root (string/= impnotes-map-source impnotes-root))
      (setq impnotes-map-source impnotes-root)
      (case (char impnotes-root (1- (length impnotes-root)))
        ((#\/ #+win32 #\\) ; chunked impnotes ==> get id-href
         (setq id-href (string-concat impnotes-root "id-href.map"))
         (with-open-stream (s (open-url id-href :if-does-not-exist nil))
           (unless s
             #2=(warn (TEXT "~S returns invalid value ~S, fix it, ~S, ~S, or ~S")
                      'impnotes-root impnotes-root '(getenv "IMPNOTES")
                      '*impnotes-root-default* '*http-proxy*)
             (return-from ensure-impnotes-map))
           (let ((table (get-string-map s)))
             (unless table   ; no table --> bail out
               #2# (return-from ensure-impnotes-map))
             (setq dest (lambda (id) (gethash id table)))))))
      (with-open-file (in (clisp-data-file "Symbol-Table.text"))
        (format *http-log-stream* "~&;; ~S(~S)..."
                'ensure-impnotes-map (truename in))
        (force-output *http-log-stream*)
        (loop :for count :upfrom 0
          :and symbol-printname = (read-line in nil nil)
          :and id = (read-line in nil nil)
          :while (and symbol-printname id) :do
          (let ((destination (funcall dest id)))
            (if destination
                (multiple-value-bind (symbol error)
                    (ignore-errors (read-from-string symbol-printname))
                  (if (integerp error)
                    (setf (documentation symbol 'sys::impnotes)
                          destination)
                    (and check-symbol-map
                         (not (gethash symbol-printname
                                       #S(HASH-TABLE EQUALP
                                          #-(or win32 cygwin) ("CUSTOM:*DEVICE-PREFIX*" . t)
                                          #-(or win32 cygwin) ("POSIX:FILE-PROPERTIES" . t)
                                          ("CUSTOM:*DEFAULT-TIME-ZONE*" . t)
                                          ("CLOS:MAKE-METHOD-LAMBDA" . t)
                                          ("SYS::DYNLOAD-MODULES" . t))))
                         ;; *default-time-zone* sys::dynload-modules ...
                         (warn (TEXT "~S: invalid symbol ~S with id ~S: ~A")
                               'ensure-impnotes-map symbol-printname
                               id error))))
                (warn (TEXT "~S: invalid id ~S for symbol ~S")
                      'ensure-impnotes-map id symbol-printname)))
          :finally (format *http-log-stream* "~:D ID~:P~%" count)))
      (setq impnotes-map-good t)) ; success
    (and impnotes-map-good impnotes-root)))

(defmethod documentation ((obj package) (type (eql 'sys::impnotes)))
  (let ((doc (sys::package-documentation obj)))
    (and (consp doc) (ensure-impnotes-map)
         (let ((suffix (funcall dest (second doc))))
           (if suffix (string-concat (impnotes-root) suffix)
               (cerror (TEXT "Ignore") (TEXT "~S(~S): ~S does not know about ~S; the Implementation Notes must be regenerated")
                       'documentation obj id-href (second doc))))))))

(defmethod documentation ((obj symbol) (type (eql 'sys::impnotes)))
  (let ((pack (symbol-package obj)))
    ;; do not search impnotes for user symbols
    (when (and pack
               (or (eq pack #,(find-package "CUSTOM"))
                   ;; CUSTOM is not in *SYSTEM-PACKAGE-LIST*
                   ;; because it must not be locked
                   (member (package-name pack) *system-package-list*
                           :test #'equal))
               (ensure-impnotes-map))
      (let ((doc (call-next-method)))
        (if doc
          (string-concat (impnotes-root) doc)
          (documentation pack 'sys::impnotes))))))

(defmethod (setf documentation) (new-value (obj package)
                                 (type (eql 'sys::impnotes)))
  (let ((doc (sys::package-documentation obj)))
    (if (consp doc)
        (setf (second doc) new-value)
        (setf (sys::package-documentation obj)
              (list "see the implementation notes" new-value)))))

;; what is the right place for these?
(setf (documentation (find-package "GRAY") 'sys::impnotes) "gray")
(setf (documentation (find-package "CL-USER") 'sys::impnotes) "clupack")
(setf (documentation (find-package "CS-CL-USER") 'sys::impnotes) "cs-clu")
(setf (documentation (find-package "CS-CL") 'sys::impnotes) "package-case")
#+screen (setf (documentation (find-package "SCREEN") 'sys::impnotes) "screen")
#+sockets (setf (documentation (find-package "SOCKET") 'sys::impnotes) "socket")
#+generic-streams
(setf (documentation (find-package "GSTREAM") 'sys::impnotes) "gstream")
(setf (documentation (find-package "I18N") 'sys::impnotes) "i18n")
#+FFI
(setf (documentation (find-package "FFI") 'sys::impnotes) "dffi")
(setf (documentation (find-package "CUSTOM") 'sys::impnotes) "customize")
#+UNICODE
(setf (documentation (find-package "CHARSET") 'sys::impnotes) "charset")
(setf (documentation (find-package "CLOS") 'sys::impnotes) "classes")
(setf (documentation (find-package "EXT") 'sys::impnotes) "ext-pac")
#+MT (setf (documentation (find-package "THREADS") 'sys::impnotes) "mt")

;;; ===========================================================================
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./clhs.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./xcharin.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Extended character input

;; This file provides the data type used by the keyboard stream,
;; and CLtL1 compatible character functions operating on font and bits.

(in-package "EXT")
(export '(char-bits char-font char-font-limit char-bits-limit
          char-control-bit char-meta-bit char-super-bit char-hyper-bit
          make-char char-bit set-char-bit char-key))

(in-package "SYSTEM")

(defconstant char-font-limit 16) ; for backward compatibility only
(defconstant char-bits-limit 16)
;; CLtL1, p. 233, 234
(defconstant char-int-limit     ; CLISP specific
  (* char-code-limit char-font-limit char-bits-limit))

(defstruct input-character
  (char nil :type (or null character))
  (bits 0   :type (integer 0 #.(1- char-bits-limit)))
  (font 0   :type (integer 0 #.(1- char-font-limit)))
  (key  nil :type (or null character symbol)))

(defconstant char-control-bit 1)
(defconstant char-meta-bit 2)
(defconstant char-super-bit 4)
(defconstant char-hyper-bit 8)
;; CLtL1, p. 243

(defun error-char-arg (arg caller)
  (error-of-type 'type-error
    :datum arg :expected-type 'character
    (TEXT "~S: argument ~S is not a character")
    caller arg))

(defun char-bits (char)
  (cond ((typep char 'character) 0)
        ((input-character-p char) (input-character-bits char))
        (t (error-char-arg char 'char-bits))))

(defun char-font (char)
  (cond ((typep char 'character) 0)
        ((input-character-p char) (input-character-font char))
        (t (error-char-arg char 'char-font))))

(defun char-key (char)
  (cond ((typep char 'character) char)
        ((input-character-p char) (input-character-key char))
        (t (error-char-arg char 'char-key))))

(defun test-font-arg (arg caller)
  (if (integerp arg)
    arg
    (error-of-type 'type-error
      :datum arg :expected-type 'integer
      (TEXT "~S: the font argument should be an integer, not ~S")
      caller arg)))

(defun test-bits-arg (arg caller)
  (if (integerp arg)
    arg
    (error-of-type 'type-error
      :datum arg :expected-type 'integer
      (TEXT "~S: the bits argument should be an integer, not ~S")
      caller arg)))

(defun make-char (char &optional (bits 0) (font 0))
  (test-font-arg font 'make-char)
  (test-bits-arg bits 'make-char)
  (unless (typep char 'character) (error-char-arg char 'make-char))
  (if (and (<= 0 bits) (< bits char-bits-limit)
           (<= 0 font) (< font char-font-limit))
    (make-input-character :char char :bits bits :font font)
    nil))

(defun test-bitname-arg (arg caller)
  (case arg
    (:CONTROL char-control-bit)
    (:META    char-meta-bit)
    (:SUPER   char-super-bit)
    (:HYPER   char-hyper-bit)
    (t (error-of-type 'type-error
         :datum arg :expected-type '(MEMBER :CONTROL :META :SUPER :HYPER)
         (TEXT "~S: the only bit names are ~S, ~S, ~S, ~S, not ~S")
         caller ':CONTROL ':META ':SUPER ':HYPER arg))))

(defun char-bit (char name)
  (let ((bitmask (test-bitname-arg name 'char-bit)))
    (cond ((typep char 'character) nil)
          ((input-character-p char)
           (not (zerop (logand (input-character-bits char) bitmask))))
          (t (error-char-arg char 'char-bit)))))

(defun set-char-bit (char name newvalue)
  (let ((bitmask (test-bitname-arg name 'char-bit))
        (new
          (cond ((typep char 'character) (make-input-character :char char))
                ((input-character-p char) (copy-input-character char))
                (t (error-char-arg char 'set-char-bit)))))
    (if newvalue
      (setf (input-character-bits new)
            (logior (input-character-bits new) bitmask))
      (setf (input-character-bits new)
            (logand (input-character-bits new) (lognot bitmask))))
    new))

;; Characters which had names in earlier versions of CLISP:
; WIN32_CHARNAMES
;  charname_hyper_13     (make-input-character :key :Enter)
;  charname_hyper_16     (make-input-character :key :Insert)
;  charname_hyper_17     (make-input-character :key :End)
;  charname_hyper_18     (make-input-character :key :Down)
;  charname_hyper_19     (make-input-character :key :PgDn)
;  charname_hyper_20     (make-input-character :key :Left)
;  charname_hyper_21     (make-input-character :key :Center)
;  charname_hyper_22     (make-input-character :key :Right)
;  charname_hyper_23     (make-input-character :key :Home)
;  charname_hyper_24     (make-input-character :key :Up)
;  charname_hyper_25     (make-input-character :key :PgUp)
;  charname_hyper_127    (make-input-character :key :Delete)
;  charname_hyper_a      (make-input-character :key :F1)
;  charname_hyper_b      (make-input-character :key :F2)
;  charname_hyper_c      (make-input-character :key :F3)
;  charname_hyper_d      (make-input-character :key :F4)
;  charname_hyper_e      (make-input-character :key :F5)
;  charname_hyper_f      (make-input-character :key :F6)
;  charname_hyper_g      (make-input-character :key :F7)
;  charname_hyper_h      (make-input-character :key :F8)
;  charname_hyper_i      (make-input-character :key :F9)
;  charname_hyper_j      (make-input-character :key :F10)
;  charname_hyper_k      (make-input-character :key :F11)
;  charname_hyper_l      (make-input-character :key :F12)
; UNIX_CHARNAMES
;  charname_hyper_16     (make-input-character :key :Insert)
;  charname_hyper_17     (make-input-character :key :End)
;  charname_hyper_18     (make-input-character :key :Down)
;  charname_hyper_19     (make-input-character :key :PgDn)
;  charname_hyper_20     (make-input-character :key :Left)
;  charname_hyper_21     (make-input-character :key :Center)
;  charname_hyper_22     (make-input-character :key :Right)
;  charname_hyper_23     (make-input-character :key :Home)
;  charname_hyper_24     (make-input-character :key :Up)
;  charname_hyper_25     (make-input-character :key :PgUp)
;  charname_hyper_a      (make-input-character :key :F1)
;  charname_hyper_b      (make-input-character :key :F2)
;  charname_hyper_c      (make-input-character :key :F3)
;  charname_hyper_d      (make-input-character :key :F4)
;  charname_hyper_e      (make-input-character :key :F5)
;  charname_hyper_f      (make-input-character :key :F6)
;  charname_hyper_g      (make-input-character :key :F7)
;  charname_hyper_h      (make-input-character :key :F8)
;  charname_hyper_i      (make-input-character :key :F9)
;  charname_hyper_j      (make-input-character :key :F10)
;  charname_hyper_k      (make-input-character :key :F11)
;  charname_hyper_l      (make-input-character :key :F12)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./xcharin.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./cfgwin32.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#0Y UTF-8 ;;;  This file is Unicode/UTF-8 encoded.  -*- coding: utf-8 -*-

;;; Site specific definitions, to be modified on installation

(in-package "EXT")
(mapcar #'fmakunbound '(short-site-name long-site-name))

(defun short-site-name ()
  (let ((s (or (sys::registry "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"
                              "RegisteredOrganization")
               (sys::registry "SOFTWARE\\Microsoft\\Windows\\CurrentVersion"
                              "RegisteredOrganization"))))
    (check-type s string)
    s))
(defun long-site-name ()
  (let ((s (or (sys::registry "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"
                              "RegisteredOwner")
               (sys::registry "SOFTWARE\\Microsoft\\Windows\\CurrentVersion"
                              "RegisteredOwner"))))
    (check-type s string)
    s))

(defparameter *editor* "notepad.exe" "The name of the editor.")
(defun editor-name () (or (getenv "EDITOR") *editor*))

(defun editor-tempfile ()
  "The temporary file LISP creates for editing."
  "lisptemp.lisp")

(defun edit-file (file)
  "(edit-file file) edits a file."
  (execute (editor-name) (namestring (absolute-pathname file))))

;; Treat Ctrl-Z in files as whitespace. Some losing medieval
;; editors insist on appending this to files.
(eval-when (load eval compile)
  (set-syntax-from-char #\Code26 #\Space))

(defparameter *load-paths*
  '(#"C:"               ; Search first in the current directory on drive C:
    #"C:\\CLISP\\**\\") ; then in all subdirectories under C:\CLISP
  "The list of directories where programs are searched on LOAD etc.
if device and directory are unspecified:")

;; This makes screen output prettier:
(setq *print-pretty* t)

;; understand CYGWIN pathnames
(setq *device-prefix* "cygdrive")

;; This perhaps makes pathname parsing more intuitive:
;;  ".clisprc" --> #S(pathname :name ".clisprc" :type nil)
(setq *parse-namestring-dot-file* :name)

;; which browser do you use? (see `*browsers*' in clhs.lisp)
;; (setq *browser* :default)

(defvar *impnotes-root-default* "http://clisp.org/impnotes/")
(defun impnotes-root ()
  "This returns the root URL for the CLISP implementation notes.
You can set the environment variable `IMPNOTES' or redefine this function
in ~/.clisprc.  On win32 you can also use the Registry."
  (or (getenv "IMPNOTES")
      (let ((s (sys::registry "SOFTWARE\\GNU\\CLISP" "IMPNOTES")))
        (check-type s (or null string))
        s)
      *impnotes-root-default*))

;; Common Lisp HyperSpec access
(defvar *clhs-root-default*)
(defun clhs-root ()
  "This returns the root URL for the Common Lisp HyperSpec.
You can set the environment variable `CLHSROOT' or redefine this function
in ~/.clisprc.  On win32 you can also use the Registry."
  (or (getenv "CLHSROOT")
      (let ((s (sys::registry "SOFTWARE\\GNU\\CLISP" "CLHSROOT")))
        (check-type s (or null string))
        s)
      *clhs-root-default*))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./cfgwin32.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./cfgunix.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#0Y UTF-8 ;;;  This file is Unicode/UTF-8 encoded.  -*- coding: utf-8 -*-

;;; Site specific definitions, to be modified on installation

(in-package "EXT")
(mapcar #'fmakunbound '(short-site-name long-site-name))

(let ((cache nil))
(defun short-site-name ()
  (if cache cache
      (setq cache
            (or (getenv "ORGANIZATION")
                (with-open-stream (s (make-pipe-input-stream "uname -n"))
                  (read-line s)))))))

(let ((cache nil))
(defun long-site-name ()
  (if cache cache
      (setq cache
            (or (getenv "ORGANIZATION")
                (with-open-stream (s (make-pipe-input-stream "uname -a"))
                  (read-line s)))))))

(defparameter *editor* "vi" "The name of the editor.")
(defun editor-name () (or (getenv "EDITOR") *editor*))

(defun edit-file (file)
  "(edit-file file) edits a file."
  (open file :direction :probe :if-does-not-exist :create)
  (shell (format nil "~A ~A" (editor-name) (truename file))))

(defun editor-tempfile ()
  "The temporary file LISP creates for editing."
  (merge-pathnames "lisptemp.lisp" (user-homedir-pathname)))

(defparameter *load-paths*
  '(#"./"           ; in the current directory
    "~/lisp/**/")   ; in all directories below $HOME/lisp
  "The list of directories where programs are searched on LOAD etc.")

;; This makes screen output prettier:
(setq *print-pretty* t)

;; This perhaps makes pathname parsing more intuitive:
;;  ".clisprc" --> #S(pathname :name ".clisprc" :type nil)
(setq *parse-namestring-dot-file* :name)

;; which browser do you use? (see `*browsers*' in clhs.lisp)
;; (setq *browser* :firefox)

(defvar *impnotes-root-default* "http://clisp.org/impnotes/")
(defun impnotes-root ()
  "This returns the root URL for the CLISP implementation notes.
You can set the environment variable `IMPNOTES' or redefine this function
in ~/.clisprc.  On win32 you can also use the Registry."
  (or (getenv "IMPNOTES") *impnotes-root-default*))

;; Common Lisp HyperSpec access
(defvar *clhs-root-default*)
(defun clhs-root ()
  "This returns the root URL for the Common Lisp HyperSpec.
You can set the environment variable `CLHSROOT' or redefine this function
in ~/.clisprc.  On win32 you can also use the Registry."
  (or (getenv "CLHSROOT") *clhs-root-default*))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./cfgunix.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./defstruct.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Sources for CLISP DEFSTRUCT macro
;;; Bruno Haible 1988-2005
;;; Sam Steingold 1998-2010, 2017
;;; German comments translated into English: Stefan Kain 2003-01-14

(in-package "SYSTEM")

#| Explanation of the appearing data types:

   For structure types (but not for structure classes!):

   (get name 'DEFSTRUCT-DESCRIPTION) =
     #(type size keyword-constructor effective-slotlist direct-slotlist
       boa-constructors copier predicate defaultfun0 defaultfun1 ...)

   type (if the type of the whole structure is meant):
      = LIST                   storage as list
      = VECTOR                 storage as (simple-)vector
      = (VECTOR element-type)  storage as vector with element-type

   size is the list length / vector length.

   keyword-constructor = NIL or the name of the keyword-constructor
   boa-constructors = list of names of BOA constructors
   copier = NIL or the name of the copier function
   predicate = NIL or the name of the predicate function

   effective-slotlist is a packed description of the slots of a structure:
   effective-slotlist = ({slot}*)
   slot = an instance of structure-effective-slot-definition, containing:
         name - the slotname,
         initargs - a list containing the initialization argument,
              or NIL for the pseudo-slot containing the structure name in
              named structures,
         offset - the location of the slot in any instance,
         initer = (initform . initfunction) - as usual,
         init-function-form -
              a form (a symbol or a list (SVREF ...)), that yields
              upon evaluation in an arbitrary environment a function,
              that returns the default value, when called.
         type - the declared type for this slot,
         readonly = NIL or = T specifying, if this slot is readonly, i.e.
              after the construction of the Structure the slot cannot be
              changed with (setf ...) anymore.
         (See also pr_structure_default() in io.d.)
   direct-slotlist is the list of slots defined together with the structure:
   direct-slotlist = ({slot*})
   slot = an instance of structure-direct-slot-definition, containing:
         name, initform, initfunction, initargs, type, initer - see above
         writers - list of setters: ((setf struct-slot-name))
         readers - list of getters: (struct-slot-name)
   The initializations are specified as follows:
     - not real slot (i.e. initargs = ()):
       initform           = `(QUOTE ,name)
       initfunction       = a constant-initfunction for name
       init-function-form = `(MAKE-CONSTANT-INITFUNCTION ',name)
     - real slot with constant initform:
       initform           = as specified by the user
       initfunction       = a constant-initfunction for the initform's value
       init-function-form = `(MAKE-CONSTANT-INITFUNCTION ,initform)
     - real slot with non-constant initform:
       initform           = as specified by the user
       initfunction       = a closure taking 0 arguments, or nil
       init-function-form = for inherited slots: `(SVREF ...)
                            for direct slots: `(FUNCTION (LAMBDA () ,initform))
                            In both cases, after some processing: a gensym
                            referring to a binding.

   For structure classes, i.e. if type = T, all this information is contained
   in the CLOS class (get name 'CLOS::CLOSCLASS). In this case, all slots are
   real slots: the names list is stored in the first memory word already by
   ALLOCATE-INSTANCE, without need for corresponding effective-slot-definition.
|#

;; Indices of the fixed elements of a defstruct-description:
;; if you add a slot, you need to modify io.d:SYS::STRUCTURE-READER
(defconstant *defstruct-description-type-location* 0)
(defconstant *defstruct-description-size-location* 1)
(defconstant *defstruct-description-kconstructor-location* 2)
(defconstant *defstruct-description-slots-location* 3)
(defconstant *defstruct-description-direct-slots-location* 4)
(defconstant *defstruct-description-boa-constructors-location* 5)
(defconstant *defstruct-description-copier-location* 6)
(defconstant *defstruct-description-predicate-location* 7)
(proclaim '(constant-inline *defstruct-description-type-location*
                            *defstruct-description-size-location*
                            *defstruct-description-kconstructor-location*
                            *defstruct-description-slots-location*
                            *defstruct-description-direct-slots-location*
                            *defstruct-description-boa-constructors-location*
                            *defstruct-description-copier-location*
                            *defstruct-description-predicate-location*))

(defun make-ds-slot (name initargs offset initer type readonly)
  (clos::make-instance-<structure-effective-slot-definition>
    clos::<structure-effective-slot-definition>
    :name name
    :initargs initargs
    :initform (car initer) :initfunction (cdr initer) 'clos::inheritable-initer initer
    :type type
    'clos::readonly readonly
    'clos::location offset))
(defun copy-<structure-effective-slot-definition> (slot)
  (make-ds-slot
    (clos:slot-definition-name slot)
    (clos:slot-definition-initargs slot)
    (clos:slot-definition-location slot)
    (clos::slot-definition-inheritable-initer slot)
    (clos:slot-definition-type slot)
    (clos::structure-effective-slot-definition-readonly slot)))
(defmacro ds-real-slot-p (slot)
  `(not (null (clos:slot-definition-initargs ,slot))))
(defmacro ds-pseudo-slot-default (slot)
  ;; The pseudo-slots have an initform = (QUOTE name) and an initfunction which
  ;; returns the name.
  `(funcall (clos:slot-definition-initfunction ,slot)))

#| The type test comes in 4 variants. Keep them in sync! |#

#| Type test, for TYPEP.
   Must be equivalent to (typep object (ds-canonicalize-type symbol)).
|#
(defun ds-typep (object symbol desc)
  (declare (ignore symbol))
  (let ((type (svref desc *defstruct-description-type-location*))
        (size (svref desc *defstruct-description-size-location*)))
    (if (eq type 'LIST)
      (and (conses-p size object)
           (dolist (slot (svref desc *defstruct-description-slots-location*) t)
             (unless (ds-real-slot-p slot)
               (unless (eq (nth (clos:slot-definition-location slot) object)
                           (ds-pseudo-slot-default slot))
                 (return nil)))))
      (and (vectorp object) (simple-array-p object)
           (>= (length object) size)
           (equal (array-element-type object)
                  (if (consp type)
                    (upgraded-array-element-type (second type))
                    'T))
           (dolist (slot (svref desc *defstruct-description-slots-location*) t)
             (unless (ds-real-slot-p slot)
               (unless (and (simple-vector-p object)
                            (eq (svref object (clos:slot-definition-location slot))
                                (ds-pseudo-slot-default slot)))
                 (return nil))))))))

#| Type test expansion, for TYPEP compiler macro. |#
(defun ds-typep-expansion (objform symbol desc)
  (declare (ignore symbol))
  (let ((type (svref desc *defstruct-description-type-location*))
        (size (svref desc *defstruct-description-size-location*))
        (tmp (gensym)))
    `(LET ((,tmp ,objform))
       ,(if (eq type 'LIST)
          `(AND ,@(case size
                    (0 '())
                    (1 `((CONSP ,tmp)))
                    (t `((CONSES-P ,size ,tmp))))
                ,@(mapcan #'(lambda (slot)
                              (unless (ds-real-slot-p slot)
                                `((EQ (NTH ,(clos:slot-definition-location slot) ,tmp)
                                      ',(ds-pseudo-slot-default slot)))))
                          (svref desc *defstruct-description-slots-location*)))
          (let ((eltype (if (consp type)
                          (upgraded-array-element-type (second type))
                          'T)))
            `(AND ,@(if (eq eltype 'T)
                      `((SIMPLE-VECTOR-P ,tmp))
                      `((VECTORP ,tmp)
                        (SIMPLE-ARRAY-P ,tmp)
                        (EQUAL (ARRAY-ELEMENT-TYPE ,tmp) ',eltype)))
                  ,(case size
                     (0 'T)
                     (t `(>= (LENGTH ,tmp) ,size)))
                  ,@(mapcan #'(lambda (slot)
                                (unless (ds-real-slot-p slot)
                                  `((EQ (SVREF ,tmp ,(clos:slot-definition-location slot))
                                        ',(ds-pseudo-slot-default slot)))))
                            (svref desc *defstruct-description-slots-location*))))))))

#| Type canonicalization, for SUBTYPEP. |#
(defun ds-canonicalize-type (symbol)
  (let ((desc (get symbol 'DEFSTRUCT-DESCRIPTION)))
    (if desc
      (let ((type (svref desc *defstruct-description-type-location*))
            (size (svref desc *defstruct-description-size-location*))
            (slotlist (svref desc *defstruct-description-slots-location*)))
        (if (eq type 'LIST)
          (let ((resulttype 'T))
            ;; Start with T, not (MEMBER NIL), because of the possibility
            ;; of subclasses.
            (dotimes (i size) (setq resulttype (list 'CONS 'T resulttype)))
            (dolist (slot slotlist)
              (unless (ds-real-slot-p slot)
                (let ((resttype resulttype))
                  (dotimes (j (clos:slot-definition-location slot))
                    (setq resttype (third resttype)))
                  (setf (second resttype) `(EQL ,(ds-pseudo-slot-default slot))))))
            resulttype)
          `(AND (SIMPLE-ARRAY ,(if (consp type) (second type) 'T) (*))
                ;; Constraints that cannot be represented through ANSI CL
                ;; type specifiers. We use SATISFIES types with uninterned
                ;; symbols. This is possible because this function is only
                ;; used for SUBTYPEP.
                ,@(when (or (plusp size)
                            (some #'(lambda (slot) (not (ds-real-slot-p slot)))
                                  slotlist))
                    (let ((constraint-name (gensym)))
                      (setf (symbol-function constraint-name)
                            #'(lambda (x) (typep x symbol)))
                      `((SATISFIES ,constraint-name)))))))
      ; The DEFSTRUCT-DESCRIPTION was lost.
      'NIL)))

#| (ds-make-pred predname type name slotlist size)
   returns the form, that creates the type-test-predicate for
   the structure name.

   type         the type of the structure,
   name         the name of the structure,
   predname     the name of the type-test-predicate,
   slotlist     (only used when type /= T) list of slots
   size         instance size
|#
(defun ds-make-pred (predname type name slotlist size)
  `(,@(if (eq type 'T) `((PROCLAIM '(INLINE ,predname))) '())
    (DEFUN ,predname (OBJECT)
      ,(if (eq type 'T)
         `(%STRUCTURE-TYPE-P ',name OBJECT)
         (let ((max-offset -1)
               (max-name-offset -1))
           (dolist (slot+initff slotlist)
             (let ((slot (car slot+initff)))
               (setq max-offset (max max-offset (clos:slot-definition-location slot)))
               (unless (ds-real-slot-p slot)
                 (setq max-name-offset (max max-name-offset (clos:slot-definition-location slot))))))
           ; This code is only used when there is at least one named slot.
           (assert (<= 0 max-name-offset max-offset))
           (assert (< max-offset size))
           (if (eq type 'LIST)
             `(AND ,@(case size
                       (0 '())
                       (1 `((CONSP OBJECT)))
                       (t `((CONSES-P ,size OBJECT))))
                   ,@(mapcan #'(lambda (slot+initff)
                                 (let ((slot (car slot+initff)))
                                   (unless (ds-real-slot-p slot)
                                     `((EQ (NTH ,(clos:slot-definition-location slot) OBJECT)
                                           ',(ds-pseudo-slot-default slot))))))
                             slotlist))
             ; This code is only used when there is at least one named slot.
             ; Therefore the vector's upgraded element type must contain
             ; SYMBOL, i.e. it must be a general vector.
             `(AND (SIMPLE-VECTOR-P OBJECT)
                   (>= (LENGTH OBJECT) ,size)
                   ,@(mapcan #'(lambda (slot+initff)
                                 (let ((slot (car slot+initff)))
                                   (unless (ds-real-slot-p slot)
                                     `((EQ (SVREF OBJECT ,(clos:slot-definition-location slot))
                                           ',(ds-pseudo-slot-default slot))))))
                             slotlist))))))))

#| auxiliary function for both constructors:
   (ds-arg-default arg slot+initff)
   returns for an argument arg (part of the argument list) the part of
   the argument list, that binds this argument with the default for slot.
|#

(defun ds-arg-default (arg slot+initff)
  (let* ((slot (car slot+initff))
         (initer (clos::slot-definition-inheritable-initer slot))
         (initfunction (clos::inheritable-slot-definition-initfunction initer)))
    `(,arg
      ;; Initial value: If it is not a constant form, must funcall the
      ;; initfunction. If it is a constant, we can use the initform directly.
      ;; If no initform has been provided, ANSI CL says that "the consequences
      ;; are undefined if an attempt is later made to read the slot's value
      ;; before a value is explicitly assigned", i.e. we could leave the slot
      ;; uninitialized (= #<UNBOUND> in the structure case). But CLtL2 says
      ;; "the element's initial value is undefined", which implies that the
      ;; slot is initialized to an arbitrary value. We use NIL as this value.
      ,(if ; equivalent to (constantp (clos::inheritable-slot-definition-initform initer))
           (or (null initfunction) (constant-initfunction-p initfunction))
         (clos::inheritable-slot-definition-initform initer)
         `(FUNCALL ,(cdr slot+initff))))))

#| auxiliary function for both constructors:
   (ds-make-constructor-body type name names size slotlist get-var)
   returns the expression, that creates and fills a structure
   of given type.
|#
(defun ds-make-constructor-body (type name names size slotlist varlist)
  (if (and (or (eq type 'VECTOR) (eq type 'LIST))
           (do ((slotlistr slotlist (cdr slotlistr))
                (index 0 (1+ index)))
               ((null slotlistr) (eql index size))
             (let* ((slot+initff (car slotlistr))
                    (slot (car slot+initff)))
               (unless (eq (clos:slot-definition-location slot) index)
                 (return nil)))))
    ;; optimize the simple case
    `(,type ,@(mapcar #'(lambda (slot+initff var)
                          (let ((slot (car slot+initff)))
                            (if (ds-real-slot-p slot)
                              `(THE ,(clos:slot-definition-type slot) ,var)
                              `(QUOTE ,(ds-pseudo-slot-default slot)))))
                       slotlist varlist))
    `(LET ((OBJECT
             ,(cond ((eq type 'T) `(%MAKE-STRUCTURE ,names ,size))
                    ((eq type 'LIST) `(MAKE-LIST ,size))
                    ((consp type)
                     `(MAKE-ARRAY ,size :ELEMENT-TYPE ',(second type)))
                    (t `(MAKE-ARRAY ,size)))))
       ,@(mapcar
           #'(lambda (slot+initff var)
               (let* ((slot (car slot+initff))
                      (offset (clos:slot-definition-location slot)))
                 `(SETF
                    ,(cond ((eq type 'T)
                            `(%STRUCTURE-REF ',name OBJECT ,offset))
                           ((eq type 'LIST)
                            `(NTH ,offset OBJECT))
                           ((eq type 'VECTOR)
                            `(SVREF OBJECT ,offset))
                           (t `(AREF OBJECT ,offset)))
                    ,(if (or (eq type 'T) (ds-real-slot-p slot))
                       `(THE ,(clos:slot-definition-type slot) ,var)
                       `(QUOTE ,(ds-pseudo-slot-default slot))))))
           slotlist varlist)
       OBJECT)))

#| auxiliary function for ds-make-boa-constructor:

   (ds-arg-with-default arg slotlist)
   returns for an argument arg (part of the argument list) the part of
   the argument list, that binds this argument with the correct default value.
|#

(defun ds-arg-with-default (arg slotlist)
  (if (and (listp arg) (consp (cdr arg)))
    ;; default value is already supplied
    arg
    ;; no default value in the lambda-list
    (let* ((var (if (listp arg) (first arg) arg))
           (slot+initff (find (if (consp var) (second var) var) slotlist
                              :key #'(lambda (slot+initff)
                                       (clos:slot-definition-name (car slot+initff)))
                              :test #'eq)))
      (if slot+initff
        ;; slot found -> take its default value
        (ds-arg-default var slot+initff)
        ;; slot not found, no default value
        arg))))

#| (ds-make-boa-constructor descriptor type name names size slotlist whole-form)
   returns the form that defines the BOA-constructor.
|#
(defun ds-make-boa-constructor (descriptor type name names size slotlist whole-form)
  (let ((constructorname (first descriptor))
        (arglist (second descriptor)))
    (multiple-value-bind (reqs optvars optinits optsvars rest
                          keyflag keywords keyvars keyinits keysvars
                          allow-other-keys auxvars auxinits)
        (analyze-lambdalist arglist
          #'(lambda (lalist detail errorstring &rest arguments)
              (declare (ignore lalist)) ; use WHOLE-FORM instead
              (sys::lambda-list-error whole-form detail
                (TEXT "~S ~S: In ~S argument list: ~?")
                'defstruct name ':constructor errorstring arguments)))
      (let* ((argnames
               ; The list of all arguments that are already supplied with
               ; values through the parameter list.
               (append reqs optvars (if (not (eql rest 0)) (list rest))
                       keyvars auxvars))
             (new-arglist ; new argument list
               `(;; required args:
                 ,@reqs
                 ;; optional args:
                 ,@(if optvars
                     (cons '&optional
                           (mapcar #'(lambda (arg var init svar)
                                       (declare (ignore var init svar))
                                       (ds-arg-with-default arg slotlist))
                                   (cdr (memq '&optional arglist))
                                   optvars optinits optsvars))
                     '())
                 ;; &rest arg:
                 ,@(if (not (eql rest 0))
                     (list '&rest rest)
                     '())
                 ;; &key args:
                 ,@(if keyflag
                     (cons '&key
                           (append
                             (mapcar #'(lambda (arg symbol var init svar)
                                         (declare (ignore symbol var init svar))
                                         (ds-arg-with-default arg slotlist))
                                     (cdr (memq '&key arglist))
                                     keywords keyvars keyinits keysvars)
                             (if allow-other-keys '(&allow-other-keys) '())))
                     '())
                 ;; &aux args:
                 &aux
                 ,@(mapcar #'(lambda (arg var init)
                               (declare (ignore var init))
                               (ds-arg-with-default arg slotlist))
                           (cdr (memq '&aux arglist))
                           auxvars auxinits)
                 ,@(let ((slotinitlist nil))
                     (dolist (slot+initff slotlist)
                       (let ((slot (car slot+initff)))
                         (when (or (eq type 'T) (ds-real-slot-p slot))
                           (unless (memq (clos:slot-definition-name slot) argnames)
                             (push (ds-arg-with-default
                                     (clos:slot-definition-name slot) slotlist)
                                   slotinitlist)))))
                     (nreverse slotinitlist)))))
        `(DEFUN ,constructorname ,new-arglist
           ,(ds-make-constructor-body type name names size slotlist
              (mapcar #'(lambda (slot+initff)
                          (clos:slot-definition-name (car slot+initff)))
                      slotlist)))))))

#| (ds-make-keyword-constructor descriptor type name names size slotlist)
   returns the form, that defines the keyword-constructor. |#
(defun ds-make-keyword-constructor (descriptor type name names size slotlist)
  (let ((varlist
          (mapcar #'(lambda (slot+initff)
                      (let ((slot (car slot+initff)))
                        (if (or (eq type 'T) (ds-real-slot-p slot))
                          (make-symbol
                            (symbol-name (clos:slot-definition-name slot)))
                          nil)))
                  slotlist)))
    `(DEFUN ,descriptor
       (&KEY
        ,@(mapcan
            #'(lambda (slot+initff var)
                (let ((slot (car slot+initff)))
                  (if (or (eq type 'T) (ds-real-slot-p slot))
                    (list (ds-arg-default var slot+initff))
                    '())))
            slotlist varlist))
       ,(ds-make-constructor-body type name names size slotlist varlist))))

(defun ds-make-copier (copiername name type)
  (declare (ignore name))
  `(,@(if (or (eq type 'T) (eq type 'LIST))
        `((PROCLAIM '(INLINE ,copiername)))
        '())
    (DEFUN ,copiername (STRUCTURE)
      ,(if (eq type 'T)
         '(COPY-STRUCTURE STRUCTURE)
         (if (eq type 'LIST)
           '(COPY-LIST STRUCTURE)
           (if (consp type)
             `(LET* ((OBJ-LENGTH (ARRAY-TOTAL-SIZE STRUCTURE))
                     (OBJECT (MAKE-ARRAY OBJ-LENGTH :ELEMENT-TYPE
                                         (QUOTE ,(second type)))))
                (DOTIMES (I OBJ-LENGTH OBJECT)
                  (SETF (AREF OBJECT I) (AREF STRUCTURE I))))
             '(%COPY-SIMPLE-VECTOR STRUCTURE)))))))

(defun ds-accessor-name (slotname concname)
  (if concname
    (concat-pnames concname slotname)
    slotname))

(defun ds-make-readers (name names type concname slotlist)
  (mapcap
    #'(lambda (slot+initff)
        (let ((slot (car slot+initff)))
          (when (or (eq type 'T) (ds-real-slot-p slot))
            (let ((accessorname (ds-accessor-name (clos:slot-definition-name slot) concname))
                  (offset (clos:slot-definition-location slot))
                  (slottype (clos:slot-definition-type slot)))
              ;; This makes the macroexpansion depend on the current state
              ;; of the compilation environment, but it doesn't hurt because
              ;; the included structure's definition must already be
              ;; present in the compilation environment anyway. We don't expect
              ;; people to re-DEFUN defstruct accessors.
              (unless (memq (get accessorname 'SYSTEM::DEFSTRUCT-READER name)
                            (cdr names))
                `((PROCLAIM '(FUNCTION ,accessorname (,name) ,slottype))
                  (PROCLAIM '(INLINE ,accessorname))
                  (DEFUN ,accessorname (OBJECT)
                    (THE ,slottype
                      ,(cond ((eq type 'T)
                              `(%STRUCTURE-REF ',name OBJECT ,offset))
                             ((eq type 'LIST) `(NTH ,offset OBJECT))
                             ((consp type) `(AREF OBJECT ,offset))
                             (t `(SVREF OBJECT ,offset)))))
                  (SYSTEM::%PUT ',accessorname 'SYSTEM::DEFSTRUCT-READER
                                ',name)))))))
    slotlist))

(defun ds-make-writers (name names type concname slotlist)
  (mapcap
    #'(lambda (slot+initff)
        (let ((slot (car slot+initff)))
          (when (and (or (eq type 'T) (ds-real-slot-p slot))
                     (not (clos::structure-effective-slot-definition-readonly slot)))
            (let ((accessorname (ds-accessor-name (clos:slot-definition-name slot) concname))
                  (offset (clos:slot-definition-location slot))
                  (slottype (clos:slot-definition-type slot)))
              ;; This makes the macroexpansion depend on the current state
              ;; of the compilation environment, but it doesn't hurt because
              ;; the included structure's definition must already be
              ;; present in the compilation environment anyway. We don't expect
              ;; people to re-DEFUN or re-DEFSETF defstruct accessors.
              (unless (memq (get accessorname 'SYSTEM::DEFSTRUCT-WRITER name)
                            (cdr names))
                `((PROCLAIM '(FUNCTION (SETF ,accessorname) (,slottype ,name) ,slottype))
                  (PROCLAIM '(INLINE (SETF ,accessorname)))
                  (DEFUN (SETF ,accessorname) (VALUE OBJECT)
                    ,(if (eq type 'T)
                       `(%STRUCTURE-STORE ',name
                          OBJECT
                          ,offset
                          ,(if (eq 'T slottype)
                             `VALUE
                             `(THE ,slottype VALUE)))
                       (if (eq type 'LIST)
                         `(SETF (NTH ,offset OBJECT) VALUE)
                         (if (consp type)
                           `(SETF (AREF OBJECT ,offset) VALUE)
                           `(SETF (SVREF OBJECT ,offset) VALUE)))))
                  (SYSTEM::%PUT ',accessorname 'SYSTEM::DEFSTRUCT-WRITER
                                ',name)))))))
    slotlist))

(defun find-structure-class-slot-initfunction (classname slotname) ; ABI
  (let ((class (find-class classname)))
    (unless (clos::structure-class-p class)
      (error (TEXT "The class ~S is not a structure class: ~S")
             classname class))
    (let* ((slots (clos:class-slots class))
           (slot
             ; (find slotname (the list) slots :test #'clos:slot-definition-name)
             (dolist (s slots)
               (when (eql (clos:slot-definition-name s) slotname) (return s)))))
      (unless slot
        (error (TEXT "The class ~S has no slot named ~S.")
               classname slotname))
      (clos:slot-definition-initfunction slot))))

(defun find-structure-slot-initfunction (name slotname) ; ABI
  (let ((desc (get name 'DEFSTRUCT-DESCRIPTION)))
    (unless desc
      (if (clos::defined-class-p (get name 'CLOS::CLOSCLASS))
        (error (TEXT "The structure type ~S has been defined as a class.")
               name)
        (error (TEXT "The structure type ~S has not been defined.")
               name)))
    (let* ((slots (svref desc *defstruct-description-slots-location*))
           (slot
             ; (find slotname (the list) slots :test #'clos:slot-definition-name)
             (dolist (s slots)
               (when (eql (clos:slot-definition-name s) slotname) (return s)))))
      (unless slot
        (error (TEXT "The structure type ~S has no slot named ~S.")
               name slotname))
      (clos:slot-definition-initfunction slot))))

(defun ds-initfunction-fetcher (name type slotname)
  (if (eq type 'T)
    `(FIND-STRUCTURE-CLASS-SLOT-INITFUNCTION ',name ',slotname)
    `(FIND-STRUCTURE-SLOT-INITFUNCTION ',name ',slotname)))

;; A hook for CLOS
(predefun clos::defstruct-remove-print-object-method (name) ; preliminary
  (declare (ignore name))
  nil)

(defun make-load-form-slot-list (slotlist default-slots default-vars mlf)
  (mapcar #'(lambda (slot+initff)
              (let ((slot (car slot+initff)))
                (funcall mlf
                         slot
                         (let ((i (position slot+initff default-slots)))
                           (if i (nth i default-vars) (cdr slot+initff))))))
          slotlist))

(defmacro defstruct (&whole whole-form
                     name-and-options . docstring-and-slotargs)
  (let ((name                              name-and-options)
        (options                           nil)
        (conc-name-option                  t)
        (constructor-option-list           nil)
        (keyword-constructor               nil)
        (boa-constructors                  '())
        (copier-option                     t)
        (predicate-option                  0)
        (include-option                    nil)
         names
         namesform
        (namesbinding                      nil)
        (print-object-option               nil)
        (type-option                       t)
        (named-option                      0)
        (initial-offset-option             0)
        (initial-offset                    0)
        (docstring                         nil)
        (slotargs                          docstring-and-slotargs)
        (directslotlist                    nil) ; list of (slot . initff)
         size
        (include-skip                      0)
        (inherited-slot-count              0)
        (slotlist                          nil) ; list of (slot . initff)
        (slotdefaultvars                   nil)
        (slotdefaultfuns                   nil)
        (slotdefaultslots                  nil) ; list of (slot . initff)
        (slotdefaultdirectslots            nil) ; list of (slot . initff)
         constructor-forms                      )
    ;; check name-and-options:
    (when (listp name-and-options)
      (setq name (first name-and-options))
      (setq options (rest name-and-options)))
    ;; otherwise, name and options are already correct.
    (setq name (check-not-declaration name 'defstruct))
    ;; name is a symbol, options is the list of options.
    ;; processing the options:
    (dolist (option options)
      (when (keywordp option) (setq option (list option))) ; option without arguments
      (if (listp option)
        (if (keywordp (car option))
          (case (first option)
            (:CONC-NAME
             (setq conc-name-option (second option)))
            (:CONSTRUCTOR
               (if (atom (cdr option))
                 ;; default-keyword-constructor
                 (push (concat-pnames "MAKE-" name) constructor-option-list)
                 (let ((arg (second option)))
                   (setq arg (check-symbol arg 'defstruct))
                   (push
                     (if (atom (cddr option))
                       arg ; keyword-constructor
                       (if (not (listp (third option)))
                         (error-of-type 'source-program-error
                           :form whole-form
                           :detail (third option)
                           (TEXT "~S ~S: argument list should be a list: ~S")
                           'defstruct name (third option))
                         (rest option))) ; BOA-constructor
                     constructor-option-list))))
            (:COPIER
               (when (consp (cdr option))
                 (let ((arg (second option)))
                   (setq arg (check-symbol arg 'defstruct))
                   (setq copier-option arg))))
            (:PREDICATE
               (when (consp (cdr option))
                 (let ((arg (second option)))
                   (setq arg (check-symbol arg 'defstruct))
                   (setq predicate-option arg))))
            ((:INCLUDE :INHERIT)
               (if (null include-option)
                 (setq include-option option)
                 (error-of-type 'source-program-error
                   :form whole-form
                   :detail options
                   (TEXT "~S ~S: At most one :INCLUDE argument may be specified: ~S")
                   'defstruct name options)))
            ((:PRINT-FUNCTION :PRINT-OBJECT)
               (if (null (cdr option))
                 (setq print-object-option '(PRINT-STRUCTURE STRUCT STREAM))
                 (let ((arg (second option)))
                   (when (and (consp arg) (eq (first arg) 'FUNCTION))
                     (warn (TEXT "~S: Use of ~S implicitly applies FUNCTION.~@
                                     Therefore using ~S instead of ~S.")
                           'defstruct (first option) (second arg) arg)
                     (setq arg (second arg)))
                   (setq print-object-option
                         `(,arg STRUCT STREAM
                           ,@(if (eq (first option) ':PRINT-FUNCTION)
                                 '(*PRIN-LEVEL*) '()))))))
            (:TYPE (setq type-option (second option)))
            (:NAMED (setq named-option t))
            (:INITIAL-OFFSET (setq initial-offset-option (or (second option) 0)))
            (T (error-of-type 'source-program-error
                 :form whole-form
                 :detail (first option)
                 (TEXT "~S ~S: unknown option ~S")
                 'defstruct name (first option))))
          (error-of-type 'source-program-error
            :form whole-form
            :detail option
            (TEXT "~S ~S: invalid syntax in ~S option: ~S")
            'defstruct name 'defstruct option))
        (error-of-type 'source-program-error
          :form whole-form
          :detail option
          (TEXT "~S ~S: not a ~S option: ~S")
          'defstruct name 'defstruct option)))
    ;;; conc-name-option is either T or NIL or the :CONC-NAME argument.
    ;; constructor-option-list is a list of all :CONSTRUCTOR-arguments,
    ;;   each in the form  symbol  or  (symbol arglist . ...).
    ;; copier-option is either T or the :COPIER-argument.
    ;; predicate-option is either 0 or the :PREDICATE-argument.
    ;; include-option is either NIL or the entire
    ;;   :INCLUDE/:INHERIT-option.
    ;; print-object-option is NIL or a form for the body of the PRINT-OBJECT
    ;;   method.
    ;; type-option is either T or the :TYPE-argument.
    ;; named-option is either 0 or T.
    ;; initial-offset-option is either 0 or the :INITIAL-OFFSET-argument.
    ;;; inspection of the options:
    (setq named-option (or (eq type-option 'T) (eq named-option 'T)))
    ;; named-option (NIL or T) specifies, if the name is in the structure.
    (if named-option
      (when (eql predicate-option 0)
        (setq predicate-option (concat-pnames name "-P"))) ; defaultname
      (if (or (eql predicate-option 0) (eq predicate-option 'NIL))
        (setq predicate-option 'NIL)
        (error-of-type 'source-program-error
          :form whole-form
          :detail predicate-option
          (TEXT "~S ~S: There is no ~S for unnamed structures.")
          'defstruct name :predicate)))
    ;; predicate-option is
    ;;   if named-option=T: either NIL or the name of the type-test-predicate,
    ;;   if named-option=NIL meaningless.
    (when (eq conc-name-option 'T)
      (setq conc-name-option (string-concat (string name) "-")))
    ;; conc-name-option is the name prefix.
    (if constructor-option-list
      (setq constructor-option-list (remove 'NIL constructor-option-list))
      (setq constructor-option-list (list (concat-pnames "MAKE-" name))))
    ;; constructor-option-list is a list of all constructors that have to be
    ;; created, each in the form  symbol  or  (symbol arglist . ...).
    (if (eq copier-option 'T)
      (setq copier-option (concat-pnames "COPY-" name)))
    ;; copier-option is either NIL or the name of the copy function.
    (unless (or (eq type-option 'T)
                (eq type-option 'VECTOR)
                (eq type-option 'LIST)
                (and (consp type-option) (eq (first type-option) 'VECTOR)))
      (error-of-type 'source-program-error
        :form whole-form
        :detail type-option
        (TEXT "~S ~S: invalid :TYPE option ~S")
        'defstruct name type-option))
    ;; type-option is either T or LIST or VECTOR or (VECTOR ...)
    (unless (and (integerp initial-offset-option) (>= initial-offset-option 0))
      (error-of-type 'source-program-error
        :form whole-form
        :detail initial-offset-option
        (TEXT "~S ~S: The :INITIAL-OFFSET must be a nonnegative integer, not ~S")
        'defstruct name initial-offset-option))
    ;; initial-offset-option is an Integer >=0.
    (when (and (plusp initial-offset-option) (eq type-option 'T))
      (error-of-type 'source-program-error
        :form whole-form
        :detail options
        (TEXT "~S ~S: :INITIAL-OFFSET must not be specified without :TYPE : ~S")
        'defstruct name options))
    ;; if type-option=T, then initial-offset-option=0.
    (when (eq type-option 'T) (setq include-skip 1))
    ;; if type-option=T, include-skip is 1, else 0.
    (when (stringp (first docstring-and-slotargs))
      (setq docstring (first docstring-and-slotargs))
      (setq slotargs (rest docstring-and-slotargs)))
    ;; else, docstring and slotargs are already correct.
    ;; docstring is either NIL or a String.
    ;; slotargs are the remaining arguments.
    (if include-option
      (let* ((option (rest include-option))
             (subname (first option))
             (incl-class (get subname 'CLOS::CLOSCLASS))
             (incl-desc (get subname 'DEFSTRUCT-DESCRIPTION)))
        (unless (clos::defined-class-p incl-class)
          (setq incl-class nil))
        (when (and (null incl-class) (null incl-desc))
          (error-of-type 'source-program-error
            :form whole-form
            :detail subname
            (TEXT "~S ~S: included structure ~S has not been defined.")
            'defstruct name subname))
        (when (and incl-class (not (clos::structure-class-p incl-class)))
          (error-of-type 'source-program-error
            :form whole-form
            :detail subname
            (TEXT "~S ~S: included structure ~S is not a structure type.")
            'defstruct name subname))
        (when incl-class
          (setq names (cons name (clos::class-names incl-class)))
          (setq namesbinding
                (list
                  (list
                    (setq namesform (gensym))
                    `(CONS ',name (CLOS::CLASS-NAMES (GET ',subname 'CLOS::CLOSCLASS)))))))
        (unless (equalp (if incl-class 't (svref incl-desc *defstruct-description-type-location*)) type-option)
          (error-of-type 'source-program-error
            :form whole-form
            :detail subname
            (TEXT "~S ~S: included structure ~S must be of the same type ~S.")
            'defstruct name subname type-option))
        (setq slotlist
          (nreverse
            (mapcar #'(lambda (slot)
                        (cons (copy-<structure-effective-slot-definition> slot)
                              (ds-initfunction-fetcher subname type-option
                                (clos:slot-definition-name slot))))
                    (if incl-class
                      (clos:class-slots incl-class)
                      (svref incl-desc *defstruct-description-slots-location*)))))
        ;; slotlist is the reversed list of the inherited slots.
        (setq include-skip (if incl-class
                             (clos::class-instance-size incl-class)
                             (svref incl-desc *defstruct-description-size-location*)))
        (when slotlist
          (assert (> include-skip (clos:slot-definition-location (car (first slotlist))))))
        ;; include-skip >=0 is the number of slots that are already consumend
        ;;    by the substructure, the "size" of the substructure.
        ;; Process further arguments of the :INCLUDE-option:
        (dolist (slotarg (rest option))
          (let* ((slotname (if (atom slotarg) slotarg (first slotarg)))
                 (slot+initff (find slotname slotlist
                                    :key #'(lambda (slot+initff)
                                             (clos:slot-definition-name (car slot+initff)))
                                    :test #'eq)))
            (when (null slot+initff)
              (error-of-type 'source-program-error
                :form whole-form
                :detail slotname
                (TEXT "~S ~S: included structure ~S has no component with name ~S.")
                'defstruct name subname slotname))
            (let ((slot (car slot+initff)))
              (if (atom slotarg)
                ; overwrite default to NIL
                (progn
                  (setf (clos::slot-definition-inheritable-initer slot)
                        (cons 'NIL (make-constant-initfunction 'NIL)))
                  (setf (cdr slot+initff) `(MAKE-CONSTANT-INITFUNCTION NIL)))
                (progn
                  (let ((initform (second slotarg)))
                    (if (constantp initform)
                      (progn
                        (setf (clos::slot-definition-inheritable-initer slot)
                              (cons initform (make-constant-initfunction (eval initform))))
                        (setf (cdr slot+initff) `(MAKE-CONSTANT-INITFUNCTION ,initform)))
                      (progn
                        (setf (clos::slot-definition-inheritable-initer slot)
                              (cons initform nil)) ; FIXME
                        (setf (cdr slot+initff)
                              `(FUNCTION ,(concat-pnames "DEFAULT-" slotname)
                                 (LAMBDA () ,initform))))))
                  ;; Process the slot-options of this Slot-Specifier:
                  (do ((slot-arglistr (cddr slotarg) (cddr slot-arglistr)))
                      ((endp slot-arglistr))
                    (let ((slot-keyword (first slot-arglistr))
                          (slot-key-value (second slot-arglistr)))
                      (cond ((eq slot-keyword ':READ-ONLY)
                             (if slot-key-value
                               (setf (clos::structure-effective-slot-definition-readonly slot) t)
                               (if (clos::structure-effective-slot-definition-readonly slot)
                                 (error-of-type 'source-program-error
                                   :form whole-form
                                   :detail subname
                                   (TEXT "~S ~S: The READ-ONLY slot ~S of the included structure ~S must remain READ-ONLY in ~S.")
                                   'defstruct name slotname subname name)
                                 (setf (clos::structure-effective-slot-definition-readonly slot) nil))))
                            ((eq slot-keyword ':TYPE)
                             (unless
                                 (subtypep
                                   (type-for-discrimination slot-key-value)
                                   (type-for-discrimination (clos:slot-definition-type slot)))
                               (error-of-type 'source-program-error
                                 :form whole-form
                                 :detail subname
                                 (TEXT "~S ~S: The type ~S of slot ~S should be a subtype of the type defined for the included strucure ~S, namely ~S.")
                                 'defstruct name slot-key-value slotname subname
                                 (clos:slot-definition-type slot)))
                             (setf (clos:slot-definition-type slot) slot-key-value))
                            (t (error-of-type 'source-program-error
                                 :form whole-form
                                 :detail slot-keyword
                                 (TEXT "~S ~S: ~S is not a slot option.")
                                 'defstruct name slot-keyword)))))))
              (push (cons
                      (clos::make-instance-<structure-direct-slot-definition>
                        clos::<structure-direct-slot-definition>
                        :name slotname
                        :initform (clos:slot-definition-initform slot)
                        :initfunction (clos:slot-definition-initfunction slot)
                        :initargs (clos:slot-definition-initargs slot)
                        :type (clos:slot-definition-type slot)
                        'clos::inheritable-initer (clos::slot-definition-inheritable-initer slot)
                        ;; no readers/writers: these are inherited slots
                        :readers '()
                        :writers '())
                      (cdr slot+initff))
                    directslotlist))))
        (dolist (slot+initff slotlist)
          (let* ((slot (car slot+initff))
                 (initfunction (clos:slot-definition-initfunction slot)))
            (unless (or (null initfunction) (constant-initfunction-p initfunction))
              (let ((variable (gensym)))
                (push (cdr slot+initff) slotdefaultfuns)
                (push variable slotdefaultvars)
                (push slot+initff slotdefaultslots)
                (push nil slotdefaultdirectslots)
                (setf (cdr slot+initff) variable)))))
        (when (eq (first include-option) ':INHERIT)
          (setq inherited-slot-count (length slotlist))))
      (if (eq name 'STRUCTURE-OBJECT)
        (setq names (list name)
              namesform `',names)
        (setq names (cons name (clos::class-names (get 'STRUCTURE-OBJECT 'CLOS::CLOSCLASS)))
              namesbinding
              (list
                (list
                  (setq namesform (gensym))
                  `(CONS ',name (CLOS::CLASS-NAMES (GET 'STRUCTURE-OBJECT 'CLOS::CLOSCLASS))))))))
    ;; names is the include-nesting, namesform is the form belonging to it.
    ;; slotlist is the former slot list, reversed.
    ;; inherited-slot-count is the number of slots, that have to be ignored
    ;; when the accessors are created.
    (when (and named-option ; named structure
               (consp type-option) ; of type (VECTOR ...)
               ;; must be able to contain the name(s):
               (not (typep names (type-for-discrimination (second type-option)))))
      (error-of-type 'source-program-error
        :form whole-form
        :detail type-option
        (TEXT "~S ~S: structure of type ~S cannot hold the name.")
        'defstruct name type-option))
    ;; layout of the structure:
    ;; names, poss. include-slots, initial-offset-option times NIL, slots.
    ;; layout of vector or list:
    ;; include-part, initial-offset-option times NIL, poss. name, slots.
    (setq initial-offset (+ include-skip initial-offset-option))
    (unless (eq type-option 'T)
      (when named-option
        (push
          ; the type recognition pseudo-slot
          (cons
            (make-ds-slot nil
                          '()
                          initial-offset
                          (cons `(QUOTE ,name) (make-constant-initfunction name))
                          'SYMBOL ; type = symbol
                          T)      ; read-only
            `(MAKE-CONSTANT-INITFUNCTION ',name))
          slotlist)
        (incf initial-offset)))
    ;; the slots are situated behind initial-offset.
    ;; If type/=T (i.e vector or list) and named-option, the name is situated
    ;;   in Slot number  (1- initial-offset).
    ;; processing the slots:
    (let ((offset initial-offset))
      (dolist (slotarg slotargs)
        (let (slotname
              initform
              initfunction
              initfunctionform)
          (if (atom slotarg)
            (setq slotname slotarg  initform nil)
            (setq slotname (first slotarg)  initform (second slotarg)))
          ;; Here we compare slot names through their symbol-names, not through
          ;; #'eq, because if we have two slots P::X and Q::X, the two accessor
          ;; functions would have the same name FOO-X.
          (when (find (symbol-name slotname) slotlist
                      :test #'(lambda (name slot+initff)
                                (let ((slot (car slot+initff)))
                                  (and (or (eq type-option 'T) (ds-real-slot-p slot))
                                       (string= (clos:slot-definition-name slot) name)))))
            (error-of-type 'source-program-error
              :form whole-form
              :detail slotname
              (TEXT "~S ~S: There may be only one slot with the name ~S.")
              'defstruct name slotname))
          (let ((type t) (read-only nil))
            (when (consp slotarg)
              (do ((slot-arglistr (cddr slotarg) (cddr slot-arglistr)))
                  ((endp slot-arglistr))
                (let ((slot-keyword (first slot-arglistr))
                      (slot-key-value (second slot-arglistr)))
                  (cond ((eq slot-keyword ':READ-ONLY)
                         (setq read-only (if slot-key-value t nil)))
                        ((eq slot-keyword ':TYPE) (setq type slot-key-value))
                        (t (error-of-type 'source-program-error
                             :form whole-form
                             :detail slot-keyword
                             (TEXT "~S ~S: ~S is not a slot option.")
                             'defstruct name slot-keyword))))))
            (if (constantp initform)
              (setq initfunction (make-constant-initfunction (eval initform))
                    initfunctionform `(MAKE-CONSTANT-INITFUNCTION ,initform))
              (let ((variable (gensym)))
                (push
                  `(FUNCTION ,(concat-pnames "DEFAULT-" slotname)
                     (LAMBDA () ,initform))
                  slotdefaultfuns)
                (push variable slotdefaultvars)
                (setq initfunction nil ; FIXME
                      initfunctionform variable)))
            (let ((initer (cons initform initfunction))
                  (initargs (list (symbol-to-keyword slotname)))
                  (accessorname (ds-accessor-name slotname conc-name-option)))
              (when (eq predicate-option accessorname)
                (warn
                 (TEXT "~S ~S: Slot ~S accessor will shadow the predicate ~S.")
                 'defstruct name slotname predicate-option)
                (setq predicate-option nil))
              (push (cons
                      (clos::make-instance-<structure-direct-slot-definition>
                        clos::<structure-direct-slot-definition>
                        :name slotname
                        :initform initform
                        :initfunction initfunction
                        :initargs initargs
                        :type type
                        'clos::inheritable-initer initer
                        ;; we cannot recover accessor names later
                        ;; because of the :CONC-NAME option
                        :writers (if read-only '() (list `(SETF ,accessorname)))
                        :readers (list accessorname))
                      initfunctionform)
                    directslotlist)
              (push (cons
                      (make-ds-slot slotname
                                    initargs
                                    offset ; location
                                    initer
                                    ;; The following are defstruct specific.
                                    type read-only)
                      initfunctionform)
                    slotlist)
              (unless (constantp initform)
                (push (car slotlist) slotdefaultslots)
                (push (car directslotlist) slotdefaultdirectslots)))))
        (incf offset))
      (setq size offset))
    ;; size = total length of the structure
    (setq slotlist (nreverse slotlist))
    (setq directslotlist (nreverse directslotlist))
    (setq slotdefaultfuns (nreverse slotdefaultfuns))
    (setq slotdefaultvars (nreverse slotdefaultvars))
    (setq slotdefaultslots (nreverse slotdefaultslots))
    (setq slotdefaultdirectslots (nreverse slotdefaultdirectslots))
    ;; the slots in slotlist are now sorted in ascending order again.
    (setq constructor-forms
      (mapcar
        #'(lambda (constructor-option)
            (if (consp constructor-option)
              (ds-make-boa-constructor
                constructor-option type-option name namesform size slotlist whole-form)
              (progn
                (when (null keyword-constructor)
                  (setq keyword-constructor constructor-option))
                (ds-make-keyword-constructor
                  constructor-option type-option name namesform size
                  slotlist))))
        constructor-option-list))
    (setq boa-constructors
          (mapcan #'(lambda (constructor-option)
                      (when (consp constructor-option)
                        (list (first constructor-option))))
                  constructor-option-list))
    ;; constructor-forms = list of forms, that define the constructors.
    (mapc #'(lambda (slot+initff directslot+initff)
              (let* ((slot (car slot+initff))
                     (initfunctionform
                       (ds-initfunction-fetcher name type-option (clos:slot-definition-name slot))))
                (setf (cdr slot+initff) initfunctionform)
                (when directslot+initff
                  (setf (cdr directslot+initff) initfunctionform))))
          slotdefaultslots slotdefaultdirectslots)
    ;; now, slotlist contains no more slotdefaultvars.
    `(EVAL-WHEN (LOAD COMPILE EVAL)
       (LET ()
         (LET ,(append namesbinding (mapcar #'list slotdefaultvars slotdefaultfuns))
           ;; ANSI CL doesn't specify what happens when a structure is
           ;; redefined with different specification. We do here what DEFCLASS
           ;; also does: remove the accessory functions defined by the previous
           ;; specification.
           (STRUCTURE-UNDEFINE-ACCESSORIES ',name)
           ,(if (eq type-option 'T)
              `(REMPROP ',name 'DEFSTRUCT-DESCRIPTION)
              `(%PUT ',name 'DEFSTRUCT-DESCRIPTION
                     (VECTOR ',type-option
                             ,size
                             ',keyword-constructor
                             (LIST ,@(make-load-form-slot-list
                                      slotlist slotdefaultslots slotdefaultvars
                                      'clos::make-load-form-<structure-effective-slot-definition>))
                             (LIST ,@(make-load-form-slot-list
                                      directslotlist slotdefaultdirectslots
                                      slotdefaultvars
                                      'clos::make-load-form-<structure-direct-slot-definition>))
                             ',boa-constructors
                             ',copier-option
                             ',predicate-option)))
           ,@(if (eq type-option 'T)
              `((CLOS::DEFINE-STRUCTURE-CLASS ',name
                 ,namesform
                 ',keyword-constructor
                 ',boa-constructors
                 ',copier-option
                 ',predicate-option
                 (LIST ,@(make-load-form-slot-list
                          slotlist slotdefaultslots slotdefaultvars
                          'clos::make-load-form-<structure-effective-slot-definition>))
                 (LIST ,@(make-load-form-slot-list
                          directslotlist slotdefaultdirectslots slotdefaultvars
                          'clos::make-load-form-<structure-direct-slot-definition>))
                 ',docstring))
              `((CLOS::UNDEFINE-STRUCTURE-CLASS ',name)
                ;; see documentation.lisp: we map STRUCTURE to TYPE
                (sys::%set-documentation ',name 'TYPE ',docstring)))
           ,@constructor-forms)
         ,@(if (and named-option predicate-option)
             (ds-make-pred predicate-option type-option name slotlist size))
         ,@(if copier-option (ds-make-copier copier-option name type-option))
         ,@(let ((directslotlist (nthcdr inherited-slot-count slotlist)))
             `(,@(ds-make-readers name names type-option conc-name-option
                                  directslotlist)
               ,@(ds-make-writers name names type-option conc-name-option
                                  directslotlist)))
         ,@(when (eq type-option 'T)
             (list
               (if print-object-option
                 `(CLOS:DEFMETHOD CLOS:PRINT-OBJECT ((STRUCT ,name) STREAM)
                    (PROGN ,print-object-option))
                 `(CLOS::DEFSTRUCT-REMOVE-PRINT-OBJECT-METHOD ',name))))
         ',name))))


;; A kind of Meta-Object Protocol for structures.
;; These function apply to structures of any representation
;; (structure classes as well as subtypes of LIST or VECTOR).
;; This differs from the CLOS MOP
;;   1. in the use of a structure name (symbol) instead of a class,
;;   2. in the different set of available operations: classes in general
;;      don't have kconstructors, boa-constructors, copier, predicate,
;;      whereas on the other hand structures in general don't have a prototype
;;      and finalization.

(defun structure-slots (name)
  (let ((desc (get name 'DEFSTRUCT-DESCRIPTION)))
    (if desc
      (svref desc *defstruct-description-slots-location*)
      (let ((class (find-class name)))
        (clos::accessor-typecheck class 'structure-class 'structure-slots)
        (clos::class-slots class)))))
#|
 (defun (setf structure-slots) (new-value name)
  (let ((desc (get name 'DEFSTRUCT-DESCRIPTION)))
    (if desc
      (setf (svref desc *defstruct-description-slots-location*) new-value)
      (let ((class (find-class name)))
        (clos::accessor-typecheck class 'structure-class '(setf structure-slots))
        (setf (clos::class-slots class) new-value)))))
|#

(defun structure-direct-slots (name)
  (let ((desc (get name 'DEFSTRUCT-DESCRIPTION)))
    (if desc
      (svref desc *defstruct-description-direct-slots-location*)
      (let ((class (find-class name)))
        (clos::accessor-typecheck class 'structure-class 'structure-direct-slots)
        (clos::class-direct-slots class)))))
#|
 (defun (setf structure-slots) (new-value name)
  (let ((desc (get name 'DEFSTRUCT-DESCRIPTION)))
    (if desc
      (setf (svref desc *defstruct-description-direct-slots-location*) new-value)
      (let ((class (find-class name)))
        (clos::accessor-typecheck class 'structure-class '(setf structure-direct-slots))
        (setf (clos::class-direct-slots class) new-value)))))
|#

(defun structure-instance-size (name)
  (let ((desc (get name 'DEFSTRUCT-DESCRIPTION)))
    (if desc
      (svref desc *defstruct-description-size-location*)
      (let ((class (find-class name)))
        (clos::accessor-typecheck class 'structure-class 'structure-instance-size)
        (clos::class-instance-size class)))))
#|
 (defun (setf structure-instance-size) (new-value name)
  (let ((desc (get name 'DEFSTRUCT-DESCRIPTION)))
    (if desc
      (setf (svref desc *defstruct-description-size-location*) new-value)
      (let ((class (find-class name)))
        (clos::accessor-typecheck class 'structure-class '(setf structure-instance-size))
        (setf (clos::class-instance-size class) new-value)))))
|#

(defun structure-keyword-constructor (name)
  (let ((desc (get name 'DEFSTRUCT-DESCRIPTION)))
    (if desc
      (svref desc *defstruct-description-kconstructor-location*)
      (clos::class-kconstructor (find-class name)))))
#|
 (defun (setf structure-keyword-constructor) (new-value name)
  (let ((desc (get name 'DEFSTRUCT-DESCRIPTION)))
    (if desc
      (setf (svref desc *defstruct-description-kconstructor-location*) new-value)
      (setf (clos::class-kconstructor (find-class name)) new-value))))
|#

(defun structure-boa-constructors (name)
  (let ((desc (get name 'DEFSTRUCT-DESCRIPTION)))
    (if desc
      (svref desc *defstruct-description-boa-constructors-location*)
      (clos::class-boa-constructors (find-class name)))))
#|
 (defun (setf structure-boa-constructors) (new-value name)
  (let ((desc (get name 'DEFSTRUCT-DESCRIPTION)))
    (if desc
      (setf (svref desc *defstruct-description-boa-constructors-location*) new-value)
      (setf (clos::class-boa-constructors (find-class name)) new-value))))
|#

(defun structure-copier (name)
  (let ((desc (get name 'DEFSTRUCT-DESCRIPTION)))
    (if desc
      (svref desc *defstruct-description-copier-location*)
      (clos::class-copier (find-class name)))))
#|
 (defun (setf structure-copier) (new-value name)
  (let ((desc (get name 'DEFSTRUCT-DESCRIPTION)))
    (if desc
      (setf (svref desc *defstruct-description-copier-location*) new-value)
      (setf (clos::class-copier (find-class name)) new-value))))
|#

(defun structure-predicate (name)
  (let ((desc (get name 'DEFSTRUCT-DESCRIPTION)))
    (if desc
      (svref desc *defstruct-description-predicate-location*)
      (clos::class-predicate (find-class name)))))
#|
 (defun (setf structure-predicate) (new-value name)
  (let ((desc (get name 'DEFSTRUCT-DESCRIPTION)))
    (if desc
      (setf (svref desc *defstruct-description-predicate-location*) new-value)
      (setf (clos::class-predicate (find-class name)) new-value))))
|#

(defun structure-undefine-accessories (name) ; ABI
  (when (or (get name 'DEFSTRUCT-DESCRIPTION)
            (clos::structure-class-p (find-class name nil)))
    (macrolet ((fmakunbound-if-present (symbol-form)
                 `(let ((symbol ,symbol-form))
                    (when symbol (fmakunbound symbol)))))
      (fmakunbound-if-present (structure-keyword-constructor name))
      (mapc #'fmakunbound (structure-boa-constructors name))
      (fmakunbound-if-present (structure-copier name))
      (fmakunbound-if-present (structure-predicate name))
      (dolist (slot (structure-direct-slots name))
        (mapc #'fmakunbound (clos::slot-definition-readers slot))
        (mapc #'fmakunbound (clos::slot-definition-writers slot))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./defstruct.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./defseq.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Definitions for the standard sequence types
;; (in conjunction with SEQUENCE.D)
;; Bruno Haible 9.7.1989, 1.8.1989, 2.8.1989

(in-package "SYSTEM")

(%defseq
  (vector
    'LIST
    #'identity
    #'list-upd
    #'list-endtest
    #'list-fe-init
    #'list-upd
    #'list-endtest
    #'list-access
    #'list-access-set
    #'identity
    #'ext::list-length-proper
    #'make-list
    #'list-elt
    #'list-set-elt
    #'list-init-start
    #'list-fe-init-end
) )

(%defseq ; VECTOR stands for GENERAL-VECTOR
  (vector
    'VECTOR
    #'vector-init
    #'vector-upd
    #'vector-endtest
    #'vector-fe-init
    #'vector-fe-upd
    #'vector-fe-endtest
    #'aref
    #'sys::store
    #'identity
    #'vector-length
    #'make-array
    #'aref
    #'sys::store
    #'vector-init-start
    #'vector-fe-init-end
) )

(%defseq
  (vector
    'STRING
    #'vector-init
    #'vector-upd
    #'vector-endtest
    #'vector-fe-init
    #'vector-fe-upd
    #'vector-fe-endtest
    #'char
    #'sys::store
    #'identity
    #'vector-length
    #'make-string
    #'char
    #'sys::store
    #'vector-init-start
    #'vector-fe-init-end
) )

(mapc
  #'(lambda (n &aux (eltype (list 'UNSIGNED-BYTE n)))
      (%defseq
        (vector
          n ; n stands for `(VECTOR (UNSIGNED-BYTE ,n))
          #'vector-init
          #'vector-upd
          #'vector-endtest
          #'vector-fe-init
          #'vector-fe-upd
          #'vector-fe-endtest
          (if (= n 1) #'bit #'aref)
          #'sys::store
          #'identity
          #'vector-length
          (if (= n 1)
            #'make-bit-vector
            #'(lambda (length) (make-array length :element-type eltype)))
          (if (= n 1) #'bit #'aref)
          #'sys::store
          #'vector-init-start
          #'vector-fe-init-end
    ) ) )
  '(1 2 4 8 16 32)
)

(%defseq ; (VECTOR NIL)
  (vector
    0
    #'vector-init
    #'vector-upd
    #'vector-endtest
    #'vector-fe-init
    #'vector-fe-upd
    #'vector-fe-endtest
    #'aref
    #'sys::store
    #'identity
    #'vector-length
    #'(lambda (length) (make-array length :element-type nil))
    #'aref
    #'sys::store
    #'vector-init-start
    #'vector-fe-init-end))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./defseq.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./defs2.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ANSI-compatible definitions + some extensions
;;; Bruno Haible 21.7.1994 - 2006
;;; Sam Steingold 1999-2004, 2007-2009

;; ============================================================================

(in-package "COMMON-LISP")
(export '(declaim destructuring-bind complement
          constantly with-standard-io-syntax with-hash-table-iterator
          read-sequence write-sequence))
(export '(ext::trim-if) "EXT")
(in-package "SYSTEM")

;; ----------------------------------------------------------------------------

;; X3J13 vote <144>

(defmacro declaim (&rest decl-specs)
  `(PROGN
     ,@(mapcar #'(lambda (decl-spec) `(PROCLAIM (QUOTE ,decl-spec))) decl-specs)
   )
)

;; ----------------------------------------------------------------------------

;; X3J13 vote <64>

(defmacro destructuring-bind (&whole whole-form
                              lambdalist form &body body)
  (multiple-value-bind (body-rest declarations) (system::parse-body body)
    (if declarations (setq declarations `((DECLARE ,@declarations))))
    (let ((%whole-form whole-form) (%proper-list-p nil)
          (%arg-count 0) (%min-args 0) (%restp nil) (%null-tests nil)
          (%let-list nil) (%keyword-tests nil) (%default-form nil))
      (analyze1 lambdalist '<DESTRUCTURING-FORM> 'destructuring-bind '<DESTRUCTURING-FORM>)
      (let ((lengthtest (make-length-test '<DESTRUCTURING-FORM> 0))
            (mainform `(LET* ,(nreverse %let-list)
                         ,@declarations
                         ,@(nreverse %null-tests)
                         ,@(nreverse %keyword-tests)
                         ,@body-rest
           ))          )
        (if lengthtest
          (setq mainform
            `(IF ,lengthtest
               (DESTRUCTURING-ERROR <DESTRUCTURING-FORM>
                                    '(,%min-args . ,(if %restp nil %arg-count))
               )
               ,mainform
        ) )  )
        `(LET ((<DESTRUCTURING-FORM> ,form)) ,mainform)
) ) ) )

(defun destructuring-error (destructuring-form min.max) ; ABI
  (let ((min (car min.max))
        (max (cdr min.max)))
    (multiple-value-bind (length tail) (sys::list-length-dotted destructuring-form)
      (declare (ignore tail))
      (if (null length)
        (let ((*print-circle* t))
          (error-of-type 'program-error
            (TEXT "The object to be destructured should be a list with at most ~S elements, not the circular list ~S")
            min destructuring-form))
        (error-of-type 'program-error
          (TEXT "The object to be destructured should be a list with ~:[at least ~*~S~;~:[from ~S to ~S~;~S~]~] elements, not ~4@*~S.")
          max (eql min max) min max destructuring-form)
) ) ) )

;; Like destructuring-bind, except that it works only with ordinary
;; lambda-lists and generates more efficient code.
;; Compare   (disassemble #'(lambda (l) (destructuring-bind (&optional (o 'def)) l o)))
;; with      (disassemble #'(lambda (l) (simple-destructuring-bind (&optional (o 'def)) l o)))
(defmacro simple-destructuring-bind (lambdalist form &body body)
  `(APPLY #'(LAMBDA ,lambdalist ,@body) ,form))

;; ----------------------------------------------------------------------------

;; X3J13 vote <87>

(defun complement (fun)
  #'(lambda (&rest arguments) (not (apply fun arguments)))
)

;; ANSI-CL

(defun constantly (object)
  #'(lambda (&rest arguments) (declare (ignore arguments)) object)
)

;; ----------------------------------------------------------------------------

;; part of X3J13 vote <40>

(defconstant *common-lisp-user-package* (find-package "COMMON-LISP-USER")) ; ABI

(defmacro with-standard-io-syntax (&body body)
  ;; ANSI CL does not allow declarations at the beginning of the body, but
  ;; we do, as an extension.
  (multiple-value-bind (body-rest declarations) (SYSTEM::PARSE-BODY body)
    ;; It would be possible to put all these bindings into a single function,
    ;; but this would force variables into closures.
    `(LET (;; printer/reader variables:
           (*PACKAGE*                   *COMMON-LISP-USER-PACKAGE*)
           ;; printer variables:
           (*PRINT-ARRAY*               T)
           (*PRINT-BASE*                10)
           (*PRINT-CASE*                ':UPCASE)
           (*PRINT-CIRCLE*              NIL)
           (*PRINT-ESCAPE*              T)
           (*PRINT-GENSYM*              T)
           (*PRINT-LENGTH*              NIL)
           (*PRINT-LEVEL*               NIL)
           (*PRINT-LINES*               NIL)
           (*PRINT-MISER-WIDTH*         NIL)
           (*PRINT-PPRINT-DISPATCH*     (COPY-PPRINT-DISPATCH NIL))
           (*PRINT-PRETTY*              NIL)
           (*PRINT-RADIX*               NIL)
           (*PRINT-READABLY*            T)
           (*PRINT-RIGHT-MARGIN*        NIL)
           (*PRINT-CLOSURE*             NIL) ; CLISP specific
           (*PRINT-RPARS*               nil) ; CLISP specific
           (*PRINT-INDENT-LISTS*        1)   ; CLISP specific
           (SYSTEM::*PRIN-STREAM*       NIL) ; CLISP specific
           (SYSTEM::*PRIN-LINELENGTH*   79)  ; CLISP specific
           (SYSTEM::*PRIN-LINE-PREFIX*  NIL) ; CLISP specific
           (SYSTEM::*LOAD-FORMS*        NIL) ; CLISP specific
           ;; reader variables:
           (*READ-BASE*                 10)
           (*READ-DEFAULT-FLOAT-FORMAT* 'SINGLE-FLOAT)
           (*READ-EVAL*                 T)
           (*READ-SUPPRESS*             NIL)
           (*READTABLE*                 (COPY-READTABLE NIL)))
       ,@(if declarations `((DECLARE ,@declarations)))
       ,@body-rest)))

;; ----------------------------------------------------------------------------

;; part of X3J13 vote <98>

(defmacro with-hash-table-iterator ((macroname hashtable) &body body)
  (unless (symbolp macroname)
    (error (TEXT "~S: macro name should be a symbol, not ~S")
           'with-hash-table-iterator macroname))
  (let ((var (gensym "WHTI-")))
    `(LET ((,var (SYS::HASH-TABLE-ITERATOR ,hashtable)))
       (MACROLET ((,macroname () '(SYS::HASH-TABLE-ITERATE ,var) ))
         ,@body))))

;; ----------------------------------------------------------------------------

;; ANSI-CL

(defmacro lambda (&whole whole-form lambdalist &body body)
  (declare (ignore lambdalist body))
  `(FUNCTION ,whole-form))

;; ----------------------------------------------------------------------------

;; Make GET-MACRO-CHARACTER work on dispatch macro characters.
(let ((vector
        (let ((vector '#()))
          (declare (compile))
          ; This code must be in accordance with io.d:read_macro().
          (defun dispatch-reader (stream ch)
            (let ((arg 0)
                  subch)
              (let ((flag nil))
                (loop
                  (let ((nextch (read-char stream nil nil)))
                    (unless nextch
                      (error-of-type 'end-of-file
                        :stream stream
                        (TEXT "~S: input stream ~S ends within read macro beginning with ~S")
                        'read stream ch
                    ) )
                    (unless (characterp nextch)
                      (error-of-type 'stream-error
                        :stream stream
                        (TEXT "~S from ~S: character read should be a character: ~S")
                        'read stream ch
                    ) )
                    (unless (char<= #\0 nextch #\9)
                      (setq subch nextch)
                      (return)
                    )
                    (setq arg (+ (* 10 arg) (digit-char-p nextch)))
                    (setq flag t)
                ) )
                (unless flag (setq arg nil))
              )
              (let* ((subc (char-upcase subch))
                     (macrodef
                       (if (< (char-code subc) #x100)
                         (svref vector (char-code subc))
                         (gethash subc (svref vector #x100))
                    )) )
                (unless macrodef
                  (error-of-type 'stream-error
                    :stream stream
                    (TEXT "~S from ~S: After ~S is ~S an undefined dispatch macro character")
                    'read stream ch subch
                ) )
                (funcall macrodef stream subch arg)
          ) ) )
          vector
     )) )
  (let ((vector-index
          (do ((i 0 (1+ i)))
               (nil)
            (when (eq (closure-const #'dispatch-reader i) vector) (return i)))))
    (%defio #'dispatch-reader vector-index)
  )
)

;; -------------------------------------------------------------------------
;; READ-SEQUENCE and WRITE-SEQUENCE are badly specified because they assume
;; that the stream has a unique element type, either subtype of CHARACTER or
;; subtype of INTEGER. But some streams (esp. generic-streams) have a type
;; of (OR CHARACTER INTEGER).

;; This is a little hack to get the non-ambigouous cases right.
(defun stream-input-element-type (stream)
  (loop
    (typecase stream
      (SYNONYM-STREAM
       (setq stream (symbol-value (synonym-stream-symbol stream))))
      (ECHO-STREAM
       (setq stream (echo-stream-input-stream stream)))
      (TWO-WAY-STREAM
       (setq stream (two-way-stream-input-stream stream)))
      (T (return))))
  (stream-element-type stream))

(defun stream-output-element-type (stream)
  (loop
    (typecase stream
      (SYNONYM-STREAM
       (setq stream (symbol-value (synonym-stream-symbol stream))))
      (ECHO-STREAM
       (setq stream (echo-stream-output-stream stream)))
      (TWO-WAY-STREAM
       (setq stream (two-way-stream-output-stream stream)))
      (T (return))))
  (stream-element-type stream))

(defun %read-sequence (sequence stream &rest rest &key (start 0) (end nil))
  (declare (ignore start end))
  (let ((seltype (stream-input-element-type stream))
        (veltype (if (vectorp sequence) (array-element-type sequence) t)))
    (cond ((or (eq seltype 'NIL) (eq seltype 'CHARACTER)
               (eq veltype 'CHARACTER))
           (apply #'read-char-sequence sequence stream rest))
          ((or (subtypep seltype 'INTEGER) (subtypep veltype 'INTEGER))
           (apply #'read-byte-sequence sequence stream rest))
          (t
           (error (TEXT "~S: element types of ~S and ~S are ambiguous. Please use ~S or ~S.")
                  'read-sequence sequence stream
                  'read-char-sequence 'read-byte-sequence)))))

(defun read-sequence (sequence stream &rest rest &key (start 0) (end nil))
  (declare (ignore start end))
  (if (built-in-stream-p stream)
      (apply #'%read-sequence sequence stream rest)
      (apply 'gray::stream-read-sequence sequence stream rest)))

(defun %write-sequence (sequence stream &rest rest &key (start 0) (end nil))
  (declare (ignore start end))
  (let ((seltype (stream-output-element-type stream))
        (veltype (if (vectorp sequence) (array-element-type sequence) t)))
    (cond ((or (eq seltype 'NIL) (eq seltype 'CHARACTER)
               (eq veltype 'CHARACTER))
           (apply #'write-char-sequence sequence stream rest))
          ((or (subtypep seltype 'INTEGER) (subtypep veltype 'INTEGER))
           ;; `write-byte-sequence' accepts :NO-HANG and returns an extra value
           ;; since making `write-char-sequence' do the same would be hairy,
           ;; we ignore this second return value for the sake of ANSI
           (values (apply #'write-byte-sequence sequence stream rest)))
          (t
           (error (TEXT "~S: element types of ~S and ~S are ambiguous. Please use ~S or ~S.")
                  'write-sequence sequence stream
                  'write-char-sequence 'write-byte-sequence)))))

(defun write-sequence (sequence stream &rest rest &key (start 0) (end nil))
  (declare (ignore start end))
  (if (built-in-stream-p stream)
      (apply #'%write-sequence sequence stream rest)
      (apply 'gray::stream-write-sequence sequence stream rest)))

(defun trim-if (predicate sequence)
  (let ((beg (position-if-not predicate sequence)))
    (if beg
        (let ((end (1+ (position-if-not predicate sequence :from-end t))))
          (if (and (= beg 0) (= end (length sequence))) sequence
              (subseq sequence beg end)))
        (subseq sequence 0 0))))  ; empty sequence of the same type as argument

;; ----------------------------------------------------------------------------

;; ANSI-CL specifies TYPE-ERRORs in many places.
;; Here are the corresponding types.

;; (DESIGNATOR thing) is an abbreviation for many terms seen in the CLHS
;; glossary.

;; bounding index sequence    (START-INDEX sequence), (END-INDEX sequence)
;; character                  CHARACTER, BASE-CHAR
;; class                      CLASS
;; condition                  ---
;; extended function          EXTENDED-FUNCTION
;; external file format       ---
;; file position              FILE-POSITION
;; function                   FUNCTION
;; interval                   ---
;; list                       LIST
;; logical-host               LOGICAL-HOST
;; package                    PACKAGE
;; pathname                   PATHNAME
;; readtable                  READTABLE
;; restart                    RESTART
;; spreadable argument list   ---
;; stream                     STREAM
;; stream variable            ---
;; string                     STRING, (STRING length)

(deftype designator (thing)
  (cond ((symbolp thing)
         (case thing
;          (STRING
;            `(OR CHARACTER STRING SYMBOL)
;          )
           (CHARACTER
             `(OR CHARACTER
                  ,@(if (not *ansi*) `((INTEGER 0 ,(1- char-code-limit))))
                  (DESIGNATOR (STRING 1))
           )  )
           (BASE-CHAR
             `(OR BASE-CHAR
                  ,@(if (not *ansi*) `((INTEGER 0 ,(1- base-char-code-limit))))
                  #+BASE-CHAR=CHARACTER
                  (DESIGNATOR (STRING 1))
                  #-BASE-CHAR=CHARACTER
                  (AND (DESIGNATOR (STRING 1)) (SATISFIES BASE-CHAR-DESIGNATOR-P))
           )  )
;          (CLASS `(OR CLOS:CLASS (AND SYMBOL (SATISFIES CLASS-DESIGNATOR-P))))
;          (EXTENDED-FUNCTION
;            `(OR (AND (OR SYMBOL CONS) (SATISFIES FUNCTION-NAME-P)) FUNCTION)
;          )
;          (FILE-POSITION
;            `(OR (MEMBER :START :END) (INTEGER 0 *))
;          )
;          (FUNCTION
;            `(OR SYMBOL FUNCTION)
;          )
;          (LIST
;            `T
;          )
;          (LOGICAL-HOST
;            #-LOGICAL-PATHNAMES `NIL
;            #+LOGICAL-PATHNAMES `(OR STRING LOGICAL-PATHNAME)
;          )
;          (PACKAGE
;            `(OR (DESIGNATOR STRING) PACKAGE)
;          )
;          (PATHNAME
;            `(OR STRING FILE-STREAM PATHNAME)
;          )
;          (READTABLE
;            `(OR NULL READTABLE)
;          )
;          (RESTART
;            `(OR (AND SYMBOL (NOT NULL)) RESTART)
;          )
;          (STREAM
;            `(OR BOOLEAN STREAM)
;          )
           (t thing)
        ))
        ((consp thing)
         (case (first thing)
;          (START-INDEX
;            (let ((seq (second thing)))
;              (assert (typep seq 'SEQUENCE))
;              `(INTEGER 0 ,(length seq))
;          ) )
;          (END-INDEX
;            (let ((seq (second thing)))
;              (assert (typep seq 'SEQUENCE))
;              `(OR (INTEGER 0 ,(length (second thing))) NULL)
;          ) )
           (STRING
             (let ((n (second thing)))
               (assert (typep n '(INTEGER 0 *)))
               (let ((fun (intern (format nil "SYMBOL-OF-LENGTH-~D" n)
                                  (find-package "SYSTEM"))))
                 (unless (fboundp fun)
                   (setf (symbol-function fun)
                         #'(lambda (s)
                             (and (symbolp s) (eql (length (symbol-name s)) n))
                           )
                 ) )
                 `(OR ,@(if (eql n 1) '(CHARACTER) '())
                      (STRING ,n)
                      (AND SYMBOL (SATISFIES ,fun))
                  )
           ) ) )
           (t thing)
        ))
        (t (typespec-error 'designator thing))
) )

#-BASE-CHAR=CHARACTER
(defun base-char-designator-p (obj) ; ABI
  (base-char-p (char (coerce obj 'string) 0))
)

;(defun class-designator-p (sym &aux f)
;  (and (setq f (get sym 'CLOS::CLOSCLASS))
;       (clos::defined-class-p f)
;       (eq (clos:class-name f) sym)
;) )

(defun recognizable-sequence-type-p (typespec)
  (or (subtypep typespec 'LIST) (subtypep typespec 'VECTOR))
)

;; ----------------------------------------------------------------------------

(defmacro define-hash-table-test (name test hash)
  (setq name (check-symbol name 'define-hash-table-test))
  `(progn (setf (get ',name 'hash-table-test) (cons #',test #',hash)) ',name))

;; (default-directory) is a Synonym for (cd).
(defun default-directory () (cd))

;; (setf (default-directory) dir) is a Synonym for (cd dir).
(defsetf default-directory () (value)
  `(PROGN (CD ,value) ,value))

;; FORMAT-Control-String for output of dates,
;; applicable to a List (sec min hour day month year ...),
;; occupies 17-19 characters
(definternational date-format
  (t ENGLISH))
(deflocalized date-format ENGLISH
  (formatter
   "~1{~5@*~D-~4@*~2,'0D-~3@*~2,'0D ~2@*~2,'0D:~1@*~2,'0D:~0@*~2,'0D~:}"))
(defun date-format ()
  (localized 'date-format))
(defun date-string ()
  (with-output-to-string (s)
    (funcall (date-format) s (multiple-value-list (get-decoded-time)))))

;; list a directory
(defun dir (&optional (pathnames #+(or UNIX WIN32) '("*/" "*")))
  (flet ((onedir (pathname)
           (let ((pathname-list (directory pathname :full t :circle t)))
             (if (every #'atom pathname-list)
               (format t "~{~&~A~.~}"
                       (sort pathname-list #'string< :key #'namestring))
               (let ((date-format (date-format)))
                 (dolist (l (sort pathname-list #'string<
                                  :key #'(lambda (l) (namestring (first l)))))
                   (format t "~&~A~40T~7D~52T~21<~@?~>~."
                           (first l) (fourth l) date-format (third l))))))))
    (if (listp pathnames) (mapc #'onedir pathnames) (onedir pathnames)))
  (values))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./defs2.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./defs1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; some definitions for standard functions in LISP
;;;; 1.8.1989, 2.9.1989, 8.10.1989

(in-package "EXT")
(export '(expand-form doseq dohash without-package-lock memoized))

(export '(#-(or UNIX WIN32) custom::*default-time-zone*
          custom::*user-lib-directory*
          custom::*module-provider-functions*
          custom::*system-package-list*)
        "CUSTOM")
(ext:re-export "CUSTOM" "EXT")

(in-package "SYSTEM")

;;; code walker
(defun expand-form (form &aux *fenv* *venv*)
  (%expand-form form))

;;; functions for symbols (Chapter 10)

(defun copy-symbol (symbol &optional flag) ;; Common LISP, p. 169
  (let ((sym (make-symbol (symbol-name symbol))))
    (when flag
      (when (boundp symbol) (sys::set-symbol-value sym (symbol-value symbol)))
      (when (fboundp symbol) (sys::%set-symbol-function sym (symbol-function symbol)))
      (sys::%putplist sym (copy-list (symbol-plist symbol)))
      #| ;; No, ANSI CL does not say that the status of the symbol in the
         ;; global environment is copied as well.
      (cond ((constantp symbol) (sys::%proclaim-constant sym (symbol-value symbol)))
            ((sys::special-variable-p symbol) (proclaim `(SPECIAL ,sym)))
            ((sys::global-symbol-macro-p symbol) (sys::%proclaim-symbol-macro sym)))
      |#
      )
    sym))

;;; macros for packages (Chapter 11), p. 187-188
(defmacro do-symbols ((var &optional (packageform '*package*) (resultform nil))
                      &body body)
  (multiple-value-bind (body-rest declarations) (system::parse-body body)
    (let ((packvar (gensym "PACKAGE-")))
      `(BLOCK NIL
         (LET ((,packvar ,packageform))
           (LET ((,var NIL))
             (DECLARE (IGNORABLE ,var) ,@declarations)
             (SYSTEM::MAP-SYMBOLS
              #'(LAMBDA (,var)
                  ,@(if declarations `((DECLARE ,@declarations)) '())
                  (TAGBODY ,@body-rest))
               ,packvar)
             ,resultform))))))

(defmacro do-external-symbols ((var &optional (packageform '*package*)
                                    (resultform nil))
                               &body body)
  (multiple-value-bind (body-rest declarations) (system::parse-body body)
    (let ((packvar (gensym "PACKAGE-")))
      `(BLOCK NIL
         (LET ((,packvar ,packageform))
           (LET ((,var NIL))
             (DECLARE (IGNORABLE ,var) ,@declarations)
             (SYSTEM::MAP-EXTERNAL-SYMBOLS
               #'(LAMBDA (,var)
                   ,@(if declarations `((DECLARE ,@declarations)) '())
                   (TAGBODY ,@body-rest))
               ,packvar)
             ,resultform))))))

(defmacro do-all-symbols ((var &optional (resultform nil)) &body body)
  (multiple-value-bind (body-rest declarations) (system::parse-body body)
    `(BLOCK NIL
       (LET ((,var NIL))
         (DECLARE (IGNORABLE ,var) ,@declarations)
         (SYSTEM::MAP-ALL-SYMBOLS
           #'(LAMBDA (,var)
               ,@(if declarations `((DECLARE ,@declarations)) '())
               (TAGBODY ,@body-rest)))
         ,resultform))))

;;; <HS>/Body/mac_with-package-iterator.html
(defmacro with-package-iterator (&whole whole-form
                                 (name pack-list &rest types) &body body)
  (unless types
    (error-of-type 'source-program-error
      :form whole-form
      :detail types             ; == NIL
      (TEXT "missing symbol types (~S/~S/~S) in ~S")
      ':internal ':external ':inherited 'with-package-iterator))
  (dolist (symboltype types)
    (case symboltype
      ((:INTERNAL :EXTERNAL :INHERITED))
      (t (error-of-type 'source-program-error
           :form whole-form
           :detail symboltype
           (TEXT "~S: flag must be one of the symbols ~S, ~S, ~S, not ~S")
           'with-package-iterator ':internal ':external ':inherited
           symboltype))))
  (let ((iterfun (gensym "WPI-")))
    `(LET ((,iterfun (SYS::PACKAGE-ITERATOR-FUNCTION
                       ,pack-list ',(remove-duplicates types))))
       (MACROLET ((,name () '(FUNCALL ,iterfun)))
         ,@body))))
(defun package-iterator-function (pack-list symbol-types) ; ABI
  (let ((iterstates
          (mapcar #'(lambda (pack) (sys::package-iterator pack symbol-types))
                  (if (listp pack-list) pack-list (list pack-list)))))
    ;; The iterstates list is cdr'ed down during the iteration.
    #'(lambda ()
        (loop
          (if iterstates
            (multiple-value-bind (more symb acc)
                (sys::package-iterate (car iterstates))
              (if more
                (return (values more symb acc (svref (car iterstates) 4)))
                (pop iterstates)))
            (return nil))))))

(defvar *system-package-list*
  '("SYSTEM" "COMMON-LISP" "EXT" "I18N" "GRAY" "CHARSET" "CLOS"
    #+sockets "SOCKET" #+generic-streams "GSTREAM"
    #+ffi "FFI" #+screen "SCREEN")
  "The list of packages that will be locked by SAVEINITMEM.
Also the default packages to unlock by WITHOUT-PACKAGE-LOCK.")

;; Unlock the specified packages, execute the BODY, then lock them again.
(defmacro with-no-package-lock-internal (packages &body body)
  (let ((locked-packages (gensym "WOPL-")))
    `(LET ((,locked-packages (REMOVE-IF-NOT #'PACKAGE-LOCK ,packages)))
       (UNWIND-PROTECT
         (PROGN
           (SETF (PACKAGE-LOCK ,locked-packages) NIL)
           ,@body)
         (SETF (PACKAGE-LOCK ,locked-packages) T)))))
(defmacro without-package-lock (packages &body body)
  ;; NB: This is augmented by similar compiler processing,
  ;; see c-WITHOUT-PACKAGE-LOCK.
  `(WITH-NO-PACKAGE-LOCK-INTERNAL
     ,(if packages `',packages '*SYSTEM-PACKAGE-LIST*)
     ,@body))

;;; module administration (Chapter 11.8), CLTL p. 188

(defvar *modules* nil)

; Conversion from module name to string.
; cl-user::abc -> "ABC", cs-cl-user::abc -> "abc".
(defun module-name (name)
  (if (and (symbolp name)
           (symbol-package name)
           (package-case-inverted-p (symbol-package name)))
    (cs-cl:string name)
    (string name)))

(defun provide (name)
  (setq *modules* (adjoin (module-name name) *modules* :test #'string=)))

(defvar *user-lib-directory* nil
  "The location of user-installed modules.")

(defun load-path-augmentations (dynmod)
  (delete nil
    (list (merge-pathnames dynmod *lib-directory*)
          (and *user-lib-directory*
               (merge-pathnames dynmod *user-lib-directory*))
          (and *load-pathname* ; not truename to respect symlinks
               (make-pathname :name nil :type nil :defaults *load-pathname*))
          (and *compile-file-pathname* ; could be called by eval-when-compile
               (make-pathname :name nil :type nil
                              :defaults *compile-file-pathname*)))))

(defmacro with-augmented-load-path (dirs &body body)
  `(let ((*load-paths* *load-paths*))
     ;; cannot use UNION because DIRS must come _first_ in *LOAD-PATHS*
     ;; the name "dynmod/" used here should be in sync with clisp-link
     (dolist (path ,(if dirs
                        `(list ,@dirs)
                        '(load-path-augmentations "dynmod/")))
          (pushnew path *load-paths* :test #+win32 #'equalp #-win32 #'equal))
     ,@body))

(defvar *module-provider-functions* '()
  "The list of user functions to be called by REQUIRE if PATHNAME is missing.")

(defun simple-require (pathname)
  (with-augmented-load-path ()
    (if (atom pathname)
        (load pathname :ignore-pathname-defaults t)
        (mapcar (lambda (p) (load p :ignore-pathname-defaults t)) pathname))))

(defun require (module-name &optional (pathname nil p-given))
  (setq module-name (module-name module-name))
  (unless (member module-name *modules* :test #'string=)
    (prog1
        (if p-given (simple-require pathname)
            (dolist (f *module-provider-functions* (simple-require module-name))
              (let ((r (funcall f module-name)))
                (when r (return r)))))
      ;; we might have loaded a `system' package: lock it,
      ;; unless CLISP was started with "-d" and thus locking is not desired
      (when (package-lock "SYSTEM")
        (|(SETF PACKAGE-LOCK)| t *system-package-list*)))))

;;; integer constants (Chapter 12)

;; see file INTLOG.D
(defconstant boole-clr 0)
(defconstant boole-set 15)
(defconstant boole-1 10)
(defconstant boole-2 12)
(defconstant boole-c1 5)
(defconstant boole-c2 3)
(defconstant boole-and 8)
(defconstant boole-ior 14)
(defconstant boole-xor 6)
(defconstant boole-eqv 9)
(defconstant boole-nand 7)
(defconstant boole-nor 1)
(defconstant boole-andc1 4)
(defconstant boole-andc2 2)
(defconstant boole-orc1 13)
(defconstant boole-orc2 11)

;; for input of BYTEs:
(defun make-byte (&key size position) (byte size position))

;; X3J13 vote <79>
(defconstant least-positive-normalized-short-float least-positive-short-float)
(defconstant least-negative-normalized-short-float least-negative-short-float)
(defconstant least-positive-normalized-single-float least-positive-single-float)
(defconstant least-negative-normalized-single-float least-negative-single-float)
(defconstant least-positive-normalized-double-float least-positive-double-float)
(defconstant least-negative-normalized-double-float least-negative-double-float)
(proclaim
  '(constant-notinline
    least-positive-normalized-short-float
    least-negative-normalized-short-float
    least-positive-normalized-single-float
    least-negative-normalized-single-float
    least-positive-normalized-double-float
    least-negative-normalized-double-float))

;;; functions for sequences (Chapter 14)

(defmacro doseq ((var seqform &optional resultform) &body body)
  (multiple-value-bind (body-rest declarations) (system::parse-body body)
    (let ((seqvar (gensym "SEQ-")))
      `(BLOCK NIL
         (LET ((,seqvar ,seqform))
           (LET ((,var NIL))
             (DECLARE (IGNORABLE ,var) ,@declarations)
             (MAP NIL
                  #'(LAMBDA (,var)
                      ,@(if declarations `((DECLARE ,@declarations)) '())
                      (TAGBODY ,@body-rest))
                  ,seqvar)
             ,resultform))))))


;;; functions for lists (Chapter 15)

;; convert the SET represented as a LIST to a SET represented as a HASH-TABLE
(defun list-to-ht (l0 list &key test test-not key)
  (let ((n1 (list-length-proper l0))
        (n2 (list-length-proper list)))
    (unless test-not
      (let ((ht-test (case test
                       (eq 'fasthash-eq)
                       ((eql nil) 'fasthash-eql)
                       (equal 'fasthash-equal)
                       (equalp 'equalp)))) ; no separate fasthash & stablehash
        (when ht-test
          ;; --- boxers or briefs? ---
          ;; when is it worthwhile to use HASH-TABLEs as opposed to LISTS?
          ;; in sequence.d:seq_duplicates() we use a HASH-TABLE
          ;; when the list is longer than 10
          ;; here we use the following heuristic,
          ;; supported by a numeric experiment on Linux
          (unless (and (> n1 15) (> n2 5))
            (return-from list-to-ht nil))
          ;; passed the test, generate the HASH-TABLE
          (let ((ht (make-hash-table :test ht-test :size n2)))
            (unless key (setq key #'identity))
            (do ((tail list (cdr tail)))
                ((endp tail) ht)
              (sys::puthash (funcall key (car tail)) ht tail))))))))

;; Auxiliary version of MEMBER, which applies the :KEY argument also to items
;; used only by the recursive version
;(defun sys::member1 (item list &rest rest &key test test-not key)
;  (declare (ignore test test-not))
;  (apply #'member (if key (funcall key item) item) list rest))

(macrolet ((member? (item)
             (let ((i (gensym "ITEM-")) (k (gensym "KEY-")))
               `(let* ((,i ,item) (,k (if key (funcall key ,i) ,i)))
                  (if ht2
                      ;; values are non-NIL tails,
                      ;; so the first GETHASH value is good enough
                      (gethash ,k ht2)
                      (apply #'member ,k list2 rest))))))

(defun union (list1 list2 &rest rest &key test test-not key)
  (declare (ignore test test-not))
  #| ; recursive (not suitable for long lists):
  (cond ((endp list1) list2)
        ((apply #'sys::member1 (car list1) list2 rest)
         (apply #'union (cdr list1) list2 rest))
        (t (cons (car list1) (apply #'union (cdr list1) list2 rest))))
  |# ; iterative
  (let* ((list1-filtered '())
         (ht2 #1=(apply #'list-to-ht list1 list2 rest)))
    (dolist (item list1)
      (unless (member? item)
        (setq list1-filtered (cons item list1-filtered))))
    (nreconc list1-filtered list2)))

(defun nunion (list1 list2 &rest rest &key test test-not key)
  (declare (ignore test test-not))
  #| ; recursive (not suitable for long lists):
  (cond ((endp list1) list2)
        ((apply #'sys::member1 (car list1) list2 rest)
         (apply #'nunion (cdr list1) list2 rest))
        (t (rplacd list1 (apply #'nunion (cdr list1) list2 rest))))
  |# ; iterative
  (let* ((first nil) (last nil)
         (ht2 #1#))
    (do ((l list1 (cdr l)))
        ((endp l))
      (unless (member? (car l))
        (if last (rplacd last l) (setq first l))
        (setq last l)))
    (if last (progn (rplacd last list2) first) list2)))

(defun intersection (list1 list2 &rest rest &key test test-not key)
  (declare (ignore test test-not))
  #| ; recursive (not suitable for long lists):
  (cond ((endp list1) nil)
        ((apply #'sys::member1 (car list1) list2 rest)
         (cons (car list1)
               (apply #'intersection (cdr list1) list2 rest)))
        (t (apply #'intersection (cdr list1) list2 rest)))
  |# ; iterative
  (let* ((list1-filtered '())
         (ht2 #1#))
    (dolist (item list1)
      (when (member? item)
        (setq list1-filtered (cons item list1-filtered))))
    (list-nreverse list1-filtered)))

(defun nintersection (list1 list2 &rest rest &key test test-not key)
  (declare (ignore test test-not))
  #| ; recursive (not suitable for long lists):
  (cond ((endp list1) nil)
        ((apply #'sys::member1 (car list1) list2 rest)
         (rplacd list1 (apply #'nintersection (cdr list1) list2 rest)))
        (t (apply #'nintersection (cdr list1) list2 rest)))
  |# ; iterative
  (let* ((first nil) (last nil)
         (ht2 #1#))
    (do ((l list1 (cdr l)))
        ((endp l))
      (when (member? (car l))
        (if last (rplacd last l) (setq first l))
        (setq last l)))
    (if last (progn (rplacd last nil) first) nil)))

(defun set-difference (list1 list2 &rest rest &key test test-not key)
  (declare (ignore test test-not))
  #| ; recursive (not suitable for long lists):
  (cond ((endp list1) nil)
        ((not (apply #'sys::member1 (car list1) list2 rest))
         (cons (car list1)
               (apply #'set-difference (cdr list1) list2 rest)))
        (t (apply #'set-difference (cdr list1) list2 rest)))
  |# ; iterative
  (let* ((list1-filtered '())
         (ht2 #1#))
    (dolist (item list1)
      (unless (member? item)
        (setq list1-filtered (cons item list1-filtered))))
    (list-nreverse list1-filtered)))

(defun nset-difference (list1 list2 &rest rest &key test test-not key)
  (declare (ignore test test-not))
  #| ; recursive (not suitable for long lists):
  (cond ((endp list1) nil)
        ((not (apply #'sys::member1 (car list1) list2 rest))
         (rplacd list1 (apply #'nset-difference (cdr list1) list2 rest)))
        (t (apply #'nset-difference (cdr list1) list2 rest)))
  |# ; iterative
  (let* ((first nil) (last nil)
         (ht2 #1#))
    (do ((l list1 (cdr l)))
        ((endp l))
      (unless (member? (car l))
        (if last (rplacd last l) (setq first l))
        (setq last l)))
    (if last (progn (rplacd last nil) first) nil)))

(macrolet ((rev-arg (f) `(lambda (x y) (funcall ,f y x))))
  ;; this is done so that the elements of LIST1 and LIST2 are passed
  ;; to TEST and TEST-NOT always in the correct order
(defun set-exclusive-or (list1 list2 &rest rest &key test test-not key)
  (declare (ignore key))
  (append (apply #'set-difference list1 list2 rest)
          (apply #'set-difference list2 list1
                 (cond (test (list* :test (rev-arg test) rest))
                       (test-not (list* :test-not (rev-arg test-not) rest))
                       (rest)))))

(defun nset-exclusive-or (list1 list2 &rest rest &key test test-not key)
  (declare (ignore key))
  (nconc (apply #'set-difference list1 list2 rest)
         (apply #'nset-difference list2 list1
                (cond (test (list* :test (rev-arg test) rest))
                      (test-not (list* :test-not (rev-arg test-not) rest))
                      (rest)))))

) ; macrolet rev-arg

(defun subsetp (list1 list2 &rest rest &key test test-not key)
  (declare (ignore test test-not))
  (do* ((l list1 (cdr l))
        (ht2 #1#))
       ((endp l) t)
    (if (not (member? (car l))) (return nil))))

) ; macrolet member?

;; Like SUBST-IF, only that the substitution element is
;; given by a function and must not be a constant
(defun subst-if-then (newfun testfun tree &key (key #'identity))
  (labels ((subst (tree)
             (if (funcall testfun (funcall key tree))
               (funcall newfun tree)
               (if (consp tree)
                 (let* ((car (car tree)) (cdr (cdr tree))
                        (newcar (subst car)) (newcdr (subst cdr)))
                   (if (and (eq car newcar) (eq cdr newcdr))
                     tree
                     (cons newcar newcdr)))
                 tree))))
    (subst tree)))


;;; functions for hash tables (Chapter 16)

(defmacro dohash ((keyvar valuevar HTform &optional resultform) &body body)
  (multiple-value-bind (body-rest declarations) (system::parse-body body)
    (let ((HTvar (gensym "HASH-TABLE-")))
      `(BLOCK NIL
         (LET ((,HTvar ,HTform))
           (LET ((,keyvar NIL) (,valuevar NIL))
             (DECLARE (IGNORABLE ,keyvar ,valuevar) ,@declarations)
             (MAPHASH
               #'(LAMBDA (,keyvar ,valuevar)
                   ,@(if declarations `((DECLARE ,@declarations)) '())
                   (TAGBODY ,@body-rest))
               ,HTvar)
             ,resultform))))))

;; Different hash code algorithms for the same test.
(sys::%set-symbol-function 'ext:fasthash-eq #'eq)
(sys::%set-symbol-function 'ext:stablehash-eq #'eq)
(sys::%set-symbol-function 'ext:fasthash-eql #'eql)
(sys::%set-symbol-function 'ext:stablehash-eql #'eql)
(sys::%set-symbol-function 'ext:fasthash-equal #'equal)
(sys::%set-symbol-function 'ext:stablehash-equal #'equal)


;;; functions for strings (Chapter 18)

(defun string-trim (character-bag string)
  (sys::string-both-trim character-bag character-bag string nil))
(defun cs-cl::string-trim (character-bag string)
  (sys::string-both-trim character-bag character-bag string t))

(defun string-left-trim (character-bag string)
  (sys::string-both-trim character-bag nil string nil))
(defun cs-cl::string-left-trim (character-bag string)
  (sys::string-both-trim character-bag nil string t))

(defun string-right-trim (character-bag string)
  (sys::string-both-trim nil character-bag string nil))
(defun cs-cl::string-right-trim (character-bag string)
  (sys::string-both-trim nil character-bag string t))


;;; functions for pathnames (Chapter 23.1.5)
#+LOGICAL-PATHNAMES
(export '(custom::*load-logical-pathname-translations-database*) "CUSTOM")
#+LOGICAL-PATHNAMES
(ext:re-export "CUSTOM" "EXT")
#+LOGICAL-PATHNAMES
(progn
  (defvar *load-logical-pathname-translations-database* '(#p"loghosts"))
  (defun logical-pathname-translations (host)
    (setq host (string-upcase host))
    (or (gethash host *logical-pathname-translations*) ; :test #'equal !
        (error-of-type 'type-error :datum host :expected-type
          '(and string (satisfies logical-pathname-translations))
          (TEXT "~S: ~S does not name a logical host")
          'logical-pathname-translations host)))
  (defun set-logical-pathname-translations (host translations)
    (setq host (string-upcase host))
    (puthash host *logical-pathname-translations* ; :test #'equal !
             (mapcar #'(lambda (rule)
                         (cons (parse-namestring
                                (first rule) nil
                                (make-logical-pathname
                                 :host host :name :wild :type :wild
                                 :version :wild))
                               (rest rule)))
                     translations)))
  ;; load many hosts from a file, AllegroCL-style
  (defun load-lpt-many (file host &aux (*load-level* (1+ *load-level*)))
    (with-open-file (fi file :if-does-not-exist nil)
      (unless fi (return-from load-lpt-many nil))
      (loading-message (TEXT "Loading logical hosts from file ~A ...") file)
      (do* ((eof fi) (host (read fi nil eof) (read fi nil eof)))
           ((eq host eof) (loading-message (TEXT "Loaded file ~A") file))
        (setq host (string-upcase host))
        (set-logical-pathname-translations host (eval (read fi)))
        (loading-message (TEXT "Defined logical host ~A") host)))
    (gethash host *logical-pathname-translations*))
  ;; load a single host from a file, CMUCL-style
  (defun load-lpt-one (file host &aux (*load-level* (1+ *load-level*)))
    (with-open-file (fi file :if-does-not-exist nil)
      (unless fi (return-from load-lpt-one nil))
      (loading-message (TEXT "Loading logical host from file ~A ...") file)
      (set-logical-pathname-translations host (read fi))
      (loading-message (TEXT "Defined logical host ~A") host))
    (gethash host *logical-pathname-translations*))
  (defun load-logical-pathname-translations (host)
    (setq host (string-upcase host))
    (unless (gethash host *logical-pathname-translations*) ; :test #'equal !
      (let ((from (string-concat #2="LOGICAL_HOST_" host "_FROM"))
            (to (string-concat #2# host "_TO"))
            (ho (string-concat #2# host)))
        (cond ((and (fboundp 'getenv) (getenv from) (getenv to))
               (set-logical-pathname-translations
                host (list (list (getenv from) (getenv to))))
               (return-from load-logical-pathname-translations t))
              ((and (fboundp 'getenv) (getenv ho))
               (set-logical-pathname-translations
                host (read-from-string (getenv ho)))
               (return-from load-logical-pathname-translations t))
              ((dolist (file *load-logical-pathname-translations-database*)
                 (dolist (f (search-file file '(nil "host")))
                   (if (pathname-name f)
                     (when (load-lpt-many f host) ; host defined?
                       (return-from load-logical-pathname-translations t))
                     (dolist (f1 (nconc (directory (make-pathname
                                                    :name host :defaults f))
                                        (directory (make-pathname
                                                    :name host :type "host"
                                                    :defaults f))))
                       (when (load-lpt-one f1 host) ; host defined?
                         (return-from load-logical-pathname-translations
                           t)))))))))
      (error (TEXT "No translations for logical host ~S found") host)))
  (set-logical-pathname-translations "SYS"
    '((";*.LISP" "*.lisp") (";*" "*") ("*" "/*"))))


;;; functions for time (Chapter 25.4.1)

;; help function for macro TIME ; ABI
(defun %time (new-real1 new-real2 new-run1 new-run2 new-gc1 new-gc2
              new-space1 new-space2 new-gccount
              old-real1 old-real2 old-run1 old-run2 old-gc1 old-gc2
              old-space1 old-space2 old-gccount)
  (macrolet ((diff4 (newval1 newval2 oldval1 oldval2)
               (if (< internal-time-units-per-second 1000000)
                 ;; TIME_1: UNIX_TIMES
                 `(delta4 ,newval1 ,newval2 ,oldval1 ,oldval2 16)
                 ;; TIME_2: other UNIX, WIN32
                 `(+ (* (- ,newval1 ,oldval1) internal-time-units-per-second)
                     (- ,newval2 ,oldval2)))))
    (let ((Real-Time (diff4 new-real1 new-real2 old-real1 old-real2))
          (Run-Time (diff4 new-run1 new-run2 old-run1 old-run2))
          (GC-Time (diff4 new-gc1 new-gc2 old-gc1 old-gc2))
          (Space (delta4 new-space1 new-space2 old-space1 old-space2 24))
          (GC-Count (- new-gccount old-gccount))
          (stream *trace-output*))
      (fresh-line stream)
      (write-string "Real time: " stream)
      (write (float (/ Real-Time internal-time-units-per-second)) :stream stream)
      (write-string #1=" sec." stream)
      (terpri stream)
      (write-string "Run time: " stream)
      (write (float (/ Run-Time internal-time-units-per-second)) :stream stream)
      (write-string #1# stream)
      (terpri stream)
      (write-string "Space: " stream)
      (write Space :stream stream)
      (write-string " Bytes" stream)
      (when (or (plusp GC-Count) (plusp GC-Time))
        (terpri stream)
        (write-string "GC: " stream) (write GC-Count :stream stream)
        (write-string ", GC time: " stream)
        (write (float (/ GC-Time internal-time-units-per-second)) :stream stream)
        (write-string #1# stream))
      (elastic-newline stream))))

;; (sleep N) pause for N seconds. CLTL p. 447
(defun sleep (time)
  (if (and (realp time) (not (minusp time)))
    (progn
      ; Diese Fallunterscheidung hngt von sys::%sleep in time.d ab.
      #+UNIX
      (if (> time 16700000) ; mehr als 193 Tage?
        (loop (sys::%sleep 86400 0)) ; ja -> Endlosschleife
        (multiple-value-bind (seconds rest) (floor time)
          (sys::%sleep seconds (round (* rest 1000000)))))
      #+WIN32
      (if (> time 4250000) ; mehr als 49 Tage?
        (loop (sys::%sleep 86400 0)) ; ja -> Endlosschleife
        (multiple-value-bind (seconds rest) (floor time)
          (sys::%sleep seconds (round (* rest 1000))))))
    (error-of-type 'type-error
      :datum time :expected-type '(REAL 0 *)
      (TEXT "~S: argument ~S should be a nonnegative number")
      'sleep time)))


;; functions for Zeit-Umrechnung und Zeitzonen (CLTL Chapter 25.4.1)
;; Version 2, beinhaltet mehr Mathematik und basiert auf Mrz-Jahren

; Ein Mrz-Jahr sei die Periode vom 1.3. bis 28/29.2.
; Vorteil: Umrechnung Monat/Tag <--> Jahrtag wird einfacher.
; Skizze:
;   1.1.1900            1.1.1901            1.1.1902
;                                         
;   |-------------------|-------------------|-------------------|
;   |     Jahr 1900     |     Jahr 1901     |     Jahr 1902     |
;   |--|----------------|--|----------------|--|----------------|--|
;      |  Mrz-Jahr 1900   |  Mrz-Jahr 1901   |  Mrz-Jahr 1902   |
;      |-------------------|-------------------|-------------------|
;                                            
;      1.3.1900            1.3.1901            1.3.1902

; (UTag Jahr) = Nummer des Tages 1.3.Jahr (gegenber 1.1.1900)
; UTag(J) = 365*J + floor(J/4) - floor(J/100) + floor(J/400) - 693901
; damit  UTag(J) - UTag(J-1) = 365 + [1 falls J Schaltjahr]
; und    UTag(1899) = -306
; gelten.
(defun UTag (Jahr)
  (+ (* 365 Jahr) (floor Jahr 4) (- (floor Jahr 100)) (floor Jahr 400) -693901))

; Nherungwert:
; 365+1/4-1/100+1/400 = 365.2425 = 146097/400 .
; Durch Betrachtung einer Wertetabelle der 400-periodischen Funktion
; (J -> UTag(J)-146097/400*J) sieht man:
;   146097/400*J - 693902.4775 <= UTag(J) <= 146097/400*J - 693900.28

; Bestimmt zu einem Tag (0 = 1.1.1900) das Mrz-Jahr und den Tag im Mrz-Jahr.
; (Jahr&Tag UTTag) ==> Jahr, Jahrtag
; mit (= UTTag (+ (UTag Jahr) Jahrtag))
(defun Jahr&Tag (UTTag)
  ; Gesucht ist das grte Jahr mit UTag(Jahr) <= UTTag.
  ; Fr dieses Jahr J gilt
  ; 146097/400*J - 693902.4775 <= UTag(J) <= UTTag < UTag(J+1) <= 146097/400*J - 693535.0375,
  ; also 146097*J - 277560991 <= 400*UTTag < 146097*J - 277414015,
  ; also 146097*(J-1900) + 23309 <= 400*UTTag < 146097*(J-1900) + 170285,
  ; also J + 0.159544... <= 1900 + UTTag/(146097/400) < J + 1.165561... .
  (let* ((Jahr (+ 1900 (floor (- UTTag 58) 146097/400)))
         (Jahresanfang (UTag Jahr)))
    ; Wegen 146097*(J-1900) + 109 <= 400*(UTTag-58) < 146097*(J-1900) + 147084,
    ; also J <= 1900 + (UTTag-58)/(146097/400) < J+1.006755...,
    ; ist die Schtzung  Jahr := floor(1900 + (UTTag-58)/(146097/400))
    ; meist richtig und jedenfalls nicht zu klein und um hchstens 1 zu gro.
    (when (< UTTag Jahresanfang) ; zu gro?
      (decf Jahr)
      (setq Jahresanfang (UTag Jahr)))
    (values Jahr (- UTTag Jahresanfang))))

; Bei vielen Betriebssystemen (nicht bei UNIX, WIN32) muss die Zeitzone beim
; Installieren in timezone.lisp eingetragen werden. Hier stehen nur
; Defaultwerte.

#-(or UNIX WIN32)
; lokale Zeitzone
(defvar *default-time-zone* -1) ; Default: 1 h stlich GMT = MEZ
; NB: Zeitzone muss nicht ganzzahlig sein, sollte aber Vielfaches
; einer Sekunde sein.

#-(or UNIX WIN32)
; Funktion, die feststellt, ob bei gegebenem Mrz-Jahr und Tag und Stunde
; Sommerzeit gilt.
(defvar *default-dst-check* ; Default: Sommerzeit nicht explizit bekannt
  #'(lambda (Jahr Jahrtag Stunde) (declare (ignore Jahr Jahrtag Stunde)) nil))

; andere Abbildung  Jahrtag -> Monat  fr decode-universal-time:
; Seien Monat und Jahrtag auf den 1. Mrz bezogen
; (d.h. Jahrtag = 0 am 1. Mrz, = 364 am 28. Februar, usw.,
;  und Mrz=0,...,Dezember=9,Januar=10,Februar=11).
; Dann ist
;                Monat = floor(a*Jahrtag+b)
; sofern a und b so gewhlt sind, dass die Ungleichungen
;   122*a+b >= 4, 275*a+b >= 9, 30*a+b < 1, 336*a+b < 11
; gelten. Dies ist ein Viereck im Bereich
; 0.032653... = 8/245 <= a <= 7/214 = 0.032710...,
; 0.009345... = 1/107 <= b <= 1/49 = 0.020408...,
; in dem z.B. der Punkt (a=5/153,b=2/153) liegt:
;                Monat = floor((5*Jahrtag+2)/153).

; andere Abbildung  Monat -> Jahrtag
; fr encode-universal-time und decode-universal-time:
; Seien Monat und Jahrtag auf den 1. Mrz bezogen
; (d.h. Jahrtag = 0 am 1. Mrz, = 364 am 28. Februar, usw.,
;  und Mrz=0,...,Dezember=9,Januar=10,Februar=11).
; Die Abbildung
;      Monat   0  1  2  3  4   5   6   7   8   9   10  11
;      Jahrtag 0 31 61 92 122 153 184 214 245 275 306 337
; kann man schreiben
;                Jahrtag = floor(a*Monat+b)
; sofern a und b so gewhlt sind, dass die Ungleichungen
;   a+b >= 31, 11*a+b >= 337, 4*a+b < 123, 9*a+b < 276
; gelten. Dies ist ein Viereck im Bereich
; 30.5714... = 214/7 <= a <= 245/8 = 30.625,
; 0.375      = 3/8   <= b <= 5/7   = 0.7142...,
; in dem z.B. der Punkt (a=153/5,b=2/5) liegt:
;                Jahrtag = floor((153*Monat+2)/5).
; Dies ist allerdings langsamer als ein Tabellenzugriff.

(macrolet ((Monat->Jahrtag (Monat) ; 0 <= Monat < 12, 0=Mrz,...,11=Februar
             `(svref '#(0 31 61 92 122 153 184 214 245 275 306 337) ,Monat)))

; (encode-universal-time second minute hour date month year [time-zone]),
; CLTL p. 446
(defun encode-universal-time
              (Sekunde Minute Stunde Tag Monat Jahr &optional (Zeitzone nil)
               &aux Monat3 Jahr3 Jahrtag UTTag UT)
  (unless (and (and (integerp Jahr)
                    (progn
                      (when (<= 0 Jahr 99)
                        (multiple-value-bind (i1 i2 i3 i4 i5 Jahrjetzt)
                            (get-decoded-time)
                          (declare (ignore i1 i2 i3 i4 i5))
                          (setq Jahr
                                (+ Jahr (* 100 (ceiling (- Jahrjetzt Jahr 50)
                                                        100))))))
                      ;; 1900-01-01 GMT == 1899-12-31 EST
                      (<= 1899 Jahr)))
               (and (integerp Monat) (<= 1 Monat 12))
               (progn
                 (if (< Monat 3)
                   (setq Jahr3 (1- Jahr)  Monat3 (+ Monat 9))  ; Monat3 10..11
                   (setq Jahr3 Jahr       Monat3 (- Monat 3))) ; Monat3 0..9
                 (and (and (integerp Tag) (<= 1 Tag))
                      (progn
                        (setq Jahrtag (+ (1- Tag) (Monat->Jahrtag Monat3)))
                        (setq UTTag (+ Jahrtag (UTag Jahr3)))
                        (and (if (not (eql Monat3 11))
                               (< Jahrtag (Monat->Jahrtag (1+ Monat3)))
                               (< UTTag (UTag (1+ Jahr3))))
                             (and (integerp Stunde) (<= 0 Stunde 23))
                             (and (integerp Minute) (<= 0 Minute 59))
                             (and (integerp Sekunde) (<= 0 Sekunde 59))
                             (and (progn
                                    (unless Zeitzone
                                      (setq Zeitzone
                                        #-(or UNIX WIN32)
                                        (- *default-time-zone*
                                           (if (funcall *default-dst-check*
                                                        Jahr3 Jahrtag Stunde)
                                               1 0))
                                        #+(or UNIX WIN32)
                                        (default-time-zone
                                            (+ (* 24 UTTag) Stunde) nil)))
                                    (when (floatp Zeitzone)
                                      (setq Zeitzone (rational Zeitzone)))
                                    (or (integerp Zeitzone)
                                        (and (rationalp Zeitzone)
                                             (integerp (* 3600 Zeitzone)))))
                                  (<= -24 Zeitzone 24))
                             (<= 0 (setq UT (+ Sekunde
                                               (* 60 (+ Minute
                                                        (* 60 (+ Stunde Zeitzone
                                                                 (* 24 UTTag)))))))))))))
    (error-of-type 'error
      (TEXT "incorrect date: ~S-~S-~S ~S:~S:~S, time zone ~S")
      Jahr Monat Tag Stunde Minute Sekunde Zeitzone))
  UT)

; (decode-universal-time universal-time [time-zone]), CLTL p. 445
(defun decode-universal-time (UT &optional (time-zone nil)
                              &aux Sommerzeit Zeitzone)
  (if time-zone
    (setq Sommerzeit nil Zeitzone time-zone)
    #-(or UNIX WIN32)
    (setq time-zone *default-time-zone*
          Sommerzeit (let ((UT (- UT (round (* 3600 time-zone)))))
                       (multiple-value-bind (UTTag Stunde) (floor UT (* 3600 24))
                         (multiple-value-bind (Jahr Jahrtag) (Jahr&Tag UTTag)
                           (funcall *default-dst-check* Jahr Jahrtag Stunde))))
          Zeitzone (if Sommerzeit (1- time-zone) time-zone))
    #+(or UNIX WIN32)
    (progn
      (multiple-value-setq (Zeitzone Sommerzeit)
        (default-time-zone (floor UT 3600) t))
      (setq time-zone (if Sommerzeit (1+ Zeitzone) Zeitzone))))
  ; time-zone = Zeitzone ohne Sommerzeitbercksichtigung,
  ; Zeitzone = Zeitzone mit Sommerzeitbercksichtigung.
  (let ((UTSekunden (- UT (round (* 3600 Zeitzone)))))
    (multiple-value-bind (UTMinuten Sekunde) (floor UTSekunden 60)
      (multiple-value-bind (UTStunden Minute) (floor UTMinuten 60)
        (multiple-value-bind (UTTage Stunde) (floor UTStunden 24)
          (multiple-value-bind (Jahr Jahrtag) (Jahr&Tag UTTage)
            (let* ((Monat (floor (+ (* 5 Jahrtag) 2) 153))
                   (Tag (1+ (- Jahrtag (Monat->Jahrtag Monat)))))
              (if (< Monat 10) ; Monat Mrz..Dezember?
                (setq Monat (+ Monat 3)) ; Monat 3..12
                (setq Monat (- Monat 9) Jahr (+ Jahr 1))) ; Monat 1..2
              (values Sekunde Minute Stunde Tag Monat Jahr (mod UTTage 7)
                      Sommerzeit time-zone))))))))
) ; end of macrolet

; (get-decoded-time), CLTL p. 445
(defun get-decoded-time ()
  (decode-universal-time (get-universal-time)))


;;; Verschiedenes

; (concat-pnames obj1 obj2) liefert zu zwei Objekten (Symbolen oder Strings)
;  ein Symbol, dessen Printname sich aus den beiden Objekten zusammensetzt.
(defun concat-pnames (obj1 obj2)
  (let ((str (string-concat (string obj1) (string obj2))))
    (if (and (plusp (length str)) (eql (char str 0) #\:))
      (intern (subseq str 1) *keyword-package*)
      (intern str))))

; Gibt object in einen String aus, der nach Mglichkeit hchstens max Spalten
; lang sein soll.
(defun write-to-short-string (object max)
  ; Methode: probiere
  ; level = 0: length = 0,1,2
  ; level = 1: length = 1,2,3,4
  ; level = 2: length = 2,...,6
  ; usw. bis maximal level = 16.
  ; Dabei level mglichst gro, und bei festem level length mglichst gro.
  (if (or (numberp object) (symbolp object)) ; von length und level unbeeinflusst?
    (write-to-string object)
    (macrolet ((minlength (level) `,level)
               (maxlength (level) `(* 2 (+ ,level 1))))
      ; Um level mglist gro zu bekommen, dabei length = minlength whlen.
      (let* ((level ; Binrsuche nach dem richtigen level
               (let ((level1 0) (level2 16))
                 (loop
                   (when (= (- level2 level1) 1) (return))
                   (let ((levelm (floor (+ level1 level2) 2)))
                     (if (<= (string-width (write-to-string object :level levelm :length (minlength levelm))) max)
                       (setq level1 levelm) ; levelm passt, probiere grere
                       (setq level2 levelm) ; levelm passt nicht, probiere kleinere
                 ) ) )
                 level1
             ) )
             (length ; Binrsuche nach dem richtigen length
               (let ((length1 (minlength level)) (length2 (maxlength level)))
                 (loop
                   (when (= (- length2 length1) 1) (return))
                   (let ((lengthm (floor (+ length1 length2) 2)))
                     (if (<= (string-width (write-to-string object :level level :length lengthm)) max)
                       (setq length1 lengthm) ; lengthm passt, probiere grere
                       (setq length2 lengthm) ; lengthm passt nicht, probiere kleinere
                 ) ) )
                 length1
            )) )
        (write-to-string object :level level :length length)
) ) ) )

(defmacro memoized (form)
  "(MEMOIZED form) memoizes the result of FORM from its first evaluation."
  `(LET ((MEMORY
           (IF (EVAL-WHEN (EVAL) T)
             ',(cons nil nil)
             ;; Careful: Different expansions of MEMOIZED forms must yield
             ;; LOAD-TIME-VALUE forms that are not EQ, otherwise compile-file
             ;; will coalesce these LOAD-TIME-VALUE forms. Therefore here we
             ;; explicitly cons up the list and don't use backquote.
             ,(list 'LOAD-TIME-VALUE '(CONS NIL NIL)))))
     (UNLESS (CAR MEMORY)
       (SETF (CDR MEMORY) ,form)
       (SETF (CAR MEMORY) T))
     (CDR MEMORY)))

;; *ERROR-HANDLER* should be NIL or a function which accepts the following
;; arguments:
;;  - NIL (in case of ERROR) or a continue-format-string (in case of CERROR),
;;  - error-format-string,
;;  - more argument list for these two format strings,
;;  and which may return only if the first argument is /= NIL.
(defvar *error-handler* nil)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./defs1.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./defpackage.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ANSI-compatible definitions
;;; Bruno Haible 21.7.1994
;;; Sam Steingold 1999-2005

;; ============================================================================

(in-package "COMMON-LISP")
(export '(defpackage))
(in-package "SYSTEM")

;; ----------------------------------------------------------------------------

;; X3J13 vote <52>

;; Package-Definition und -Installation, CLtL2 S. 270
(defmacro defpackage (&whole whole-form
                      packname &rest options)
  (setq packname (string packname))
  ;; Process important options:
  (let ((case-sensitive nil) ; flag for :CASE-SENSITIVE
        (case-inverted nil)  ; flag for :CASE-INVERTED
        (modern :DEFAULT))   ; flag for :MODERN
    ;; Process :MODERN first, because it specifies some defaults.
    (dolist (option options)
      (when (listp option)
        (case (first option)
          (:MODERN ; CLISP extension
           (setq modern (second option))
           (setq case-inverted (setq case-sensitive (not (null modern))))))))
    (dolist (option options)
      (when (listp option)
        (case (first option)
          (:CASE-SENSITIVE ; CLISP extension
           (setq case-sensitive (not (null (second option)))))
          (:CASE-INVERTED ; CLISP extension
           (setq case-inverted (not (null (second option))))))))
    (let ((to-string (if case-inverted #'cs-cl:string #'cl:string)))
      ;; Process options:
      (let ((size nil) ; :SIZE has been supplied
            (documentation nil) ; :DOCUMENTATION string
            (nickname-list '()) ; list of nicknames
            (shadow-list '()) ; list of symbol names to shadow
            (shadowing-list '()) ; list of pairs (symbol-name . package-name) for shadowing-import
            (use-list '()) ; list of package-names for use-package
            (use-default "COMMON-LISP") ; default use-list
            (import-list '()) ; list of (symbol-name . package-name) for import
            (intern-list '()) ; list of symbol-names for intern
            (symname-list '()) ; list of all symbol names specified so far
            (export-list '())) ; liste of symbol-names for export
        (flet ((record-symname (name)
                 (if (member name symname-list :test #'string=)
                   (error-of-type 'source-program-error
                     :form whole-form
                     :detail name
                     (TEXT "~S ~A: the symbol ~A must not be specified more than once")
                     'defpackage packname name)
                   (push name symname-list)))
               (modernize (name)
                 ;; MODERN: CL ==> CS-CL
                 (let ((pack (if (packagep name) name
                                 (sys::%find-package (string name)))))
                   (ecase modern
                     ((t) (if (eq pack #.(find-package "COMMON-LISP"))
                              "CS-COMMON-LISP" (package-name pack)))
                     ((nil) (if (eq pack #.(find-package "CS-COMMON-LISP"))
                                "COMMON-LISP" (package-name pack)))
                     ((:DEFAULT) (package-name pack))))))
          (setq use-default (modernize use-default))
          (dolist (option options)
            (if (listp option)
              (if (keywordp (car option))
                (case (first option)
                  (:SIZE
                   (if size
                     (error-of-type 'source-program-error
                       :form whole-form
                       :detail options
                       (TEXT "~S ~A: the ~S option must not be given more than once")
                       'defpackage packname ':SIZE)
                     (setq size t))) ; ignored
                  (:DOCUMENTATION ; ANSI-CL
                   (if documentation
                     (error-of-type 'source-program-error
                       :form whole-form
                       :detail options
                       (TEXT "~S ~A: the ~S option must not be given more than once")
                       'defpackage packname ':DOCUMENTATION)
                     (setq documentation (second option))))
                  (:NICKNAMES
                   (dolist (name (rest option))
                     (push (string name) nickname-list)))
                  (:SHADOW
                   (dolist (name (rest option))
                     (setq name (funcall to-string name))
                     (unless (member name shadow-list :test #'string=)
                       (push name shadow-list)
                       (record-symname name))))
                  (:SHADOWING-IMPORT-FROM
                   (let ((pack (modernize (second option))))
                     (dolist (name (cddr option))
                       (setq name (funcall to-string name))
                       (let ((name+pack (cons name pack)))
                         (unless (member name+pack shadowing-list :test #'equal) ; #'string= on car and cdr
                           (push name+pack shadowing-list)
                           (record-symname name))))))
                  (:USE
                   (dolist (name (rest option))
                     (push (modernize name) use-list))
                   (setq use-default nil))
                  (:IMPORT-FROM
                   (let ((pack (modernize (second option))))
                     (dolist (name (cddr option))
                       (setq name (funcall to-string name))
                       (let ((name+pack (cons name pack)))
                         (unless (member name+pack import-list :test #'equal) ; #'string= on car and cdr
                           (push name+pack import-list)
                           (record-symname name))))))
                  (:INTERN
                   (dolist (name (rest option))
                     (setq name (funcall to-string name))
                     (unless (member name intern-list :test #'string=)
                       (push name intern-list)
                       (record-symname name))))
                  (:EXPORT
                   (dolist (name (rest option))
                     (setq name (funcall to-string name))
                     (unless (member name export-list :test #'string=)
                       (push name export-list))))
                  (:CASE-SENSITIVE) ; CLISP extension, already handled above
                  (:CASE-INVERTED) ; CLISP extension, already handled above
                  (:MODERN) ; CLISP extension, already handled above
                  (T (error-of-type 'source-program-error
                       :form whole-form
                       :detail (first option)
                       (TEXT "~S ~A: unknown option ~S")
                       'defpackage packname (first option))))
                (error-of-type 'source-program-error
                  :form whole-form
                  :detail option
                  (TEXT "~S ~A: invalid syntax in ~S option: ~S")
                  'defpackage packname 'defpackage option))
              (error-of-type 'source-program-error
                :form whole-form
                :detail option
                (TEXT "~S ~A: not a ~S option: ~S")
                'defpackage packname 'defpackage option)))
          ;; Check for overlaps between intern-list and export-list:
          (setq symname-list intern-list)
          (mapc #'record-symname export-list))
        ;; Reverse lists and apply default values:
        (setq nickname-list (nreverse nickname-list))
        (setq shadow-list (nreverse shadow-list))
        (setq shadowing-list (nreverse shadowing-list))
        (setq use-list (if use-default (list use-default) (nreverse use-list)))
        (setq import-list (nreverse import-list))
        (setq intern-list (nreverse intern-list))
        (setq export-list (nreverse export-list))
        ;; Produce the expansion:
        `(EVAL-WHEN (:COMPILE-TOPLEVEL :LOAD-TOPLEVEL :EXECUTE)
           (SYSTEM::%IN-PACKAGE ,packname :NICKNAMES ',nickname-list :USE '()
                                :CASE-SENSITIVE ,case-sensitive
                                :CASE-INVERTED ,case-inverted)
           ;; Step 0
           ,@(ecase modern
               ((t)
                `((when (find "COMMON-LISP" (package-use-list ,packname)
                              :test #'string= :key #'package-name)
                    (unuse-package "COMMON-LISP" ,packname)
                    (use-package "CS-COMMON-LISP" ,packname))))
               ((nil)
                `((when (find "CS-COMMON-LISP" (package-use-list ,packname)
                              :test #'string= :key #'package-name)
                    (unuse-package "CS-COMMON-LISP" ,packname)
                    (use-package "COMMON-LISP" ,packname))))
               ((:DEFAULT) '()))
           ;; Step 1
           ,@(if shadow-list
               `((,(if case-inverted 'CS-CL:shadow 'CL:SHADOW)
                   ',shadow-list ,packname)))
           ,@(mapcar #'(lambda (pair)
                         `(SHADOWING-IMPORT-CERROR ,(car pair) ,(cdr pair)
                                                   ,case-inverted ,packname))
                     shadowing-list)
           ;; Step 2
           ,@(if use-list `((USE-PACKAGE ',use-list ,packname)))
           ;; Step 3
           ,@(mapcar #'(lambda (pair)
                         `(IMPORT-CERROR ,(car pair) ,(cdr pair)
                                         ,case-inverted ,packname))
                     import-list)
           ,@(mapcar #'(lambda (symname)
                         `(,(if case-inverted 'CS-CL:intern 'CL:INTERN)
                            ,symname ,packname))
                     intern-list)
           ;; Step 4
           ,@(if export-list
               `((INTERN-EXPORT ',export-list ,packname ,case-inverted)))
           ;; Step 5
           ,@(if documentation
               `((SETF (SYS::PACKAGE-DOCUMENTATION (FIND-PACKAGE ,packname))
                       ,documentation)))
           (FIND-PACKAGE ,packname))))))

; Hilfsfunktionen:
(defun find-symbol-cerror (string packname invert calling-packname)
  (multiple-value-bind (sym found)
      (if invert
        (cs-cl:find-symbol string packname)
        (cl:find-symbol string packname))
    (unless found
      (cerror ; 'package-error ??
              (TEXT "This symbol will be created.")
              (TEXT "~S ~A: There is no symbol ~A::~A .")
              'defpackage calling-packname packname string)
      (setq sym (if invert
                  (cs-cl:intern string packname)
                  (cl:intern string packname))))
    sym))
(defun shadowing-import-cerror (string packname invert calling-packname) ; ABI
  (let ((sym (find-symbol-cerror string packname invert calling-packname)))
    (shadowing-import (or sym '(NIL)) calling-packname)))
(defun import-cerror (string packname invert calling-packname) ; ABI
  (let ((sym (find-symbol-cerror string packname invert calling-packname)))
    (import (or sym '(NIL)) calling-packname)))
(defun intern-export (string-list packname invert) ; ABI
  (export (mapcar #'(lambda (string)
                      (if invert
                        (cs-cl:intern string packname)
                        (cl:intern string packname)))
                  string-list)
          packname))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./defpackage.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./defmacro.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; File DEFMACRO.LISP
;;; DEFMACRO macro and a few utility functions for complex macros.
;;; 1988-01-09
;;; Adapted from DEFTYPE on 1989-10-06
;;; German comments translated by Mirian Lennox <mirian@cosmic.com> 2003-01-19

(in-package "SYSTEM")

;; Import from CONTROL.D:

#| (SYSTEM::PARSE-BODY body &optional docstring-allowed)
   detects occurring declarations (and if docstring-allowed=T,
   also a docstring) and returns three values:
   1. body-rest, the remaining forms
   2. declspec-list, a list of declspecs that appeared
   3. docstring, a docstring that appeared, or NIL
|#
#| (SYSTEM::KEYWORD-TEST arglist kwlist)
   tests if arglist (a pair of keyword/value lists) contains only
   keywords which come from the list kwlist, or else contains a
   keyword/value pair :ALLOW-OTHER-KEYS with value other than NIL.
   If not, an error is raised.
 (defun keyword-test (arglist kwlist)
  (let ((unallowed-arglistr nil)
        (allow-other-keys-flag nil))
    (do ((arglistr arglist (cddr arglistr)))
        ((null arglistr))
      (if (eq (first arglistr) ':ALLOW-OTHER-KEYS)
          (if (second arglistr) (setq allow-other-keys-flag t))
          (do ((kw (first arglistr))
               (kwlistr kwlist (cdr kwlistr)))
              ((or (null kwlistr) (eq kw (first kwlistr)))
               (if (and (null kwlistr) (null unallowed-arglistr))
                   (setq unallowed-arglistr arglistr))))))
    (unless allow-other-keys-flag
      (if unallowed-arglistr
        (cerror (TEXT "Both will be ignored.")
                (TEXT "Invalid keyword-value-pair: ~S ~S")
                (first unallowed-arglistr) (second unallowed-arglistr))))))
;; Definition in assembler (see CONTROL.Q)
|#

(defun macro-call-error (macro-form) ; ABI
  (multiple-value-bind (length tail) (sys::list-length-dotted macro-form)
    (if (null length)
      (let ((*print-circle* t))
        (error-of-type 'source-program-error
          :form macro-form
          :detail macro-form
          (TEXT "The macro ~S may not be called with a circular argument list: ~S")
          (car macro-form) macro-form))
      (if tail
        (error-of-type 'source-program-error
          :form macro-form
          :detail macro-form
          (TEXT "The macro ~S may not be called with a dotted argument list: ~S")
          (car macro-form) macro-form)
        (error-of-type 'source-program-error
          :form macro-form
          :detail macro-form
          (TEXT "The macro ~S may not be called with ~S arguments: ~S")
          (car macro-form) (1- (length macro-form)) macro-form)))))

(defun macro-nonnull-element-error (macro-form macro-name element) ; ABI
  (error-of-type 'source-program-error
    :form macro-form
    :detail element
    (TEXT "~S: ~S does not match lambda list element ~:S")
    macro-name element '()))

(proclaim '(special
        %whole-form ;; the whole source form being macroexpanded or compiled

        %proper-list-p ;; check whether the whole list is proper,
                       ;; even if %restp is true

        %restp ;; indicates whether &REST/&BODY/&KEY was given,
               ;; and therefore the number of arguments is unlimited.

        %min-args ;; indicates the mininum number of arguments

        %arg-count ;; indicates the number of individual arguments
                   ;; (required and optional arguments combined)

        %let-list ;; reversed list of bindings that have to be done with LET*

        %keyword-tests ;; list of KEYWORD-TEST calls that have to be included

        %default-form ;; default form for optional and keyword arguments,
                      ;; for which no default form is supplied
                      ;; NIL normally, or (QUOTE *) for DEFTYPE.

        %null-tests   ;; tests for () matches
))
#|
 (ANALYZE1 lambdalist accessexp name wholevar)
analyses a macro lambda list (without &ENVIRONMENT).  accessexp is the
expression which supplies the arguments to be matched with this
lambda list.

 (ANALYZE-REST lambdalistr restexp name)
analyses the part of a macro lambda list that appears after the &REST/&BODY
expression. restexp is the expression that returns the arguments to be matched with this rest of the list.

 (ANALYZE-KEY lambdalistr restvar name)
analyses the part of a macro lambda list which comes after &KEY.
restvar is the symbol that will contain the remaining arguments.

 (ANALYZE-AUX lambdalistr name)
analyses the part of a macro lambda list that comes after &AUX.

 (REMOVE-ENV-ARG lambdalist name)
removes the pair &ENVIRONMENT/Symbol from a macro lambda list; returns
two values: the shortened lambda list and the symbol to be used
as environment (or the original lambda list and NIL, if &ENVIRONMENT
is not found).

 (MAKE-LENGTH-TEST symbol)
creates a testform from %restp, %min-args, %arg-count, %proper-list-p,
which indicates during evaluation whether the variable value of the symbol
can be a function call for the macro.

 (MAKE-MACRO-EXPANSION macrodef whole-form)
returns, for a macro definition macrodef = (name lambdalist . body),
1. the macro-expander as the program text (FUNCTION ... (LAMBDA ..)),
2. name, a symbol
3. lambda list
4. docstring (or NIL, if not there)

 (MAKE-MACRO-EXPANDER macrodef whole-form &optional env)
returns, for a macro definition macrodef = (name lambdalist . body),
the actual object #<MACRO expander> for the FENV.
|#

(defun analyze-aux (lambdalistr name)
  (do ((listr lambdalistr (cdr listr)))
      ((atom listr)
       (if listr
         (cerror (TEXT "The rest of the lambda list will be ignored.")
                 (TEXT "The lambda list of macro ~S contains a dot after ~S.")
                 name '&aux)))
    (cond ((symbolp (car listr)) (setq %let-list (cons `(,(car listr) nil) %let-list)))
          ((atom (car listr))
           (error-of-type 'source-program-error
             :form %whole-form
             :detail (car listr)
             (TEXT "in macro ~S: ~S may not be used as &AUX variable.")
             name (car listr)))
          (t (setq %let-list
                   (cons `(,(caar listr) ,(cadar listr)) %let-list))))))

(defun get-supplied-p (name item)
  (when (and (consp (cdr item)) (consp (cddr item)))
    (unless (symbolp (caddr item))
      (error-of-type 'source-program-error
        :form %whole-form
        :detail (caddr item)
        (TEXT "~S: invalid supplied-p variable ~S")
        name (caddr item)))
    (third item)))

;; this should be a macro...
(defun kwd-arg-form (restvar kw svar default &aux (dummy '#.(cons nil nil)))
  ;; the default value should not be evaluated unless it is actually used
  (let ((arg (gensym "KWD-ARG-")))
    `(let ((,arg (GETF ,restvar ',kw ',dummy)))
       (if (eq ,arg ',dummy)
           (progn ,@(when svar `((setq ,svar nil))) ,default)
           ,arg))))

(defun analyze-key (lambdalistr restvar name
                    &aux (other-keys-forbidden t) (kwlist nil))
  (do ((listr lambdalistr (cdr listr))
       (next)
       (kw)
       (svar)
       (g))
      ((atom listr)
       (if listr
         (cerror (TEXT "The rest of the lambda list will be ignored.")
                 (TEXT "The lambda list of macro ~S contains a dot after ~S.")
                 name '&key)))
    (setq next (car listr))
    (cond ((eq next '&ALLOW-OTHER-KEYS) (setq other-keys-forbidden nil))
          ((eq next '&AUX)
           (return-from nil (analyze-aux (cdr listr) name)))
          ((or (eq next '&ENVIRONMENT) (eq next '&WHOLE) (eq next '&REST)
               (eq next '&OPTIONAL) (eq next '&BODY) (eq next '&KEY))
           (cerror #1=(TEXT "It will be ignored.")
                   (TEXT "The lambda list of macro ~S contains a badly placed ~S.")
                   name next))
          (t
           (when %default-form
             (cond ((symbolp next) (setq next (list next %default-form)))
                   ((and (consp next) (eql (length next) 1))
                    (setq next (list (car next) %default-form)))))
           (cond ((symbolp next)  ; foo
                  (setq kw (symbol-to-keyword next))
                  (setq %let-list
                        (cons `(,next (GETF ,restvar ',kw NIL)) %let-list))
                  (setq kwlist (cons kw kwlist)))
                 ((atom next)
                  (cerror #1# (TEXT "The lambda list of macro ~S contains the invalid element ~S")
                          name next))
                 ((symbolp (car next))  ; (foo ...)
                  (setq kw (symbol-to-keyword (car next)))
                  (when (setq svar (get-supplied-p name next))
                    (setq %let-list (cons `(,svar t) %let-list)))
                  (setq %let-list
                        (cons `(,(car next)
                                 ,(kwd-arg-form restvar kw svar (cadr next)))
                              %let-list))
                  (setq kwlist (cons kw kwlist)))
                 ((not (and (consp (car next)) (symbolp (caar next)) (consp (cdar next))))
                  (cerror (TEXT "~0*It will be ignored.")
                          (TEXT "The lambda list of macro ~S contains an invalid keyword specification ~S")
                          name (car next)))
                 ((symbolp (cadar next))  ; ((:foo *foo*) ...)
                  (setq kw (caar next))
                  (when (setq svar (get-supplied-p name next))
                    (setq %let-list (cons `(,svar t) %let-list)))
                  (setq %let-list
                        (cons `(,(cadar next)
                                 ,(kwd-arg-form restvar kw svar (cadr next)))
                              %let-list))
                  (setq kwlist (cons kw kwlist)))
                 (t ; subform
                  (setq kw (caar next))
                  (setq g (gensym))
                  (setq svar (and (cddr next) (symbolp (third next))
                                  (third next)))
                  (when svar
                    (setq %let-list (cons `(,svar t) %let-list)))
                  (setq %let-list
                        (cons `(,g ,(kwd-arg-form restvar kw svar (cadr next)))
                              %let-list))
                  (setq kwlist (cons kw kwlist))
                  (let ((%min-args 0) (%arg-count 0) (%restp nil)
                        (%default-form nil))
                    (analyze1 (cadar next) g name g)))))))
  (if other-keys-forbidden
      (setq %keyword-tests
            (cons `(KEYWORD-TEST ,restvar ',kwlist) %keyword-tests))))

(defun analyze-rest (lambdalistr restexp name)
  (if (atom lambdalistr)
      (error-of-type 'source-program-error
        :form %whole-form
        :detail lambdalistr
        (TEXT "The lambda list of macro ~S is missing a variable after &REST/&BODY.")
        name))
  (let ((restvar (car lambdalistr))
        (listr (cdr lambdalistr)))
    (setq %restp t)
    (cond ((symbolp restvar)
           (setq %let-list (cons `(,restvar ,restexp) %let-list)))
          ((atom restvar)
           (error-of-type 'source-program-error
             :form %whole-form
             :detail restvar
             (TEXT "The lambda list of macro ~S contains an illegal variable after &REST/&BODY: ~S")
             name restvar))
          (t
           (let ((%min-args 0) (%arg-count 0) (%restp nil))
             (analyze1 restvar restexp name restexp))))
    (cond ((null listr))
          ((atom listr)
           (cerror (TEXT "The rest of the lambda list will be ignored.")
                   (TEXT "The lambda list of macro ~S contains a misplaced dot.")
                   name))
          ((eq (car listr) '&KEY) (analyze-key (cdr listr) restvar name))
          ((eq (car listr) '&AUX) (analyze-aux (cdr listr) name))
          (t (cerror (TEXT "They will be ignored.")
                     (TEXT "The lambda list of macro ~S contains superfluous elements: ~S")
                     name listr)))))

(defun cons-car (exp &aux h)
  (if
   (and
    (consp exp)
    (setq h
          (assoc (car exp)
                 '((car . caar) (cdr . cadr)
                   (caar . caaar) (cadr . caadr) (cdar . cadar) (cddr . caddr)
                   (caaar . caaaar) (caadr . caaadr) (cadar . caadar)
                   (caddr . caaddr) (cdaar . cadaar) (cdadr . cadadr)
                   (cddar . caddar) (cdddr . cadddr)
                   (cddddr . fifth)))))
   (cons (cdr h) (cdr exp))
   (list 'car exp)))

(defun cons-cdr (exp &aux h)
  (if
   (and
    (consp exp)
    (setq h
          (assoc (car exp)
                 '((car . cdar) (cdr . cddr)
                   (caar . cdaar) (cadr . cdadr) (cdar . cddar) (cddr . cdddr)
                   (caaar . cdaaar) (caadr . cdaadr) (cadar . cdadar)
                   (caddr . cdaddr) (cdaar . cddaar) (cdadr . cddadr)
                   (cddar . cdddar) (cdddr . cddddr)))))
   (cons (cdr h) (cdr exp))
   (list 'cdr exp)))

(defun empty-pattern (name accessexp wholevar)
  (let ((g (gensym)))
    (setq %let-list (cons `(,g ,(cons-car accessexp)) %let-list))
    (setq %null-tests
          (cons `(WHEN ,g (MACRO-NONNULL-ELEMENT-ERROR ,wholevar ',name ,g))
                 %null-tests))))

(defun analyze1 (lambdalist accessexp name wholevar)
  (do ((listr lambdalist (cdr listr))
       (within-optional nil)
       (disallow-whole nil)
       (item)
       (g) (g1) (test))
      ((atom listr)
       (when listr
         (unless (symbolp listr)
           (error-of-type 'source-program-error
             :form %whole-form
             :detail listr
             (TEXT "The lambda list of macro ~S contains an illegal &REST variable: ~S")
             name listr))
         (setq %let-list (cons `(,listr ,accessexp) %let-list))
         (setq %restp t)))
    (setq item (car listr))
    (cond ((eq item '&WHOLE)
           (if (and wholevar (cdr listr))
             (if disallow-whole
               (progn
                 (cerror #2=(TEXT "It will be ignored.")
                         (TEXT "The lambda list of macro ~S contains a badly placed ~S.")
                         name item)
                 (setq listr (cdr listr)))
               (if (symbolp (cadr listr))
                 (setq %let-list (cons `(,(cadr listr) ,wholevar) %let-list)
                       listr (cdr listr))
                 (let ((%min-args 0) (%arg-count 0) (%restp nil))
                   (setq listr (cdr listr)) ; pop &WHOLE
                   (analyze1 (car listr) wholevar name wholevar))))
             (error-of-type 'source-program-error
               :form %whole-form
               :detail listr
               (TEXT "The lambda list of macro ~S contains an invalid &WHOLE: ~S")
               name listr)))
          ((eq item '&OPTIONAL)
           (if within-optional
               (cerror #2# (TEXT "The lambda list of macro ~S contains a superfluous ~S.")
                       name item))
           (setq within-optional t
                 disallow-whole t))
          ((or (eq item '&REST) (eq item '&BODY))
           (return-from nil (analyze-rest (cdr listr) accessexp name)))
          ((eq item '&KEY)
           (setq g (gensym))
           (setq %restp t)
           (setq %let-list (cons `(,g ,accessexp) %let-list))
           (return-from nil (analyze-key (cdr listr) g name)))
          ((eq item '&ALLOW-OTHER-KEYS)
           (cerror #2# (TEXT "The lambda list of macro ~S contains ~S before &KEY.")
                   name item))
          ((eq item '&ENVIRONMENT)
           (cerror #2# (TEXT "The lambda list of macro ~S contains ~S which is illegal here.")
                   name item))
          ((eq item '&AUX)
           (return-from nil (analyze-aux (cdr listr) name)))
          (within-optional
           (setq %arg-count (1+ %arg-count))
           (if %default-form
             (cond ((symbolp item) (setq item (list item %default-form)))
                   ((and (consp item) (eql (length item) 1))
                    (setq item (list (car item) %default-form)))))
           (cond ((null item) (empty-pattern name accessexp wholevar))
                 ((symbolp item)
                  (setq %let-list (cons `(,item ,(cons-car accessexp))
                                        %let-list)))
                 ((atom item)
                  #1=
                  (error-of-type 'source-program-error
                    :form %whole-form
                    :detail item
                    (TEXT "The lambda list of macro ~S contains an invalid element ~S")
                    name item))
                 ((symbolp (car item))
                  (setq %let-list
                        (cons `(,(car item) (IF ,accessexp
                                              ,(cons-car accessexp)
                                              ,(if (consp (cdr item))
                                                 (cadr item) 'NIL)))
                              %let-list))
                  (when (setq g (get-supplied-p name item))
                    (setq %let-list
                          (cons `(,g (NOT (NULL ,accessexp)))
                                %let-list))))
                 (t
                  (setq g (gensym))
                  (setq %let-list
                        (cons `(,g ,(if (consp (cdr item))
                                      `(IF ,accessexp
                                         ,(cons-car accessexp)
                                         ,(cadr item))
                                      (cons-car accessexp)))
                              %let-list))
                  (let ((%min-args 0) (%arg-count 0) (%restp nil))
                    (analyze1 (car item) g name g))
                  (if (consp (cddr item))
                    (setq %let-list
                          (cons `(,(caddr item) (NOT (NULL ,accessexp))) %let-list)))))
           (setq accessexp (cons-cdr accessexp)))
          (t ; required arguments
           (setq %min-args (1+ %min-args))
           (setq %arg-count (1+ %arg-count))
           (cond ((null item) (empty-pattern name accessexp wholevar))
                 ((symbolp item)
                  (setq %let-list (cons `(,item ,(cons-car accessexp)) %let-list)))
                 ((atom item)
                  #1#) ; (error-of-type ... name item), s.o.
                 (t
                  (setq g (gensym) g1 (gensym)
                        %let-list (list* `(,g1 ,g) `(,g ,(cons-car accessexp))
                                         %let-list))
                  (let ((%min-args 0) (%arg-count 0) (%restp nil))
                    (analyze1 item g1 name g1)
                    (setq test (make-length-test g 0)))
                  (if test
                    (rplaca (cdr (assoc g1 %let-list))
                            `(if ,test
                               (error-of-type 'source-program-error
                                 :form ,wholevar
                                 :detail ,g
                                 (TEXT "~S: ~S does not match lambda list element ~:S")
                                 ',name ,g ',item)
                               ,g)))))
           (setq accessexp (cons-cdr accessexp)
                 disallow-whole t)))))

(defun remove-env-arg (lambdalist name)
  (do ((listr lambdalist (cdr listr)))
      ((atom listr) (values lambdalist nil))
    (if (eq (car listr) '&ENVIRONMENT)
      (if (and (consp (cdr listr)) (symbolp (cadr listr)) (cadr listr))
        ;; found &ENVIRONMENT
        (return
          (values
           (do ((l1 lambdalist (cdr l1)) ; lambda list without &ENVIRONMENT/symbol
                (l2 nil (cons (car l1) l2)))
               ((eq (car l1) '&ENVIRONMENT)
                (nreconc l2 (cddr l1))))
           (cadr listr)))
        (error-of-type 'source-program-error
          :form %whole-form
          :detail lambdalist
          (TEXT "In the lambda list of macro ~S, &ENVIRONMENT must be followed by a non-NIL symbol: ~S")
          name lambdalist)))))

(defun make-length-test (var &optional (header 1))
  (if (and (zerop %min-args) %restp)
    ; No length constraint, test only whether the list is a proper list.
    (if %proper-list-p
      `(NOT (PROPER-LIST-P ,var))
      NIL)
    ; Perform all tests in a single function call.
    `(NOT
       ,(if %proper-list-p
          `(SYS::PROPER-LIST-LENGTH-IN-BOUNDS-P ,var ,(+ header %min-args)
             ,@(if %restp '() (list (+ header %arg-count))))
          `(SYS::LIST-LENGTH-IN-BOUNDS-P ,var ,(+ header %min-args)
             ,(+ header %arg-count) ,(not (not %restp)))))))

(defun make-macro-expansion (macrodef whole-form
                             ;; Optional arguments, for define-compiler-macro:
                             &optional (valid-name-p #'symbolp)
                                       pre-process)
  (when (atom macrodef)
    (error-of-type 'source-program-error
      :form macrodef
      :detail macrodef
      (TEXT "Cannot define a macro from that: ~S")
      macrodef))
  (unless (funcall valid-name-p (car macrodef))
    (error-of-type 'source-program-error
      :form macrodef
      :detail (car macrodef)
      (TEXT "The name of a macro must be a symbol, not ~S")
      (car macrodef)))
  (when (atom (cdr macrodef))
    (error-of-type 'source-program-error
      :form macrodef
      :detail (cdr macrodef)
      (TEXT "Macro ~S is missing a lambda list.")
      (car macrodef)))
  (let ((name (car macrodef))
        (lambdalist (cadr macrodef))
        (body (cddr macrodef)))
    (multiple-value-bind (body-rest declarations docstring) (parse-body body t)
      (if declarations
        (setq declarations (list (cons 'DECLARE declarations))))
      (let ((%whole-form whole-form) (%proper-list-p nil))
        (multiple-value-bind (newlambdalist envvar)
            (remove-env-arg lambdalist name)
          (let ((%arg-count 0) (%min-args 0) (%restp nil) (%null-tests nil)
                (%let-list nil) (%keyword-tests nil) (%default-form nil))
            (analyze1 newlambdalist '(CDR <MACRO-FORM>) name '<MACRO-FORM>)
            (let ((lengthtest (make-length-test '<MACRO-FORM>))
                  (mainform `(LET* ,(nreverse %let-list)
                               ,@declarations
                               ,@(nreverse %null-tests)
                               ,@(nreverse %keyword-tests)
                               (BLOCK ,(function-block-name name)
                                 ,@body-rest))))
              (if lengthtest
                (setq mainform
                      `(IF ,lengthtest
                         (MACRO-CALL-ERROR <MACRO-FORM>)
                         ,mainform)))
              (let ((lambdabody
                      `((<MACRO-FORM> ,(or envvar '<ENV-ARG>))
                        (DECLARE (CONS <MACRO-FORM>))
                        ,@(if envvar
                            declarations ;; possibly contains a (declare (ignore envvar))
                            '((DECLARE (IGNORE <ENV-ARG>))))
                        ,@(if docstring (list docstring))
                        ,@(if pre-process
                            `((setq <MACRO-FORM> (,pre-process <MACRO-FORM>))))
                        ,mainform)))
                (values
                  `(FUNCTION ,name (LAMBDA ,@lambdabody))
                  lambdabody
                  name
                  lambdalist
                  docstring)))))))))

;; Creates a macro expander for MACROLET.
(defun make-macro-expander (macrodef whole-form
                            &optional
                            ;; The environment is tricky: ANSI CL says that
                            ;; 1. declarations, macros and symbol-macros from
                            ;; outside can be used in the macro expander,
                            ;; 2. other variable and function bindings cannot.
                            ;; 3. It is unclear about BLOCK and TAGBODY tags.
                            (env (vector (and (boundp '*venv*)
                                              (cons 'MACROLET *venv*))
                                         (and (boundp '*fenv*)
                                              (cons 'MACROLET *fenv*))
                                         (and (boundp '*benv*)
                                              *benv*)
                                         (and (boundp '*genv*)
                                              *genv*)
                                         (if (boundp '*denv*)
                                           *denv*
                                           *toplevel-denv*))))
  (make-macro
    (evalhook (make-macro-expansion macrodef whole-form) nil nil env)
    (second whole-form)))

;; Creates a macro expander for FUNCTION-MACRO-LET.
;; Unlike in MACROLET, the macro is defined in the null lexical environment.
(defun make-funmacro-full-lambdabody (macrodef)
  (multiple-value-bind (expansion expansion-lambdabody)
      (make-macro-expansion macrodef
                            `(#:FUNCTION-MACRO-LET ,macrodef)) ; a dummy
    (declare (ignore expansion))
    expansion-lambdabody))
(defun make-funmacro-expander (name full-lambdabody)
  (make-macro
    (evalhook `(FUNCTION ,name (LAMBDA ,@full-lambdabody)) nil nil
              *toplevel-environment*)
    (first full-lambdabody)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./defmacro.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./query.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Querying the user

(in-package "SYSTEM")

; -----------------------------------------------------------------------------

; (Y-OR-N-P [format-string {arg}*]), CLTL S. 407
(defun y-or-n-p (&optional format-string &rest args)
  (when format-string
    (fresh-line *query-io*)
    (apply #'format *query-io* format-string args)
    (write-string (TEXT " (y/n) ") *query-io*)
    (force-output *query-io*))
  (let ((localinfo (localized 'y-or-n)))
    (loop
      (let ((line (string-left-trim " " (read-line *query-io*))))
        (when (plusp (length line))
          (let ((first-char (char-upcase (char line 0))))
            (when (member first-char (car localinfo)) (return nil))
            (when (member first-char (cdr localinfo)) (return t)))))
      (write-string (TEXT "Please answer with y or n : ") *query-io*)
      (force-output *query-io*))))
(definternational y-or-n (t ENGLISH))
(deflocalized y-or-n ENGLISH '((#\N) . (#\Y)))

; (YES-OR-NO-P [format-string {arg}*]), CLTL S. 408
(defun yes-or-no-p (&optional format-string &rest args)
  (when format-string
    (fresh-line *query-io*)
    (apply #'format *query-io* format-string args)
    (write-string (TEXT " (yes/no) ") *query-io*)
    (force-output *query-io*))
  (let ((localinfo (localized 'yes-or-no)))
    (loop
      (clear-input *query-io*)
      (let ((line (string-trim " " (read-line *query-io*))))
        (when (member line (car localinfo) :test #'string-equal) (return nil))
        (when (member line (cdr localinfo) :test #'string-equal) (return t)))
      (write-string (TEXT "Please answer with yes or no : ") *query-io*)
      (force-output *query-io*))))
(definternational yes-or-no (t ENGLISH))
(deflocalized yes-or-no ENGLISH '(("no" "nah") . ("yes" "yup" "yep" "yeah")))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./query.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./french.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; French translations of DEFINTERNATIONALed values.
;;; Bruno Haible, Jrg Hhle

(in-package "I18N")
(common-lisp:export 'FRANAIS)
(common-lisp:import 'FRANAIS "EXT")
(common-lisp:export 'FRANAIS "EXT")

(common-lisp:in-package "SYSTEM")

(deflanguage FRANAIS)

(deflocalized date-format FRANAIS
  (formatter "~1{~3@*~D/~4@*~D/~5@*~D ~2@*~2,'0D:~1@*~2,'0D:~0@*~2,'0D~:}")
)
(deflocalized room-format FRANAIS
  (list (formatter "Classe~VT instances  taille (octets)  t. moyenne~%")
        (formatter "------~VT ---------  ---------------  ----------~%")
        (formatter       "~VT~8D     ~9D  ~13,3F~%")
) )
(deflocalized space-format FRANAIS
  (list (formatter       "~VT     permanent            temporaire~%")
        (formatter "Classe~VTinstances   octets   instances   octets~%")
        (formatter "------~VT--------- ---------  --------- ---------~%")
        (formatter       "~VT~9D ~9D  ~9D ~9D~%")
) )
(deflocalized y-or-n FRANAIS '((#\N) . (#\O #\Y)))
(deflocalized yes-or-no FRANAIS '(("non") . ("oui")))
(deflocalized print-condition-format FRANAIS
  (formatter "Condition exceptionnelle de type ~S.")
)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./french.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./check-lispfun.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Copyright (C) 2002-2009, 2011 by Sam Steingold
;;; This is Free Software, distributed under the GNU GPL v2+
;;; See http://www.gnu.org/copyleft/gpl.html
;;;
;;; Check LISPFUN, LISPFUNN and LISPSPECFORM

(in-package "USER")

(defun make-c-rt (&optional (rt (copy-readtable)))
  (set-syntax-from-char #\, #\Space rt)
  rt)
(defvar *c-rt* (make-c-rt))
(defun get-lisp-def (line st)
  (let* ((*readtable* *c-rt*)
         (in (make-concatenated-stream (make-string-input-stream line) st))
         (fn (read in))
         (li (read in)))
    (values li fn)))

(defvar *form-decls* '("subr" "fsubr"))
(defvar *const-decls* '("constsym" "constobj" "constobj_tl" "constpack"))

(defun get-lisp-defs (file &optional decs &aux (pos 0) (error-count 0))
  (with-open-file (st file :direction :input :external-format charset:utf-8)
    (format t "~&~s: file ~s~%" 'get-lisp-defs file)
    (values (ext:with-collect (keep)
              (loop (let ((line (read-line st nil nil)) p s)
                      (unless line (return)) (incf pos)
                      (when (and decs (setq p (search #1="funcall(S(" line)))
                        (let ((fn (subseq line (+ p #.(length #1#))
                                          (position #\) line :start p))))
                          (when (and (setq s (find fn decs :test #'string-equal
                                                   :key #'car))
                                     ;; load is called as S(load) because
                                     ;; it is redefined in init.lisp
                                     (sys::subr-info (car s)))
                            (cerror "proceed with checks"
                                    "~a:~d: funcall(S(~a)) for a subr ~s"
                                    file pos fn s)
                            (incf error-count))))
                      (when (sys::string-beg-with "LISP" line)
                        (multiple-value-bind (li fn) (get-lisp-def line st)
                          (push fn (cdr li))
                          (keep li))))))
            error-count)))

(defun check-lisp-defs (dir)
  (format t "~&~s: ~s~%" 'check-lisp-defs dir)
  (let* ((exclude (append *const-decls* *form-decls*))
         (error-count 0)
         (dec-forms
          (delete-duplicates
           (sort (mapcan #'get-lisp-defs
                         (mapcar (lambda (fi)
                                   (make-pathname :name fi :type "d"
                                                  :defaults dir))
                                 *form-decls*))
                 #'string< :key #'car)
           :test #'equal))
         (def-forms
          (delete-duplicates
           (sort (mapcan (lambda (f)
                           (multiple-value-bind (forms errors)
                               (get-lisp-defs f dec-forms)
                             (incf error-count errors)
                             forms))
                         (delete-if (lambda (fi)
                                      (member (pathname-name fi) exclude
                                              :test #'string-equal))
                                    (directory (merge-pathnames "*.d" dir))))
                 #'string< :key #'car)
           :test #'equal)))
    (cond ((= (length def-forms) (length dec-forms))
           (format t "~d forms~%" (length def-forms)))
          (t (cerror #1="proceed with checks"
                     "# of defined forms ~s != # of declared forms ~s"
                     (length def-forms) (length dec-forms))
             (incf error-count)))
    (when (set-difference dec-forms def-forms :test #'equal)
      (cerror #1# "declaration (subr.d) differs from the definition:~%~s"
              (set-difference dec-forms def-forms :test #'equal))
      (incf error-count))
    (when (set-difference def-forms dec-forms :test #'equal)
      (cerror #1# "definition differs from the declaration (subr.d):~%~s"
              (set-difference def-forms dec-forms :test #'equal))
      (incf error-count))
    (when (plusp error-count)
      (error "~d errors" error-count))))

(defun write-subrs (file)
  (let ((count 0) (*package* (find-package "CL-USER")))
    (with-open-file (out file :direction :output)
      (do-all-symbols (sy)
        (let ((sig (multiple-value-list (sys::subr-info sy))))
          (when sig
            (incf count)
            (write sig :stream out)
            (terpri out)))))
    count))

;;; file check-lispfun.lisp ends here
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./check-lispfun.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./documentation.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Generic documentation
;;;; Sam Steingold 2002 - 2006, 2008, 2010, 2017
;;;; Bruno Haible 2004

(in-package "CLOS")

(defun function-documentation (x &aux name)
  (cond ((typep-class x <standard-generic-function>)
         (std-gf-documentation x))
        ((eq (type-of x) 'FUNCTION) ; interpreted function?
         (sys::%record-ref x 2))    ; clos_docstring
        #+FFI ((eq (type-of x) 'ffi::foreign-function)
               (getf (sys::%record-ref x 6) :documentation)) ; ff_properties
        ((sys::closurep x) (sys::closure-documentation x))
        ((setq name (sys::subr-info x)) (get :documentation name)) ; subr
        (t (get :documentation (sys::%record-ref x 0))))) ; clos_name

;;; documentation
(defgeneric documentation (x doc-type)
  (declare (dynamically-modifiable))
  (:argument-precedence-order doc-type x)
  (:method ((x function) (doc-type (eql 't)))
    (function-documentation x))
  (:method ((x function) (doc-type (eql 'function)))
    (function-documentation x))
  (:method ((x cons) (doc-type (eql 'function)))
    (setq x (check-function-name x 'documentation))
    (and (fboundp x) (function-documentation (sys::unwrapped-fdefinition x))))
  (:method ((x cons) (doc-type (eql 'compiler-macro)))
    (setq x (check-function-name x 'documentation))
    (if (symbolp x)
      (documentation x 'compiler-macro)
      (documentation (second x) 'setf-compiler-macro)))
  (:method ((x symbol) (doc-type (eql 'function)))
    (and (fboundp x) (function-documentation (sys::unwrapped-fdefinition x))))
  (:method ((x symbol) (doc-type symbol))
    ;; doc-type = `compiler-macro', `setf', `variable', `type',
    ;; `setf-compiler-macro'
    (getf (get x 'sys::doc) doc-type))
  (:method ((x symbol) (doc-type (eql 'type)))
    (let ((class (find-class x nil)))
      (if class
        (documentation class 't)
        (call-next-method))))
  (:method ((x symbol) (doc-type (eql 'structure))) ; structure --> type
    (documentation x 'type))
  (:method ((x symbol) (doc-type (eql 'class))) ; class --> type
    (documentation x 'type))
  (:method ((x method-combination) (doc-type (eql 't)))
    (method-combination-documentation x))
  (:method ((x method-combination) (doc-type (eql 'method-combination)))
    (method-combination-documentation x))
  (:method ((x symbol) (doc-type (eql 'method-combination)))
    (method-combination-documentation (get-method-combination x 'documentation)))
  (:method ((x standard-method) (doc-type (eql 't)))
    (std-method-documentation x))
  (:method ((x package) (doc-type (eql 't)))
    (let ((doc (sys::package-documentation x)))
      (if (consp doc) (first doc) doc)))
  (:method ((x standard-class) (doc-type (eql 't)))
    (class-documentation x))
  (:method ((x standard-class) (doc-type (eql 'type)))
    (class-documentation x))
  (:method ((x structure-class) (doc-type (eql 't)))
    (class-documentation x))
  (:method ((x structure-class) (doc-type (eql 'type)))
    (class-documentation x))
  ;;; The following are CLISP extensions.
  (:method ((x standard-object) (doc-type (eql 't)))
    (documentation (class-of x) 'type))
  (:method ((x standard-object) (doc-type (eql 'type)))
    (documentation (class-of x) 'type))
  (:method ((x structure-object) (doc-type (eql 't)))
    (documentation (class-of x) 'type))
  (:method ((x structure-object) (doc-type (eql 'type)))
    (documentation (class-of x) 'type))
  (:method ((x defined-class) (doc-type (eql 't)))
    (class-documentation x))
  (:method ((x defined-class) (doc-type (eql 'type)))
    (class-documentation x))
  (:method ((x slot-definition) (doc-type (eql 't)))
    (slot-definition-documentation x)))

(defun set-function-documentation (x new-value &aux name)
  (cond ((typep-class x <standard-generic-function>)
         (setf (std-gf-documentation x) new-value))
        ((eq (type-of x) 'FUNCTION) ; interpreted function?
         (setf (sys::%record-ref x 2) new-value)) ; clos_docstring
        #+FFI ((eq (type-of x) 'ffi::foreign-function)
               (setf (getf (sys::%record-ref x 6) ; ff_properties
			   :documentation) new-value))
        ((sys::closurep x) (sys::closure-set-documentation x new-value))
        ((setq name (sys::subr-info x)) ; subr
         (setf (get :documentation name) new-value))
        (t                      ; fsubr
         (setf (get :documentation (sys::%record-ref x 0)) ; clos_name
	       new-value))))

(defgeneric (setf documentation) (new-value x doc-type)
  (declare (dynamically-modifiable))
  (:argument-precedence-order doc-type x new-value)
  (:method (new-value (x function) (doc-type (eql 't)))
    (set-function-documentation x new-value))
  (:method (new-value (x function) (doc-type (eql 'function)))
    (set-function-documentation x new-value))
  (:method (new-value (x cons) (doc-type (eql 'function)))
    (setq x (check-function-name x '(setf documentation)))
    (and (fboundp x)
         (set-function-documentation (sys::unwrapped-fdefinition x) new-value)))
  (:method (new-value (x cons) (doc-type (eql 'compiler-macro)))
    (setq x (check-function-name x '(setf documentation)))
    (if (symbolp x)
      (sys::%set-documentation x 'compiler-macro new-value)
      (sys::%set-documentation (second x) 'setf-compiler-macro new-value)))
  (:method (new-value (x symbol) (doc-type (eql 'function)))
    (and (fboundp x)
         (set-function-documentation (sys::unwrapped-fdefinition x) new-value)))
  (:method (new-value (x symbol) (doc-type symbol))
    ;; doc-type = `compiler-macro', `setf', `variable', `type',
    ;; `setf-compiler-macro'
    (sys::%set-documentation x doc-type new-value))
  (:method (new-value (x symbol) (doc-type (eql 'type)))
    (let ((class (find-class x nil)))
      (if class
        (setf (documentation class 't) new-value)
        (call-next-method))))
  (:method (new-value (x symbol) (doc-type (eql 'structure)))
    (setf (documentation x 'type) new-value))
  (:method (new-value (x symbol) (doc-type (eql 'class)))
    (setf (documentation x 'type) new-value))
  (:method (new-value (x method-combination) (doc-type (eql 't)))
    (setf (method-combination-documentation x) new-value))
  (:method
      (new-value (x method-combination) (doc-type (eql 'method-combination)))
    (setf (method-combination-documentation x) new-value))
  (:method (new-value (x symbol) (doc-type (eql 'method-combination)))
    (setf (method-combination-documentation (get-method-combination x '(setf documentation)))
          new-value))
  (:method (new-value (x standard-method) (doc-type (eql 't)))
    (setf (std-method-documentation x) new-value))
  (:method (new-value (x package) (doc-type (eql 't)))
    (let ((doc (sys::package-documentation x)))
      (if (consp doc)
          (setf (first doc) new-value)
          (setf (sys::package-documentation x) new-value))))
  (:method (new-value (x standard-class) (doc-type (eql 't)))
    (setf (class-documentation x) new-value))
  (:method (new-value (x standard-class) (doc-type (eql 'type)))
    (setf (class-documentation x) new-value))
  (:method (new-value (x structure-class) (doc-type (eql 't)))
    (setf (class-documentation x) new-value))
  (:method (new-value (x structure-class) (doc-type (eql 'type)))
    (setf (class-documentation x) new-value))
  ;;; The following are CLISP extensions.
  (:method (new-value (x standard-object) (doc-type (eql 't)))
    (sys::%set-documentation (class-of x) 'type new-value))
  (:method (new-value (x standard-object) (doc-type (eql 'type)))
    (sys::%set-documentation (class-of x) 'type new-value))
  (:method (new-value (x structure-object) (doc-type (eql 't)))
    (sys::%set-documentation (class-of x) 'type new-value))
  (:method (new-value (x structure-object) (doc-type (eql 'type)))
    (sys::%set-documentation (class-of x) 'type new-value))
  (:method (new-value (x defined-class) (doc-type (eql 't)))
    (setf (class-documentation x) new-value))
  (:method (new-value (x defined-class) (doc-type (eql 'type)))
    (setf (class-documentation x) new-value))
  (:method (new-value (x slot-definition) (doc-type (eql 't)))
    (setf (slot-definition-documentation x) new-value)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./documentation.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./backquote.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Backquote Implementation for CLISP

;;; Parts of this file
;;; Copyright 2003 Kaz Kylheku <kaz@ashi.footprints.net>
;;; Dedicated to Pei-Yin Lin
;;;
;;; LIBERAL FREEWARE LICENSE: This Lisp source code document may be used
;;; by anyone for any purpose, and freely redistributed alone or in
;;; combination with other software, provided that the license is not
;;; violated.  The only possible way to violate the license is to
;;; redistribute this code in source form, with the copyright notice or
;;; license removed or altered.  This license applies to this document
;;; only, not any other software that it is combined with.

;;; Parts of this file
;;; Copyright (C) 1988, 1989, 1992-2004 Michael Stoll, Bruno Haible
;;; Copyright (C) 2002-2003, 2005-2006 Sam Steingold
;;; This is Free Software, distributed under the GNU GPL v2+

(in-package "SYSTEM")

;;; ============================== Reader Macro ==============================

;;; At this level, we do only parsing, not simplification, so that things
;;; like `,A print as they were input. Parsing returns
;;; the following                  for
;;;   (BACKQUOTE x)                `x
;;;   (UNQUOTE x)                  ,x
;;;   (SPLICE x)                   ,@x
;;;   (NSPLICE x)                  ,.x

;;; *unquote-occurred* flips to T when a sub-reader encounters the unquote
;;; syntax. This variable is the basis for a trick by which we diagnose uses of
;;; the unquote syntax inside forms which are not vectors or lists, such as:
;;; #`#s(foo-structure :bar #,z) without an cooperation from the readers of
;;; these forms. In some cases, however, such unquote syntax will cause the
;;; reader of the subform to raise an error before we catch it.
(proclaim '(special *unquote-occurred*))

;;; *backquote-level* measures the level of backquote nesting that the reader
;;; is entangled in. It increases by one when reading the backquoted object,
;;; and decreases by one over reading an unquoted form.
(proclaim '(special *backquote-level*))

;;; *reading-array* is normally unbound. When the reader is running, it
;;; is dynamically bound to NIL, and when a #A array is being read,
;;; it is bound to T. This lets the comma-reader signal an error when
;;; unquotes occur in an array.
(proclaim '(special *reading-array*))

;;; *reading-struct* is analogous to *reading-array*, but for structs.
(proclaim '(special *reading-struct*))

;;; Handle the ` read syntax.
(defun backquote-reader (stream char)
  (declare (ignore char))
  (let* ((*unquote-occurred* nil)
         (*reading-array* nil)
         (*reading-struct* nil)
         (*backquote-level* (1+ (or *backquote-level* 0)))
         (object (read stream t nil t)))
    (unless (or (and (vectorp object) (eq (array-element-type object) 'T))
                (listp object))
      (when *unquote-occurred*
        (error-of-type 'reader-error
          :stream stream
          (TEXT "~S: unquotes may occur only in (...) or #(...) forms")
          'read)))
    (when (consp object)
      (let ((head (first object)))
        (when (or (eq head 'SPLICE) (eq head 'NSPLICE))
          (bq-non-list-splice-error head stream)))
      (when (bq-member 'SPLICE object)
        (bq-dotted-splice-error 'SPLICE stream))
      (when (bq-member 'NSPLICE object)
        (bq-dotted-splice-error 'NSPLICE stream)))
    (list 'BACKQUOTE object)))

;;; Handle the read syntax ,
(defun comma-reader (stream char)
  (declare (ignore char))
  (when (null *backquote-level*)
    (error-of-type 'reader-error
      :stream stream
      (TEXT "~S: comma is illegal outside of backquote")
      'read))
  (when (zerop *backquote-level*)
    (error-of-type 'reader-error
      :stream stream
      (TEXT "~S: more commas out than backquotes in, is illegal")
      'read))
  (when *reading-struct*
    (error-of-type 'reader-error
      :stream stream
      (TEXT "~S: unquotes may not occur in structures")
      'read))
  (when *reading-array*
    (error-of-type 'reader-error
      :stream stream
      (TEXT "~S: unquotes may not occur in arrays")
      'read))
  (setq *unquote-occurred* t)
  (let ((*backquote-level* (1- *backquote-level*))
        (next (peek-char nil stream)))
    (cond ((char= next #\@)
           (read-char stream)
           (list 'SPLICE (read stream t nil t)))
          ((char= next #\.)
           (read-char stream)
           (list 'NSPLICE (read stream t nil t)))
          (t (list 'UNQUOTE (read stream t nil t))))))

;;; Like MEMBER but handles improper lists without error.
(defun bq-member (elem list &key (test #'eql))
  (do ((list list (rest list)))
      ((atom list) nil)
   (when (funcall test (first list) elem)
     (return list))))

;;; ----------------------------- Error Messages -----------------------------

;;; Used by the Reader Macro and the Macroexpander.

;;; Signal error for `,.form or `,@form.
;;; It's undefined behaviour; we signal an error for it.
;;; If stream is non-NIL, then add the prefix "READ: ", to flag the error as
;;; coming from the reader.
(defun bq-non-list-splice-error (sym &optional stream)
  (let ((errmsg
          (if (eq sym 'SPLICE)
            (TEXT "the syntax `,@form is invalid")
            (TEXT "the syntax `,.form is invalid"))))
    (if stream
      (error-of-type 'reader-error
        :stream stream
        (TEXT "READ: ~@?")
        errmsg)
      (error-of-type 'error
        "~@?"
        errmsg))))

;;; Signal error for `(... . ,@form) or `(... . ,.form).
;;; It's undefined behaviour; we signal an error for it.
(defun bq-dotted-splice-error (sym &optional stream)
  (let ((errmsg
          (if (eq sym 'SPLICE)
            (TEXT "the syntax `( ... . ,@form) is invalid")
            (TEXT "the syntax `( ... . ,.form) is invalid"))))
    (if stream
      (error-of-type 'reader-error
        :stream stream
        (TEXT "READ: ~@?")
        errmsg)
      (error-of-type 'error
        "~@?"
        errmsg))))

;;; ============================== Macroexpander ==============================

;;; The macroexpander consists of three parts:
;;; - The backquote macro: the entry point, taking the form as provided by
;;;   the reader, and producing an evaluatable form.
;;; - The recursive expansion engine. Its behaviour is dictated by the
;;;   HyperSpec's general description of backquote.
;;; - The expansion optimizer. Its purpose is to use the Lisp's list/vector
;;;   construction primitives as efficiently as possible. It can run in a
;;;   non-optimized mode, where lists are always constructed through LIST and
;;;   APPEND; or optimization can be performed that reduce run-time consing or
;;;   otherwise simplify the macroexpansion.

;;; ------------------------------ Entry-points ------------------------------

;; The BACKQUOTE macro just calls the backquote expander on its argument.
(sys::%set-symbol-function 'BACKQUOTE
  (sys::make-macro
    (function BACKQUOTE
      (lambda (form env)
        (declare (ignore env))
        (bq-expand (second form))))
    '(form)))

;;; ----------------------- Recursive Expansion Engine -----------------------

;;; Top level cases
;;;
;;; `()        -->  ()
;;; `cons      -->  result of (bq-expand-cons cons)
;;; `#( ... )  -->  result of (bq-expand-vector #( ... ))
;;;  other     -->  'other
(defun bq-expand (form)
  ;; we don't have TYPECASE at this stage
  (cond
    ((null form) nil)
    ((consp form)
      ;; Handle base cases as described by HyperSpec, plus nested backquote:
      ;;
      ;; `,form     -->  form
      ;; `,@form    -->  error
      ;; ``form     -->  `form-expanded
      ;; list-form  -->  (append f1 f2 f3 ...) where (f1 f2 f3 ...)
      ;;                 is the output of (bq-expand-list list-form).
      (case (first form)
        ((UNQUOTE)
          (second form))
        ((SPLICE NSPLICE)
          (bq-non-list-splice-error (second form)))
        ((BACKQUOTE)
          (list 'BACKQUOTE (bq-expand (second form))))
        (otherwise
          (let ((expansion (bq-expand-list form)))
            (bq-append-multiple expansion)))))
    ((and (vectorp form) (eq (array-element-type form) 'T))
      ;; Handle vector expansion, along the lines suggested by HyperSpec.
      (let ((expansion (bq-expand-list (map 'list #'identity form))))
        (bq-optimize-for-vector expansion (bq-append-multiple expansion))))
    (t (list 'quote form))))

;;; Handle the transformation of `(x1 x2 x3 ...) as described by HyperSpec
;;; to produce a list of forms that can be combined into an APPEND form.
;;; There is one deviation from the HyperSpec: namely, in the case
;;; `(x1 x2 ... xn . atom) the atom is translated to (BACKQUOTE atom)
;;; rather than (QUOTE atom). This allows for the atom to be a vector
;;; with embedded unquotes, an apparently common extension.
(defun bq-expand-list (forms)
  (let ((expanded '())) ; reversed list of expanded forms to be APPENDed
    (do ()
        ((null forms))
      (let ((expanded-car (bq-transform (first forms))))
        (setq expanded (cons expanded-car expanded)))
      (let ((tail (rest forms)))
        (cond ((null tail) (return-from nil))
              ((consp tail)
               (case (first tail)
                 ;; well-defined dotted unquote `( ... . ,form)
                 ((UNQUOTE)
                  (setq expanded (cons (second tail) expanded))
                  (return-from nil))
                 ;; undefined dotted splice: `( ... . ,@form)
                 ((SPLICE NSPLICE)
                  (bq-dotted-splice-error (first tail)))
                 (otherwise
                  (setq forms tail))))
              (t (setq expanded (cons (list 'BACKQUOTE tail) expanded))
                 (return-from nil)))))
    (nreverse expanded)))

;;; Handle the transformation of [x1] [x2] ... forms as described
;;; in the HyperSpec. In addition, nested backquotes are handled here.
(defun bq-transform (form)
  (if (consp form)
    (case (first form)
      ((UNQUOTE) (bq-list (second form)))
      ((SPLICE) (second form))
      ;; (BQ-NCONCABLE FORM) serves as a parse tree annotation which
      ;; tells the optimizer that FORM may be destructively manipulated.
      ((NSPLICE) (list 'BQ-NCONCABLE (second form)))
      ((BACKQUOTE) (bq-list (list 'BACKQUOTE (bq-expand (second form)))))
      (otherwise (bq-list (bq-expand form))))
    (bq-list (bq-expand form))))

;;; --------------------------- Expansion Optimizer ---------------------------

;;; Naive expansion produces inefficient construction forms, e.g.
;;;   `(,(foo) ,(bar)) => (APPEND (LIST (foo)) (LIST (bar)))
;;;   instead of          (LIST (foo) (bar))
;;; Backquote expansion optimizers are enabled by default, but can be turned
;;; off for debugging.
(proclaim '(special *backquote-optimize-cons*))
(setq *backquote-optimize-cons* t)
(proclaim '(special *backquote-optimize-list*))
(setq *backquote-optimize-list* t)
(proclaim '(special *backquote-optimize-append*))
(setq *backquote-optimize-append* t)
(proclaim '(special *backquote-optimize-nconc*))
(setq *backquote-optimize-nconc* t)
(proclaim '(special *backquote-optimize-vector*))
(setq *backquote-optimize-vector* t)

;;; This simplifies CONS, LIST, APPEND, NCONC calls that are emitted by the
;;; backquote expander. We are *not* allowed to collapse CONS or LIST calls
;;; given by the user.
;;; E.g. `((,a ,b 3) (,a ,@(list b 3)))
;;; can be simplified to (LIST (LIST* A B '(3)) (LIST A B 3))
;;; but not to           (LIST (LIST* A B '(3)) (LIST* A B '(3))).

;;; The set of simplifications has been chosen in a minimal way, to satisfy
;;; the testsuite. Don't add additional simplifications if the testsuite
;;; doesn't show a need for it - otherwise such simplifications would just
;;; be no-ops that slow down the macroexpander.

;;; Some optimizations have to be inhibited on splicing forms because while
;;; primitives LIST and APPEND handle splicing automatically correctly,
;;; primitives like CONS and QUOTE don't.

;;; Tests whether the given form may yield multiple list elements.
;;; Not only ,@x and ,.x are splicing, but also ,,@x !
(defun bq-splicing-p (form)
  (and (consp form)
       (case (first form)
         ((UNQUOTE) (bq-splicing-p (second form)))
         ((SPLICE NSPLICE) t)
         (t nil))))

;;; To convert a splicing form to a non-splicing one.
(defun bq-non-splicing (form)
  (if (bq-splicing-p form) (list 'APPEND form) form))

;;; BQ-CONS returns a form that returns a CONS of the results of the two
;;; given forms. Assumes that form2 is not splicing.
(defun bq-cons (form1 form2)
  (let ((operator (if (bq-splicing-p form1) 'LIST* 'CONS)))
    (if *backquote-optimize-cons*
      ; Simplify `(CONS ,form1 ,form2) or `(LIST* ,form1... ,form2):
      (cond #|
            ((and (not (bq-splicing-p form1)) (constantp form1)
                  (constantp form2))
             ; Both parts constant -> combine immediately.
             (list 'QUOTE (cons (eval form1) (eval form2))))
            ((null form2)
             ; (CONS form1 NIL) -> (LIST form1)
             ; (LIST* form1... NIL) -> (LIST form1...)
             (list 'LIST form1))
            |#
            ((atom form2)
             ; Cannot simplify.
             (list operator form1 form2))
            ((eq (first form2) 'LIST)
             ; (CONS form1 (LIST . more)) -> (LIST form1 . more)
             ; (LIST* form1... (LIST . more)) -> (LIST form1... . more)
             ; Test case: `(,(f1) ,(f2))
             (list* 'LIST form1 (rest form2)))
            #|
            ((or (eq (first form2) 'LIST*) (eq (first form2) 'CONS))
             ; (CONS form1 (LIST* . more)) -> (LIST* form1 . more)
             ; (CONS form1 (CONS . more)) -> (LIST* form1 . more)
             ; (LIST* form1... (LIST* . more)) -> (LIST* form1... . more)
             ; (LIST* form1... (CONS . more)) -> (LIST* form1... . more)
             (list 'LIST* form1 (rest form2)))
            |#
            ((and (consp form2) (eq (first form2) 'QUOTE)
                  (consp (cdr form2)) (null (cddr form2))
                  (not (bq-splicing-p (second form2)))
                  (consp form1) (eq (first form1) 'QUOTE)
                  (consp (cdr form1)) (null (cddr form1))
                  (not (bq-splicing-p (second form1))))
             ; Test case: `(c1 c2)
             (list 'QUOTE (cons (second form1) (second form2))))
            (t (list operator form1 form2)))
      (list operator form1 form2))))

;;; BQ-LIST returns a form that returns a list of the result of the given form.
(defun bq-list (form1)
  ; Equivalent to (bq-cons form1 'NIL).
  (if *backquote-optimize-list*
    (cond ((and (not (bq-splicing-p form1)) (constantp form1))
           ; Test case: `(c1)
           (list 'QUOTE (list (eval form1))))
          (t (list 'LIST form1)))
    (list 'LIST form1)))

;;; BQ-APPEND returns a form that returns the nondestructive concatenation of
;;; the results of the given forms.
(defun bq-append (form1 form2)
  (if *backquote-optimize-append*
    ; Simplify `(APPEND ,form1 ,form2):
    (cond ((null form1)
           ; (APPEND NIL form2) -> (APPEND form2) -> form2
           ; Test case: `(,@() ,@(f1))
           form2)
          ((null form2)
           ; (APPEND form1 NIL) -> (APPEND form1) -> form1
           ; Test case: `(,@(f1) ,@())
           form1)
          ((and (consp form1) (eq (first form1) 'LIST)
                (null (cdr (last form1))))
           ; (APPEND (LIST x1 ... xn) form2) -> (LIST* x1 ... xn form2),
           ; or (CONS x1 form2) if n = 1, or form2 if n = 0.
           ; Test cases: `(,(f1) c2) and `(,(f1) ,(f2))
           (setq form2 (bq-non-splicing form2))
           (cond ((null (cdr form1)) form2)
                 ((null (cddr form1)) (bq-cons (second form1) form2))
                 (t (cons 'LIST* (append (rest form1) (list form2))))))
          ((and (consp form1) (eq (first form1) 'QUOTE)
                (consp (cdr form1)) (null (cddr form1))
                (not (bq-splicing-p (second form1))) ; too hairy
                ; Cannot append to l if l is not a proper list.
                (listp (second form1)) (null (cdr (last (second form1))))
                ; Cannot append to l if l starts with UNQUOTE, because
                ; UNQUOTE expects exactly one argument.
                (not (eq (first (second form1)) 'UNQUOTE)))
           ; (APPEND (QUOTE l) form2) -> (LIST* ... form2)
           ; Test cases: `(c1 c2) and `(c1 ,(f2))
           (setq form2 (bq-non-splicing form2))
           (let ((result form2))
             (do ((l (reverse (second form1)) (cdr l)))
                 ((endp l))
               (setq result (bq-cons (list 'QUOTE (car l)) result)))
             result))
          ((and (consp form2) (eq (first form2) 'APPEND))
           ; (APPEND form1 (APPEND . more)) -> (APPEND form1 . more)
           ; Test case: `(,@(f1) ,@(f2) ,@(f3))
           (list* 'APPEND form1 (rest form2)))
          (t (list 'APPEND form1 form2)))
    (list 'APPEND form1 form2)))

;;; BQ-NCONC returns a form that returns the destructive concatenation of the
;;; results of the given forms.
(defun bq-nconc (form1 form2)
  (if *backquote-optimize-nconc*
    ; Simplify `(NCONC ,form1 ,form2):
    (cond ((null form1)
           ; (NCONC NIL form2) -> (NCONC form2) -> form2
           ; Test case: `(,.() ,.(f1))
           form2)
          ((null form2)
           ; (NCONC form1 NIL) -> (NCONC form1) -> form1
           ; Test case: `(,.(f1) ,.())
           form1)
          ((and (consp form2) (eq (first form2) 'NCONC))
           ; (NCONC form1 (NCONC . more)) -> (NCONC form1 . more)
           ; Test case: `(,.(f1) ,.(f2) ,@(f3))
           (list* 'NCONC form1 (rest form2)))
          (t (list 'NCONC form1 form2)))
    (list 'NCONC form1 form2)))

;;; BQ-APPEND-MULTIPLE returns a form that returns the concatenation of the
;;; results of the given forms. It uses destructive concatenation for forms
;;; that start with BQ-NCONCABLE.
(defun bq-append-multiple (forms)
  (setq forms (reverse forms))
  (if (endp forms)
    'NIL
    (let (result nconcable)
      (let ((form (car forms)))
        (if (and (consp form) (eq (first form) 'BQ-NCONCABLE))
          (setq result (second form) nconcable t)
          (setq result form nconcable nil)))
      (setq forms (cdr forms))
      (do ()
          ((endp forms))
        (let ((form (car forms)))
          (setq result
                (if (and (consp form) (eq (first form) 'BQ-NCONCABLE))
                  ; Must wrap the already constructed result in an APPEND to
                  ; prevent it from splicing, since destructive modifications
                  ; are allowed on form, but not on result.
                  (bq-nconc (second form)
                            (if (and (bq-splicing-p result) (not nconcable))
                              (list 'APPEND result)
                              result))
                  (bq-append form
                             (if (and (bq-splicing-p result) nconcable)
                               (list 'NCONC result)
                               result))))
          (setq nconcable nil))
        (setq forms (cdr forms)))
      ;; The caller cannot handle a naked (SPLICE ...) or (NSPLICE ...) form,
      ;; so wrap it in an APPEND.
      (bq-non-splicing result))))

;;; BQ-OPTIMIZE-FOR-VECTOR generates a better translation for a backquoted
;;; vector. The vector has been already converted to a list, which
;;; was subject to unoptimized backquote expansion. That resulting
;;; list of append arguments is what is passed to this function.
;;; The expansion is optimized and then converted to a vector
;;; form according to these rules:
;;;
;;; '(...)  -> #(...)
;;; (list ...) -> (vector ...)
;;; (append ...) -> (multiple-value-call #'vector ...)
;;;
;;; The (append ...) case is based on the original unoptimized
;;; append args. The arguments are each treated as follows:
;;;
;;; (list ...) -> (values ...)
;;; (splice ...) -> (values-list (append ...))
;;; (nsplice ...) -> (values-list (nconc ...))
;;; other -> (values-list other)
(defun bq-optimize-for-vector (unoptimized optimized)
  (if *backquote-optimize-vector*
    (cond ((or (eq optimized 'NIL)
               (and (consp optimized) (eq (first optimized) 'QUOTE)
                    (consp (cdr optimized)) (null (cddr optimized))
                    (not (bq-splicing-p (second optimized)))))
           ; Create the vector at macroexpansion time.
           (apply #'vector (eval optimized)))
          ((not (consp optimized))
           (list 'APPLY '#'VECTOR optimized))
          ((eq (first optimized) 'LIST)
           ; Test cases: `#(,(f1) ,(f2)) and ``#(,,@(f1) ,,@(f2))
           (cons 'VECTOR (rest optimized)))
          (t (list* 'MULTIPLE-VALUE-CALL '#'VECTOR
                    (mapcan #'(lambda (form &aux (nconcable nil))
                                (when (and (consp form) (eq (first form) 'BQ-NCONCABLE))
                                  (setq form (second form) nconcable t))
                                (cond ((atom form)
                                       (list (list 'VALUES-LIST form)))
                                      ((memq (first form) '(SPLICE NSPLICE))
                                       ; Test case: ``#(,.,.(f1) ,.,@(f2) ,@,.(f3) ,@,@(f4))
                                       (list
                                         (list 'VALUES-LIST
                                           (list (if nconcable 'NCONC 'APPEND)
                                                 form))))
                                      ((eq (first form) 'LIST)
                                       ; Test case: `#(,(f1) ,@(f2))
                                       (mapcar #'(lambda (f)
                                                   (if (bq-splicing-p f)
                                                     (list 'VALUES-LIST (list 'LIST f))
                                                     (list 'VALUES f)))
                                               (rest form)))
                                      ((and (eq (first form) 'QUOTE)
                                            (consp (cdr form)) (null (cddr form))
                                            (not (bq-splicing-p (second form))))
                                       ; Test case: `#(c1 ,@(f2))
                                       (mapcar #'(lambda (x) (list 'QUOTE x))
                                               (second form)))
                                      (t (list (list 'VALUES-LIST form)))))
                             unoptimized))))
    (list 'APPLY '#'VECTOR optimized)))

;;; =========================== Other Entry-points ===========================

;;; Interfaces used by other modules within CLISP, and possibly
;;; by CLISP applications.
;;;
;;; Note: to dynamically add a variable number of unquotes to a nested
;;; backquote, consider using the ,,@ syntax:
;;;
;;;   (let ((unquote-these-forms '((list 1 2) (list 3 4)))
;;;     `(outer `(inner ,,@unquote-these-forms))
;;;
;;; rather than ADD-BACKQUOTE and ADD-UNQUOTE:
;;;
;;;   (let ((unquote-these-forms '((list 1 2) (list 3 4))))
;;;     `(outer ,(system::add-backquote
;;;                `(inner ,@(mapcar #'system::add-unquote
;;;                                  unquote-these-forms)))))
;;;
;;; The effect is like `(outer ,(inner ,(list 1 2) ,(list 3 4)))
;;;
;;; If you want the effect `(outer ,(inner ,@(list 1 2) ,@(list 3 4)))
;;; then substitute `(outer `(inner ,@,@unquote-these-forms))
;;;
;;; If you think you need ADD-BACKQUOTE and ADD-UNQUOTE, or even
;;; the nonexistent ADD-SPLICE, it's likely that your requirements
;;; may be satisfied by the ,,@ and ,@,@ syntax. The distributive
;;; rule is simple: the right ,@ splices the forms into the list, and the
;;; left , or ,@ distributes itself over those forms before the next
;;; expansion round.
;;;
;;; There are exceptions, like the more complicated situation in CLISP's
;;; giant defstruct macro, which prepares a list of nested lists each
;;; containing a buried unquote forms, and then later encloses it in a
;;; backquote.

(defun add-backquote (skel)
  (list 'BACKQUOTE skel))

(defun add-unquote (skel)
  (list 'UNQUOTE skel))

(defun backquote-cons (car cdr)
  (bq-cons car cdr))

(defun backquote-append (left right)
  (bq-append left right))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./backquote.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./subtypep.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; SUBTYPEP
;;;; Bruno Haible 2004-03-28, 2004-04-03
;;;; Sam Steingold 2004-2005

;; SUBTYPEP is very powerful. It can tell:
;; - whether a type is empty:
;;     (subtypep a 'NIL)
;; - whether two types are disjoint:
;;     (subtypep `(AND ,a ,b) 'NIL)
;; - whether two types are equal:
;;     (and (subtypep a b) (subtypep b a))
;; - whether an object is an element of a given type:
;;     (subtypep `(eql ,x) a)
;; - whether two objects are identical:
;;     (subtypep `(eql ,x) `(eql ,y))
;; - whether a number is positive:
;;     (subtypep `(eql ,x) '(real (0) *))
;; and much more.

(in-package "SYSTEM")

;;; SUBTYPEP
;;; After many hacked attempts that always failed to recognize complicated
;;; cases like the equivalence of
;;;   (INTEGER 0 3)                       (MEMBER 0 3 1 2)
;;;   (AND (INTEGER 0 4) (NOT (EQL 2)))   (MEMBER 0 3 1 4)
;;;   (AND (RATIONAL -1 1) (NOT INTEGER)) (AND (OR (RATIONAL -1 (0)) (RATIONAL (0) 1)) (NOT INTEGER))
;;; here finally comes an implementation of the approach presented in
;;;   Henry G. Baker: A Decision Procedure for Common Lisp's SUBTYPEP Predicate
;;;   Lisp and Symbolic Computation 5,3 (Sept. 1992), 157-190.
;;; The main idea is to use AND/OR logic to reduce the problem to 17 disjoint
;;; categories of types, and implement this logic correctly for each of the 17
;;; categories.
;;; The general outline of the decision procedure:
;;; 1. Do some superficial simplification and error checking:
;;;    CANONICALIZE-TYPE.
;;; 2. Flatten the ANDs and ORs of the outermost level and reduce the
;;;    problem to  (SUBTYPEP `(AND ,a1 ... ,am) `(OR ,b1 ... ,bn)).
;;; 3. Remove MEMBER and EQL specifiers from a1, ..., am, b1, ..., bn.
;;; 4. Classify a1, ..., am, b1, ..., bn into one of the 17 categories.
;;; 5. In each of the 17 categories, simplify the AND part and the OR part
;;;    to an appropriate canonical representation (for example, for REAL,
;;;    an ordered list of intervals).
;;; 6. Decide the SUBTYPEP relationship in the particular category.

;;; SUBTYPEP and (function ...) types
;;;
;;; How is SUBTYPEP on specific function types meant to work?
;;;
;;; HyperSpec/Body/syscla_function.html says:
;;;
;;;   "The list form of the function type-specifier can be used only for
;;;    declaration and not for discrimination."
;;;
;;; So this means, the function call
;;;
;;;   (typep #'cons '(function (t t) cons))
;;;
;;; is invalid. But HyperSpec/Body/fun_subtypep.html talks about what
;;; may happen when (function ...) is passed to SUBTYPEP. So the result of
;;;
;;;   (subtypep '(eql #.#'cons) '(function (t t) cons))
;;;
;;; must be either nil;nil (means unknown) or t;t (means true).
;;;
;;; Now, what about
;;;
;;;   (defun covariant ()
;;;     (subtypep '(function (integer integer) cons)
;;;               '(function (t t) cons)))
;;;
;;;   (defun contravariant ()
;;;     (subtypep '(function (t t) cons)
;;;               '(function (integer integer) cons)))
;;;
;;; Can either of these functions ever return true? In other words, are the
;;; argument types in function types covariant or contravariant?
;;;
;;; Since a function that accepts any objects as arguments also accepts,
;;; integers but not versa, the interpretation of a type as a "set of objects"
;;; suggests that
;;;   (covariant)     => nil;t or nil;nil
;;;   (contravariant) => t;t or nil;nil
;;;
;;; But type relationships can also be defined through declarations: According
;;; to HyperSpec/Body/dec_type.html, (subtypep A B) is true if and only if
;;;
;;;   (locally (declare (type A x)) (declare (type B x))
;;;     (form ...))
;;;
;;; is equivalent to
;;;
;;;   (locally (declare (type A x))
;;;     (form ...))
;;;
;;; When we transpose this to function types, (subtypep A B) should be true if
;;; and only if
;;;
;;;   (locally (declare (ftype A x)) (declare (ftype B x))
;;;     (form ...))
;;;
;;; is equivalent to
;;;
;;;   (locally (declare (ftype A x))
;;;     (form ...))
;;;
;;; Using the definition of the semantics of FTYPE declarations in
;;; HyperSpec/Body/syscla_function.html we arrive to the conclusion that
;;;
;;;   (locally (declare (ftype (function (t t) cons) x))
;;;            (declare (ftype (function (integer integer) cons)))
;;;     (form ...))
;;;
;;; is equivalent to
;;;
;;;   (locally (declare (ftype (function (integer integer) cons)))
;;;     (form ...))
;;;
;;; hence
;;;
;;;   (covariant)     => t;t or nil;nil
;;;   (contravariant) => nil;t or nil;nil
;;;
;;; In summary, the view of a type as a "set of objects" leads to a view of
;;; subtypes that is opposite to the view of a function type as describing
;;; function calls. Since "the function type-specifier can be used only for
;;; declaration and not for discrimination" the first view is not the correct
;;; one. Rather the second view should be used.
;;;
;;; However, I believe the contradiction persists because the view of a type
;;; as a "set of objects" is so fundamental.
;;;
;;; Implementations like SBCL, CMUCL use the second view:
;;;
;;;   (covariant)     => t;t
;;;   (contravariant) => nil;t
;;;
;;; Implementations like ACL 6.2 and LispWorks 4.3 punt and return nil;nil.
;;; We do the same.

;;; Defines a type category.
;;; (DEF-TYPE-CATEGORY name atomic-type-specifiers list-type-specifiers
;;;                    and-simplifier or-simplifier subtype-decider)
;;; The name denotes the type category.
;;; The atomic-type-specifiers and list-type-specifiers are lists of symbols.
;;; The and-simplifier, or-simplifier, subtype-decider are lambda expressions.
;;; and-simplifier: Simplifies `(AND ,@parts). Takes a nonempty list of
;;;                 elementary type specifiers, returns a type specifier.
;;;                 Can, but does not need to, return NIL if `(AND ,@parts)
;;;                 is the empty type.
;;; or-simplifier: Simplifies `(OR ,@parts). Takes a list of elementary type
;;;                specifiers, returns a list of elementary type specifiers.
;;; subtype-decider: Decides whether type1 is a subtype of `(OR ,@type2parts).
;;;                  Takes a result of and-simplifier (but not NIL), a result
;;;                  of or-simplifier, and a boolean telling whether an attempt
;;;                  should be made to prove (no) when a (yes) cannot be proven.
;;;                  Returns two values, with the same meaning as in SUBTYPEP.
;;;                  The macros (yes), (no), (unknown) can be used here. (no)
;;;                  may only be returned if the third argument try-prove-no is
;;;                  true.
(defmacro def-type-category (name atomic-type-specifiers list-type-specifiers
                             and-simplifier or-simplifier subtype-decider)
  (let ((and-simplifier-name
          (intern (string-concat "SIMPLIFY-AND-" (symbol-name name)) "SYSTEM"))
        (or-simplifier-name
          (intern (string-concat "SIMPLIFY-OR-" (symbol-name name)) "SYSTEM"))
        (subtype-decider-name
          (intern (string-concat "SUBTYPEP-" (symbol-name name)) "SYSTEM")))
    `(PROGN
       ,@(if (symbol-package name)
           `((EVAL-WHEN (COMPILE LOAD EVAL)
               (SETF (GET ',name 'SUBTYPEP-ATOM) ',atomic-type-specifiers)
               (SETF (GET ',name 'SUBTYPEP-LIST) ',list-type-specifiers)
               (SETQ *type-categories* (UNION *type-categories* '(,name)))
         )  ))
       (DEFUN ,and-simplifier-name ,(cadr and-simplifier)
         ,@(cddr and-simplifier))
       (DEFUN ,or-simplifier-name ,(cadr or-simplifier)
         ,@(cddr or-simplifier))
       ,(multiple-value-bind (body-rest declarations)
            (sys::parse-body (cddr subtype-decider))
          `(DEFUN ,subtype-decider-name ,(cadr subtype-decider)
             ,@(if declarations `((DECLARE ,@declarations)))
             (MACROLET ((YES () '(RETURN-FROM ,subtype-decider-name (VALUES T T)))
                        (NO () '(RETURN-FROM ,subtype-decider-name (VALUES NIL T)))
                        (UNKNOWN () '(RETURN-FROM ,subtype-decider-name (VALUES NIL NIL))))
               ,@body-rest)))
       ,@(if (symbol-package name)
           `((SETF (GET ',name 'SUBTYPEP-SIMPLIFY-AND) ',and-simplifier-name)
             (SETF (GET ',name 'SUBTYPEP-SIMPLIFY-OR) ',or-simplifier-name)
             (SETF (GET ',name 'SUBTYPEP-DECIDE) ',subtype-decider-name)
         )  )
       ',name
     )
) )
;; Defines a type category for a type which has no special subtypes except
;; NIL and itself (ignoring SATISFIES types).
(defmacro def-misc-type-category (name)
  `(PROGN
     (EVAL-WHEN (COMPILE LOAD EVAL)
       (SETF (GET ',name 'SUBTYPEP-ATOM) '(,name))
       (SETF (GET ',name 'SUBTYPEP-LIST) '())
       (SETQ *type-categories* (UNION *type-categories* '(,name)))
     )
     (SETF (GET ',name 'SUBTYPEP-SIMPLIFY-AND) 'SIMPLIFY-AND-MISC)
     (SETF (GET ',name 'SUBTYPEP-SIMPLIFY-OR) 'SIMPLIFY-OR-MISC)
     (SETF (GET ',name 'SUBTYPEP-DECIDE) 'SUBTYPEP-MISC)
     ',name
   )
)
(eval-when (compile load eval)
  (defvar *type-categories* '())
)

(def-type-category ARRAY (ARRAY SIMPLE-ARRAY) (ARRAY SIMPLE-ARRAY)
  ;; Each part is of the form ([SIMPLE-]ARRAY &optional el-type dims).
  (lambda (parts)
    ;; Simplify `(AND ,@parts):
    (let ((final-kind 'ARRAY) (final-eltype '*) (final-dims '*))
      (dolist (type parts `(,final-kind ,final-eltype ,final-dims))
        (when (or (eq type 'SIMPLE-ARRAY)
                  (and (consp type) (eq (first type) 'SIMPLE-ARRAY)))
          (setq final-kind 'SIMPLE-ARRAY))
        (when (and (consp type) (rest type))
          (let ((eltype (second type)))
            (unless (eq eltype '*)
              (setq eltype (upgraded-array-element-type eltype))
              ; Constraint: All upgraded-eltypes must be the same.
              ; Here we use the fact that the upgraded-array-element-type
              ; return values are so simple that they can be compared with
              ; EQUAL.
              (if (eq final-eltype '*)
                (setq final-eltype eltype)
                (unless (equal eltype final-eltype)
                  ; Contradictory element-types.
                  (return 'NIL))))))
        (when (and (consp type) (cddr type))
          (let ((dims (third type)))
            (unless (eq dims '*)
              (if (eq final-dims '*)
                (setq final-dims dims)
                (if (listp dims)
                  (if (listp final-dims)
                    (if (eql (length dims) (length final-dims))
                      (setq final-dims
                            (mapcar #'(lambda (d1 d2)
                                        (if (integerp d2)
                                          (if (integerp d1)
                                            (if (eql d1 d2)
                                              d1
                                              ; Contradictory dimension constraint.
                                              (return 'NIL))
                                            d2)
                                          d1))
                                    final-dims dims))
                      ; Contradictory dimensions constraint.
                      (return 'NIL))
                    (if (eql (length dims) final-dims)
                      (setq final-dims dims)
                      ; Contradictory dimensions constraint.
                      (return 'NIL)))
                  (unless (eql dims (if (listp final-dims) (length final-dims) final-dims))
                    ; Contradictory dimensions constraint.
                    (return 'NIL))))))))))
  (lambda (parts)
    parts)
  (lambda (type1 type2parts try-prove-no)
    (let (kind1 eltype1 dims1)
      (if (atom type1)
        (setq kind1 type1
              eltype1 '*
              dims1 '*)
        (setq kind1 (first type1)
              eltype1 (if (rest type1) (second type1) '*)
              dims1 (if (cddr type1) (third type1) '*)))
      (assert (member kind1 '(ARRAY SIMPLE-ARRAY)))
      (assert (or (eq eltype1 '*)
                  (equal eltype1 (upgraded-array-element-type eltype1))))
      (let ((uncovered-eltypes
              ; The possible results of upgraded-array-element-type.
              '(NIL CHARACTER BIT (UNSIGNED-BYTE 2) (UNSIGNED-BYTE 4)
                (UNSIGNED-BYTE 8) (UNSIGNED-BYTE 16) (UNSIGNED-BYTE 32) T)))
        (dolist (type2 type2parts)
          (let (kind2 eltype2 dims2)
            (if (atom type2)
              (setq kind2 type2
                    eltype2 '*
                    dims2 '*)
              (setq kind2 (first type2)
                    eltype2 (if (rest type2) (second type2) '*)
                    dims2 (if (cddr type2) (third type2) '*)))
            (assert (member kind2 '(ARRAY SIMPLE-ARRAY)))
            (when
              (and (or (eq kind2 'ARRAY) (eq kind2 kind1))
                   (or (eq dims2 '*)
                       (if (listp dims1)
                         (if (listp dims2)
                           (and (eql (length dims1) (length dims2))
                                (every #'(lambda (a b) (or (eq b '*) (eql a b)))
                                       dims1 dims2))
                           (eql (length dims1) dims2))
                         (if (listp dims2)
                           (and (eql dims1 (length dims2))
                                (every #'(lambda (b) (eq b '*)) dims2))
                           (eql dims1 dims2)))))
              (if (eq eltype2 '*)
                (yes)
                (let ((eltype2 (upgraded-array-element-type eltype2)))
                  (if (eq eltype1 '*)
                    ;; type2 does not cover all of type1 but only a significant
                    ;; portion of it. Keep track which portions are covered.
                    (setq uncovered-eltypes
                      (remove eltype2 uncovered-eltypes :test #'equal))
                    (when (equal eltype1 eltype2)
                      (yes))))))))
        (when (null uncovered-eltypes)
          ;; eltype1 was *, and the type2parts cover all possible array element
          ;; types.
          (yes)))
      (when try-prove-no
        ;; We could construct a testimony using MAKE-ARRAY.
        ;; Don't test eltype1 against NIL, since we have arrays with element
        ;; type NIL.
        (when (or (eq dims1 '*)
                  (if (listp dims1)
                    (and (< (length dims1) #,array-rank-limit)
                         (every #'(lambda (a) (or (eq a '*) (< a #,array-dimension-limit)))
                                dims1)
                         (or (member '* dims1)
                             (< (reduce #'* dims1) #,array-total-size-limit)))
                    (< dims1 #,array-rank-limit)))
          (no)))
      (unknown)))
)

(def-type-category COMPLEX (COMPLEX) (COMPLEX)
  ;; Each part is of the form (COMPLEX &optional rtype itype).
  (lambda (parts)
    ;; Simplify `(AND ,@parts):
    (let ((final-rtype '*) (final-itype '*))
      (dolist (type parts)
        (when (and (consp type) (rest type))
          (let* ((rtype (second type))
                 (itype (if (cddr type) (third type) rtype)))
            (unless (eq rtype '*)
              (setq rtype (upgraded-complex-part-type rtype))
              (when (eq final-rtype '*) (setq final-rtype 'REAL))
              (setq final-rtype `(AND ,final-rtype ,rtype)))
            (unless (eq itype '*)
              (setq itype (upgraded-complex-part-type itype))
              (when (eq final-itype '*) (setq final-itype 'REAL))
              (setq final-itype `(AND ,final-itype ,itype))))))
      (if (or (and (not (eq final-rtype '*)) (subtypep final-rtype 'NIL))
              (and (not (eq final-itype '*)) (subtypep final-itype 'NIL)))
        ; Contradictory type constraint.
        'NIL
        (if (and (eq final-rtype '*) (eq final-itype '*))
          'COMPLEX
          `(COMPLEX ,final-rtype ,final-itype)))))
  (lambda (parts)
    parts)
  (lambda (type1 type2parts try-prove-no)
    (let (rtype1 itype1)
      (if (atom type1)
        (setq rtype1 '*
              itype1 '*)
        (setq rtype1 (if (rest type1) (second type1) '*)
              itype1 (if (cddr type1) (third type1) '*)))
      (dolist (type2 type2parts)
        (let (rtype2 itype2)
          (if (atom type2)
            (setq rtype2 '*
                  itype2 '*)
            (setq rtype2 (if (rest type2) (second type2) '*)
                  itype2 (if (cddr type2) (third type2) '*)))
          (when
            (and (or (eq rtype2 '*)
                     (subtypep (if (eq rtype1 '*) 'REAL `(AND REAL ,rtype1))
                               (upgraded-complex-part-type `(AND REAL ,rtype2))))
                 (or ; shortcut to avoid calling subtypep a second time
                     (and (eq itype1 rtype1) (eq itype2 rtype2))
                     (eq itype2 '*)
                     (subtypep (if (eq itype1 '*) 'REAL `(AND REAL ,itype1))
                               (upgraded-complex-part-type `(AND REAL ,itype2)))))
            (yes))))
      (when try-prove-no
        ;; It's too hard to prove a (no) if there is more than one type2.
        (when (<= (length type2parts) 1)
          (multiple-value-bind (remptyis remptyknown)
              (if (eq rtype1 '*)
                (values nil t)
                (subtypep `(AND REAL ,rtype1) 'NIL))
            (multiple-value-bind (iemptyis iemptyknown)
                (if (eq itype1 '*)
                  (values nil t)
                  (subtypep `(AND REAL ,itype1) 'NIL))
              (case (length type2parts)
                (0 (when (and remptyknown (not remptyis)
                              iemptyknown (not iemptyis))
                     (no)))
                (1
                  (let ((type2 (first type2parts)) rtype2 itype2)
                    (if (atom type2)
                      (setq rtype2 '*
                            itype2 '*)
                      (setq rtype2 (if (rest type2) (second type2) '*)
                            itype2 (if (cddr type2) (third type2) '*)))
                    (multiple-value-bind (rsubis rsubknown)
                        (if (eq rtype2 '*)
                          (values t t)
                          (subtypep (if (eq rtype1 '*) 'REAL `(AND REAL ,rtype1))
                                    (upgraded-complex-part-type `(AND REAL ,rtype2))))
                      (multiple-value-bind (isubis isubknown)
                          (if (eq itype2 '*)
                            (values t t)
                            (subtypep (if (eq itype1 '*) 'REAL `(AND REAL ,itype1))
                                      (upgraded-complex-part-type `(AND REAL ,itype2))))
                        (when (or (and rsubknown (not rsubis)
                                       iemptyknown (not iemptyis))
                                  (and isubknown (not isubis)
                                       remptyknown (not remptyis)))
                          (no)))))))))))
        (unknown)))
)

(def-type-category CONS (CONS) (CONS)
  ;; Each part is of the form (CONS &optional cartype cdrtype).
  (lambda (parts)
    ;; Simplify `(AND ,@parts):
    (let ((final-cartype '*) (final-cdrtype '*))
      (dolist (type parts)
        (when (and (consp type) (rest type))
          (let ((cartype (second type)))
            (unless (eq cartype '*)
              (setq final-cartype
                    (if (eq final-cartype '*)
                      cartype
                      `(AND ,final-cartype ,cartype)))))
          (when (cddr type)
            (let ((cdrtype (third type)))
              (unless (eq cdrtype '*)
                (setq final-cdrtype
                      (if (eq final-cdrtype '*)
                        cdrtype
                        `(AND ,final-cdrtype ,cdrtype))))))))
      (if (or (and (not (eq final-cartype '*)) (subtypep final-cartype 'NIL))
              (and (not (eq final-cdrtype '*)) (subtypep final-cdrtype 'NIL)))
        ; Contradictory type constraint.
        'NIL
        (if (and (eq final-cartype '*) (eq final-cdrtype '*))
          'CONS
          `(CONS ,final-cartype ,final-cdrtype)))))
  (lambda (parts)
    parts)
  (lambda (type1 type2parts try-prove-no)
    (let (cartype1 cdrtype1)
      (if (atom type1)
        (setq cartype1 '*
              cdrtype1 '*)
        (setq cartype1 (if (rest type1) (second type1) '*)
              cdrtype1 (if (cddr type1) (third type1) '*)))
      (dolist (type2 type2parts)
        (let (cartype2 cdrtype2)
          (if (atom type2)
            (setq cartype2 '*
                  cdrtype2 '*)
            (setq cartype2 (if (rest type2) (second type2) '*)
                  cdrtype2 (if (cddr type2) (third type2) '*)))
          (when
            (and (or (eq cartype2 '*)
                     (subtypep (if (eq cartype1 '*) 'T cartype1) cartype2))
                 (or (eq cdrtype2 '*)
                     (subtypep (if (eq cdrtype1 '*) 'T cdrtype1) cdrtype2)))
            (yes))))
      (when try-prove-no
        ;; It's too hard to prove a (no) if there is more than one type2.
        (when (<= (length type2parts) 1)
          (multiple-value-bind (caremptyis caremptyknown)
              (if (eq cartype1 '*) (values nil t) (subtypep cartype1 'NIL))
            (multiple-value-bind (cdremptyis cdremptyknown)
                (if (eq cdrtype1 '*) (values nil t) (subtypep cdrtype1 'NIL))
              (case (length type2parts)
                (0 (when (and caremptyknown (not caremptyis)
                              cdremptyknown (not cdremptyis))
                     (no)))
                (1
                  (let ((type2 (first type2parts)) cartype2 cdrtype2)
                    (if (atom type2)
                      (setq cartype2 '*
                            cdrtype2 '*)
                      (setq cartype2 (if (rest type2) (second type2) '*)
                            cdrtype2 (if (cddr type2) (third type2) '*)))
                    (multiple-value-bind (carsubis carsubknown)
                        (if (eq cartype2 '*)
                          (values t t)
                          (subtypep (if (eq cartype1 '*) 'T cartype1) cartype2))
                      (multiple-value-bind (cdrsubis cdrsubknown)
                          (if (eq cdrtype2 '*)
                            (values t t)
                            (subtypep (if (eq cdrtype1 '*) 'T cdrtype1) cdrtype2))
                        (when (or (and carsubknown (not carsubis)
                                       cdremptyknown (not cdremptyis))
                                  (and cdrsubknown (not cdrsubis)
                                       caremptyknown (not caremptyis)))
                          (no)))))))))))
      (unknown)))
)

(def-type-category REAL
  (REAL RATIONAL INTEGER FLOAT SHORT-FLOAT SINGLE-FLOAT DOUBLE-FLOAT LONG-FLOAT)
  (INTERVALS)
  ;; Each part is of the form (kind &optional lo-bound hi-bound).
  ;; The canonical representation is (INTERVALS kind [lo-bound hi-bound]+), a
  ;; non-empty list of disjoint intervals, in ascending order. This allows
  ;; grouping nonadjacent intervals of the same kind together, and also allows
  ;; removing single elements from an interval without too much list surgery.
  ;; If the kind is FLOAT or LONG-FLOAT, the bounds can be rational numbers
  ;; instead of floating-point numbers; this is needed because we don't have
  ;; a floating-point type of maximal precision.
  (lambda (parts)
    ;; Simplify `(AND ,@parts):
    (block simplify
      (let ((final-kind 'REAL))
        (dolist (type parts)
          (let ((kind (if (atom type) type (second type))))
            (if (or ; Exact and inexact types are disjoint.
                    (and (member final-kind '(RATIONAL INTEGER))
                         (member kind '(FLOAT SHORT-FLOAT SINGLE-FLOAT DOUBLE-FLOAT LONG-FLOAT)))
                    (and (member final-kind '(FLOAT SHORT-FLOAT SINGLE-FLOAT DOUBLE-FLOAT LONG-FLOAT))
                         (member kind '(RATIONAL INTEGER)))
                    ; The four different floating-point types are disjoint.
                    (and (member final-kind '(SHORT-FLOAT SINGLE-FLOAT DOUBLE-FLOAT LONG-FLOAT))
                         (member kind '(SHORT-FLOAT SINGLE-FLOAT DOUBLE-FLOAT LONG-FLOAT))
                         (not (eq kind final-kind))))
              (return-from simplify 'NIL)
              (if (real-types-subtypep kind final-kind)
                (setq final-kind kind)
                (assert (real-types-subtypep final-kind kind))))))
        ;; Map the parts all to final-kind, make all INTEGER bounds inclusive,
        ;; and return NIL if any of the parts is empty.
        (setq parts
              (mapcar #'(lambda (type)
                          (let ((intervals (if (atom type) '(* *) (cddr type))))
                            (setq intervals (intervals-mapto intervals final-kind))
                            (when (null intervals)
                              (return-from simplify 'NIL))
                            `(INTERVALS ,final-kind ,@intervals)))
                      parts))
        ;; Intersect the interval ranges.
        (let ((intervals (reduce #'intervals-intersection parts :key #'cddr)))
          (if intervals
            `(INTERVALS ,final-kind ,@intervals)
            'NIL)))))
  (lambda (parts)
    ;; Make all INTEGER bounds inclusive, and remove empty parts.
    (setq parts
          (mapcan #'(lambda (type)
                      (let ((kind (if (atom type) type (second type)))
                            (intervals (if (atom type) '(* *) (cddr type))))
                        (setq intervals (intervals-mapto intervals kind))
                        (if intervals
                          (list `(INTERVALS ,kind ,@intervals))
                          '())))
                  parts))
    ;; Merge those parts together that belong to the same kind. The parts
    ;; list thus becomes a kind of alist, indexed by the number kind.
    (let ((new-parts '()))
      (dolist (type parts)
        (let* ((kind (second type))
               (other (find kind new-parts :key #'second)))
          (if other
            (setf (cddr other) (intervals-union (cddr other) (cddr type) kind))
            (push (list* 'INTERVALS kind (cddr type)) new-parts))))
      (nreverse new-parts)))
  (lambda (type1 type2parts try-prove-no)
    (let ((kind1 (second type1))
          (intervals1 (cddr type1)))
      (dolist (type2 type2parts)
        (let ((kind2 (second type2))
              (intervals2 (cddr type2)))
          (when (real-types-subtypep kind1 kind2)
            (when (intervals-subtypep intervals1 (intervals-mapto intervals2 kind1))
              (yes)))))
      ;; Handle disjoint unions: REAL == RATIONAL u FLOAT,
      ;; FLOAT == SHORT-FLOAT u SINGLE-FLOAT u DOUBLE-FLOAT u LONG-FLOAT,
      ;; through recursion.
      ;; (Think of (FLOAT 0.0 1.0) and
      ;;    (OR (SHORT-FLOAT 0.0s0 1.0s0) (SINGLE-FLOAT 0.0f0 1.0f0)
      ;;        (DOUBLE-FLOAT 0.0d0 1.0d0) (LONG-FLOAT 0.0L0 1.0L0)) ...)
      (when (and (eq kind1 'REAL)
                 ; No possible win if the type2parts are only REAL.
                 (intersection (mapcar #'second type2parts)
                               '(RATIONAL INTEGER FLOAT SHORT-FLOAT
                                 SINGLE-FLOAT DOUBLE-FLOAT LONG-FLOAT)))
        (when (and (let ((type1a (simplify-and-REAL (list type1 'RATIONAL))))
                     (or (eq type1a 'NIL)
                         (subtypep-REAL type1a type2parts nil)))
                   (let ((type1b (simplify-and-REAL (list type1 'FLOAT))))
                     (or (eq type1b 'NIL)
                         (subtypep-REAL type1b type2parts nil))))
          (yes)))
      (when (and (eq kind1 'FLOAT)
                 ; No possible win if the type2parts are only FLOAT and REAL.
                 (intersection (mapcar #'second type2parts)
                               '(SHORT-FLOAT SINGLE-FLOAT DOUBLE-FLOAT
                                 LONG-FLOAT)))
        (when (and (let ((type1a (simplify-and-REAL (list type1 'SHORT-FLOAT))))
                     (or (eq type1a 'NIL)
                         (subtypep-REAL type1a type2parts nil)))
                   (let ((type1b (simplify-and-REAL (list type1 'SINGLE-FLOAT))))
                     (or (eq type1b 'NIL)
                         (subtypep-REAL type1b type2parts nil)))
                   (let ((type1c (simplify-and-REAL (list type1 'DOUBLE-FLOAT))))
                     (or (eq type1c 'NIL)
                         (subtypep-REAL type1c type2parts nil)))
                   (let ((type1d (simplify-and-REAL (list type1 'LONG-FLOAT))))
                     (or (eq type1d 'NIL)
                         (subtypep-REAL type1d type2parts nil))))
          (yes)))
      ;; Similarly, RATIONAL == RATIO u INTEGER.
      ;; (Think of (RATIONAL -1 1) and
      ;;    (OR (INTEGER * *) (RATIONAL -1 (0)) (RATIONAL (0) 1)) ...)
      (when (and (eq kind1 'RATIONAL)
                 ; No possible win if the type2parts are only RATIONAL and REAL.
                 (intersection (mapcar #'second type2parts) '(INTEGER)))
        (when (and ; Look at the INTEGER part only:
                   (let ((type1a (simplify-and-REAL (list type1 'INTEGER))))
                     (or (eq type1a 'NIL)
                         (subtypep-REAL type1a type2parts nil)))
                   ; Look at the RATIO part only:
                   (let ((type2b (find 'RATIONAL type2parts :key #'second)))
                     (and type2b
                          (subtypep-REAL type1
                                         `((INTERVALS RATIONAL ,@(intervals-integer-closure (cddr type2b))))
                                         nil))))
          (yes)))
      (when try-prove-no
        ;; All checks have already been done above.
        (no))
      (unknown)))
)
;; Subtypep for elements of the list
;; (REAL RATIONAL INTEGER FLOAT SHORT-FLOAT SINGLE-FLOAT DOUBLE-FLOAT LONG-FLOAT):
(defun real-types-subtypep (kind1 kind2)
  (or (eq kind1 kind2)
      (eq kind2 'REAL)
      (and (eq kind2 'RATIONAL) (eq kind1 'INTEGER))
      (and (eq kind2 'FLOAT)
           (or (eq kind1 'SHORT-FLOAT) (eq kind1 'SINGLE-FLOAT)
               (eq kind1 'DOUBLE-FLOAT) (eq kind1 'LONG-FLOAT)))))
;; Auxiliary functions working on interval lists: ([lo-bound hi-bound]*).
;; Each interval gives rise to 4 variables:
;;   lo-incl lo-excl  -  inclusive and exclusive lower bound,
;;   hi-incl hi-excl  -  inclusive and exclusive upper bound.
;; Missing bounds indicate -infty (for lo) or infty (for hi).
(defun interval-lolo-<= (lo1-incl lo1-excl lo2-incl lo2-excl)
  (if lo1-incl
    (if lo2-incl (<= lo1-incl lo2-incl) (if lo2-excl (<= lo1-incl lo2-excl) nil))
    (if lo1-excl
      (if lo2-incl (< lo1-excl lo2-incl) (if lo2-excl (<= lo1-excl lo2-excl) nil))
      t)))
(defun interval-lolo-< (lo1-incl lo1-excl lo2-incl lo2-excl)
  (if lo1-incl
    (if lo2-incl (< lo1-incl lo2-incl) (if lo2-excl (< lo1-incl lo2-excl) nil))
    (if lo1-excl
      (if lo2-incl (< lo1-excl lo2-incl) (if lo2-excl (< lo1-excl lo2-excl) nil))
      (if (or lo2-incl lo2-excl) t nil))))
(defun interval-hihi-<= (hi1-incl hi1-excl hi2-incl hi2-excl)
  (if hi1-incl
    (if hi2-incl (<= hi1-incl hi2-incl) (if hi2-excl (< hi1-incl hi2-excl) t))
    (if hi1-excl
      (if hi2-incl (<= hi1-excl hi2-incl) (if hi2-excl (<= hi1-excl hi2-excl) t))
      (if (or hi2-incl hi2-excl) nil t))))
(defun interval-hihi-< (hi1-incl hi1-excl hi2-incl hi2-excl)
  (if hi1-incl
    (if hi2-incl (< hi1-incl hi2-incl) (if hi2-excl (< hi1-incl hi2-excl) t))
    (if hi1-excl
      (if hi2-incl (< hi1-excl hi2-incl) (if hi2-excl (< hi1-excl hi2-excl) t))
      nil)))
; Tests whether the interval [lo,hi] is nonempty.
(defun interval-lohi-<= (lo-incl lo-excl hi-incl hi-excl)
  (if lo-incl
    (if hi-incl (<= lo-incl hi-incl) (if hi-excl (< lo-incl hi-excl) t))
    (if lo-excl
      (if hi-incl (< lo-excl hi-incl) (if hi-excl (< lo-excl hi-excl) t))
      t)))
; Tests whether there are numbers not covered by (-infty,hi] u [lo,infty).
(defun interval-hilo-< (hi-incl hi-excl lo-incl lo-excl)
  (if hi-incl
    (if lo-incl (< hi-incl lo-incl) (if lo-excl (< hi-incl lo-excl) nil))
    (if hi-excl
      (if lo-incl (< hi-excl lo-incl) (if lo-excl (<= hi-excl lo-excl) nil))
      nil)))
; Maps an interval list to a given number type.
(defun intervals-mapto (intervals kind)
  (let ((new-intervals '()))
    (do ((l intervals (cddr l)))
        ((endp l))
      (let* ((lo (car l))
             (lo-incl (and (realp lo) lo))
             (lo-excl (and (consp lo) (car lo)))
             (hi (cadr l))
             (hi-incl (and (realp hi) hi))
             (hi-excl (and (consp hi) (car hi))))
        (flet ((mapto (value kind)
                 (case kind
                   (RATIONAL (values (rational value) nil))
                   (INTEGER (values (ceiling value) nil))
                   ((FLOAT LONG-FLOAT)
                    (if (rationalp value)
                      (let ((x (coerce value kind)))
                        (if (= x value)
                          (values x nil)
                          ;; Keep the rational number, because there is
                          ;; no smallest FLOAT > value.
                          (values value t)))
                      (values value nil)))
                   (t (values (coerce value kind) nil)))))
          (cond (lo-incl
                 (multiple-value-bind (x force-excl) (mapto lo-incl kind)
                   (if (or (< x lo-incl) force-excl)
                     (setq lo-excl x lo-incl nil)
                     (setq lo-incl x))))
                (lo-excl
                 (let ((x (mapto lo-excl kind)))
                   (if (<= x lo-excl)
                     (setq lo-excl x)
                     (setq lo-incl x lo-excl nil))))))
        (flet ((mapto (value kind)
                 (case kind
                   (RATIONAL (values (rational value) nil))
                   (INTEGER (values (floor value) nil))
                   ((FLOAT LONG-FLOAT)
                    (if (rationalp value)
                      (let ((x (coerce value kind)))
                        (if (= x value)
                          (values x nil)
                          ;; Keep the rational number, because there is
                          ;; no smallest FLOAT < value.
                          (values value t)))
                      (values value nil)))
                   (t (values (coerce value kind) nil)))))
          (cond (hi-incl
                 (multiple-value-bind (x force-excl) (mapto hi-incl kind)
                   (if (or (> x hi-incl) force-excl)
                     (setq hi-excl x hi-incl nil)
                     (setq hi-incl x))))
                (hi-excl
                 (let ((x (mapto hi-excl kind)))
                   (if (>= x hi-excl)
                     (setq hi-excl x)
                     (setq hi-incl x hi-excl nil))))))
        (when (eq kind 'INTEGER)
          (when lo-excl (setq lo-incl (+ lo-excl 1) lo-excl nil))
          (when hi-excl (setq hi-incl (- hi-excl 1) hi-excl nil)))
        (when (interval-lohi-<= lo-incl lo-excl hi-incl hi-excl)
          (push (if lo-incl lo-incl (if lo-excl `(,lo-excl) '*)) new-intervals)
          (push (if hi-incl hi-incl (if hi-excl `(,hi-excl) '*)) new-intervals))))
    (nreverse new-intervals)))
; Returns the intersection of two interval lists, assuming the same number type.
(defun intervals-intersection (intervals1 intervals2)
  (if (and intervals1 intervals2)
    (let ((new-intervals '())
          lo1-incl lo1-excl hi1-incl hi1-excl
          lo2-incl lo2-excl hi2-incl hi2-excl)
      (macrolet ((advance1 ()
                   '(let ((lo (car intervals1)) (hi (cadr intervals1)))
                      (setq lo1-incl (and (realp lo) lo))
                      (setq lo1-excl (and (consp lo) (car lo)))
                      (setq hi1-incl (and (realp hi) hi))
                      (setq hi1-excl (and (consp hi) (car hi)))
                      (setq intervals1 (cddr intervals1))))
                 (advance2 ()
                   '(let ((lo (car intervals2)) (hi (cadr intervals2)))
                      (setq lo2-incl (and (realp lo) lo))
                      (setq lo2-excl (and (consp lo) (car lo)))
                      (setq hi2-incl (and (realp hi) hi))
                      (setq hi2-excl (and (consp hi) (car hi)))
                      (setq intervals2 (cddr intervals2)))))
        (advance1)
        (advance2)
        (block outer-loop
          (loop
            ;; Search the start of a common interval.
            (loop
              (cond ((not (interval-lohi-<= lo2-incl lo2-excl hi1-incl hi1-excl))
                     (when (null intervals1) (return-from outer-loop))
                     (advance1))
                    ((not (interval-lohi-<= lo1-incl lo1-excl hi2-incl hi2-excl))
                     (when (null intervals2) (return-from outer-loop))
                     (advance2))
                    (t (return))))
            (multiple-value-bind (lo-incl lo-excl)
                (if (interval-lolo-<= lo1-incl lo1-excl lo2-incl lo2-excl)
                  (values lo2-incl lo2-excl)
                  (values lo1-incl lo1-excl))
              (push (if lo-incl lo-incl (if lo-excl `(,lo-excl) '*))
                    new-intervals)
              ;; Seach the end of the common interval.
              (if (interval-hihi-<= hi1-incl hi1-excl hi2-incl hi2-excl)
                (progn
                  (push (if hi1-incl hi1-incl (if hi1-excl `(,hi1-excl) '*))
                        new-intervals)
                  (when (null intervals1) (return-from outer-loop))
                  (advance1))
                (progn
                  (push (if hi2-incl hi2-incl (if hi2-excl `(,hi2-excl) '*))
                        new-intervals)
                  (when (null intervals2) (return-from outer-loop))
                  (advance2)))))))
      (nreverse new-intervals))
    '()))
; Returns the union of two interval lists, assuming the same number type.
(defun intervals-union (intervals1 intervals2 kind)
  (if (and intervals1 intervals2)
    (let ((new-intervals '())
          lo1-incl lo1-excl (hi1-incl 'uninitialized) hi1-excl
          lo2-incl lo2-excl (hi2-incl 'uninitialized) hi2-excl)
      (macrolet ((halfadvance1 ()
                   '(let ((lo (car intervals1)))
                      (setq lo1-incl (and (realp lo) lo))
                      (setq lo1-excl (and (consp lo) (car lo)))))
                 (halfadvance2 ()
                   '(let ((lo (car intervals2)))
                      (setq lo2-incl (and (realp lo) lo))
                      (setq lo2-excl (and (consp lo) (car lo)))))
                 (advance1 ()
                   '(let ((hi (cadr intervals1)) (lo (caddr intervals1)))
                      (setq hi1-incl (and (realp hi) hi))
                      (setq hi1-excl (and (consp hi) (car hi)))
                      (setq lo1-incl (and (realp lo) lo))
                      (setq lo1-excl (and (consp lo) (car lo)))
                      (setq intervals1 (cddr intervals1))))
                 (advance2 ()
                   '(let ((hi (cadr intervals2)) (lo (caddr intervals2)))
                      (setq hi2-incl (and (realp hi) hi))
                      (setq hi2-excl (and (consp hi) (car hi)))
                      (setq lo2-incl (and (realp lo) lo))
                      (setq lo2-excl (and (consp lo) (car lo)))
                      (setq intervals2 (cddr intervals2)))))
        (halfadvance1)
        (halfadvance2)
        (block outer-loop
          (tagbody start
            ;; Search the start of a union interval.
            (if (interval-lolo-<= lo1-incl lo1-excl lo2-incl lo2-excl)
              (progn
                (push (if lo1-incl lo1-incl (if lo1-excl `(,lo1-excl) '*))
                      new-intervals)
                (go label1))
              (progn
                (push (if lo2-incl lo2-incl (if lo2-excl `(,lo2-excl) '*))
                      new-intervals)
                (go label2)))
            ;; Seach the end of the union interval.
           label1
            (advance1)
            (when (null intervals1)
              (loop
                (cond ((and intervals2
                            (not (interval-hilo-< hi1-incl hi1-excl
                                                  lo2-incl lo2-excl)))
                       (advance2))
                      (t (return))))
              (return-from outer-loop))
            (when (not (interval-hilo-< hi1-incl hi1-excl lo2-incl lo2-excl))
              (go label2))
            (push (if hi1-incl hi1-incl (if hi1-excl `(,hi1-excl) '*))
                  new-intervals)
            (go start)
           label2
            (advance2)
            (when (null intervals2)
              (loop
                (cond ((and intervals1
                            (not (interval-hilo-< hi2-incl hi2-excl
                                                  lo1-incl lo1-excl)))
                       (advance1))
                      (t (return))))
              (return-from outer-loop))
            (when (not (interval-hilo-< hi2-incl hi2-excl lo1-incl lo1-excl))
              (go label1))
            (push (if hi2-incl hi2-incl (if hi2-excl `(,hi2-excl) '*))
                  new-intervals)
            (go start)))
        (if (cond ((eq hi1-incl 'uninitialized) t)
                  ((eq hi2-incl 'uninitialized) nil)
                  (t (interval-hihi-<= hi1-incl hi1-excl hi2-incl hi2-excl)))
          (push (if hi2-incl hi2-incl (if hi2-excl `(,hi2-excl) '*))
                new-intervals)
          (push (if hi1-incl hi1-incl (if hi1-excl `(,hi1-excl) '*))
                new-intervals)))
      (setq new-intervals (nreconc new-intervals (or intervals1 intervals2)))
      ;; Simplify [x,y] u (y,z] and [x,y) u [y,z] to [x,z].
      (do ((l new-intervals))
          ((null (cddr l)))
        (let* ((hi (cadr l))
               (hi-incl (and (realp hi) hi))
               (hi-excl (and (consp hi) (car hi)))
               (lo (caddr l))
               (lo-incl (and (realp lo) lo))
               (lo-excl (and (consp lo) (car lo))))
          (if (or (and hi-incl lo-excl (= lo-excl hi-incl))
                  (and hi-excl lo-incl (= lo-incl hi-excl))
                  (and (eq kind 'INTEGER)
                       hi-incl lo-incl (eql lo-incl (1+ hi-incl))))
            (setf (cdr l) (cdddr l))
            (setq l (cddr l)))))
      new-intervals)
    (or intervals1 intervals2)))
; Tests whether intervals1 is contained in intervals2, assuming the same number
; type.
(defun intervals-subtypep (intervals1 intervals2)
  (if intervals1
    (if intervals2
      (let (lo1-incl lo1-excl hi1-incl hi1-excl
            lo2-incl lo2-excl hi2-incl hi2-excl)
        (macrolet ((advance1 ()
                     '(let ((lo (car intervals1)) (hi (cadr intervals1)))
                        (setq lo1-incl (and (realp lo) lo))
                        (setq lo1-excl (and (consp lo) (car lo)))
                        (setq hi1-incl (and (realp hi) hi))
                        (setq hi1-excl (and (consp hi) (car hi)))
                        (setq intervals1 (cddr intervals1))))
                   (advance2 ()
                     '(let ((lo (car intervals2)) (hi (cadr intervals2)))
                        (setq lo2-incl (and (realp lo) lo))
                        (setq lo2-excl (and (consp lo) (car lo)))
                        (setq hi2-incl (and (realp hi) hi))
                        (setq hi2-excl (and (consp hi) (car hi)))
                        (setq intervals2 (cddr intervals2)))))
          (advance1)
          (advance2)
          (loop
            (when (not (interval-lolo-<= lo2-incl lo2-excl lo1-incl lo1-excl))
              (return-from intervals-subtypep nil))
            (if (interval-hilo-< hi2-incl hi2-excl lo1-incl lo1-excl)
              (progn
                (when (null intervals2)
                  (return-from intervals-subtypep nil))
                (advance2))
              (progn
                (when (not (interval-hihi-<= hi1-incl hi1-excl hi2-incl hi2-excl))
                  (return-from intervals-subtypep nil))
                (when (null intervals1)
                  (return-from intervals-subtypep t))
                (advance1))))))
      nil)
    t))
; Tests whether a given object is covered by the interval.
(defun intervals-typep (intervals obj)
  (do ((l intervals (cddr l)))
      ((endp l) nil)
    (let* ((lo (car l))
           (lo-incl (and (realp lo) lo))
           (lo-excl (and (consp lo) (car lo)))
           (hi (cadr l))
           (hi-incl (and (realp hi) hi))
           (hi-excl (and (consp hi) (car hi))))
      (when (and (if lo-incl (<= lo-incl obj) (if lo-excl (< lo-excl obj) t))
                 (if hi-incl (<= obj hi-incl) (if hi-excl (< obj hi-excl) t)))
        (return t)))))
; Returns the intervals, with exclusive integer bounds replaced with inclusive
; integer bounds. Implicitly, kind = RATIONAL.
(defun intervals-integer-closure (intervals)
  (let ((new-intervals '()))
    (do ((l intervals (cddr l)))
        ((endp l))
      (let* ((lo (car l))
             (lo-incl (and (realp lo) lo))
             (lo-excl (and (consp lo) (car lo)))
             (hi (cadr l))
             (hi-incl (and (realp hi) hi))
             (hi-excl (and (consp hi) (car hi))))
        (when (integerp lo-excl) (setq lo-incl lo-excl lo-excl nil))
        (when (integerp hi-excl) (setq hi-incl hi-excl hi-excl nil))
        (setq new-intervals
              (list* (if hi-incl hi-incl (if hi-excl `(,hi-excl) '*))
                     (if lo-incl lo-incl (if lo-excl `(,lo-excl) '*))
                     new-intervals))))
    (setq new-intervals (nreverse new-intervals))
    ;; Simplify [x,y] u [y,z] and [x,y] u (y,z] and [x,y) u [y,z] to [x,z].
    (do ((l new-intervals))
        ((null (cddr l)))
      (let* ((hi (cadr l))
             (hi-incl (and (realp hi) hi))
             (hi-excl (and (consp hi) (car hi)))
             (lo (caddr l))
             (lo-incl (and (realp lo) lo))
             (lo-excl (and (consp lo) (car lo))))
        (if (or (and hi-incl lo-incl (= lo-incl hi-incl))
                (and hi-incl lo-excl (= lo-excl hi-incl))
                (and hi-excl lo-incl (= lo-incl hi-excl)))
          (setf (cdr l) (cdddr l))
          (setq l (cddr l)))))
    new-intervals))
; Returns the intervals minus a given singleton, assuming it's of the right
; number type.
(defun intervals-remove-one (intervals kind obj)
  (let ((new-intervals '()))
    (flet ((cons-new-interval (lo-incl lo-excl hi-incl hi-excl kind new-intervals)
             (when (eq kind 'INTEGER)
               (when lo-excl (setq lo-incl (+ lo-excl 1) lo-excl nil))
               (when hi-excl (setq hi-incl (- hi-excl 1) hi-excl nil)))
             (if (interval-lohi-<= lo-incl lo-excl hi-incl hi-excl)
               (list* (if hi-incl hi-incl (if hi-excl `(,hi-excl) '*))
                      (if lo-incl lo-incl (if lo-excl `(,lo-excl) '*))
                      new-intervals)
               new-intervals)))
      (macrolet ((add-new-interval (lo-incl lo-excl hi-incl hi-excl)
                   `(setq new-intervals
                          (cons-new-interval ,lo-incl ,lo-excl ,hi-incl ,hi-excl kind
                                             new-intervals))))
        (do ((l intervals (cddr l)))
            ((endp l))
          (let* ((lo (car l))
                 (lo-incl (and (realp lo) lo))
                 (lo-excl (and (consp lo) (car lo)))
                 (hi (cadr l))
                 (hi-incl (and (realp hi) hi))
                 (hi-excl (and (consp hi) (car hi))))
            (if (and (if lo-incl (<= lo-incl obj) (if lo-excl (< lo-excl obj) t))
                     (if hi-incl (<= obj hi-incl) (if hi-excl (< obj hi-excl) t)))
              (progn
                (add-new-interval lo-incl lo-excl nil obj)
                (add-new-interval nil obj hi-incl hi-excl))
              (add-new-interval lo-incl lo-excl hi-incl hi-excl))))))
    (nreverse new-intervals)))
;; Remove a single object from the type. The type is of the form
;; (kind [lo-bound hi-bound]+). The result is a type in the same form, or
;; an `(OR ...) of types in the same form, or NIL.
(defun subtypep-REAL-remove-singleton (type obj)
  (let* ((kind (if (atom type) type (second type)))
         (intervals (if (atom type) '(* *) (cddr type)))
         (test (get kind 'TYPE-SYMBOL)))
    (if (and (funcall test obj) (intervals-typep intervals obj))
      (let ((splittypes
              (case kind
                ;; Have to split the type before removing obj. For example,
                ;; (AND REAL (NOT (EQL 0))) is equivalent to
                ;; (OR (RATIONAL * (0) (0) *) FLOAT), not (REAL * (0) (0) *).
                (REAL
                  (remove 'NIL
                    (list (subtypep-REAL-remove-singleton
                            `(INTERVALS RATIONAL ,@(intervals-mapto intervals 'RATIONAL)) obj)
                          (subtypep-REAL-remove-singleton
                            `(INTERVALS FLOAT ,@(intervals-mapto intervals 'FLOAT)) obj))))
                (FLOAT
                  (remove 'NIL
                    (list (subtypep-REAL-remove-singleton
                            `(INTERVALS SHORT-FLOAT ,@(intervals-mapto intervals 'SHORT-FLOAT)) obj)
                          (subtypep-REAL-remove-singleton
                            `(INTERVALS SINGLE-FLOAT ,@(intervals-mapto intervals 'SINGLE-FLOAT)) obj)
                          (subtypep-REAL-remove-singleton
                            `(INTERVALS DOUBLE-FLOAT ,@(intervals-mapto intervals 'DOUBLE-FLOAT)) obj)
                          (subtypep-REAL-remove-singleton
                            `(INTERVALS LONG-FLOAT ,@(intervals-mapto intervals 'LONG-FLOAT)) obj))))
                (t
                  (setq intervals (intervals-remove-one intervals kind obj))
                  (if intervals (list `(INTERVALS ,kind ,@intervals)) '())))))
        (case (length splittypes)
          (0 'NIL)
          (1 (first splittypes))
          (t `(OR ,@splittypes))))
      type)))

(def-type-category CHARACTER (CHARACTER) (CHARACTER-INTERVALS)
  ;; Each part is of the form (CHARACTER-INTERVALS [lo-bound hi-bound]+), a
  ;; non-empty list of disjoint intervals, in ascending order, or an encoding.
  ;; This allows manipulating encoding as true sets of characters.
  ;; TODO: This needs an update when we use upgraded-complex-element-type.
  (lambda (parts)
    ;; Simplify `(AND ,@parts):
    ;; First, simplify encodings that cover the whole character range.
    (setq parts (mapcar #'subtypep-CHARACTER-pre-simplify parts))
    (setq parts (remove 'CHARACTER parts))
    (case (length parts)
      (0 'CHARACTER)
      (1 (first parts))
      (t
        ;; Intersect the interval ranges.
        (let ((intervals
                (reduce #'intervals-intersection parts
                        :key #'(lambda (type)
                                 (if (encodingp type)
                                   (map 'list #'char-code (get-charset-range (encoding-charset type)))
                                   (rest type))))))
          (if intervals
            `(CHARACTER-INTERVALS ,@intervals)
            'NIL)))))
  (lambda (parts)
    ;; First, simplify encodings that cover the whole character range.
    (setq parts (mapcar #'subtypep-CHARACTER-pre-simplify parts))
    parts)
  (lambda (type1 type2parts try-prove-no)
    ;; Try to work out things without expanding encodings to intervals unless
    ;; really needed.
    (when (member 'CHARACTER type2parts)
      (yes))
    (cond ((encodingp type1)
           (when (member type1 type2parts)
             (yes))
           #| ;; Shortcut that avoids consing but makes testing harder.
           (when (and (eql (length type2parts) 1) (encodingp (first type2parts)))
             (when (charset-subtypep type1 (first type2parts))
               (yes))
             (when try-prove-no (no))
             (unknown))
           |#
           (let ((intervals
                   (map 'list #'char-code (get-charset-range (encoding-charset type1)))))
             (setq type1 `(CHARACTER-INTERVALS ,@intervals))))
          ((eq type1 'CHARACTER)
           (setq type1 '(CHARACTER-INTERVALS 0 #,char-code-limit))))
    ;; Now type1 is in `(CHARACTER-INTERVALS ,@intervals) form.
    (assert (eq (first type1) 'CHARACTER-INTERVALS))
    (let ((intervals1 (rest type1)))
      ;; First pass, ignoring encodings on the right-hand side.
      (dolist (type2 type2parts)
        (unless (encodingp type2)
          (assert (eq (first type2) 'CHARACTER-INTERVALS))
          (let ((intervals2 (rest type2)))
            (when (intervals-subtypep intervals1 intervals2)
              (yes)))))
      ;; Now we need to expand the encodings on the right-hand side.
      (setq type2parts
            (mapcar #'(lambda (type2)
                        (if (encodingp type2)
                          (let ((intervals
                                  (map 'list #'char-code (get-charset-range (encoding-charset type2)))))
                            (when (intervals-subtypep intervals1 intervals)
                              (yes))
                            `(CHARACTER-INTERVALS ,@intervals))
                          type2))
                    type2parts))
      ;; Now all the type2parts are in `(CHARACTER-INTERVALS ,@intervals) form.
      (when (> (length type2parts) 1)
        (let ((intervals2 (reduce #'intervals-union type2parts :key #'rest)))
          (when (intervals-subtypep intervals1 intervals2)
            (yes))))
      (when try-prove-no
        ;; All checks have already been done above.
        (no))
      (unknown)))
)
;; Simplify an encoding that covers the whole character range.
(defun subtypep-CHARACTER-pre-simplify (type)
  (if (encodingp type)
    (let ((charset (encoding-charset type)))
      (case charset
        #+UNICODE
        ((charset:unicode-16-big-endian charset:unicode-16-little-endian
          charset:unicode-32-big-endian charset:unicode-32-little-endian
          charset:utf-8 charset:java)
          'CHARACTER)
        (t
          (if (and (stringp charset)
                   (or (string= charset "UTF-16") (string= charset "UTF-7")))
            'CHARACTER
            type))))
    type))
;; Remove a single object from the type. The type is of the form
;; (CHARACTER [lo-bound hi-bound]+). The result is a type in the same form,
;; or NIL.
(defun subtypep-CHARACTER-remove-singleton (type obj)
  (let ((intervals (if (atom type) '(* *) (rest type))))
    (if (and (characterp obj) (intervals-typep intervals (char-code obj)))
      (progn
        (setq intervals (intervals-remove-one intervals 'INTEGER (char-code obj)))
        (if intervals `(CHARACTER-INTERVALS ,@intervals) 'NIL))
      type)))
;; Conversion of an encoding to a list of intervals.
#+UNICODE
(defun get-charset-range (charset &optional maxintervals)
  (let ((table #,(make-hash-table :key-type '(or string symbol)
                                  :value-type 'simple-string
                                  :test 'stablehash-equal
                                  :warn-if-needs-rehash-after-gc t)))
    ;; cache: charset name -> list of intervals #(start1 end1 ... startm endm)
    #| ; Now in C and much more efficient.
  (defun charset-range (encoding start end)
    (setq start (char-code start))
    (setq end (char-code end))
    (let ((intervals '())   ; finished intervals
          (i1 nil) (i2 nil) ; interval being built
          (i start))
      (loop
        (if (charset-typep (code-char i) encoding)
          (if i2 (setq i2 i) (setq i1 i i2 i))
          (if i2 (setq intervals (list* i2 i1 intervals) i1 nil i2 nil)))
        (when (eql i end) (return))
        (incf i))
      (when i2 (setq intervals (list* i2 i1 intervals)))
      (map 'simple-string #'code-char (nreverse intervals))))
    |#
    ;; Return the definition range of a character set. If necessary, compute it
    ;; and store it in the cache.
    (or (gethash charset table)
        (setf (gethash charset table)
              (charset-range (make-encoding :charset charset)
                             (code-char 0) (code-char (1- char-code-limit))
                             maxintervals)))))
#| ;; Older code for a special case.
;; Test whether all characters encodable in encoding1 are also encodable in
;; encoding2.
 (defun charset-subtypep (encoding1 encoding2)
  #-UNICODE (declare (ignore encoding1 encoding2)) #-UNICODE t
  #+UNICODE
  (let* ((intervals1 (get-charset-range (encoding-charset encoding1)))
         (intervals2 (get-charset-range (encoding-charset encoding2)))
         (n1 (length intervals1))
         (n2 (length intervals2))
         (jj1 0)  ; grows by 2 from 0 to n1
         (jj2 0)) ; grows by 2 from 0 to n2
    (loop
      ;; Get next interval from intervals1.
      (when (eql jj1 n1) (return-from charset-subtypep t))
      (let ((i1 (schar intervals1 jj1)) (i2 (schar intervals1 (+ jj1 1))))
        ;; Test whether [i1,i2] is contained in intervals2.
        (let (i3 i4)
          (loop
            (when (eql jj2 n2) ; [i1,i2] not contained in intervals2.
              (return-from charset-subtypep nil))
            (setq i3 (schar intervals2 jj2))
            (setq i4 (schar intervals2 (+ jj2 1)))
            ;; If i3 <= i4 < i1 <= i2, skip the interval [i3,i4].
            (when (char>= i4 i1) (return))
            (incf jj2 2))
          (when (char< i1 i3) ; i1 not contained in intervals2.
            (return-from charset-subtypep nil))
          (when (char< i4 i2) ; i4+1 (in [i1,i2]) not contained in intervals2.
            (return-from charset-subtypep nil))
          ;; Now (<= i3 i1) and (<= i2 i4),
          ;; hence [i1,i2] is contained in intervals2.
          (incf jj1 2))))))
|#

(def-type-category PATHNAME (PATHNAME LOGICAL-PATHNAME) ()
  ;; Each part is PATHNAME or LOGICAL-PATHNAME.
  (lambda (parts)
    (cond #+LOGICAL-PATHNAMES ((member 'LOGICAL-PATHNAME parts) 'LOGICAL-PATHNAME)
          (t 'PATHNAME)))
  (lambda (parts)
    (cond ((member 'PATHNAME parts) (list 'PATHNAME))
          #+LOGICAL-PATHNAMES ((member 'LOGICAL-PATHNAME parts) (list 'LOGICAL-PATHNAME))
          (t '())))
  (lambda (type1 type2parts try-prove-no)
    (when (and type2parts
               #+LOGICAL-PATHNAMES (or (eq type1 'LOGICAL-PATHNAME)
                                       (eq (first type2parts) 'PATHNAME)))
      (yes))
    (when try-prove-no
      ;; All checks have already been done above.
      (no))
    (unknown))
)

;; Miscellaneous types that each form their own category.
(def-type-category #:misc () ()
  (lambda (parts)
    ; All parts are the same.
    (first parts))
  (lambda (parts)
    parts)
  (lambda (type1 type2parts try-prove-no)
    (declare (ignore type1))
    (when type2parts (yes))
    (when try-prove-no (no))
    (unknown))
)
(def-misc-type-category ENCODING)
(def-misc-type-category HASH-TABLE)
(def-misc-type-category PACKAGE)
(def-misc-type-category RANDOM-STATE)
(def-misc-type-category READTABLE)
(def-misc-type-category SYMBOL)
(def-misc-type-category BYTE)
(def-misc-type-category SPECIAL-OPERATOR)
(def-misc-type-category LOAD-TIME-EVAL)
(def-misc-type-category SYMBOL-MACRO)
#+(or UNIX FFI WIN32)
(def-misc-type-category FOREIGN-POINTER)
#+FFI
(def-misc-type-category FFI::FOREIGN-ADDRESS)
#+FFI
(def-misc-type-category FFI::FOREIGN-VARIABLE)
(def-misc-type-category WEAK-POINTER)
(def-misc-type-category READ-LABEL)
(def-misc-type-category FRAME-POINTER)
(def-misc-type-category SYSTEM-INTERNAL)

(def-type-category STRUCTURE-OBJECT () ()
  ;; Each part is a CLOS class of metaclass <structure-class>.
  ;; Exploit the fact that this metaclass supports no multiple inheritance.
  (lambda (parts)
    ;; Simplify `(AND ,@parts):
    (if (rest parts)
      (let ((minimal-class (first parts)))
        (dolist (other-class (rest parts) minimal-class)
          (cond ((clos::subclassp minimal-class other-class))
                ((clos::subclassp other-class minimal-class)
                 (setq minimal-class other-class))
                (t
                  ;; No multiple inheritance -> minimal-class and other-class
                  ;; can have no common subclass.
                  (return 'NIL)))))
      (first parts)))
  (lambda (parts)
    ;; It's not worth simplifying.
    parts)
  (lambda (type1 type2parts try-prove-no)
    ;; We actually need to test (clos::subclassp type1 class2) only for
    ;; those class2 that are maximal among type2parts. But it's not worth
    ;; determining the maximal classes. Just process them all.
    (dolist (class2 type2parts)
      (when (clos::subclassp type1 class2)
        (yes)))
    (when try-prove-no
      ;; All checks already done. Any instance of class1 would be a testimony.
      (no))
    (unknown))
)

(def-type-category STANDARD-OBJECT () (FUNCTION)
  ;; Each part is
  ;; a CLOS class of metaclass <standard-class> or <funcallable-standard-class>,
  ;; or <function>, of metaclass <built-in-class>,
  ;; or of the form (FUNCTION ...).
  (lambda (parts)
    ;; Simplify `(AND ,@parts):
    (cond #+FFI
          ((member 'FFI::FOREIGN-FUNCTION parts)
           (let ((other-parts
                   (set-difference parts
                     (list (find-class 'FUNCTION) #+FFI 'FFI::FOREIGN-FUNCTION))))
             (if (some #'atom other-parts)
               'NIL
               (if (null other-parts)
                 'FFI::FOREIGN-FUNCTION
                 `(AND ,@parts)))))
          (t (when (some #'consp parts)
               ; If some part is (FUNCTION ...), #<class FUNCTION> is redundant.
               (setq parts (remove (find-class 'FUNCTION) parts)))
             (if (rest parts) `(AND ,@parts) (first parts)))))
  (lambda (parts)
    ;; It's not worth simplifying the intersection of parts with
    ;; '(FUNCTION #+FFI FFI::FOREIGN-FUNCTION).
    parts)
  (lambda (type1 type2parts try-prove-no)
    ;; Under <standard-object>, any set of classes can have a common subclass
    ;; (you only need to be careful about the order of the superclasses when
    ;; you define the subclass, to avoid an error when computing the CPL)
    ;; and therefore also a common instance.
    (cond #+FFI
          ((eq type1 'FFI::FOREIGN-FUNCTION)
           (when (intersection type2parts
                   (list (find-class 'FUNCTION) #+FFI 'FFI::FOREIGN-FUNCTION))
             (yes)))
          ((and (consp type1) (eq (car type1) 'FUNCTION)) ; (FUNCTION ...)
           (when (member (find-class 'FUNCTION) type2parts)
             (yes))
           (when (member type1 type2parts :test #'canonicalized-types-equal-p)
             (yes)))
          (t (let ((type1parts
                     (if (consp type1)
                       (progn (assert (eq (first type1) 'AND)) (rest type1))
                       (list type1))))
               (dolist (class1 type1parts)
                 (if (consp class1) ; (FUNCTION ...)
                   (when (member class1 type2parts :test #'canonicalized-types-equal-p)
                     (yes))
                   (dolist (class2 type2parts)
                     (multiple-value-bind (is known)
                         (indefinite-subclassp class1 class2)
                       (declare (ignore known))
                       (when is
                         (yes)))))))))
    (when try-prove-no
      ;; For classes, all checks already done. Any common instance of type1
      ;; would be a testimony.
      (unless (or (consp type1) (some #'consp type2parts))
        (no)))
    (unknown))
)
;; (indefinite-subclassp class1 class2) is like (clos::subclassp class1 class2),
;; except that it doesn't signal an error if class1 is not finalizable, and
;; it has the same return value convention as SUBTYPEP: NIL, NIL for
;; "unknown"; boolean, T for a definite result.
(defun indefinite-subclassp (class1 class2)
  ;; Can we guarantee that every class with metaclass <standard-class> will be
  ;; a subclass of <standard-object>? I don't think so, because the user can
  ;; play weird games by installing methods on VALIDATE-SUPERCLASSES.
  #|
  (when (and (eq (class-of class1) clos::<standard-class>)
             (eq class2 clos::<standard-object>))
    (return-from indefinite-subclassp (values t t)))
  |#
  ;; Recurse through the known direct superclasses, starting from class1.
  ;; Use a hash table of the already visited classes, to avoid exponential
  ;; running time or running into cycles.
  (let ((ht (make-hash-table :key-type 'class :value-type '(eql t)
                             :test 'ext:stablehash-eq :warn-if-needs-rehash-after-gc t))
        (definite t))
    (labels ((recurse (class)
               (unless (gethash class ht) ; don't visit the same class twice
                 (if (eq class class2)
                   (return-from indefinite-subclassp (values t t))
                   (progn
                     (setf (gethash class ht) t)
                     (if (clos:class-finalized-p class)
                       (when (clos::subclassp class class2)
                         (return-from indefinite-subclassp (values t t)))
                       (dolist (sc (clos:class-direct-superclasses class))
                         (if (clos::forward-reference-to-class-p sc)
                           (setq definite nil)
                           (recurse sc)))))))))
      (recurse class1)
      (values nil definite))))

;; Determine the category of the given type.
;; Returns NIL for types about which nothing is known, such as SATISFIES types.
(defun type-category (type)
  (macrolet ((case-atomic (expr &rest clauses)
               `(CASE ,expr
                  ,@(append (mapcan #'(lambda (category)
                                        (let ((specifiers (get category 'SUBTYPEP-ATOM)))
                                          (if specifiers
                                            (list `(,specifiers ',category))
                                            '())))
                                    *type-categories*)
                            clauses)))
             (case-list (expr &rest clauses)
               `(CASE ,expr
                  ,@(append (mapcan #'(lambda (category)
                                        (let ((specifiers (get category 'SUBTYPEP-LIST)))
                                          (if specifiers
                                            (list `(,specifiers ',category))
                                            '())))
                                    *type-categories*)
                            clauses))))
    (if (consp type)
      (case-list (first type)
        (t 'NIL)) ; SATISFIES and VALUES types cannot be classified.
      (case-atomic type
        ((FUNCTION #+FFI FFI::FOREIGN-FUNCTION)
         ;; FUNCTION is not a category of its own, because of GENERIC-FUNCTION.
         'STANDARD-OBJECT)
        (t (cond ((clos::defined-class-p type)
                  (if (clos::structure-class-p type)
                    'STRUCTURE-OBJECT
                    'STANDARD-OBJECT))
                 ((encodingp type) 'CHARACTER)
                 ((symbolp type)
                  ;; Symbols that name CLOS classes have already been mapped
                  ;; the class object by canonicalize-type. No need to handle
                  ;; them here.
                  'NIL)
                 (t 'NIL)))))))

;; To efficiently handle ranges of real numbers and characters, the REAL and
;; CHARACTER type categories use the type specifiers
;;   (INTERVALS kind [lo-bound hi-bound]+)
;;   (CHARACTER-INTERVALS [lo-bound hi-bound]+)
;; We use this type specifier, instead of just (kind [lo-bound hi-bound]+),
;; so that canonicalize-type can do proper error checking and reject malformed
;; type specifiers like (INTEGER 0 1 4 5) or (CHARACTER 0 255). The reason is
;; that canonicalized types can be fed to canonicalize-type again; indeed,
;; the handling of MEMBER types in subtypep-logic, through
;; subtypep-REAL-remove-singleton and subtypep-CHARACTER-remove-singleton,
;; passes a mix of INTERVALS types and canonicalized types to subtypep.
(setf (get 'INTERVALS 'TYPE-LIST)
      (function type-list-intervals
        (lambda (x kind &rest intervals)
          (let ((test (get kind 'TYPE-SYMBOL)))
            (and (funcall test x)
                 (intervals-typep intervals x))))))
(setf (get 'CHARACTER-INTERVALS 'TYPE-LIST)
      (function type-list-character-intervals
        (lambda (x &rest intervals)
          (and (characterp x) (intervals-typep intervals (char-code x))))))

;; (CANONICALIZE-TYPE type) returns a superficially simplified type.
;; The purpose of this function is not to be a complicated simplifier,
;; but rather it only brings the type into a recognizable shape so that
;; SUBTYPEP can work in the right direction. SUBTYPEP is recursive,
;; therefore CANONICALIZE-TYPE does not need to be recursive. But
;; CANONICALIZE-TYPE must prepare for the classification; that's why
;; for example NUMBER becomes '(OR REAL COMPLEX).
;; CANONICALIZE-TYPE also does non-recursive error checking.
(defun canonicalize-type (type
                          &aux head)
  ;; Expand DEFTYPE types at the outermost level only.
  (setq type (expand-deftype type))
  (cond ((symbolp type)
         (case type
           (ATOM '(NOT CONS))
           (BASE-CHAR #+BASE-CHAR=CHARACTER 'CHARACTER
                      #-BASE-CHAR=CHARACTER '(CHARACTER-INTERVALS 0 #,base-char-code-limit))
           (BIGNUM  '(AND INTEGER (NOT FIXNUM)))
           (BIT '(INTERVALS INTEGER 0 1))
           (BOOLEAN '(MEMBER NIL T))
           (COMPILED-FUNCTION '(AND FUNCTION (SATISFIES COMPILED-FUNCTION-P)))
           (EXTENDED-CHAR #+BASE-CHAR=CHARACTER '(OR) ; NIL
                          #-BASE-CHAR=CHARACTER '(CHARACTER-INTERVALS #,(1+ base-char-code-limit) #,char-code-limit))
           (FIXNUM '(INTERVALS INTEGER #,most-negative-fixnum #,most-positive-fixnum))
           (KEYWORD '(AND SYMBOL (SATISFIES KEYWORDP)))
           (LIST '(OR CONS (MEMBER NIL)))
           ((NIL) '(OR))
           (NULL '(MEMBER NIL))
           (NUMBER '(OR REAL COMPLEX))
           (RATIO '(AND RATIONAL (NOT INTEGER)))
           (SEQUENCE '(OR LIST VECTOR)) ; user-defined sequences??
           (SIGNED-BYTE '(INTERVALS INTEGER * *))
           (STANDARD-CHAR '(CHARACTER-INTERVALS #,(char-code #\Newline) #,(char-code #\Newline) #,(char-code #\Space) #,(char-code #\~)))
           (STRING-CHAR 'CHARACTER)
           ((T) '(AND))
           (UNSIGNED-BYTE '(INTERVALS INTEGER 0 *))
           (ARRAY
            ; (canonicalize-type (list type)) =>
            '(ARRAY))
           (SIMPLE-ARRAY
            ; (canonicalize-type (list type)) =>
            '(SIMPLE-ARRAY))
           (BIT-VECTOR
            ; (canonicalize-type (list type)) =>
            '(ARRAY BIT (*)))
           (SIMPLE-BIT-VECTOR
            ; (canonicalize-type (list type)) =>
            '(SIMPLE-ARRAY BIT (*)))
           ((STRING cs-cl:string)
            ; (canonicalize-type (list type)) =>
            '(OR (ARRAY CHARACTER (*))
                 #-BASE-CHAR=CHARACTER (ARRAY BASE-CHAR (*))
                 (ARRAY NIL (*))))
           (SIMPLE-STRING
            ; (canonicalize-type (list type)) =>
            '(OR (SIMPLE-ARRAY CHARACTER (*))
                 #-BASE-CHAR=CHARACTER (SIMPLE-ARRAY BASE-CHAR (*))
                 (SIMPLE-ARRAY NIL (*))))
           (BASE-STRING
            ; (canonicalize-type (list type)) =>
            '(ARRAY BASE-CHAR (*)))
           (SIMPLE-BASE-STRING
            ; (canonicalize-type (list type)) =>
            '(SIMPLE-ARRAY BASE-CHAR (*)))
           (VECTOR
            ; (canonicalize-type (list type)) =>
            '(ARRAY * (*)))
           (SIMPLE-VECTOR
            ; (canonicalize-type (list type)) =>
            '(SIMPLE-ARRAY T (*)))
           (COMPLEX
            ; (canonicalize-type (list type)) =>
            '(COMPLEX))
           (REAL
            ; (canonicalize-type (list type)) =>
            '(INTERVALS REAL * *))
           (INTEGER
            ; (canonicalize-type (list type)) =>
            '(INTERVALS INTEGER * *))
           (RATIONAL
            ; (canonicalize-type (list type)) =>
            '(INTERVALS RATIONAL * *))
           (FLOAT
            ; (canonicalize-type (list type)) =>
            '(INTERVALS FLOAT * *))
           (SHORT-FLOAT
            ; (canonicalize-type (list type)) =>
            '(INTERVALS SHORT-FLOAT * *))
           (SINGLE-FLOAT
            ; (canonicalize-type (list type)) =>
            '(INTERVALS SINGLE-FLOAT * *))
           (DOUBLE-FLOAT
            ; (canonicalize-type (list type)) =>
            '(INTERVALS DOUBLE-FLOAT * *))
           (LONG-FLOAT
            ; (canonicalize-type (list type)) =>
            '(INTERVALS LONG-FLOAT * *))
           ((FUNCTION STREAM FILE-STREAM SYNONYM-STREAM BROADCAST-STREAM
             CONCATENATED-STREAM TWO-WAY-STREAM ECHO-STREAM STRING-STREAM)
            ;; We treat FUNCTION like a CLOS class, so that
            ;; (subtypep 'GENERIC-FUNCTION FUNCTION) can return T.
            ;; We treat STREAM and subclasses like CLOS classes, so that
            ;; (subtypep 'FUNDAMENTAL-STREAM 'STREAM) can return T.
            (or (clos-class type) type))
           ;; Misc type categories, excluding those that are CLOS classes.
           ((ENCODING BYTE SPECIAL-OPERATOR LOAD-TIME-EVAL SYMBOL-MACRO
             #+(or UNIX FFI WIN32) FOREIGN-POINTER
             #+FFI FFI::FOREIGN-ADDRESS
             #+FFI FFI::FOREIGN-VARIABLE
             #+FFI FFI::FOREIGN-FUNCTION
             WEAK-POINTER READ-LABEL FRAME-POINTER SYSTEM-INTERNAL)
            type)
           (t
            (let ((f (clos-class type)))
              (if f
                (if (clos::built-in-class-p f) type f)
                (or (ds-canonicalize-type type)
                    (typespec-error 'subtypep type)))))))
        ((and (consp type) (symbolp (setq head (first type))))
         (unless (and (list-length type) (null (cdr (last type))))
           (typespec-error 'subtypep type))
         (case head
           (MEMBER ; (MEMBER &rest objects)
            (if (null (rest type))
              '(OR)
              type))
           (EQL ; (EQL object)
            (unless (eql (length type) 2)
              (typespec-error 'subtypep type))
            `(MEMBER ,(second type)))
           ((AND OR) ; (AND type*), (OR type*)
            type)
           (NOT ; (NOT type)
            (unless (eql (length type) 2)
              (typespec-error 'subtypep type))
            type)
           (MOD ; (MOD n)
            (unless (eql (length type) 2)
              (typespec-error 'subtypep type))
            (let ((n (second type)))
              (unless (and (integerp n) (>= n 0))
                (typespec-error 'subtypep type))
              (if (eql n 0) '(OR) `(INTERVALS INTEGER 0 ,(1- n)))))
           (SIGNED-BYTE ; (SIGNED-BYTE &optional s)
            (when (cddr type)
              (typespec-error 'subtypep type))
            (let ((s (if (cdr type) (second type) '*)))
              (if (eq s '*)
                '(INTERVALS INTEGER * *)
                (progn
                  (unless (and (integerp s) (plusp s))
                    (typespec-error 'subtypep type))
                  (let ((n (ash 1 (1- s)))) ; (ash 1 n) == (expt 2 n)
                    `(INTERVALS INTEGER ,(- n) ,(1- n)))))))
           (UNSIGNED-BYTE ; (UNSIGNED-BYTE &optional s)
            (when (cddr type)
              (typespec-error 'subtypep type))
            (let ((s (if (cdr type) (second type) '*)))
              (if (eq s '*)
                '(INTERVALS INTEGER 0 *)
                (progn
                  (unless (and (integerp s) (>= s 0))
                    (typespec-error 'subtypep type))
                  `(INTERVALS INTEGER 0 ,(1- (ash 1 s))))))) ; (ash 1 n) == (expt 2 n)
           (SIMPLE-BIT-VECTOR ; (SIMPLE-BIT-VECTOR &optional size)
            (when (cddr type)
              (typespec-error 'subtypep type))
            (let ((size (if (cdr type) (second type) '*)))
              (unless (or (eq size '*) (and (integerp size) (>= size 0)))
                (typespec-error 'subtypep type))
              `(SIMPLE-ARRAY BIT (,size))))
           (SIMPLE-STRING ; (SIMPLE-STRING &optional size)
            (when (cddr type)
              (typespec-error 'subtypep type))
            (let ((size (if (cdr type) (second type) '*)))
              (unless (or (eq size '*) (and (integerp size) (>= size 0)))
                (typespec-error 'subtypep type))
              `(OR (SIMPLE-ARRAY CHARACTER (,size))
                   #-BASE-CHAR=CHARACTER (SIMPLE-ARRAY BASE-CHAR (,size))
                   (SIMPLE-ARRAY NIL (,size)))))
           (SIMPLE-BASE-STRING ; (SIMPLE-BASE-STRING &optional size)
            (when (cddr type)
              (typespec-error 'subtypep type))
            (let ((size (if (cdr type) (second type) '*)))
              (unless (or (eq size '*) (and (integerp size) (>= size 0)))
                (typespec-error 'subtypep type))
              `(SIMPLE-ARRAY BASE-CHAR (,size))))
           (SIMPLE-VECTOR ; (SIMPLE-VECTOR &optional size)
            (when (cddr type)
              (typespec-error 'subtypep type))
            (let ((size (if (cdr type) (second type) '*)))
              (unless (or (eq size '*) (and (integerp size) (>= size 0)))
                (typespec-error 'subtypep type))
              `(SIMPLE-ARRAY T (,size))))
           (BIT-VECTOR ; (BIT-VECTOR &optional size)
            (when (cddr type)
              (typespec-error 'subtypep type))
            (let ((size (if (cdr type) (second type) '*)))
              (unless (or (eq size '*) (and (integerp size) (>= size 0)))
                (typespec-error 'subtypep type))
              `(ARRAY BIT (,size))))
           ((STRING cs-cl:string) ; (STRING &optional size)
            (when (cddr type)
              (typespec-error 'subtypep type))
            (let ((size (if (cdr type) (second type) '*)))
              (unless (or (eq size '*) (and (integerp size) (>= size 0)))
                (typespec-error 'subtypep type))
              `(OR (ARRAY CHARACTER (,size))
                   #-BASE-CHAR=CHARACTER (ARRAY BASE-CHAR (,size))
                   (ARRAY NIL (,size)))))
           (BASE-STRING ; (BASE-STRING &optional size)
            (when (cddr type)
              (typespec-error 'subtypep type))
            (let ((size (if (cdr type) (second type) '*)))
              (unless (or (eq size '*) (and (integerp size) (>= size 0)))
                (typespec-error 'subtypep type))
              `(ARRAY BASE-CHAR (,size))))
           (VECTOR ; (VECTOR &optional el-type size)
            (when (cdddr type)
              (typespec-error 'subtypep type))
            (let ((el-type (if (cdr type) (second type) '*))
                  (size (if (cddr type) (third type) '*)))
              (unless (or (eq size '*) (and (integerp size) (>= size 0)))
                (typespec-error 'subtypep type))
              `(ARRAY ,el-type (,size))))
           ((ARRAY SIMPLE-ARRAY) ; ([SIMPLE-]ARRAY &optional el-type dims)
            (when (cdddr type)
              (typespec-error 'subtypep type))
            (let ((dims (if (cddr type) (third type) '*)))
              (unless (or (eq dims '*)
                          (and (integerp dims) (>= dims 0))
                          (and (listp dims)
                               (every #'(lambda (d)
                                          (or (eq d '*)
                                              (and (integerp d) (>= d 0))))
                                      dims)))
                (typespec-error 'subtypep type))
              type))
           ((COMPLEX) ; (COMPLEX &optional rtype itype)
            (when (cdddr type)
              (typespec-error 'subtypep type))
            type)
           ((REAL RATIONAL INTEGER FLOAT
             SHORT-FLOAT SINGLE-FLOAT DOUBLE-FLOAT LONG-FLOAT)
            (when (cdddr type)
              (typespec-error 'subtypep type))
            (let ((lo (if (cdr type) (second type) '*))
                  (hi (if (cddr type) (third type) '*))
                  (test (get head 'SYS::TYPE-SYMBOL)))
              (flet ((valid-interval-designator-p (bound test)
                       ;; Tests whether the bound is valid interval designator
                       ;; for the given type.
                       (or (eq bound '*)
                           (funcall test bound)
                           (and (consp bound) (null (cdr bound))
                                (funcall test (first bound))))))
                (unless (and (valid-interval-designator-p lo test)
                             (valid-interval-designator-p hi test))
                  (typespec-error 'subtypep type))
                ; Recons the type, to bring into the multiple-intervals
                ; representation that is used later.
                `(INTERVALS ,head ,lo ,hi))))
           (INTERVALS
            (unless (and (member (second type)
                                 '(REAL RATIONAL INTEGER FLOAT
                                   SHORT-FLOAT SINGLE-FLOAT DOUBLE-FLOAT LONG-FLOAT))
                         (oddp (length (rest type))))
              (typespec-error 'subtypep type))
            ;; We don't perform a full check of the intervals list here,
            ;; for speed.
            type)
           (CHARACTER-INTERVALS
            (unless (oddp (length type))
              (typespec-error 'subtypep type))
            ;; We don't perform a full check of the intervals list here,
            ;; for speed.
            type)
           ((CONS) ; (CONS &optional cartype cdrtype)
            (when (cdddr type)
              (typespec-error 'subtypep type))
            type)
           (SATISFIES ; (SATISFIES predicate)
            (unless (and (null (cddr type)) (symbolp (second type)))
              (typespec-error 'subtypep type))
            type)
           (VALUES ; (VALUES &rest types)
            type)
           (FUNCTION ; (FUNCTION &optional argtypes valuetype)
            (unless (and (listp (cdr type)) (listp (cadr type))
                         (listp (cddr type)) (null (cdddr type)))
              (typespec-error 'subtypep type))
            (if (null (cdr type))
              ;; (FUNCTION) = FUNCTION. Return the CLOS class, as above.
              (clos-class 'FUNCTION)
              type))
           (t (typespec-error 'subtypep type))))
        ((clos::defined-class-p type)
         (if (and (clos::built-in-class-p type)
                  (eq (get (clos:class-name type) 'CLOS::CLOSCLASS) type))
           (canonicalize-type (clos:class-name type))
           type))
        ((clos::eql-specializer-p type)
         `(MEMBER ,(clos::eql-specializer-singleton type)))
        ((encodingp type)
         #+UNICODE type
         #-UNICODE 'CHARACTER)
        (t (typespec-error 'subtypep type))))

;; Compares two canonicalized types for superficial equality.
;; Note that EQUAL is forbidden on types, because of (EQL #1=(x . #1#)).
(defun canonicalized-types-equal-p (type1 type2)
  (or (eq type1 type2)
      (and (consp type1) (consp type2)
           (eq (first type1) (first type2))
           (case (first type1)
             (MEMBER ; (MEMBER &rest objects)
              (let ((objects1 (remove-duplicates (rest type1) :test #'eql))
                    (objects2 (remove-duplicates (rest type2) :test #'eql)))
                (and (eql (length objects1) (length objects2))
                     (or (every #'eql objects1 objects2)
                         (and (null (set-difference objects1 objects2 :test #'eql))
                              (null (set-difference objects2 objects1 :test #'eql)))))))
             (EQL ; (EQL object)
              (eql (second type1) (second type2)))
             ((AND OR COMPLEX CONS VALUES)
              ; (AND type*), (OR type*),
              ; (COMPLEX &optional rtype itype), (CONS &optional cartype cdrtype),
              ; (VALUES &rest types)
              (let ((types1 (rest type1))
                    (types2 (rest type2)))
                (and (eql (length types1) (length types2))
                     (every #'canonicalized-types-equal-p types1 types2))))
             (NOT ; (NOT type)
              (canonicalized-types-equal-p (second type1) (second type2)))
             ((ARRAY SIMPLE-ARRAY) ; ([SIMPLE-]ARRAY &optional el-type dims)
              (and (canonicalized-types-equal-p (if (cdr type1) (second type1))
                                                (if (cdr type2) (second type2)))
                   (equal (cddr type1) (cddr type2))))
             (FUNCTION ; (FUNCTION &optional argtypes valuetype)
              (and (= (length type1) (length type2))
                   (= (length (second type1)) (length (second type2)))
                   (every #'canonicalized-types-equal-p (second type1) (second type2))
                   (canonicalized-types-equal-p (third type1) (third type2))))
             (t ; Other canonicalized types only contain numbers and symbols.
              (equal (rest type1) (rest type2)))))))

(defun subtypep (type1 type2 &optional env
                 &aux head1)
  (macrolet ((yes () '(return-from subtypep (values t t)))
             (no () '(return-from subtypep (values nil t)))
             (unknown () '(return-from subtypep (values nil nil))))
    ;; Rules:
    ;; - Say (yes) or (no) only when the result is mathematically provable.
    ;; - Don't say (unknown) too early, use (unknown) only as a last resort.
    ;; - Don't compare type specificier using EQUAL.
    ;;
    ;; Quick superficial simplification.
    ;; Note: it maps NIL to (OR), T to (AND).
    (setq type1 (canonicalize-type type1))
    (setq type2 (canonicalize-type type2))
    ;; Trivial cases.
    (when (equal '(OR) type1) ; type1 the empty type?
      (yes))
    (when (equal '(AND) type2) ; type2 is T?
      (yes))
    (when (canonicalized-types-equal-p type1 type2)
      ; (subtypep type type) always true
      (yes))
    (when (consp type1)
      (setq head1 (first type1))
      (cond ;; Nothing is known about SATISFIES types.
            ;; But don't signal (unknown) too early.
            ;((and (eq head1 'SATISFIES) (eql (length type1) 2))
            ; (unknown)
            ;)
            ;; EQL: Element must belong to type2.
            ((eq head1 'EQL)
             (return-from subtypep (safe-typep (second type1) type2 env)))
            ;; MEMBER: All elements must belong to type2.
            ((eq head1 'MEMBER)
             (let ((all-yes t))
               (dolist (x (rest type1))
                 (multiple-value-bind (is known) (safe-typep x type2 env)
                   (unless is
                     (if known (no) (setq all-yes nil)))))
               (if all-yes (yes) (unknown))))
            ;; OR: Each type must be a subtype of type2.
            ((eq head1 'OR)
             (let ((all-yes t))
               (dolist (type (rest type1))
                 (multiple-value-bind (is known) (subtypep type type2)
                   (unless is
                     (if known (no) (setq all-yes nil)))))
               (if all-yes (yes) (unknown))))))
    (when (consp type2)
      (cond ;; Nothing is known about SATISFIES types.
            ;; But don't signal (unknown) too early.
            ;((and (eq (first type2) 'SATISFIES) (eql (length type2) 2))
            ; (unknown)
            ;)
            ;; AND: type1 must be a subtype of each type.
            ((eq (first type2) 'AND)
             (let ((all-yes t))
               (dolist (type (rest type2))
                 (multiple-value-bind (is known) (subtypep type1 type)
                   (unless is
                     (if known (no) (setq all-yes nil)))))
               (if all-yes (yes) (unknown))))))
    (subtypep-logic (list type1) (list type2))))
;; Flattening the ANDs and ORs uses two mutually recursive functions.
;; Since our LABELS implementation allocates closures at runtime, use global
;; functions instead.
(defvar *subtypep-type1parts*)
(defvar *subtypep-type2parts*)
(defvar *subtypep-type2eqlparts*)
;; Add a canonicalized type to the left-hand side: type1parts.
(defun subtypep-flatten-AND (type)
  (if (consp type)
    (case (first type)
      (AND
       (mapc #'(lambda (x) (subtypep-flatten-AND (canonicalize-type x)))
             (rest type)))
      (NOT
       (subtypep-flatten-OR (canonicalize-type (second type))))
      (t
       (push type *subtypep-type1parts*)))
    (push type *subtypep-type1parts*)))
;; Add a canonicalized type to the right-hand side: type2parts, type2eqlparts.
(defun subtypep-flatten-OR (type)
  (if (consp type)
    (case (first type)
      (OR
       (mapc #'(lambda (x) (subtypep-flatten-OR (canonicalize-type x)))
             (rest type)))
      (NOT
       (subtypep-flatten-AND (canonicalize-type (second type))))
      (MEMBER
       (setq *subtypep-type2eqlparts*
             (revappend (rest type) *subtypep-type2eqlparts*)))
      (EQL
       (push (second type) *subtypep-type2eqlparts*))
      (t
       (push type *subtypep-type2parts*)))
    (push type *subtypep-type2parts*)))
;; Entry point taking lists of canonicalized type specs.
(defun subtypep-logic (types1 types2)
  (macrolet ((yes () '(return-from subtypep-logic (values t t)))
             (no () '(return-from subtypep-logic (values nil t)))
             (unknown () '(return-from subtypep-logic (values nil nil))))
    ;; Logic simplification: (subtypep type1 type2) is equivalent to
    ;; (subtypep (and type1 (not type2)) nil). Therefore the interesting
    ;; irreducible case is when type1 is an (AND ...) and type2 is an (OR ...).
    ;; Write type1 as `(AND ,@type1parts)
    ;; and type2 as `(OR ,@type2parts (MEMBER ,@type2eqlparts)),
    ;; shuffling around the NOTs according to the rules
    ;;   (subtypep `(AND ,@a (NOT ,c)) `(OR ,@b)) <==> (subtypep `(AND ,@a) `(OR ,@b ,c))
    ;;   (subtypep `(AND ,@a) `(OR ,@b (NOT ,c))) <==> (subtypep `(AND ,@a ,c) `(OR ,@b))
    (let (type1parts type2parts type2eqlparts)
      (let ((*subtypep-type1parts* '())
            (*subtypep-type2parts* '())
            (*subtypep-type2eqlparts* '()))
        (mapc #'subtypep-flatten-AND types1)
        (mapc #'subtypep-flatten-OR types2)
        (setq type1parts (nreverse *subtypep-type1parts*))
        (setq type2parts (nreverse *subtypep-type2parts*))
        (setq type2eqlparts (nreverse *subtypep-type2eqlparts*)))
      ;; type1parts and type2parts are now lists of canonicalized types.
      ;; Now: None of the type1parts is an AND.
      ;;      None of the type2parts is an OR or MEMBER/EQL.
      ;; Remove trivialities:
      (when (member '(OR) type1parts :test #'equal)
        ; The left-hand side is equivalent to the type NIL.
        (yes))
      (when (member '(AND) type2parts :test #'equal)
        ; The right-hand side is equivalent to the type T.
        (yes))
      ;; Remove duplicates:
      (setq type1parts (remove-duplicates type1parts :test #'canonicalized-types-equal-p))
      (setq type2parts (remove-duplicates type2parts :test #'canonicalized-types-equal-p))
      (setq type2eqlparts (remove-duplicates type2eqlparts))
      (setq type2eqlparts
        (remove-if #'(lambda (x)
                       (dolist (tp type2parts nil)
                         (when (safe-typep x tp) (return t))))
                   (the list type2eqlparts)))
      ;; Enumeratable results:
      ;; Does type1parts contain only a finite set?
      (let ((set 't))
        (dolist (part1 type1parts)
          (when (consp part1)
            (cond ((eq (first part1) 'MEMBER)
                   (let ((l (rest part1)))
                     (setq set (if (eq set 't) l (intersection set l)))))
                  ((eq (first part1) 'EQL)
                   (let ((l (list (second part1))))
                     (setq set (if (eq set 't) l (intersection set l))))))))
        (unless (eq set 't) ; Is type1parts entirely enumerated?
          ; Yes, so we can decide the result by a finite number of TYPEP calls.
          (let ((all-yes t))
            (dolist (x set)
              (multiple-value-bind (is1 known1)
                  ; Is x eliminated by `(AND ,@type1parts) ?
                  (let ((all-yes t))
                    (dolist (tp type1parts (values nil all-yes))
                      (multiple-value-bind (is known) (safe-typep x tp)
                        (unless is
                          (if known (return (values t t)) (setq all-yes nil))))))
                (multiple-value-bind (is2 known2)
                    ; Is x contained in `(OR ,@type2parts (MEMBER ,@type2eqlparts)) ?
                    (let ((all-known t))
                      (dolist (tp type2parts
                               (if (member x type2eqlparts) (values t t) (values nil all-known)))
                        (multiple-value-bind (is known) (safe-typep x tp)
                          (when is (return (values t t)))
                          (unless known (setq all-known nil)))))
                  (cond ((and known1 known2)
                         (unless (or is1 is2) (no)))
                        (known1 (unless is1 (setq all-yes nil)))
                        (known2 (unless is2 (setq all-yes nil)))
                        (t (setq all-yes nil))))))
            (if all-yes (yes) (unknown)))))
      ;; Now: None of the type1parts is an AND or MEMBER/EQL.
      ;;      None of the type2parts is an OR or MEMBER/EQL.
      ;; Handle `(OR ...) in type1parts:
      (let ((reducible-part1
              (member-if #'(lambda (part1)
                             (and (consp part1) (eq (first part1) 'OR)))
                         type1parts)))
        (when reducible-part1
          (let ((type1parts-before (ldiff type1parts reducible-part1))
                (type1parts-after (rest reducible-part1))
                (all-yes t))
            (dolist (sub (rest (first reducible-part1)))
              (setq sub (canonicalize-type sub))
              (multiple-value-bind (is known)
                  (subtypep-logic
                    (append type1parts-before (list sub) type1parts-after)
                    (append type2parts (if type2eqlparts `((MEMBER ,@type2eqlparts)) '())))
                (unless is
                  (if known (no) (setq all-yes nil)))))
            (if all-yes (yes) (unknown)))))
      ;; Handle `(AND ...) in type2parts:
      (let ((reducible-part2
              (member-if #'(lambda (part2)
                             (and (consp part2) (eq (first part2) 'AND)))
                         type2parts)))
        (when reducible-part2
          (let ((type2parts-before (ldiff type2parts reducible-part2))
                (type2parts-after (rest reducible-part2))
                (all-yes t))
            (dolist (sub (rest (first reducible-part2)))
              (setq sub (canonicalize-type sub))
              (multiple-value-bind (is known)
                  (subtypep-logic
                    type1parts
                    (append type2parts-before (list sub) type2parts-after
                            (if type2eqlparts `((MEMBER ,@type2eqlparts)) '())))
                (unless is
                  (if known (no) (setq all-yes nil)))))
            (if all-yes (yes) (unknown)))))
      ;; Now: None of the type1parts is an AND, OR or MEMBER/EQL.
      ;;      None of the type2parts is an AND, OR or MEMBER/EQL.
      ;; Simple results:
      ;; Is some part of type1parts the same as a part of type2parts?
      (dolist (part1 type1parts)
        (dolist (part2 type2parts)
          (when (canonicalized-types-equal-p part1 part2)
            (yes))))
      #|
      ;; Is some part of type1parts a subtype of a part of type2parts?
      ;; FIXME: Is this test good or bad for performance?
      (when (or (> (length type1parts) 1) ; avoid infinite recursion
                (> (length type2parts) 1))
        (dolist (part1 type1parts)
          (dolist (part2 type2parts)
            (when (subtypep-logic (list part1) (list part2))
              (yes)))))
      |#
      (when type2eqlparts
        ;; Handle the type2eqlparts.
        ;; The type1parts are either
        ;;   - built-in types that have an arbitrary number of instances, or
        ;;   - numeric or character types, or
        ;;   - SATISFIES types, which are undecidable anyway.
        ;; From each of them we remove each of the type2eqlparts. (It would
        ;; be necessary to remove each of the type2eqlparts only from _one_ of
        ;; the type1parts, but we don't know in advance which one is the best.)
        (let ((modified nil))
          (do ((type2eqlpartsr type2eqlparts))
              ((null type2eqlpartsr))
            (let ((obj (pop type2eqlpartsr)))
              (when (or (realp obj) (characterp obj))
                (let ((got-OR nil))
                  (mapl #'(lambda (l)
                            (let ((type1part (car l)))
                              (cond ((and (realp obj)
                                          (if (atom type1part)
                                            (member type1part
                                                    '(REAL INTEGER RATIONAL FLOAT SHORT-FLOAT
                                                      SINGLE-FLOAT DOUBLE-FLOAT LONG-FLOAT))
                                            (eq (first type1part) 'INTERVALS)))
                                     (let ((type1part-without-obj
                                             (subtypep-REAL-remove-singleton
                                               type1part obj)))
                                       (when (eq type1part-without-obj 'NIL)
                                         (yes))
                                       (unless (equal type1part-without-obj type1part)
                                         (setq modified t)
                                         (when (and (consp type1part-without-obj)
                                                    (eq (first type1part-without-obj) 'OR))
                                           (setq got-OR t)))
                                       (setf (car l) type1part-without-obj)))
                                    ((and (characterp obj)
                                          (if (atom type1part)
                                            (eq type1part 'CHARACTER)
                                            (eq (first type1part) 'CHARACTER-INTERVALS)))
                                     (let ((type1part-without-obj
                                             (subtypep-CHARACTER-remove-singleton
                                               type1part obj)))
                                       (when (eq type1part-without-obj 'NIL)
                                         (yes))
                                       (unless (equal type1part-without-obj type1part)
                                         (setq modified t)
                                         ; `(OR ...) types cannot occur here.
                                         (when (consp type1part-without-obj)
                                           (assert (eq (first type1part-without-obj) 'CHARACTER-INTERVALS))))
                                       (setf (car l) type1part-without-obj))))))
                        type1parts)
                  (when got-OR
                    ; Eliminate the OR, then continue processing.
                    (return-from subtypep-logic
                      (subtypep-logic
                        type1parts
                        (append type2parts
                                (if type2eqlpartsr `((MEMBER ,@type2eqlpartsr)) '())))))))))
          (when modified
            ;; Do the simple tests once again.
            ;; Is some part of type1parts the same as a part of type2parts?
            (dolist (part1 type1parts)
              (dolist (part2 type2parts)
                (when (canonicalized-types-equal-p part1 part2)
                  (yes)))))))
      ;; Now we can forget about type2eqlparts.
      ;; Now it's time to group the type1parts and type2parts into categories.
      (let ((type1category nil))
        (dolist (type1part type1parts)
          (let ((category (type-category type1part)))
            (if category
              (cond ((null type1category)
                     (setq type1category category))
                    ((eq type1category category))
                    (t ; Encountered two different categories.
                      ; `(AND ,@type1parts) therefore is the empty type.
                      (yes))))))
        (unless type1category
          ;; Could not categorize the type1parts.
          (when (null type1parts)
            ;; No wonder: the left-hand side is equivalent to the type T.
            (let ((try-prove-no t))
              (dolist (type2part type2parts)
                (unless (type-category type2part) (setq try-prove-no nil)))
              (when try-prove-no
                ;; No right-hand side can possibly cover all possible objects
                ;; (think of implementation dependent extra misc type
                ;; categories), therefore we can say
                (no))))
          (unknown))
        ;; Keep only the parts belonging to the same category.
        ;; Set try-prove-no to nil if we remove some uncategorized parts
        ;; from type1parts.
        (let ((try-prove-no t))
          (setq type1parts
                (remove-if-not #'(lambda (type1part)
                                   (let ((category (type-category type1part)))
                                     (if (eq category type1category)
                                       t
                                       (progn
                                         (setq try-prove-no nil)
                                         nil))))
                               (the list type1parts)))
          (setq type2parts
                (remove-if-not #'(lambda (type2part)
                                   (let ((category (type-category type2part)))
                                     (if (eq category type1category)
                                       t
                                       (progn
                                         (unless category (setq try-prove-no nil))
                                         nil))))
                               (the list type2parts)))
          ;; Operate using the functions specific to the category.
          (let ((and-simplifier (get type1category 'SUBTYPEP-SIMPLIFY-AND))
                (or-simplifier (get type1category 'SUBTYPEP-SIMPLIFY-OR))
                (decider (get type1category 'SUBTYPEP-DECIDE)))
            ;; Simplify the type1parts. (It is still a non-empty list.)
            ;; Also see if it evidently represents the empty type.
            (let ((type1 (funcall and-simplifier type1parts)))
              (when (eq type1 'NIL)
                ;; The type1parts represent the empty type.
                (yes))
              ;; Simplify the type2parts.
              (setq type2parts (funcall or-simplifier type2parts))
              ;; Now perform the decision.
              (funcall decider type1 type2parts try-prove-no))))))))

#|
;; Debugging hints:
 (in-package "SYSTEM")
 (setf (package-lock *system-package-list*) nil)
 (trace sys::simplify-and-array sys::simplify-or-array sys::subtypep-array
        sys::simplify-and-complex sys::simplify-or-complex sys::subtypep-complex
        sys::simplify-and-cons sys::simplify-or-cons sys::subtypep-cons
        sys::simplify-and-real sys::simplify-or-real sys::subtypep-real
        sys::intervals-mapto sys::intervals-intersection sys::intervals-union sys::intervals-subtypep
        sys::intervals-typep sys::intervals-integer-closure
        sys::intervals-remove-one sys::subtypep-REAL-remove-singleton
        sys::simplify-and-character sys::simplify-or-character sys::subtypep-character
        sys::subtypep-CHARACTER-pre-simplify sys::subtypep-CHARACTER-remove-singleton
        sys::subtypep-pathname
        sys::subtypep-misc
        sys::simplify-and-structure-object sys::subtypep-structure-object
        sys::simplify-and-standard-object sys::subtypep-standard-object
        sys::type-category
        sys::canonicalize-type
        subtypep sys::subtypep-logic)
|#
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./subtypep.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./gray.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Gray streams, following David N. Gray's STREAM-DEFINITION-BY-USER proposal
;;; ftp://parcftp.xerox.com/pub/cl/cleanup/mail/stream-definition-by-user.mail

(in-package "GRAY")

(common-lisp:export
 '(;; Classes:
   fundamental-stream
   fundamental-input-stream
   fundamental-output-stream
   fundamental-character-stream
   fundamental-binary-stream
   fundamental-character-input-stream
   fundamental-character-output-stream
   fundamental-binary-input-stream
   fundamental-binary-output-stream
   ;; general generic functions:
   stream-position
   stream-read-sequence
   stream-write-sequence
   ;; Generic functions for character input:
   stream-read-char
   stream-unread-char
   stream-read-char-no-hang
   stream-peek-char
   stream-listen
   stream-read-char-will-hang-p
   stream-read-char-sequence
   stream-read-line
   stream-clear-input
   ;; Generic functions for character output:
   stream-write-char
   stream-line-column
   stream-start-line-p
   stream-write-char-sequence
   stream-write-string
   stream-terpri
   stream-fresh-line
   stream-finish-output
   stream-force-output
   stream-clear-output
   stream-advance-to-column
   ;; Generic functions for binary input:
   stream-read-byte
   stream-read-byte-lookahead
   stream-read-byte-will-hang-p
   stream-read-byte-no-hang
   stream-read-byte-sequence
   ;; Generic functions for binary output:
   stream-write-byte
   stream-write-byte-sequence))
(common-lisp:in-package "SYSTEM")
(import '(close open-stream-p stream-element-type) "GRAY")
(use-package '("GRAY") "EXT")
(ext:re-export "GRAY" "EXT")

;; Classes

(defmethod clos:validate-superclass ((class class)
                                     (superclass (eql clos::<stream>)))
  (or (call-next-method)
      (eq (clos:class-name class) 'fundamental-stream)))
(ext:compiler-let ((clos::*allow-mixing-metaclasses* t))
  (let ((clos::*allow-mixing-metaclasses* t))
    (clos:defclass fundamental-stream (stream clos:standard-object)
      (($open :type boolean :initform t) ; whether the stream is open
       ($fasl :type boolean :initform nil) ; read-eval is allowed; \r=#\Return
       ($penl :type boolean :initform nil))))) ; whether an elastic newline is pending

(clos:defclass fundamental-input-stream (fundamental-stream)
  ())

(clos:defclass fundamental-output-stream (fundamental-stream)
  ())

; Stuff these classes into the runtime system.
(%defgray
  (vector
    (clos:find-class 'fundamental-stream)       ; for STREAMP to work
    (clos:find-class 'fundamental-input-stream) ; for INPUT-STREAM-P to work
    (clos:find-class 'fundamental-output-stream))) ; for OUTPUT-STREAM-P to work

(clos:defclass fundamental-character-stream (fundamental-stream)
  ())

(clos:defclass fundamental-binary-stream (fundamental-stream)
  ())

(clos:defclass fundamental-character-input-stream
    (fundamental-input-stream fundamental-character-stream)
  (($lastchar :initform nil))) ; last character read (and not yet unread)


(clos:defclass fundamental-character-output-stream
    (fundamental-output-stream fundamental-character-stream)
  ())

(clos:defclass fundamental-binary-input-stream
    (fundamental-input-stream fundamental-binary-stream)
  ())

(clos:defclass fundamental-binary-output-stream
    (fundamental-output-stream fundamental-binary-stream)
  ())

;; General generic functions

(clos:defgeneric close (stream &key abort)
  (declare (dynamically-modifiable))
  (:method ((stream stream) &rest args)
    (apply #'sys::built-in-stream-close stream args))
  (:method ((stream fundamental-stream) &rest more-args)
    (declare (ignore more-args))
    (clos:with-slots ($open $penl) stream
      (when $penl (setq $penl nil) (write-char #\Newline stream))
      (prog1 $open (setq $open nil)))))

(clos:defgeneric open-stream-p (stream)
  (declare (dynamically-modifiable))
  (:method ((stream stream))
    (sys::built-in-stream-open-p stream))
  (:method ((stream fundamental-stream))
    (clos:with-slots ($open) stream
      $open)))

(clos:defgeneric stream-element-type (stream)
  (declare (dynamically-modifiable))
  (:method ((stream stream))
    (sys::built-in-stream-element-type stream))
  (:method ((stream fundamental-stream))
    (clos:no-applicable-method #'stream-element-type stream))
  (:method ((stream fundamental-character-stream))
    'CHARACTER))
(clos:defgeneric (setf stream-element-type) (new-element-type stream)
  (declare (dynamically-modifiable))
  (:method (new-element-type (stream stream))
    (sys::built-in-stream-set-element-type stream new-element-type))
  (:method (new-element-type (stream fundamental-stream))
    (clos:no-applicable-method #'(setf stream-element-type) new-element-type stream)))

(clos:defgeneric stream-position (stream position)
  (declare (dynamically-modifiable))
  (:method ((stream stream) position)
    (if position
        (cl:file-position stream position)
        (cl:file-position stream)))
  (:method ((stream fundamental-stream) position)
    (clos:no-applicable-method #'stream-position stream position)))


(clos:defgeneric stream-read-sequence (sequence stream &key start end)
  (declare (dynamically-modifiable))
  (:method (sequence (stream fundamental-binary-input-stream)
            &key (start 0) (end nil))
    (stream-read-byte-sequence stream sequence start end))
  (:method (sequence (stream fundamental-character-input-stream)
            &key (start 0) (end nil))
    (stream-read-char-sequence stream sequence start end))
  (:method (sequence (stream fundamental-input-stream) &rest rest)
    (apply #'sys::%read-sequence sequence stream rest)))

(clos:defgeneric stream-write-sequence (sequence stream &key start end)
  (declare (dynamically-modifiable))
  (:method (sequence (stream fundamental-binary-output-stream)
            &key (start 0) (end nil))
    (stream-write-byte-sequence stream sequence start end))
  (:method (sequence (stream fundamental-character-output-stream)
            &key (start 0) (end nil))
    (stream-write-char-sequence stream sequence start end))
  (:method (sequence (stream fundamental-output-stream) &rest rest)
    (apply #'sys::%write-sequence sequence stream rest)))

;; Generic functions for character input

; We define the methods on fundamental-input-stream, not
; fundamental-character-input-stream, so that people can use
; (setf stream-element-type).

(clos:defgeneric stream-read-char (stream)
  (declare (dynamically-modifiable)))

(clos:defgeneric stream-unread-char (stream char)
  (declare (dynamically-modifiable)))

(clos:defgeneric stream-read-char-no-hang (stream)
  (declare (dynamically-modifiable))
  (:method ((stream fundamental-input-stream))
    (stream-read-char stream)))

(clos:defgeneric stream-peek-char (stream)
  (declare (dynamically-modifiable))
  (:method ((stream fundamental-input-stream))
    (let ((c (stream-read-char stream)))
      (unless (eq c ':EOF) (stream-unread-char stream c))
      c)))

(clos:defgeneric stream-listen (stream)
  (declare (dynamically-modifiable))
  (:method ((stream fundamental-input-stream))
    (let ((c (stream-read-char-no-hang stream)))
      (if (or (eq c 'NIL) (eq c ':EOF))
        nil
        (progn (stream-unread-char stream c) t)))))

(clos:defgeneric stream-read-char-will-hang-p (stream)
  (declare (dynamically-modifiable))
  (:method ((stream fundamental-input-stream))
    (let ((c (stream-read-char-no-hang stream)))
      (cond ((eq c 'NIL) t)
            ((eq c ':EOF) nil)
            (t (stream-unread-char stream c) nil)))))

(clos:defgeneric stream-read-char-sequence (stream sequence &optional start end)
  (declare (dynamically-modifiable))
  (:method ((stream fundamental-input-stream) (sequence string)
            &optional (start 0) (end nil))
    ; sequence is a simple-string, and start and end are suitable integers.
    (unless end (setq end (length sequence)))
    (do ((index start (1+ index)))
        ((eql index end) index)
      (let ((c (stream-read-char stream)))
        (when (eq c ':EOF) (return index))
        (setf (char sequence index) c)))))

(clos:defgeneric stream-read-line (stream)
  (declare (dynamically-modifiable))
  (:method ((stream fundamental-input-stream))
    (let ((buffer (make-array 10 :element-type 'character :adjustable t :fill-pointer 0)))
      (loop
        (let ((c (stream-read-char stream)))
          (cond ((eq c ':EOF) (return (values (coerce buffer 'simple-string) t)))
                ((eql c #\Newline) (return (values (coerce buffer 'simple-string) nil)))
                (t (vector-push-extend c buffer))))))))

(clos:defgeneric stream-clear-input (stream)
  (declare (dynamically-modifiable))
  (:method ((stream fundamental-input-stream))
    nil))

;; Generic functions for character output

; We define the methods on fundamental-output-stream, not
; fundamental-character-output-stream, so that people can use
; (setf stream-element-type).

(clos:defgeneric stream-write-char (stream character)
  (declare (dynamically-modifiable)))

(clos:defgeneric stream-line-column (stream)
  (declare (dynamically-modifiable)))

(clos:defgeneric stream-start-line-p (stream)
  (declare (dynamically-modifiable))
  (:method ((stream fundamental-output-stream))
    (eql (stream-line-column stream) 0)))

(clos:defgeneric stream-write-char-sequence (stream sequence &optional start end)
  (declare (dynamically-modifiable))
  (:method ((stream fundamental-output-stream) (sequence string)
            &optional (start 0) (end nil))
    ; sequence is a simple-string, and start and end are suitable integers.
    (unless end (setq end (length sequence)))
    (do ((index start (1+ index)))
        ((eql index end) nil)
      (stream-write-char stream (char sequence index)))))

(clos:defgeneric stream-write-string (stream string &optional start end)
  (declare (dynamically-modifiable))
  (:method ((stream fundamental-output-stream) string &optional (start 0) (end nil))
    (stream-write-char-sequence stream string start end)
    string))

(clos:defgeneric stream-terpri (stream)
  (declare (dynamically-modifiable))
  (:method ((stream fundamental-output-stream))
    (stream-write-char stream #\Newline)
    nil))

(clos:defgeneric stream-fresh-line (stream)
  (declare (dynamically-modifiable))
  (:method ((stream fundamental-output-stream))
    (if (stream-start-line-p stream)
      nil
      (progn (stream-terpri stream) t))))

(clos:defgeneric stream-finish-output (stream)
  (declare (dynamically-modifiable))
  (:method ((stream fundamental-output-stream))
    nil))

(clos:defgeneric stream-force-output (stream)
  (declare (dynamically-modifiable))
  (:method ((stream fundamental-output-stream))
    nil))

(clos:defgeneric stream-clear-output (stream)
  (declare (dynamically-modifiable))
  (:method ((stream fundamental-output-stream))
    nil))

(clos:defgeneric stream-advance-to-column (stream column)
  (declare (dynamically-modifiable))
  (:method ((stream fundamental-output-stream) (column real))
    (let ((currcol (stream-line-column stream)))
      (if currcol
        (dotimes (i (- column currcol) t) (stream-write-char stream #\Space))
        nil))))

;; Generic functions for binary input

(clos:defgeneric stream-read-byte (stream)
  (declare (dynamically-modifiable)))

(clos:defgeneric stream-read-byte-lookahead (stream)
  (declare (dynamically-modifiable)))

(clos:defgeneric stream-read-byte-will-hang-p (stream)
  (declare (dynamically-modifiable))
  (:method ((stream fundamental-input-stream))
    (eq (stream-read-byte-lookahead stream) 'NIL)))

(clos:defgeneric stream-read-byte-no-hang (stream)
  (declare (dynamically-modifiable))
  (:method ((stream fundamental-input-stream))
    (if (stream-read-byte-lookahead stream)
      (stream-read-byte stream)
      nil)))

(clos:defgeneric stream-read-byte-sequence (stream sequence
                                            &optional start end no-hang interactive)
  (declare (dynamically-modifiable))
  (:method ((stream fundamental-input-stream) (sequence vector)
            &optional (start 0) (end nil) (no-hang nil) (interactive nil))
    ;; sequence is a (simple-array (unsigned-byte 8) (*)),
    ;; and start and end are suitable integers.
    (unless end (setq end (length sequence)))
    (do ((index start (1+ index)))
        ((eql index end) index)
      (let ((x (if (or no-hang (and interactive (> index start)))
                 (stream-read-byte-no-hang stream)
                 (stream-read-byte stream))))
        (when (or (null x) (eq x ':EOF)) (return index))
        (setf (aref sequence index) x)))))

;; Generic functions for binary output

(clos:defgeneric stream-write-byte (stream integer)
  (declare (dynamically-modifiable)))

(clos:defgeneric stream-write-byte-sequence (stream sequence
                                             &optional start end no-hang interactive)
  (declare (dynamically-modifiable))
  (:method ((stream fundamental-output-stream) (sequence vector)
            &optional (start 0) (end nil) (no-hang nil) (interactive nil))
    ;; sequence is a (simple-array (unsigned-byte 8) (*)),
    ;; and start and end are suitable integers.
    ;; if no-hang and you write less than end-start bytes then you should
    ;; return the first unwritten index as the second value
    ;; first value should then be sequence argument
    (when no-hang
      (error "~S: ~S is not supported by the default method"
             'stream-write-byte-sequence :NO-HANG))
    (when interactive
      (error "~S: ~S is not supported by the default method"
             'stream-write-byte-sequence :INTERACTIVE))
    (unless end (setq end (length sequence)))
    (do ((index start (1+ index)))
        ((eql index end) nil)
      (stream-write-byte stream (aref sequence index)))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./gray.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./analyse-funtab.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Copyright (C) 2008 by Sam Steingold
;;; This is Free Software, distributed under the GNU GPL v2+
;;; See http://www.gnu.org/copyleft/gpl.html
;;;
;;; Study which functions should be added to eval.d:FUNTAB.
;;; This is not TRT, of course: we are counting how many other functions
;;; call the not-inlined system functions, not how often they are actually
;;; called, but this still may be useful.

(defun byte-compiled-closure (fdef)
  "Check whether the object is a byte compiled lisp function."
  (and (sys::closurep fdef) (compiled-function-p fdef)
       (not (sys::subr-info fdef))
       fdef))

(defparameter *closures*
  (let ((ht (make-hash-table)))
    (do-all-symbols (s)
      (when (and (fboundp s) (not (special-operator-p s))
                 (byte-compiled-closure (fdefinition s)))
        (setf (gethash s ht) t)))
    ht)
  "All compiled Lisp closure names.")

(defparameter *interpreted-functions* ;empty!
  (let ((ht (make-hash-table)))
    (do-all-symbols (s)
      (when (and (fboundp s) (not (special-operator-p s))
                 (let ((fdef (fdefinition s)))
                   (and (sys::closurep fdef) (not (compiled-function-p fdef))
                        (not (typep fdef 'generic-function)))))
        (setf (gethash s ht) t)))
    ht)
  "All compiled Lisp closure names.")

(defparameter *notinline-subrs*
  (let ((ht (make-hash-table)))
    (dolist (s (nth-value 2 (module-info "clisp" t)) ht)
      ;; some subrs, e.g., LOAD, are later redefined in Lisp
      (when (and (sys::subr-info s) (not (gethash s sys::function-codes)))
        (setf (gethash s ht) (cons 0 nil)))))
  "Lisp functions implemented in C but not inlined in FUNTAB.
Values are pairs of (caller-count . caller-list),
i.e. (car pair) = (length (cdr pair))")

(defun incf-notinline-subr (caller s)
  "Augment *NOTINLINE-SUBRS* for the given S called by CALLER."
  (let ((pair (gethash s *notinline-subrs*)))
    (when pair
      (incf (car pair))
      (push caller (cdr pair)))))

(defun show-count-ht (ht)
  "Print map (object -> (count . callers) nicely, dropping 0 counts."
  (loop :with *print-length* = 5 :and *print-pretty* = nil
    :for (sym count . callers)
    :in (sort (ext:with-collect (c)
                (maphash (lambda (sym count-callers)
                           (when (cdr count-callers)
                             (c (cons sym count-callers))))
                         ht))
              #'> :key #'second)
    :do (format t "~10:D  ~S  ~S~%" count sym callers)))

(defun map-cclosures (f)
  "Call f on all lisp compiled closures once."
  (let ((done (make-hash-table)))
    (labels ((mapsubs (closure)
               (setf (gethash closure done) t)
               (funcall f closure)
               (dolist (const (sys::closure-consts closure))
                 (when (and (byte-compiled-closure const)
                            (not (gethash const done)))
                   (mapsubs const)))))
      (maphash (lambda (sym _t)
                 (declare (ignore _t))
                 (mapsubs (fdefinition sym)))
             *closures*))))

;; map-calls is by far the trickiest part of the code
(defgeneric map-calls (f closure)
  (:documentation "Call F on each function call in the CLOSURE.")
  (:method ((f t) (closure function))
    (multiple-value-bind (req-num opt-num rest-p
                          key-p keyword-list allow-other-keys-p
                          byte-list const-list)
        (sys::signature closure)
      (declare (ignore req-num opt-num rest-p
                       key-p keyword-list allow-other-keys-p))
      (let ((lap-list (sys::disassemble-LAP byte-list const-list))
            (caller (sys::closure-name closure)))
        (dolist (L lap-list)
          (let* ((instr (cdr L))
                 (const (when (consp instr)
                          (case (first instr)
                            ((SYS::CALL SYS::CALL&PUSH)
                             (nth (third instr) const-list))
                            ((SYS::CALL0 SYS::CALL1 SYS::CALL1&PUSH
                              SYS::CALL1&JMPIFNOT SYS::CALL1&JMPIF
                              SYS::CALL2 SYS::CALL2&PUSH SYS::CALL2&JMPIFNOT
                              SYS::CALL2&JMPIF
                              SYS::CONST&SYMBOL-FUNCTION&PUSH
                              SYS::CONST&SYMBOL-FUNCTION
                              SYS::COPY-CLOSURE&PUSH SYS::COPY-CLOSURE
                              SYS::CONST&SYMBOL-FUNCTION&STORE
                              SYS::TAGBODY-OPEN SYS::HANDLER-OPEN)
                             (nth (second instr) const-list))))))
            (when (and const (symbolp const))
              (funcall f caller const)))))))
  (:method ((f t) (gf generic-function))
    (dolist (m (generic-function-methods gf))
      (map-calls f (clos::std-method-fast-function m)))))

#+(or) (progn

(map-cclosures (lambda (closure) (map-calls #'incf-notinline-subr closure)))

(show-count-ht *notinline-subrs*)

;;; 2008-03-01
       691  SYSTEM::TEXT  (REGEXP:REGEXP-SPLIT POSIX::MAKE-XTERM-IO-STREAM-1-1 SET-PPRINT-DISPATCH ED TYPEP ...)
       155  CLOS::TYPEP-CLASS  (TYPEP DESCRIBE ENSURE-GENERIC-FUNCTION ENSURE-GENERIC-FUNCTION SYSTEM::WARN-OF-TYPE ...)
        63  CLOS::DEFINED-CLASS-P  (TYPEP SYSTEM::SUBTYPE-SEQUENCE SYSTEM::CLOS-CLASS SYSTEM::CANONICALIZE-TYPE SYSTEM::FIND-STRUCTURE-SLOT-INITFUNCTION ...)
        37  CLOS::|(SETF STANDARD-INSTANCE-ACCESS)|  ((SETF CLOS::METHOD-COMBINATION-OPTIONS) (SETF CLOS::STD-GF-INITIALIZED) (SETF CLOS::STD-METHOD-GENERIC-FUNCTION) (SETF CLOS::STD-METHOD-FUNCTION) (SETF CLOS::STD-GF-LAMBDA-LIST) ...)
        36  STANDARD-INSTANCE-ACCESS  (CLOS::STD-GF-DOCUMENTATION CLOS::STD-METHOD-SPECIALIZERS CLOS::METHOD-COMBINATION-CHECK-METHOD-QUALIFIERS CLOS::METHOD-COMBINATION-IDENTITY-WITH-ONE-ARGUMENT CLOS::STD-GF-INITIALIZED ...)
        23  PROPER-LIST-P  (CLOS::COMPUTE-SLOTS-<SLOTTED-CLASS>-AROUND CLOS::SHARED-INITIALIZE-<DEFINED-CLASS> CLOS::SHARED-INITIALIZE-<DEFINED-CLASS> CLOS::SHARED-INITIALIZE-<DEFINED-CLASS> CLOS::COMPUTE-EFFECTIVE-SLOT-DEFINITION-INITARGS-<DEFINED-CLASS> ...)
        19  MAPCAP  (SYSTEM::C-LABELS SYSTEM::WRAP-USER-COMMANDS SYSTEM::C-FUNCTION-MACRO-LET SYSTEM::C-FLET SYSTEM::C-GENERIC-FLET ...)
        15  GETENV  (SHORT-SITE-NAME LONG-SITE-NAME LOAD-LOGICAL-PATHNAME-TRANSLATIONS LOAD-LOGICAL-PATHNAME-TRANSLATIONS LOAD-LOGICAL-PATHNAME-TRANSLATIONS ...)
        11  SYSTEM::|(SETF PACKAGE-LOCK)|  (SYSTEM::C-WITHOUT-PACKAGE-LOCK SYSTEM::C-WITHOUT-PACKAGE-LOCK CLOS::SET-<FORWARD-REFERENCED-CLASS>-<MISDESIGNED-FORWARD-REFERENCED-CLASS> CLOS::SET-<FORWARD-REFERENCED-CLASS>-<MISDESIGNED-FORWARD-REFERENCED-CLASS> CLOS::SET-<CLASS>-<POTENTIAL-CLASS> ...)
        11  SYSTEM::MACROP  (COMPILE SYSTEM::%EXPAND-FORM SYSTEM::%EXPAND-FORM SYSTEM::UNWRAPPED-FDEFINITION SYSTEM::TRACE1 ...)
         9  SYSTEM::ENCODINGP  (TYPEP SYSTEM::SIMPLIFY-AND-CHARACTER-1 SYSTEM::CANONICALIZE-TYPE SYSTEM::SUBTYPEP-CHARACTER SYSTEM::SUBTYPEP-CHARACTER ...)
         9  SYSTEM::%COMPILED-FUNCTION-P  (FUNCTION-LAMBDA-EXPRESSION ED COMPILE COMPILE SYSTEM::FUNCTION-SIGNATURE ...)
         8  SYSTEM::FORMAT-TABULATE  (PPRINT-TAB COMMON-LISP::APROPOS-1 SYSTEM::DESCRIBE-SLOTTED-OBJECT-1 SYSTEM::DESCRIBE-SLOTTED-OBJECT-1 SYSTEM::BREAK-LOOP ...)
         7  PPRINT-NEWLINE  (COMMON-LISP::PPRINT-LINEAR-1 COMMON-LISP::PPRINT-LINEAR-1 COMMON-LISP::PPRINT-FILL-1 COMMON-LISP::PPRINT-FILL-1 COMMON-LISP::PPRINT-TABULAR-1 ...)
         7  SYSTEM::WRITE-UNREADABLE  (CLOS::PRINT-OBJECT-<POTENTIAL-CLASS> CLOS::PRINT-OBJECT-<FORWARD-REFERENCE-TO-CLASS> CLOS::PRINT-OBJECT-<STANDARD-METHOD> CLOS::PRINT-OBJECT-<SLOT-DEFINITION> CLOS::PRINT-OBJECT-<EQL-SPECIALIZER> ...)
         6  STRING-WIDTH  (SYSTEM::WARN-OF-TYPE SYSTEM::FILL-STREAM-LINE-POSITION SYSTEM::WRITE-TO-SHORT-STRING SYSTEM::WRITE-TO-SHORT-STRING SYSTEM::FORMAT-JUSTIFIED-SEGMENTS ...)
         6  SYSTEM::WRITE-SPACES  (SYSTEM::FILL-STREAM-FLUSH-BUFFER SYSTEM::FILL-STREAM-FLUSH-BUFFER SYSTEM::FILL-STREAM-FLUSH-BUFFER SYSTEM::STREAM-TAB SYSTEM::TRACE-OUTPUT ...)
         6  SHELL  (MAKE-XTERM-IO-STREAM SYSTEM::DISASSEMBLE-MACHINE-CODE SYSTEM::DISASSEMBLE-MACHINE-CODE SYSTEM::DISASSEMBLE-MACHINE-CODE EDIT-FILE ...)
         6  SYSTEM::SYMBOL-MACRO-P  (SYSTEM::%EXPAND-VARLIST-MACROP SYSTEM::%EXPAND-FORM SYSTEM::VENV-SEARCH-MACRO SYSTEM::%EXPAND-SETQLIST-MACROP SYSTEM::VENV-SEARCH ...)
         6  SYSTEM::MACRO-EXPANDER  (COMPILE SYSTEM::%EXPAND-FORM SYSTEM::UNWRAPPED-FDEFINITION SYSTEM::FENV-SEARCH SYSTEM::FENV-SEARCH ...)
         6  SYSTEM::%UNBOUND  (CLOS::PRINT-OBJECT-<STANDARD-METHOD>-1 CLOS::PRINT-OBJECT-<STANDARD-METHOD>-1 (SETF CLOS::CLASS-VALID-INITARGS-FROM-SLOTS) CLOS::CREATE-SHARED-SLOTS-VECTOR CLOS::STD-GF-UNDETERMINEDP ...)
         5  SYSTEM::CHECK-FUNCTION-NAME  ((SETF COMPILER-MACRO-FUNCTION) COMPILER-MACRO-FUNCTION COMPILE SYSTEM::CHECK-TRACEABLE CLOS::ANALYZE-DEFGENERIC)
         5  SYSTEM::FRAME-UP  (SYSTEM::FRAME-UP-DOWN SYSTEM::DEBUG-TOP SYSTEM::FRAME-LIMIT-UP SYSTEM::DEBUG-UP SYSTEM::FRAME-LIMIT-DOWN)
         5  SYSTEM::DESCRIBE-FRAME  (SYSTEM::DEBUG-TOP SYSTEM::DEBUG-UP SYSTEM::DEBUG-WHERE SYSTEM::DEBUG-BOTTOM SYSTEM::DEBUG-DOWN)
         5  ENCODING-CHARSET  (SYSTEM::SIMPLIFY-AND-CHARACTER-1 SYSTEM::ENCODING-ZEROES SYSTEM::SUBTYPEP-CHARACTER SYSTEM::SUBTYPEP-CHARACTER SYSTEM::SUBTYPEP-CHARACTER-PRE-SIMPLIFY)
         5  SYSTEM::EXPAND-DEFTYPE  (TYPEP SYSTEM::SUBTYPE-SEQUENCE SYSTEM::CANONICALIZE-TYPE SYSTEM::SUBTYPE-INTEGER TYPE-EXPAND)
         4  SYSTEM::FRAME-DOWN  (SYSTEM::FRAME-UP-DOWN SYSTEM::FRAME-LIMIT-UP SYSTEM::DEBUG-BOTTOM SYSTEM::DEBUG-DOWN)
         4  CONVERT-STRING-TO-BYTES  (SYSTEM::HTTP-ERROR SYSTEM::ENCODING-ZEROES SYSTEM::ENCODING-ZEROES OPEN-HTTP)
         4  SIGNAL  (CERROR SYSTEM::CHECK-TYPE-FAILED-4-1 SYSTEM::WARN-OF-TYPE SYSTEM::COERCE-TO-CONDITION)
         4  PPRINT-INDENT  (COMMON-LISP::PPRINT-LINEAR-1 COMMON-LISP::PPRINT-FILL-1 COMMON-LISP::PPRINT-TABULAR-1 SYSTEM::FORMAT-PPRINT-INDENT)
         4  CLOS::POTENTIAL-CLASS-P  (CLOS::CLASS-CLASSNAME (SETF CLOS::CLASS-DIRECT-SUBCLASSES-TABLE) CLOS::CLASS-DIRECT-SUBCLASSES-TABLE (SETF CLOS::CLASS-CLASSNAME))
         4  SYSTEM::MAKE-MACRO  (COMPILE SYSTEM::TRACE1 SYSTEM::MAKE-MACRO-EXPANDER SYSTEM::MAKE-FUNMACRO-EXPANDER)
         4  SYSTEM::LINE-NUMBER  (COMPILE-FILE COMPILE-FILE LOAD LOAD)
         4  SYSTEM::%PUTF  (SYSTEM::%SET-DOCUMENTATION SYSTEM::SET-FILE-DOC CLOS::SET-FUNCTION-DOCUMENTATION CLOS::ENSURE-GENERIC-FUNCTION-USING-CLASS-<T>)
         3  SYSTEM::ADD-IMPLICIT-BLOCK  (SYSTEM::C-LABELS SYSTEM::C-FLET SYSTEM::%EXPAND-LAMBDABODY)
         3  STRING-INVERTCASE  (SYSTEM::COMPLETION-1 SYSTEM::COMPLETION SYSTEM::COMPLETION)
         3  SYSTEM::READ-EVAL-PRINT  (SYSTEM::STEP-HOOK-FN-1-3 SYSTEM::BREAK-LOOP-2-3 SYSTEM::MAIN-LOOP-1)
         3  SYSTEM::%PPRINT-LOGICAL-BLOCK  (PPRINT-LINEAR PPRINT-FILL PPRINT-TABULAR)
         3  SYSTEM::%CIRCLEP  (COMMON-LISP::PPRINT-LINEAR-1 COMMON-LISP::PPRINT-FILL-1 COMMON-LISP::PPRINT-TABULAR-1)
         3  PACKAGE-CASE-INVERTED-P  (SYSTEM::MODULE-NAME SYSTEM::COMPLETION FFI::TO-C-NAME)
         3  SYSTEM::HEAP-STATISTICS  (ROOM SYSTEM::%SPACE1 SYSTEM::%SPACE)
         3  SYMBOL-MACRO-EXPAND  (APROPOS SYSTEM::VENV-SEARCH-MACRO SYSTEM::VENV-ASSOC)
         3  SYSTEM::MACRO-LAMBDA-LIST  (COMPILE SYSTEM::TRACE1 ARGLIST)
         3  SYSTEM::FUNCTION-MACRO-P  (SYSTEM::%EXPAND-FORM SYSTEM::%EXPAND-FORM SYSTEM::FENV-SEARCH)
         3  WEAK-LIST-P  (CLOS::REMOVE-FROM-WEAK-SET CLOS::ADD-TO-WEAK-SET CLOS::LIST-WEAK-SET)
         3  WEAK-LIST-LIST  (CLOS::REMOVE-FROM-WEAK-SET CLOS::ADD-TO-WEAK-SET CLOS::LIST-WEAK-SET)
         3  WRITE-CHAR-SEQUENCE  (SYSTEM::FILL-STREAM-FLUSH-BUFFER SYSTEM::FILL-STREAM-FLUSH-BUFFER SYSTEM::FILL-STREAM-FLUSH-BUFFER)
         3  MAKE-PIPE-INPUT-STREAM  (SHORT-SITE-NAME LONG-SITE-NAME RUN-SHELL-COMMAND)
         3  SYSTEM::%REMF  (SYSTEM::%SET-DOCUMENTATION CLOS::ENSURE-GENERIC-FUNCTION-USING-CLASS-<T> CLOS::ENSURE-CLASS-USING-CLASS-<T>)
         2  SYSTEM::FUNCTION-BLOCK-NAME  (SYSTEM::MAKE-MACRO-EXPANSION CLOS::ANALYZE-METHOD-DESCRIPTION)
         2  NSTRING-INVERTCASE  (SYSTEM::COMPLETION-4 SYSTEM::COMPLETION)
         2  SYSTEM::READ-FORM  (SYSTEM::STEP-HOOK-FN SYSTEM::DEBUG-RETURN)
         2  SYSTEM::THE-FRAME  (SYSTEM::FRAME-LIMIT-UP SYSTEM::FRAME-LIMIT-DOWN)
         2  SYSTEM::SAME-ENV-AS  (SYSTEM::STEP-HOOK-FN-1 SYSTEM::BREAK-LOOP-2)
         2  SYSTEM::TRAP-EVAL-FRAME  (SYSTEM::DEBUG-TRAP-OFF SYSTEM::DEBUG-TRAP-ON)
         2  GC  (SYSTEM::%SPACE2 SYSTEM::%SPACE1)
         2  READTABLE-CASE  (SYSTEM::COMPLETION SYSTEM::COMPLETION)
         2  LIST-LENGTH-DOTTED  (SYSTEM::DESTRUCTURING-ERROR SYSTEM::MACRO-CALL-ERROR)
         2  LIST-LENGTH-PROPER  (SYSTEM::LIST-TO-HT SYSTEM::LIST-TO-HT)
         2  SYSTEM::LIST-LENGTH-IN-BOUNDS-P  (SYSTEM::FINALIZE-COUTPUT-FILE-9 SYSTEM::CORRECTABLE-ERROR)
         2  SYSTEM::VERSION  (COMPILE-FILE SYSTEM::OPEN-FOR-LOAD-CHECK-COMPILED-FILE)
         2  SYSTEM::DEFAULT-TIME-ZONE  (DECODE-UNIVERSAL-TIME ENCODE-UNIVERSAL-TIME)
         2  SYSTEM::LIB-DIRECTORY  (REQUIRE SYSTEM::CLISP-DATA-FILE)
         2  SYSTEM::GC-STATISTICS  (SYSTEM::%SPACE2 SYSTEM::%SPACE1)
         2  SYSTEM::CLOSURE-CONST  (SYSTEM::%LOCAL-GET SYSTEM::PASS3)
         2  SYSTEM::SET-CLOSURE-CONST  (SYSTEM::PASS3 SYSTEM::%LOCAL-SET)
         2  SYSTEM::CLOSURE-SET-DOCUMENTATION  (COMPILE CLOS::SET-FUNCTION-DOCUMENTATION)
         2  SET-FUNCALLABLE-INSTANCE-FUNCTION  (CLOS::FINALIZE-FAST-GF CLOS::INSTALL-DISPATCH)
         2  SYSTEM::GENERIC-FUNCTION-EFFECTIVE-METHOD-FUNCTION  (CLOS::%CALL-NEXT-METHOD CLOS::%CALL-NEXT-METHOD)
         2  SYSTEM::MAKE-SYMBOL-MACRO  (SYSTEM::%EXPAND-FORM SYSTEM::C-SYMBOL-MACROLET)
         2  SYSTEM::|(SETF WEAK-LIST-LIST)|  (CLOS::REMOVE-FROM-WEAK-SET CLOS::ADD-TO-WEAK-SET)
         2  SYNONYM-STREAM-SYMBOL  (SYSTEM::STREAM-OUTPUT-ELEMENT-TYPE SYSTEM::STREAM-INPUT-ELEMENT-TYPE)
         2  TWO-WAY-STREAM-INPUT-STREAM  (SYSTEM::STREAM-INPUT-ELEMENT-TYPE DRIBBLE-STREAM)
         2  TWO-WAY-STREAM-OUTPUT-STREAM  (SYSTEM::STREAM-OUTPUT-ELEMENT-TYPE DRIBBLE-STREAM)
         2  ECHO-STREAM-INPUT-STREAM  (SYSTEM::STREAM-INPUT-ELEMENT-TYPE DRIBBLE-STREAM)
         2  ECHO-STREAM-OUTPUT-STREAM  (SYSTEM::STREAM-OUTPUT-ELEMENT-TYPE DRIBBLE-STREAM)
         2  SYSTEM::TERMINAL-RAW  (SYSTEM::EXEC-WITH-KEYBOARD SYSTEM::EXEC-WITH-KEYBOARD)
         2  MAKE-PIPE-OUTPUT-STREAM  (SYSTEM::MAKE-PRINTER-STREAM RUN-SHELL-COMMAND)
         2  INTERACTIVE-STREAM-P  (CERROR SYSTEM::BREAK-LOOP)
         2  SYSTEM::RANDOM-POSFIXNUM  (CLOS::SHARED-INITIALIZE-<STANDARD-STABLEHASH> CLOS::MAKE-STRUCTURE-STABLEHASH)
         1  SYSTEM::CHECK-SYMBOL  (CLOS::SHARED-INITIALIZE-<POTENTIAL-CLASS>)
         1  SYSTEM::EVAL-AT  (SYSTEM::STEP-HOOK-FN)
         1  SYSTEM::EVAL-FRAME-P  (SYSTEM::COMMANDS)
         1  SYSTEM::DRIVER-FRAME-P  (SYSTEM::FRAME-LIMIT-UP)
         1  SYSTEM::REDO-EVAL-FRAME  (SYSTEM::DEBUG-REDO)
         1  SYSTEM::RETURN-FROM-EVAL-FRAME  (SYSTEM::DEBUG-RETURN)
         1  SHOW-STACK  (SYSTEM::PRINT-BACKTRACE)
         1  SYSTEM::%ROOM  (ROOM)
         1  MAKE-ENCODING  (SYSTEM::GET-CHARSET-RANGE)
         1  SYSTEM::CHARSET-TYPEP  (TYPEP)
         1  SYSTEM::CHARSET-RANGE  (SYSTEM::GET-CHARSET-RANGE)
         1  SYSTEM::FOREIGN-ENCODING  (FFI::EXEC-WITH-FOREIGN-STRING)
         1  CONVERT-STRING-FROM-BYTES  (OPEN-HTTP)
         1  SYSTEM::CONSES-P  (SYSTEM::DS-TYPEP)
         1  SYSTEM::CURRENT-LANGUAGE  (LOCALIZED)
         1  SYSTEM::DELTA4  (SYSTEM::%TIME)
         1  PACKAGE-LOCK  (SYSTEM::F-SIDE-EFFECT)
         1  PACKAGE-CASE-SENSITIVE-P  (SYSTEM::COMPLETION)
         1  SYSTEM::SYMBOL-VALUE-LOCK  (SYSTEM::SET-CHECK-LOCK)
         1  SYSTEM::CHECK-PACKAGE-LOCK  (SYSTEM::CHECK-REDEFINITION)
         1  DELETE-PACKAGE  (INSPECT)
         1  SYSTEM::PACKAGE-ITERATOR  (SYSTEM::PACKAGE-ITERATOR-FUNCTION)
         1  SYSTEM::PACKAGE-ITERATE  (SYSTEM::PACKAGE-ITERATOR-FUNCTION-1)
         1  LOGICAL-PATHNAME  (SYSTEM::VALID-LOGICAL-PATHNAME-STRING-P-3)
         1  TRANSLATE-LOGICAL-PATHNAME  (SYSTEM::OPEN-FOR-LOAD)
         1  SYSTEM::MAKE-LOGICAL-PATHNAME  (SYSTEM::SET-LOGICAL-PATHNAME-TRANSLATIONS)
         1  USER-HOMEDIR-PATHNAME  (EDITOR-TEMPFILE)
         1  ABSOLUTE-PATHNAME  (SYSTEM::XSTRING)
         1  SYSTEM::SET-LIB-DIRECTORY  (SYSTEM::CLISP-DATA-FILE-1)
         1  SYSTEM::NOTE-NEW-STRUCTURE-CLASS  (CLOS::SHARED-INITIALIZE-<STRUCTURE-CLASS>)
         1  SYSTEM::NOTE-NEW-STANDARD-CLASS  (CLOS::FINALIZE-INSTANCE-SEMI-STANDARD-CLASS)
         1  SYSTEM::LIST-STATISTICS  (SYSTEM::%SPACE)
         1  SYSTEM::HEAP-STATISTICS-STATISTICS  (SYSTEM::%SPACE)
         1  SYSTEM::GC-STATISTICS-STATISTICS  (SYSTEM::%SPACE)
         1  SYSTEM::|(SETF CLOSURE-NAME)|  (SYSTEM::MAKE-PRELIMINARY)
         1  SYSTEM::CONSTANT-INITFUNCTION-P  (SYSTEM::DS-ARG-DEFAULT)
         1  SYSTEM::CLOSURE-DOCUMENTATION  (CLOS::FUNCTION-DOCUMENTATION)
         1  SYSTEM::CLOSURE-LAMBDA-LIST  (ARGLIST)
         1  SYSTEM::GLOBAL-SYMBOL-MACRO-DEFINITION  (SYSTEM::VENV-ASSOC)
         1  SYSTEM::FUNCTION-MACRO-EXPANDER  (SYSTEM::FENV-SEARCH)
         1  FINALIZE  (MAKE-XTERM-IO-STREAM)
         1  CLOS::ALLOCATE-METAOBJECT-INSTANCE  (CLOS::COPY-STANDARD-CLASS)
         1  CLOS::%CHANGE-CLASS  (CLOS::DO-CHANGE-CLASS)
         1  MAKE-WEAK-LIST  (CLOS::ADD-TO-WEAK-SET)
         1  WRITE-BYTE-SEQUENCE  (SYSTEM::HTTP-ERROR)
         1  BROADCAST-STREAM-STREAMS  (DRIBBLE-STREAM)
         1  SYSTEM::MAKE-KEYBOARD-STREAM  (SYSTEM::EXEC-WITH-KEYBOARD)
         1  MAKE-PIPE-IO-STREAM  (RUN-SHELL-COMMAND)
         1  SOCKET-ACCEPT  (SYSTEM::HTTP-COMMAND)
         1  SOCKET-CONNECT  (EXT::OPEN-HTTP-3)
         1  SYSTEM::SET-STREAM-EXTERNAL-FORMAT  (SYSTEM::SET-OUTPUT-STREAM-FASL)
         1  SYSTEM::STREAM-FASL-P  (SYSTEM::SET-OUTPUT-STREAM-FASL)
         1  FFI:VALIDP  (REGEXP::%MATCH)
         1  FFI::CALL-WITH-FOREIGN-STRING  (FFI::EXEC-WITH-FOREIGN-STRING)

;;; 2008-03-06
       692  SYSTEM::TEXT  (REGEXP:REGEXP-SPLIT POSIX::MAKE-XTERM-IO-STREAM-1-1 SET-PPRINT-DISPATCH ED TYPEP ...)
        15  GETENV  (SHORT-SITE-NAME LONG-SITE-NAME LOAD-LOGICAL-PATHNAME-TRANSLATIONS LOAD-LOGICAL-PATHNAME-TRANSLATIONS LOAD-LOGICAL-PATHNAME-TRANSLATIONS ...)
        11  SYSTEM::|(SETF PACKAGE-LOCK)|  (SYSTEM::C-WITHOUT-PACKAGE-LOCK SYSTEM::C-WITHOUT-PACKAGE-LOCK CLOS::SET-<FORWARD-REFERENCED-CLASS>-<MISDESIGNED-FORWARD-REFERENCED-CLASS> CLOS::SET-<FORWARD-REFERENCED-CLASS>-<MISDESIGNED-FORWARD-REFERENCED-CLASS> CLOS::SET-<CLASS>-<POTENTIAL-CLASS> ...)
         8  SYSTEM::FORMAT-TABULATE  (PPRINT-TAB COMMON-LISP::APROPOS-1 SYSTEM::DESCRIBE-SLOTTED-OBJECT-1 SYSTEM::DESCRIBE-SLOTTED-OBJECT-1 SYSTEM::BREAK-LOOP ...)
         7  PPRINT-NEWLINE  (COMMON-LISP::PPRINT-LINEAR-1 COMMON-LISP::PPRINT-LINEAR-1 COMMON-LISP::PPRINT-FILL-1 COMMON-LISP::PPRINT-FILL-1 COMMON-LISP::PPRINT-TABULAR-1 ...)
         7  SYSTEM::WRITE-UNREADABLE  (CLOS::PRINT-OBJECT-<POTENTIAL-CLASS> CLOS::PRINT-OBJECT-<FORWARD-REFERENCE-TO-CLASS> CLOS::PRINT-OBJECT-<STANDARD-METHOD> CLOS::PRINT-OBJECT-<SLOT-DEFINITION> CLOS::PRINT-OBJECT-<EQL-SPECIALIZER> ...)
         6  STRING-WIDTH  (SYSTEM::WARN-OF-TYPE SYSTEM::FILL-STREAM-LINE-POSITION SYSTEM::WRITE-TO-SHORT-STRING SYSTEM::WRITE-TO-SHORT-STRING SYSTEM::FORMAT-JUSTIFIED-SEGMENTS ...)
         6  SYSTEM::WRITE-SPACES  (SYSTEM::FILL-STREAM-FLUSH-BUFFER SYSTEM::FILL-STREAM-FLUSH-BUFFER SYSTEM::FILL-STREAM-FLUSH-BUFFER SYSTEM::STREAM-TAB SYSTEM::TRACE-OUTPUT ...)
         6  SHELL  (MAKE-XTERM-IO-STREAM SYSTEM::DISASSEMBLE-MACHINE-CODE SYSTEM::DISASSEMBLE-MACHINE-CODE SYSTEM::DISASSEMBLE-MACHINE-CODE EDIT-FILE ...)
         5  SYSTEM::FRAME-UP  (SYSTEM::FRAME-UP-DOWN SYSTEM::DEBUG-TOP SYSTEM::FRAME-LIMIT-UP SYSTEM::DEBUG-UP SYSTEM::FRAME-LIMIT-DOWN)
         5  SYSTEM::DESCRIBE-FRAME  (SYSTEM::DEBUG-TOP SYSTEM::DEBUG-UP SYSTEM::DEBUG-WHERE SYSTEM::DEBUG-BOTTOM SYSTEM::DEBUG-DOWN)
         5  ENCODING-CHARSET  (SYSTEM::SIMPLIFY-AND-CHARACTER-1 SYSTEM::ENCODING-ZEROES SYSTEM::SUBTYPEP-CHARACTER SYSTEM::SUBTYPEP-CHARACTER SYSTEM::SUBTYPEP-CHARACTER-PRE-SIMPLIFY)
         5  SYSTEM::EXPAND-DEFTYPE  (TYPEP SYSTEM::SUBTYPE-SEQUENCE SYSTEM::CANONICALIZE-TYPE SYSTEM::SUBTYPE-INTEGER TYPE-EXPAND)
         4  SYSTEM::FRAME-DOWN  (SYSTEM::FRAME-UP-DOWN SYSTEM::FRAME-LIMIT-UP SYSTEM::DEBUG-BOTTOM SYSTEM::DEBUG-DOWN)
         4  CONVERT-STRING-TO-BYTES  (SYSTEM::HTTP-ERROR SYSTEM::ENCODING-ZEROES SYSTEM::ENCODING-ZEROES OPEN-HTTP)
         4  SIGNAL  (CERROR SYSTEM::CHECK-TYPE-FAILED-4-1 SYSTEM::WARN-OF-TYPE SYSTEM::COERCE-TO-CONDITION)
         4  PPRINT-INDENT  (COMMON-LISP::PPRINT-LINEAR-1 COMMON-LISP::PPRINT-FILL-1 COMMON-LISP::PPRINT-TABULAR-1 SYSTEM::FORMAT-PPRINT-INDENT)
         4  CLOS::POTENTIAL-CLASS-P  (CLOS::CLASS-CLASSNAME (SETF CLOS::CLASS-DIRECT-SUBCLASSES-TABLE) CLOS::CLASS-DIRECT-SUBCLASSES-TABLE (SETF CLOS::CLASS-CLASSNAME))
         4  SYSTEM::LINE-NUMBER  (COMPILE-FILE COMPILE-FILE LOAD LOAD)
         4  SYSTEM::%PUTF  (SYSTEM::%SET-DOCUMENTATION SYSTEM::SET-FILE-DOC CLOS::SET-FUNCTION-DOCUMENTATION CLOS::ENSURE-GENERIC-FUNCTION-USING-CLASS-<T>)
         3  SYSTEM::ADD-IMPLICIT-BLOCK  (SYSTEM::C-LABELS SYSTEM::C-FLET SYSTEM::%EXPAND-LAMBDABODY)
         3  STRING-INVERTCASE  (SYSTEM::COMPLETION-1 SYSTEM::COMPLETION SYSTEM::COMPLETION)
         3  SYSTEM::READ-EVAL-PRINT  (SYSTEM::STEP-HOOK-FN-1-3 SYSTEM::BREAK-LOOP-2-3 SYSTEM::MAIN-LOOP-1)
         3  SYSTEM::%PPRINT-LOGICAL-BLOCK  (PPRINT-LINEAR PPRINT-FILL PPRINT-TABULAR)
         3  SYSTEM::%CIRCLEP  (COMMON-LISP::PPRINT-LINEAR-1 COMMON-LISP::PPRINT-FILL-1 COMMON-LISP::PPRINT-TABULAR-1)
         3  PACKAGE-CASE-INVERTED-P  (SYSTEM::MODULE-NAME SYSTEM::COMPLETION FFI::TO-C-NAME)
         3  SYSTEM::HEAP-STATISTICS  (ROOM SYSTEM::%SPACE1 SYSTEM::%SPACE)
         3  SYMBOL-MACRO-EXPAND  (APROPOS SYSTEM::VENV-SEARCH-MACRO SYSTEM::VENV-ASSOC)
         3  SYSTEM::MACRO-LAMBDA-LIST  (COMPILE SYSTEM::TRACE1 ARGLIST)
         3  SYSTEM::FUNCTION-MACRO-P  (SYSTEM::%EXPAND-FORM SYSTEM::%EXPAND-FORM SYSTEM::FENV-SEARCH)
         3  WEAK-LIST-P  (CLOS::REMOVE-FROM-WEAK-SET CLOS::ADD-TO-WEAK-SET CLOS::LIST-WEAK-SET)
         3  WEAK-LIST-LIST  (CLOS::REMOVE-FROM-WEAK-SET CLOS::ADD-TO-WEAK-SET CLOS::LIST-WEAK-SET)
         3  WRITE-CHAR-SEQUENCE  (SYSTEM::FILL-STREAM-FLUSH-BUFFER SYSTEM::FILL-STREAM-FLUSH-BUFFER SYSTEM::FILL-STREAM-FLUSH-BUFFER)
         3  MAKE-PIPE-INPUT-STREAM  (SHORT-SITE-NAME LONG-SITE-NAME RUN-SHELL-COMMAND)
         3  SYSTEM::%REMF  (SYSTEM::%SET-DOCUMENTATION CLOS::ENSURE-GENERIC-FUNCTION-USING-CLASS-<T> CLOS::ENSURE-CLASS-USING-CLASS-<T>)
         2  SYSTEM::FUNCTION-BLOCK-NAME  (SYSTEM::MAKE-MACRO-EXPANSION CLOS::ANALYZE-METHOD-DESCRIPTION)
         2  NSTRING-INVERTCASE  (SYSTEM::COMPLETION-4 SYSTEM::COMPLETION)
         2  SYSTEM::READ-FORM  (SYSTEM::STEP-HOOK-FN SYSTEM::DEBUG-RETURN)
         2  SYSTEM::THE-FRAME  (SYSTEM::FRAME-LIMIT-UP SYSTEM::FRAME-LIMIT-DOWN)
         2  SYSTEM::SAME-ENV-AS  (SYSTEM::STEP-HOOK-FN-1 SYSTEM::BREAK-LOOP-2)
         2  SYSTEM::TRAP-EVAL-FRAME  (SYSTEM::DEBUG-TRAP-OFF SYSTEM::DEBUG-TRAP-ON)
         2  GC  (SYSTEM::%SPACE2 SYSTEM::%SPACE1)
         2  READTABLE-CASE  (SYSTEM::COMPLETION SYSTEM::COMPLETION)
         2  LIST-LENGTH-DOTTED  (SYSTEM::DESTRUCTURING-ERROR SYSTEM::MACRO-CALL-ERROR)
         2  LIST-LENGTH-PROPER  (SYSTEM::LIST-TO-HT SYSTEM::LIST-TO-HT)
         2  SYSTEM::LIST-LENGTH-IN-BOUNDS-P  (SYSTEM::FINALIZE-COUTPUT-FILE-9 SYSTEM::CORRECTABLE-ERROR)
         2  SYSTEM::VERSION  (COMPILE-FILE SYSTEM::OPEN-FOR-LOAD-CHECK-COMPILED-FILE)
         2  SYSTEM::DEFAULT-TIME-ZONE  (DECODE-UNIVERSAL-TIME ENCODE-UNIVERSAL-TIME)
         2  SYSTEM::LIB-DIRECTORY  (REQUIRE SYSTEM::CLISP-DATA-FILE)
         2  SYSTEM::GC-STATISTICS  (SYSTEM::%SPACE2 SYSTEM::%SPACE1)
         2  SYSTEM::CLOSURE-CONST  (SYSTEM::%LOCAL-GET SYSTEM::PASS3)
         2  SYSTEM::SET-CLOSURE-CONST  (SYSTEM::PASS3 SYSTEM::%LOCAL-SET)
         2  SYSTEM::CLOSURE-SET-DOCUMENTATION  (COMPILE CLOS::SET-FUNCTION-DOCUMENTATION)
         2  SET-FUNCALLABLE-INSTANCE-FUNCTION  (CLOS::FINALIZE-FAST-GF CLOS::INSTALL-DISPATCH)
         2  SYSTEM::GENERIC-FUNCTION-EFFECTIVE-METHOD-FUNCTION  (CLOS::%CALL-NEXT-METHOD CLOS::%CALL-NEXT-METHOD)
         2  SYSTEM::MAKE-SYMBOL-MACRO  (SYSTEM::%EXPAND-FORM SYSTEM::C-SYMBOL-MACROLET)
         2  SYSTEM::|(SETF WEAK-LIST-LIST)|  (CLOS::REMOVE-FROM-WEAK-SET CLOS::ADD-TO-WEAK-SET)
         2  SYNONYM-STREAM-SYMBOL  (SYSTEM::STREAM-OUTPUT-ELEMENT-TYPE SYSTEM::STREAM-INPUT-ELEMENT-TYPE)
         2  TWO-WAY-STREAM-INPUT-STREAM  (SYSTEM::STREAM-INPUT-ELEMENT-TYPE DRIBBLE-STREAM)
         2  TWO-WAY-STREAM-OUTPUT-STREAM  (SYSTEM::STREAM-OUTPUT-ELEMENT-TYPE DRIBBLE-STREAM)
         2  ECHO-STREAM-INPUT-STREAM  (SYSTEM::STREAM-INPUT-ELEMENT-TYPE DRIBBLE-STREAM)
         2  ECHO-STREAM-OUTPUT-STREAM  (SYSTEM::STREAM-OUTPUT-ELEMENT-TYPE DRIBBLE-STREAM)
         2  SYSTEM::TERMINAL-RAW  (SYSTEM::EXEC-WITH-KEYBOARD SYSTEM::EXEC-WITH-KEYBOARD)
         2  MAKE-PIPE-OUTPUT-STREAM  (SYSTEM::MAKE-PRINTER-STREAM RUN-SHELL-COMMAND)
         2  INTERACTIVE-STREAM-P  (CERROR SYSTEM::BREAK-LOOP)
         2  SYSTEM::RANDOM-POSFIXNUM  (CLOS::SHARED-INITIALIZE-<STANDARD-STABLEHASH> CLOS::MAKE-STRUCTURE-STABLEHASH)
         1  SYSTEM::CHECK-SYMBOL  (CLOS::SHARED-INITIALIZE-<POTENTIAL-CLASS>)
         1  SYSTEM::EVAL-AT  (SYSTEM::STEP-HOOK-FN)
         1  SYSTEM::EVAL-FRAME-P  (SYSTEM::COMMANDS)
         1  SYSTEM::DRIVER-FRAME-P  (SYSTEM::FRAME-LIMIT-UP)
         1  SYSTEM::REDO-EVAL-FRAME  (SYSTEM::DEBUG-REDO)
         1  SYSTEM::RETURN-FROM-EVAL-FRAME  (SYSTEM::DEBUG-RETURN)
         1  SHOW-STACK  (SYSTEM::PRINT-BACKTRACE)
         1  SYSTEM::%ROOM  (ROOM)
         1  MAKE-ENCODING  (SYSTEM::GET-CHARSET-RANGE)
         1  SYSTEM::CHARSET-TYPEP  (TYPEP)
         1  SYSTEM::CHARSET-RANGE  (SYSTEM::GET-CHARSET-RANGE)
         1  SYSTEM::FOREIGN-ENCODING  (FFI::EXEC-WITH-FOREIGN-STRING)
         1  CONVERT-STRING-FROM-BYTES  (OPEN-HTTP)
         1  SYSTEM::CONSES-P  (SYSTEM::DS-TYPEP)
         1  SYSTEM::CURRENT-LANGUAGE  (LOCALIZED)
         1  SYSTEM::DELTA4  (SYSTEM::%TIME)
         1  PACKAGE-LOCK  (SYSTEM::F-SIDE-EFFECT)
         1  PACKAGE-CASE-SENSITIVE-P  (SYSTEM::COMPLETION)
         1  SYSTEM::SYMBOL-VALUE-LOCK  (SYSTEM::SET-CHECK-LOCK)
         1  SYSTEM::CHECK-PACKAGE-LOCK  (SYSTEM::CHECK-REDEFINITION)
         1  DELETE-PACKAGE  (INSPECT)
         1  SYSTEM::PACKAGE-ITERATOR  (SYSTEM::PACKAGE-ITERATOR-FUNCTION)
         1  SYSTEM::PACKAGE-ITERATE  (SYSTEM::PACKAGE-ITERATOR-FUNCTION-1)
         1  LOGICAL-PATHNAME  (SYSTEM::VALID-LOGICAL-PATHNAME-STRING-P-3)
         1  TRANSLATE-LOGICAL-PATHNAME  (SYSTEM::OPEN-FOR-LOAD)
         1  SYSTEM::MAKE-LOGICAL-PATHNAME  (SYSTEM::SET-LOGICAL-PATHNAME-TRANSLATIONS)
         1  USER-HOMEDIR-PATHNAME  (EDITOR-TEMPFILE)
         1  ABSOLUTE-PATHNAME  (SYSTEM::XSTRING)
         1  SYSTEM::SET-LIB-DIRECTORY  (SYSTEM::CLISP-DATA-FILE-1)
         1  SYSTEM::NOTE-NEW-STRUCTURE-CLASS  (CLOS::SHARED-INITIALIZE-<STRUCTURE-CLASS>)
         1  SYSTEM::NOTE-NEW-STANDARD-CLASS  (CLOS::FINALIZE-INSTANCE-SEMI-STANDARD-CLASS)
         1  SYSTEM::LIST-STATISTICS  (SYSTEM::%SPACE)
         1  SYSTEM::HEAP-STATISTICS-STATISTICS  (SYSTEM::%SPACE)
         1  SYSTEM::GC-STATISTICS-STATISTICS  (SYSTEM::%SPACE)
         1  SYSTEM::|(SETF CLOSURE-NAME)|  (SYSTEM::MAKE-PRELIMINARY)
         1  SYSTEM::CONSTANT-INITFUNCTION-P  (SYSTEM::DS-ARG-DEFAULT)
         1  SYSTEM::CLOSURE-DOCUMENTATION  (CLOS::FUNCTION-DOCUMENTATION)
         1  SYSTEM::CLOSURE-LAMBDA-LIST  (ARGLIST)
         1  SYSTEM::GLOBAL-SYMBOL-MACRO-DEFINITION  (SYSTEM::VENV-ASSOC)
         1  SYSTEM::FUNCTION-MACRO-EXPANDER  (SYSTEM::FENV-SEARCH)
         1  FINALIZE  (MAKE-XTERM-IO-STREAM)
         1  CLOS::ALLOCATE-METAOBJECT-INSTANCE  (CLOS::COPY-STANDARD-CLASS)
         1  CLOS::%CHANGE-CLASS  (CLOS::DO-CHANGE-CLASS)
         1  MAKE-WEAK-LIST  (CLOS::ADD-TO-WEAK-SET)
         1  WRITE-BYTE-SEQUENCE  (SYSTEM::HTTP-ERROR)
         1  BROADCAST-STREAM-STREAMS  (DRIBBLE-STREAM)
         1  SYSTEM::MAKE-KEYBOARD-STREAM  (SYSTEM::EXEC-WITH-KEYBOARD)
         1  MAKE-PIPE-IO-STREAM  (RUN-SHELL-COMMAND)
         1  SOCKET-ACCEPT  (SYSTEM::HTTP-COMMAND)
         1  SOCKET-CONNECT  (EXT::OPEN-HTTP-3)
         1  SYSTEM::SET-STREAM-EXTERNAL-FORMAT  (SYSTEM::SET-OUTPUT-STREAM-FASL)
         1  SYSTEM::STREAM-FASL-P  (SYSTEM::SET-OUTPUT-STREAM-FASL)
         1  FFI:VALIDP  (REGEXP::%MATCH)
         1  FFI::CALL-WITH-FOREIGN-STRING  (FFI::EXEC-WITH-FOREIGN-STRING)


)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./analyse-funtab.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./loadform.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; MAKE-LOAD-FORM for CLISP
;;; Sam Steingold 2001-2004, 2009, 2017
;;; Bruno Haible 2004

;; this could have been placed in in clos.lisp,
;; but `make-init-form' uses conditions

(in-package "CLOS")

(defun make-load-form-saving-slots
    (object &key environment
     (slot-names
      (let ((slots (class-slots (class-of object))))
        (etypecase object
          (standard-object
           (mapcan (lambda (slot)
                     (when (eq (slot-definition-allocation slot) ':instance)
                       (list (slot-definition-name slot))))
                   slots))
          (structure-object (mapcar #'slot-definition-name slots))))))
  (declare (ignore environment))
  (values `(allocate-instance (find-class ',(class-name (class-of object))))
          `(progn
            (setf ,@(mapcan (lambda (slot)
                              (when (slot-boundp object slot)
                                `((slot-value ,object ',slot)
                                  ',(slot-value object slot))))
                            slot-names))
            (initialize-instance ,object))))

;; Condition type thrown by make-load-form.
;; It's not sufficient to rely on method-call-error because a test like
;;    (eq (method-call-error-generic-function err) #'make-load-form)
;; doesn't work when make-load-form is traced.
(define-condition missing-load-form (error)
  (($object :initarg :object :reader missing-load-form-object)))
(define-condition simple-missing-load-form (simple-error missing-load-form) ())

(defun signal-missing-load-form (object)
  (let ((class (class-name (class-of object))))
    (error-of-type 'simple-missing-load-form :object object
      (TEXT "A method on ~S for class ~S is necessary for externalizing the object ~S, according to ANSI CL 3.2.4.4, but no such method is defined.")
      'make-load-form class object)))

(defgeneric make-load-form (object &optional environment)
  ;; <http://www.lisp.org/HyperSpec/Body/stagenfun_make-load-form.html>
  ;; "The methods specialized on standard-object, structure-object, and
  ;;  condition all signal an error of type error."
  (declare (dynamically-modifiable))
  (:method ((object standard-object) &optional environment)
    (declare (ignore environment))
    (signal-missing-load-form object))
  (:method ((object structure-object) &optional environment)
    (declare (ignore environment))
    (signal-missing-load-form object))
  (:method ((object condition) &optional environment)
    (declare (ignore environment))
    (signal-missing-load-form object))
  (:method ((object defined-class) &optional environment)
    (declare (ignore environment))
    ;; TODO: Implement as described in CLHS
    `(find-class ',(class-name object))))

(defun mlf-init-function (object)
  (multiple-value-bind (creation-form initialization-form)
      (make-load-form object)
    (let ((funname
            (gensym
              (sys::string-concat
                "CREATE-INSTANCE-OF-<"
                (write-to-string (class-name (class-of object)) :readably nil)
                ">-"))))
      `(FUNCTION ,funname
         (LAMBDA ()
           ,@(if (and sys::*compiling* sys::*compiling-from-file*)
               '((DECLARE (COMPILE)))
               '())
           ,(if initialization-form
              (let ((var (gensym "MAKE-LOAD-FORM-")))
                `(LET ((,var ,creation-form))
                   ,(sublis `((',object . ,var) (,object . ,var))
                            initialization-form
                            :test #'equal)
                   ,var))
              creation-form))))))

(defun make-init-form (object)
  (when sys::*load-forms*
    (multiple-value-bind (form found-p)
        (gethash object sys::*load-forms*)
      (if found-p
        form
        (setf (gethash object sys::*load-forms*)
              (block compute-init-form
                (handler-bind
                  ((missing-load-form
                     #'(lambda (err)
                         (when (eql (missing-load-form-object err) object)
                           (return-from compute-init-form nil)))))
                  `(funcall ,(eval (mlf-init-function object))))))))))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./loadform.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;







;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; BEGIN FILE ./trace.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Tracer
;; Bruno Haible 13.2.1990, 15.3.1991, 4.4.1991
;; German comments translated into English: Stefan Kain 2001-12-26
;; Sam Steingold 2001-2009, 2011

(in-package "COMMON-LISP")
(export '(trace untrace))
(export '(custom::*trace-indent*) "CUSTOM")
(in-package "EXT")
(export '(*trace-function* *trace-args* *trace-form* *trace-values*
          custom::*trace-indent*))
(in-package "SYSTEM")

(defvar *trace-indent* nil
  "Use indentation in addition to numbering to indicate the trace level.")

(proclaim '(special *trace-function* *trace-args* *trace-form* *trace-values*))
(defvar *traced-functions* nil) ; list of currently traced function-names ; ABI
;; So long as a function-name funname [resp. more exactly: the Symbol
;; symbol = (get-funname-symbol funname)] are traced, the Property
;; sys::traced-definition contains the old content of the function-cell, the
;; Property sys::tracing-definition contains the new content of the
;; function-cell, and the function-name is element of the list
;; *traced-functions*.
;; Meanwhile the content of the function-cell can change, however!
;; At all events the following is true:
;;  (and (fboundp symbol)
;;       (eq (symbol-function symbol) (get symbol 'sys::tracing-definition)))
;; ===>   (member funname *traced-functions* :test #'equal)
;; <==>   (get symbol 'sys::traced-definition)

(defvar *trace-level* 0) ; nesting depth for Trace-Output

(labels ((subclosure-pos (closure name)
           (do* ((length (sys::%record-length closure))
                 ;; SYMBOL-SUFFIX is defined in compiler.lisp
                 (nm (symbol-suffix (closure-name closure) name))
                 (nm-traced (symbol-suffix nm "TRACED"))
                 (pos 0 (1+ pos)) obj)
                ((= pos length)
                 (error (TEXT "~S: no local name ~S in ~S")
                        'local name closure))
             (setq obj (sys::closure-const closure pos))
             (when (and (closurep obj)
                        (or (eq (closure-name obj) nm)
                            (eq (closure-name obj) nm-traced)))
               (return pos))))
         (force-cclosure (name)
           (let ((closure (fdefinition name)))
             (unless (closurep closure)
               (error-of-type 'type-error
                 :datum closure :expected-type 'closure
                 (TEXT "~S: ~S does not name a closure") 'local name))
             (if (sys::%compiled-function-p closure)
                 closure
                 (fdefinition (compile name closure)))))
         (local-helper (spec)
           (do* ((spe (cdr spec) (cdr spe))
                 (clo (force-cclosure (car spec))
                      (sys::%record-ref clo pos))
                 (pos (subclosure-pos clo (car spe))
                      (subclosure-pos clo (car spe))))
                ((endp (cdr spe)) (values clo pos)))))

  (defun %local-get (spec) ; ABI
    (multiple-value-bind (clo pos) (local-helper spec)
      (sys::closure-const clo pos)))
  (defun %local-set (new-def spec) ; ABI
    (unless (closurep new-def)
      (error-of-type 'type-error
        :datum new-def :expected-type 'closure
        (TEXT "~S: ~S is not a closure") `(setf (local ,@spec)) new-def))
    (multiple-value-bind (clo pos) (local-helper spec)
      (setf (sys::closure-const clo pos)
            (if (sys::%compiled-function-p new-def)
                new-def
                (fdefinition (compile (closure-name (sys::%record-ref clo pos))
                                      new-def)))))))

(defmacro local (&rest spec)
  "Return the closure defined locally with LABELS or FLET.
SPEC is a list of (CLOSURE SUB-CLOSURE SUB-SUB-CLOSURE ...)
CLOSURE must be compiled."
  (%local-get spec))

(define-setf-expander local (&rest spec)
  "Modify the local definition (LABELS or FLET).
This will not work with closures that use lexical variables!"
  (let ((store (gensym "LOCAL-")))
    (values nil nil `(,store) `(%LOCAL-SET ,store ',spec)
            `(%LOCAL-GET ,spec))))

;; check whether the object might name a local (LABELS or FLET) function
(defun local-function-name-p (obj)
  (and (consp obj) (eq 'local (car obj))))

;; Structure containing all trace options for a given function.
;; make-tracer is ABI
(defstruct (tracer (:type vector))
  name symb cur-def local-p
  suppress-if max-depth step-if pre post pre-break-if post-break-if
  bindings
  pre-print post-print print)

;; install the new function definition
(defun tracer-set-fdef (trr new-fdef)
  (if (tracer-local-p trr)
      (%local-set new-fdef (rest (tracer-name trr)))
      (setf (symbol-function (tracer-symb trr)) new-fdef)))

(defmacro trace (&rest funs)
  "Trace function execution.
\(TRACE) returns the list of all traced functions.
\(TRACE fun ...) additionally traces the functions fun, ... .
Format for fun:
 Either a function name
 or a list made of a function-cell and a few keyword arguments (pairwise!)
  (function-name
   [:suppress-if form]   ; no trace output, as long as form is true
   [:max-depth form]     ; no trace output, as long as (> *trace-level* form)
   [:step-if form]       ; trace moves into the stepper, if form is true
   [:bindings ((variable form)...)] ; binds variables around the following forms
   [:pre form]           ; executes form before function call
   [:post form]          ; executes form after  function call
   [:pre-break-if form]  ; trace moves into break-loop before function call,
                         ; if form is true
   [:post-break-if form] ; trace moves into break-loop after  function call,
                         ; if form is true
   [:pre-print form]     ; prints the values of form before function call
   [:post-print form]    ; prints the values of form after  function call
   [:print form]         ; prints the values of form before
                         ; and after the function call
  )
In all these forms *TRACE-FUNCTION* (the function itself),
  *TRACE-ARGS* (the function arguments),
  *TRACE-FORM* (the function-/macro-call as form),
  and after function call also *TRACE-VALUES* (the list of values
  of the function call) can be accessed,
  and the function can be left with RETURN with given values.
TRACE and UNTRACE are also applicable to functions (SETF symbol) and macros,
 however not applicable to locally defined functions and macros."
  (if (null funs)
    '*TRACED-FUNCTIONS*
    `(APPEND
      ,@(mapcar #'(lambda (fun)
                    `(TRACE1
                       ,(if (or (function-name-p fun) (local-function-name-p fun))
                          `(MAKE-TRACER :NAME ',fun)
                          `(APPLY #'MAKE-TRACER :NAME ',fun))))
                funs))))

;; check whether the FUNNAME can be traced,
;; fill SYMB, CUR-DEF and LOCAL-P slots of TRR and return TRR
(defun check-traceable (funname trr caller)
  (tagbody restart
    (cond ((function-name-p funname)
           (let ((sym (get-funname-symbol funname)))
             (unless (fboundp sym)
               (error (TEXT "~S: undefined function ~S") caller funname))
             (when (special-operator-p sym)
               (error (TEXT "~S: cannot trace special operator ~S")
                      caller funname))
             (setf (tracer-symb trr) sym
                   (tracer-cur-def trr) (symbol-function sym)
                   (tracer-local-p trr) nil)))
          ((local-function-name-p funname)
           (setf (tracer-cur-def trr) (%local-get (rest funname))
                 (tracer-symb trr) (closure-name (tracer-cur-def trr))
                 (tracer-local-p trr) t)
           (when (get (tracer-symb trr) 'sys::untraced-name)
             (setf (tracer-symb trr)
                   (get (tracer-symb trr) 'sys::untraced-name))))
          (t (setq funname (check-function-name funname caller))
             (go restart))))
  (check-redefinition funname caller (TEXT "function"))
  trr)

(defun trace1 (trr) ; ABI
  (check-traceable (tracer-name trr) trr 'trace)
  (let ((macro-flag (macrop (tracer-cur-def trr)))
        (sig (when (tracer-local-p trr)
               (sig-to-list (get-signature (tracer-cur-def trr))))))
    (unless (eq (tracer-cur-def trr) ; already traced?
                (get (tracer-symb trr) 'sys::tracing-definition))
      (setf (get (tracer-symb trr) 'sys::traced-definition)
            (tracer-cur-def trr))
      (pushnew (tracer-name trr) *traced-functions* :test #'equal))
    (fresh-line)
    (format t (TEXT ";; Tracing ~:[function~;macro~] ~S.")
            macro-flag (tracer-name trr))
    (setf (get (tracer-symb trr) 'sys::tracing-definition)
          ;; new function, that replaces the original one:
          (let ((newname (symbol-suffix (tracer-symb trr) "TRACED"))
                (body
                 `((declare (inline car cdr cons apply values-list))
                   (let ((*trace-level* (1+ *trace-level*))
                         ,@(tracer-bindings trr))
                     (block nil
                       (unless (or ,(tracer-suppress-if trr)
                                   ,(if (tracer-max-depth trr) `(> *trace-level* ,(tracer-max-depth trr)) 'nil))
                         (trace-pre-output))
                       ,@(when (tracer-pre-print trr)
                           `((trace-print (multiple-value-list
                                           ,(tracer-pre-print trr)))))
                       ,@(when (tracer-print trr)
                           `((trace-print (multiple-value-list
                                           ,(tracer-print trr)))))
                       ,(tracer-pre trr)
                       ,@(when (tracer-pre-break-if trr)
                           `((when ,(tracer-pre-break-if trr)
                               (sys::break-loop t))))
                       (let ((*trace-values*
                              (multiple-value-list
                               ,(if (tracer-local-p trr)
                                  `(funcall ,(tracer-cur-def trr) ,@sig)
                                  `(if ,(tracer-step-if trr)
                                     (trace-step-apply)
                                     (apply *trace-function* *trace-args*))))))
                         ,@(when (tracer-post-break-if trr)
                             `((when ,(tracer-post-break-if trr)
                                 (sys::break-loop t))))
                         ,(tracer-post trr)
                         ,@(when (tracer-print trr)
                             `((trace-print (multiple-value-list
                                             ,(tracer-print trr)))))
                         ,@(when (tracer-post-print trr)
                             `((trace-print (multiple-value-list
                                             ,(tracer-post-print trr)))))
                         (unless (or ,(tracer-suppress-if trr)
                                     ,(if (tracer-max-depth trr) `(> *trace-level* ,(tracer-max-depth trr)) 'nil))
                           (trace-post-output))
                         (values-list *trace-values*)))))))
            (setf (get newname 'sys::untraced-name) (tracer-symb trr))
            (macrolet ((f (def) `(fdefinition (compile newname ,def))))
              (cond (macro-flag
                     (make-macro
                      (f `(lambda (&rest *trace-args*
                                   &aux (*trace-form* (car *trace-args*))
                                   (*trace-function*
                                    (macro-expander
                                     (get-traced-definition
                                      ',(tracer-symb trr)))))
                            ,@body))
                      (macro-lambda-list (tracer-cur-def trr))))
                    ((tracer-local-p trr)
                     (f `(lambda ,sig
                           (let* ((*trace-args* (list ,@sig))
                                  (*trace-form*
                                   (make-apply-form ',(tracer-name trr)
                                                    *trace-args*))
                                  (*trace-function*
                                   (get-traced-definition
                                    ',(tracer-symb trr))))
                             ,@body))))
                  (t (f `(lambda (&rest *trace-args*
                                  &aux (*trace-form*
                                        (make-apply-form ',(tracer-name trr)
                                                         *trace-args*))
                                  (*trace-function*
                                   (get-traced-definition
                                    ',(tracer-symb trr))))
                           ,@body)))))))
    ;; install the new definition
    (tracer-set-fdef trr (get (tracer-symb trr) 'sys::tracing-definition))
    ;; return the name
    (list (tracer-name trr))))

;; auxiliary functions:
;; fetch original function definition:
(defun get-traced-definition (symbol) (get symbol 'sys::traced-definition))
;; apply, but step by step:
(defun trace-step-apply ()
  (eval `(step (apply ',*trace-function* ',*trace-args*))))
;; build Eval-Form, that corresponds to an Apply (approximately) :
(defun make-apply-form (funname args)
  (declare (inline cons mapcar))
  (cons funname
        (mapcar #'(lambda (arg)
                    ;; (list 'quote arg)
                    (cons 'quote (cons arg nil)))
                args)))
;; Output before call, uses *trace-level* and *trace-form*
(defun trace-output () ; common for pre & post
  (fresh-line *trace-output*)
  (when *trace-indent*
    (write-spaces *trace-level* *trace-output*))
  (write *trace-level* :stream *trace-output* :base 10 :radix t)
  (write-string " Trace: " *trace-output*))
(defun trace-pre-output ()
  (trace-output)
  (prin1 *trace-form* *trace-output*)
  (elastic-newline *trace-output*))
;; Output after call, uses *trace-level*, *trace-form* and *trace-values*
(defun trace-post-output ()
  (declare (inline car cdr consp atom))
  (trace-output)
  (write (car *trace-form*) :stream *trace-output*)
  (write-string " ==> " *trace-output*)
  (trace-print *trace-values* nil))
;; Output of a list of values:
(defun trace-print (vals &optional (nl-flag t))
  (when nl-flag (fresh-line *trace-output*))
  (when (consp vals)
    (loop
      (prin1 (pop vals) *trace-output*)
      (when (atom vals) (return))
      (write-string ", " *trace-output*)))
  (elastic-newline *trace-output*))

(defmacro untrace (&rest funs)
  "(UNTRACE) returns the list of traced functions, stops tracing all of them.
\(UNTRACE symbol ...) removes symbol, ... from the list of traced functions."
  `(MAPCAN #'UNTRACE1
     ,(if (null funs) `(COPY-LIST *TRACED-FUNCTIONS*) `',funs)))

(defun untrace1 (funname) ; ABI
  (let* ((trr (check-traceable funname (make-tracer :name funname) 'untrace))
         (symbol (tracer-symb trr))
         (old-definition (get symbol 'sys::traced-definition)))
    (prog1
      (if old-definition
        ;; symbol was traced
        (progn
          (if (eq (tracer-cur-def trr)
                  (get symbol 'sys::tracing-definition))
            (tracer-set-fdef trr old-definition)
            (warn (TEXT "~S: ~S was traced and has been redefined!")
                  'untrace funname))
          `(,funname))
        ;; funname was not traced
        '())
      (untrace2 trr))))

(defun untrace2 (funname)
  ;; funname can be either a tracer (from untrace1)
  ;; or a function name (from remove-old-definitions)
  (let ((symbol (if (vectorp funname) (tracer-symb funname)
                    (get-funname-symbol funname))))
    (remprop symbol 'sys::traced-definition)
    (remprop symbol 'sys::tracing-definition))
  (setq *traced-functions*
        (delete (if (vectorp funname) (tracer-name funname) funname)
                *traced-functions* :test #'equal)))
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; END FILE ./trace.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;




